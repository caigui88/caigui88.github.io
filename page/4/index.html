<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-后端开发/框架学习/微服务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.171Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务相关内容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ol>
<li>随着项目的不断扩展，可以通过对原本项目按照服务内容进行项目的拆分，每一个功能模块单独运行在自己的进程中，模块间使用轻量级通信机制建立连接。</li>
<li>传统的软件的架构大多数都是独立系统堆砌，这样子建立的系统的可拓展性太差，存在牵一发而动全身的问题，维护成本过高。</li>
</ol>
<h2 id="微服务与单体架构对比："><a href="#微服务与单体架构对比：" class="headerlink" title="微服务与单体架构对比："></a>微服务与单体架构对比：</h2><ol>
<li><p>由于笔者目前只接触过单体架构这种与微服务不一样的架构，因此与单体架构进行对比</p>
</li>
<li><p>单体架构所有的模块代码都耦合在一起，单个项目的代码量大，假如此时只需要对一个模块的一个功能进行迭代，但是因为这个模块耦合在整个单体架构中，所以不得不将整个项目停下，在迭代好后再重新启动。</p>
<p>微服务架构每一个模块都被抽离成一个单独的项目，一个大项目里包含有许多小项目，单个小项目代码量明显降低，且耦合度低，安全性高</p>
</li>
<li><p>单体架构只使用一个数据库，存储方式单一，容易出现单点故障</p>
<p>微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。（单体架构也可以实现，但是比较麻烦）</p>
</li>
<li><p>单体架构所有的模块开发所使用的技术一样。</p>
<p>微服务每个模块都可以使用不同的开发技术，开发模式更灵活。</p>
</li>
</ol>
<h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><blockquote>
<p>由于将项目进行拆分，导致原本在同一线程下的各个模块可以直接调用的操作无法实现，需要通过通信机制来进行模块间的连接，以实现模块间的互相调用，由于使用到了通信机制（通常是http请求）因此叫做远程调用。</p>
</blockquote>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><h2 id="服务的治理"><a href="#服务的治理" class="headerlink" title="服务的治理"></a>服务的治理</h2><blockquote>
<p>将每一个模块注册到注册中心，以便于观察每个服务的运行状态</p>
</blockquote>
<h3 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h3><h2 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关 gateway"></a>网关 gateway</h2><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>使用nacos实现</p>
<h2 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h2><h3 id="雪崩问题："><a href="#雪崩问题：" class="headerlink" title="雪崩问题："></a>雪崩问题：</h3><ol>
<li>由于单个服务的故障导致引发链式灾难，进而使得整个项目崩溃<ol>
<li>服务相互调用，服务提供者出现故障或阻塞</li>
<li>服务调用者没做好异常处理，导致自身故障</li>
<li>调用链中的所有服务级联失败，导致集群故障</li>
</ol>
</li>
<li>解决思路：<ol>
<li>尽量避免服务出现故障或阻塞</li>
</ol>
</li>
</ol>
<h3 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h3><ol>
<li><strong>请求限流</strong>（流量整型）：限制流量在服务可以处理的范围，避免突发流量导致的故障</li>
<li><strong>线程隔离</strong>（舱壁模式）：限定每一个业务能够使用的线程数量，将故障业务隔离，避免故障扩散。</li>
<li><strong>服务熔断</strong>：由断路器统计请求的异常比例或慢调用比例，超出阈值则熔断该业务，拦截该接口的请求。</li>
<li><strong>失败处理</strong>：熔断期间，所有请求快速失败，但失败时不抛出异常，而是进入fallback逻辑（返回默认数据或友好提示）</li>
</ol>
<h4 id="保护技术"><a href="#保护技术" class="headerlink" title="保护技术"></a>保护技术</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011226359.png" alt="image-20240922184706978"></p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h4 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227719.png" alt="image-20240923133631762"></p>
<h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227786.png" alt="image-20240923133703690"></p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><ol>
<li>对超出QPS上限的请求进行<strong>降级处理</strong></li>
<li>当某个模块的延迟突然升高，响应时间变长，且会占用到其他正常的业务的资源导致其他业务出现高延迟，则应该立即停用不健康的模块接口，进行<strong>降级处理</strong>，避免影响到当前项目的服务体验，这种做法就是 <strong>熔断</strong>。</li>
</ol>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="数据库ACID四大特性"><a href="#数据库ACID四大特性" class="headerlink" title="数据库ACID四大特性"></a>数据库ACID四大特性</h4><ol>
<li><strong>原子性 atomic</strong></li>
<li><strong>一致性 consistency</strong></li>
<li><strong>隔离性 isolation</strong></li>
<li><strong>持久性 durability</strong></li>
</ol>
<h4 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h4><p>在一个分布式系统中，当一个业务涉及到多个服务合作完成，且每个服务都有各自的事务，则同属于一个业务的多个事务必须同时成功或失败，这些事务就是<strong>分布式事务</strong>，其中每个服务的事务就是一个<strong>分支事务</strong>，整个业务称为<strong>全局事务</strong>。（为了保证数据的一致性和操作的原子性）</p>
<h3 id="Seata框架"><a href="#Seata框架" class="headerlink" title="Seata框架"></a>Seata框架</h3><p>Seata事务管理三个重要角色：</p>
<ol>
<li><strong>TC （Transaction Coordinator）-事务协调者</strong>：维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li><strong>TM （Transaction Manager）-事务管理器</strong>：定义全局事务的范围，开始全局事务，提交或回滚全局事务。</li>
<li><strong>RM （Resource Manager） -资源管理器</strong>：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态。</li>
</ol>
<h3 id="Seata的两种模式："><a href="#Seata的两种模式：" class="headerlink" title="Seata的两种模式："></a>Seata的两种模式：</h3><p><strong>XA模式</strong>：两阶段工作</p>
<ol>
<li><p>一阶段：</p>
<ol>
<li>RM注册分支事务到TC</li>
<li>RM执行分支业务sql但不提交</li>
<li>RM报告执行状态到TC</li>
</ol>
</li>
<li><p>二阶段：</p>
<ol>
<li><p>TC检测各分支事务执行</p>
<p>如果都成功，通知所有RM提交事务</p>
<p>如果有至少一个失败，通知所有RM回滚事务</p>
</li>
<li><p>RM接受TC指令，提交或回滚事务</p>
</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>事务具有强一致性，满足ACID原则</li>
<li>常用数据库都支持，实现简单，且没有代码入侵</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>一阶段需要上锁独占数据库资源，等待二阶段结束才可以释放，性能差</li>
<li>依赖于关系型数据库实现事务</li>
</ol>
</li>
</ol>
<p><strong>模式实例图</strong>：</p>
<img src="E:\DeskTable\博客学习截图传输\image-20241007133720162.png" alt="image-20241007133720162" style="zoom: 50%;" /> 



<p><strong>AT模式</strong>：</p>
<blockquote>
<p>关键是进行了快照保存，一旦出现错误，直接使用快照进行回滚</p>
</blockquote>
<ol>
<li>一阶段RM的工作：<ol>
<li>注册分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ol>
</li>
<li></li>
</ol>
<p><strong>模式示例图</strong>：</p>
<img src="E:\DeskTable\博客学习截图传输\image-20241007155906690.png" alt="image-20241007155906690" style="zoom:50%;" /> 





<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>rabbitMQ登录时遇到身份验证弹窗解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61399406/article/details/132536144#:~:text=%E5%85%B3%E4%BA%8E%22%E7%99%BB%E5%BD%95r">登录rabbitMQ管理界面时浏览器显示要求进行身份验证，与此站点连接不安全解决办法_登录以访问此站点 要求进行身份验证-CSDN博客</a></p>
<p>⚠️⚠️⚠️注意⚠️⚠️⚠️</p>
<p>在新创建完一个用户后，需要为其添加对应的虚拟机操作权限</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41977631/article/details/106560748">Linux下rabbitmq创建用户并设置权限_rabbitmq的guest用户已拥有所有权限,但还是不能创建交换机,怎么设置guest用户的远-CSDN博客</a></p>
<h3 id="MQ（Message-Queue）"><a href="#MQ（Message-Queue）" class="headerlink" title="MQ（Message Queue）"></a>MQ（Message Queue）</h3><p>本质就是一个队列，遵循FIFO原则，队列中存放的数据是msg</p>
<p>主要用途是：不同进程process&#x2F;线程thread间的通信</p>
<p><strong>AMQP advanced message queuing protocol</strong>：信息队列的一个协议</p>
<p>对于一个MQ系统来说，可以有两种模式：简单模式和发布订阅模式</p>
<p><strong>简单模式</strong>：使用默认交换机，一个消息只能被消费一次，消费者之间是竞争关系</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227902.png" alt="image-20241008131925667"></p>
<p><strong>发布订阅模式</strong>：通过指定交换机，可以用多个队列实现一个消息被多个消费者消费，消费者之间共享消息</p>
<h3 id="交换机的概念"><a href="#交换机的概念" class="headerlink" title="交换机的概念"></a>交换机的概念</h3><p>RabbitMQ消息传递模型的核心思想是：生产者生产的消息不会直接发生到队列中，因为事实上生产者本身是不知道生产出的消息应该要传递到哪些队列的</p>
<p>生产者只会将消息发送到交换机(exchange)，交换机只负责：接收来自生产者的消息；将消息推送入信息队列中</p>
<p><strong>交换机的作用：</strong> 生产者向broker（rabbitmq服务器）发送消息，交换机通过生产者绑定的路由键，将消息推送到不同的消息队列中。而消费者，只绑定队列，从队列中获取消息。</p>
<p><strong>交换机需要明确知道如何处理消息</strong>，处理信息的方式由信息队列的类型来决定</p>
<p>交换机就相当于一个具有路由规则的路由程序，每一个消息都有一个路由键（route key）</p>
<h3 id="四种交换机类型："><a href="#四种交换机类型：" class="headerlink" title="四种交换机类型："></a>四种交换机类型：</h3><ol>
<li><p><strong>direct 直接，定向路由</strong>：每一个queue都与Exchange设置一个bindingkey</p>
<ul>
<li><p>工作模式图解</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227028.png" alt="image-20241008173123159"></p>
</li>
<li><p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明交换机、队列、路由键绑定</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"><span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment">puvlic class RabbitConfig &#123;</span></span><br><span class="line"><span class="comment">	/**</span></span><br><span class="line"><span class="comment">	 * 创建直连交换机</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">createExchange</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;testE&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span> (<span class="string">&quot;testQ&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过路由键绑定交换机和队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">createBinding</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> BindingBuilder</span><br><span class="line">		.bind(<span class="built_in">this</span>.createQueue())</span><br><span class="line">		.to(<span class="built_in">this</span>.createExchange())</span><br><span class="line">		.with(<span class="string">&quot;testR&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;testE&quot;</span>, <span class="string">&quot;testR&quot;</span>, msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>topic 主题</strong>：与direct区别是，topic可以使用通配符的方式对路由键进行绑定，更加灵活的对消息进行路由</p>
<ul>
<li><p>工作模式图解 </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227485.png" alt="image-20241008173442176"></p>
</li>
<li><p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRabbitMqConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic_queue_A&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic_queue_B&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Topic交换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topic_exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeQueueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueA()).to(exchange()).with(<span class="string">&quot;*.*.routeKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeQueueB</span><span class="params">(Queue topicQueueB, TopicExchange exchange)</span> &#123;</span><br><span class="line">        <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueB()).to(exchange()).with(<span class="string">&quot;routeKey.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;topic_exchange&quot;</span>, <span class="string">&quot;routeKey.test.routeKey&quot;</span>, </span><br><span class="line">	</span><br><span class="line">	msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>headers 标题</strong>：暂无，</p>
</li>
<li><p><strong>fanout 扇出</strong>：会将接收到的消息进行广播</p>
<ul>
<li><p>工作模式图解</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227358.png" alt="image-20241008173247059"> </p>
</li>
<li><p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueA&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueB&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueC</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueC&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;exchangeFanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeC</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueC()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;exchangeFanout&quot;</span>, <span class="string">&quot;&quot;</span>, msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>临时队列</strong>：</p>
<ul>
<li><p>队列的名称对我们来说至关重要，我们需要指定消费者去消费哪个队列的消息。</p>
</li>
<li><p>每当我们连接到 RabbitMQ 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。<br>注意：一旦我们断开了消费者的连接，队列将被自动删除。</p>
</li>
<li><p>创建临时队列的方式如下:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>



<p><strong>绑定 bindings</strong>：</p>
<p>将 exchange和特定的queue建立桥梁进行绑定</p>
<p>java代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue, String exchange, String routingKey)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li>同步通讯</li>
<li>异步通讯</li>
</ol>
<h3 id="消息可靠性问题"><a href="#消息可靠性问题" class="headerlink" title="消息可靠性问题"></a>消息可靠性问题</h3><h4 id="sender的可靠性"><a href="#sender的可靠性" class="headerlink" title="sender的可靠性"></a>sender的可靠性</h4><p><strong>发送者重连</strong>：</p>
<p>springAMQP的重连机制是阻塞式的，会影响其他业务的性能，如果对业务性能要求较高，</p>
<p>要么<strong>禁用</strong>重连机制</p>
<p>要么<strong>异步</strong>线程执行消息发送代码</p>
<p><strong>发送者确认</strong>：</p>
<p><code>Publisher Confirm</code>和<code>Publisher Return</code>两种机制，开启后，MQ发送消息会返回确认结果给发送者</p>
<p>返回结果情况如下：</p>
<ol>
<li>消息投递到MQ，但路由失败，会通过<code>PublisherReturn</code>返回路由异常原因，然后通过<code>PublisherConfirm</code>返回<em>ACK</em>，告知投递成功</li>
<li>临时消息投递到MQ，并且入队成功，返回<em>ACK</em>，告知投递成功</li>
<li>持久消息投递到MQ，并且入队成功完成持久化，返回<em>ACK</em>，告知投递成功</li>
<li>其他情况返回<em>NACK</em>，告知投递失败</li>
</ol>
<h4 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h4><h4 id="consumer的可靠性"><a href="#consumer的可靠性" class="headerlink" title="consumer的可靠性"></a>consumer的可靠性</h4><h4 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" data-id="cm7pnj29l0035ucv27llc9voo" data-title="微服务相关内容" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/框架学习/spring注解收集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.170Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>@RestControllerAdvice</code></p>
<p><code>@RestControllerAdvice</code> 注解用于定义<strong>全局异常处理器</strong>。它结合了 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code>，使得在处理控制器异常时，可以直接返回 JSON 或 XML 格式的响应。这个注解通常用于捕获和处理应用程序中的异常，并将其转换为适当的 HTTP 响应。</p>
<ul>
<li><code>@ControllerAdvice</code>:<ul>
<li>这是一个 Spring 提供的注解，用于定义全局的异常处理、数据绑定、数据预处理等。</li>
<li>它可以应用于所有控制器，帮助开发者集中管理控制器的全局配置。</li>
</ul>
</li>
<li><code>@ResponseBody</code>:<ul>
<li>这是一个 Spring MVC 提供的注解，用于将控制器的方法返回值直接写入 HTTP 响应体中。</li>
<li>通常用于 RESTful Web 服务，返回 JSON 或 XML 格式的数据，而不是视图页面。</li>
</ul>
</li>
</ul>
<p><code>@ConditionalOnProperty</code> 注解的作用是根据配置文件中的属性值来决定是否启用某个 Spring 组件。具体来说：</p>
<ul>
<li><code>prefix</code>：属性的前缀。</li>
<li><code>name</code>：属性的名称。</li>
<li><code>havingValue</code>：属性的期望值。</li>
</ul>
<p>例如在代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;bilibili&quot;, name = &quot;exception-handler&quot;, havingValue = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>

<p>表示只有当配置文件中 <code>bilibili.exception-handler</code> 的值为 <code>true</code> 时，<code>GlobalExceptionHandler</code> 类才会被加载到 Spring 容器中。</p>
<p><code>CrossOrigin</code>用来解决跨域问题，且是服务端进行解决</p>
<p><code>@Data</code> 是 Lombok 提供的一个注解，用于简化 Java 类的开发。它的作用是自动生成常见的类方法，减少了样板代码。具体来说，<code>@Data</code> 注解会自动为类生成以下方法：</p>
<ol>
<li><strong>Getter</strong>：为所有字段生成 getter 方法。</li>
<li><strong>Setter</strong>：为所有非 <code>final</code> 字段生成 setter 方法。</li>
<li><strong>toString()</strong>：生成 <code>toString()</code> 方法，包含类中所有字段。</li>
<li><strong>equals()</strong>：生成 <code>equals()</code> 方法，比较两个对象的字段是否相等。</li>
<li><strong>hashCode()</strong>：生成 <code>hashCode()</code> 方法，根据对象的字段计算 hash 值。</li>
<li><strong>RequiredArgsConstructor</strong>：生成一个包含所有 <code>final</code> 字段和标记为 <code>@NonNull</code> 的字段的构造函数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86/" data-id="cm7pnj29k002yucv27ymx1o0n" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/框架学习/spring原理篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E5%8E%9F%E7%90%86%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.169Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E5%8E%9F%E7%90%86%E7%AF%87/">Java学习路线</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring原理"><a href="#Spring原理" class="headerlink" title="Spring原理"></a>Spring原理</h1><blockquote>
<p>学习spring较为底层的原理</p>
</blockquote>
<h2 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h2><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228523.png" alt="ConfigurableApplicationContext"></p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><blockquote>
<p><code>ApplicationContext</code>的父接口</p>
<p>spring的<strong>核心容器</strong>，主要的<code>ApplicationContext</code>实现都【组合】了其功能</p>
</blockquote>
<p>beanFactory管理容器</p>
<p>其中容器中的single instance bean都是由 <code>DefaultSingletonBeanRegistry</code> 的<code>singletonObject</code>变量进行管理</p>
<h4 id="BeanFactory的功能"><a href="#BeanFactory的功能" class="headerlink" title="BeanFactory的功能"></a>BeanFactory的功能</h4><blockquote>
<p>控制反转<em>IOC</em>，基本的依赖注入，Bean的生命周期的各种功能都由其实现类<code>DefaultListableBeanFactory</code>提供</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228085.png" alt="DefaultListableBeanFactory"></p>
<h4 id="BeanFactory实现的特点"><a href="#BeanFactory实现的特点" class="headerlink" title="BeanFactory实现的特点"></a>BeanFactory实现的特点</h4><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><blockquote>
</blockquote>
<h4 id="ApplicationContext的功能"><a href="#ApplicationContext的功能" class="headerlink" title="ApplicationContext的功能"></a>ApplicationContext的功能</h4><p><code>ConfigurableApplicationContext interface</code>的继承&#x2F;实现图谱</p>
<p><code>MessageSource</code>：Spring应用上下文的一个拓展接口，用于提供高效的上下文配置和控制功能</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>允许刷新、关闭和重新配置应用上下文（如 <code>refresh()</code> 和 <code>close()</code> 方法）。</li>
<li>提供了 <code>getBeanFactory()</code> 方法，用于获取底层的 <code>BeanFactory</code>，并允许对 Bean 工厂进行进一步配置。</li>
<li>支持 <code>addApplicationListener()</code> 添加事件监听器，用于监听应用上下文事件（如启动、关闭等）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>,<span class="literal">null</span>, Locale.SIMPLIFIED_CHINESE));</span><br><span class="line">System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>,<span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228078.png" alt="image-20241029201137782"> </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 国际化</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">i18n/messages</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<p>需注意，假如将 messages配置文件修改了路径，则需要额外在 <code>application.yml</code>当中专门进行配置，防止寻找不到messages.properties文件的位置</p>
<p><code>ResourcePatternResolver</code>：资源访问接口，用于解析文件、类路径资源等多种资源类型，并支持通配符（如 <code>*</code> 和 <code>?</code>）进行模式匹配。</p>
<ul>
<li><p><strong>功能</strong>：</p>
<ul>
<li><p>通过 <code>getResource(String location)</code> 方法，可以加载单一资源。</p>
</li>
<li><p>通过 <code>getResources(String locationPattern)</code> 方法，可以加载匹配特定模式的多个资源。</p>
</li>
<li><p>在 Spring 应用中，通常用于加载配置文件、XML、YAML 或属性文件等资源。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Resource[] resources =</span><br><span class="line">        context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ApplicationEventPublisher</code>：用于 Spring 应用事件的发布。</p>
<ul>
<li><p><strong>功能</strong>：</p>
</li>
<li><p>使用 <code>publishEvent()</code> 方法来发布应用事件，这些事件可以被 <code>ApplicationListener</code> 监听并做出相应的处理。</p>
</li>
<li><p>常用于触发某些特定的业务逻辑，例如用户注册事件、订单完成事件等，支持松耦合的事件驱动开发模式。</p>
</li>
</ul>
<p>事件的发布</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件发布</span></span><br><span class="line">context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(context));</span><br></pre></td></tr></table></figure>



<p>对发布事件进行监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">    <span class="comment">//调试日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component2.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event: &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>EnviromentCapable</code>：环境访问接口，用于获取应用运行环境的信息。</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>提供了 <code>getEnvironment()</code> 方法，返回当前的 <code>Environment</code> 对象。</li>
<li><code>Environment</code> 包含了应用的属性信息（如系统环境变量、配置文件属性等），在开发和生产环境的配置管理中非常重要。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;maven_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228782.png" alt="ConfigurableApplicationContext-1730200572243-1"></p>
<h3 id="事件解耦"><a href="#事件解耦" class="headerlink" title="事件解耦"></a>事件解耦</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E5%8E%9F%E7%90%86%E7%AF%87/" data-id="cm7pnj29l0032ucv2ha1u25sk" data-title="Java学习路线" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/框架学习/Spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Spring/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.167Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Spring/">spring相关内容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概念与术语解析"><a href="#概念与术语解析" class="headerlink" title="概念与术语解析"></a>概念与术语解析</h1><h2 id="什么是脚手架"><a href="#什么是脚手架" class="headerlink" title="什么是脚手架"></a>什么是脚手架</h2><p>脚手架在实际生活中是一种用在建筑领域的辅助工具，或者说是为了保证各施工过程顺利进行而搭设的工作平台。</p>
<p>对应到软件工程领域，脚手架可以解释为帮助开发人员在开发过程中使用的<strong>开发工具、开发框架（即别人已经造好的轮子不要重复造）</strong>，使用脚手架你无须从头开始搭建或者编写底层软件。</p>
<p>参考Stack Overflow对于脚手架的定义（更加偏向于应用服务框架使用的一种编程思想或者说编程范式）（仅供参考！！）：</p>
<p><strong>脚手架（scaffolding）</strong>：是一种元编程的方法，程序员编写一份规格说明书（Specification），用来描述怎样去使用数据库，然后由编译器脚手架根据这份规格说明书生成相应的代码，进行增、删、改、查等数据库的操作，在脚手架上更高效地建造出强大的应用。</p>
<h1 id="Spring简史"><a href="#Spring简史" class="headerlink" title="Spring简史"></a>Spring简史</h1><h2 id="Spring-1-x-时代"><a href="#Spring-1-x-时代" class="headerlink" title="Spring 1.x 时代"></a>Spring 1.x 时代</h2><p><strong>特点</strong>:</p>
<ul>
<li>引入了**控制反转（IoC）<strong>和</strong>面向切面编程（AOP）**的概念，也是spring框架的核心技术。</li>
<li>提供了轻量级的容器，允许开发者通过 XML 配置文件管理对象的生命周期，在spring1.x时，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。</li>
<li>使得开发者能够将业务逻辑与基础设施代码分离。</li>
</ul>
<h2 id="Spring-2-0-2006"><a href="#Spring-2-0-2006" class="headerlink" title="Spring 2.0 (2006)"></a>Spring 2.0 (2006)</h2><p><strong>特点</strong>:</p>
<ul>
<li>随着 JDK1.5 引入的注解支持，spring2.x 使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。</li>
<li>引入了新的 AOP 支持，允许更灵活的切面定义。</li>
<li>加强了对 Web 应用的支持，包括 Spring MVC 的改进。</li>
</ul>
<h2 id="Spring-3-0-2009"><a href="#Spring-3-0-2009" class="headerlink" title="Spring 3.0 (2009)"></a>Spring 3.0 (2009)</h2><p><strong>特点</strong>:</p>
<ul>
<li><p>使用Java配置的方式来配置Beans，进一步减少了 XML 配置的需求。</p>
<ul>
<li>Java 配置方式是指使用 Java 类来定义和配置 Spring 应用程序中的 Beans，而不是使用传统的 XML 配置文件。这种方式通过使用注解（如 <code>@Configuration</code> 和 <code>@Bean</code>）来声明 Bean 的创建和依赖关系，使得配置更直观和可维护<ul>
<li><strong>类型安全</strong>：通过 Java 代码，编译器可以检查配置的正确性。</li>
<li><strong>更好的 IDE 支持</strong>：开发环境可以提供自动补全和重构支持。</li>
<li><strong>灵活性</strong>：可以使用 Java 语言的所有特性（如条件判断、循环等）来<strong>动态创建</strong> Beans。</li>
</ul>
</li>
</ul>
</li>
<li><p>支持 RESTful Web 服务，促进了现代 Web 应用程序的开发。</p>
</li>
<li><p>引入了表达式语言（SpEL）以增强配置的灵活性。</p>
</li>
</ul>
<h2 id="4-Spring-4-0-2013"><a href="#4-Spring-4-0-2013" class="headerlink" title="4. Spring 4.0 (2013)"></a>4. <strong>Spring 4.0 (2013)</strong></h2><p><strong>特点</strong>:</p>
<ul>
<li>增加了对 Java 8 的支持，特别是对 Lambda 表达式和流的支持。</li>
<li>引入了新的 WebSocket 支持，使得实时应用程序的开发变得更加容易。</li>
<li>增强了对 Spring MVC 的支持，提供了更好的 REST 功能。</li>
</ul>
<h2 id="Spring-5-0-2017"><a href="#Spring-5-0-2017" class="headerlink" title="Spring 5.0 (2017)"></a>Spring 5.0 (2017)</h2><p><strong>特点</strong>：</p>
<ul>
<li>引入了响应式编程支持，推出了 WebFlux 模块，允许开发者构建非阻塞的应用程序。</li>
<li>加强了对 Kotlin 的支持，允许使用 Kotlin 语言进行 Spring 开发。</li>
<li>改进了对微服务架构的支持，简化了与 Spring Cloud 的集成。</li>
</ul>
<h2 id="Spring-5-1-和-5-2-2018-2019"><a href="#Spring-5-1-和-5-2-2018-2019" class="headerlink" title="Spring 5.1 和 5.2 (2018-2019)"></a>Spring 5.1 和 5.2 (2018-2019)</h2><p>特点:</p>
<ul>
<li>进一步增强了反应式编程的特性，改善了与 R2DBC 的集成。</li>
<li>增加了对更多 Spring Boot 特性的支持，如配置属性的简化。</li>
</ul>
<h2 id="Spring-6-0-2022"><a href="#Spring-6-0-2022" class="headerlink" title="Spring 6.0 (2022)"></a>Spring 6.0 (2022)</h2><p><strong>特点</strong>:</p>
<ul>
<li>完全支持 Java 17 和 Jakarta EE 9。</li>
<li>重构了许多核心模块，以利用 Java 语言的新特性和改进。</li>
<li>加强了对模块化和微服务架构的支持，进一步优化了开发体验。</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol>
<li><p><strong>Spring</strong>：</p>
<ul>
<li><strong>介绍</strong>：Spring是一个开源框架，提供了全面的基础设施支持，用于Java应用的开发。核心特性包括依赖注入和面向切面的编程。</li>
<li><strong>知识点</strong>：IoC（控制反转）、AOP（面向切面编程）、Spring容器等。</li>
</ul>
</li>
<li><p><strong>Spring Boot</strong>：</p>
<ul>
<li><strong>介绍</strong>：Spring Boot是Spring的扩展，旨在简化Spring应用的配置和部署。它提供了开箱即用的配置，减少了开发者的工作量。</li>
<li><strong>知识点</strong>：自动配置、独立应用、嵌入式服务器、Spring Boot Starter等。</li>
</ul>
</li>
<li><p><strong>Spring MVC</strong>：</p>
<ul>
<li><strong>介绍</strong>：Spring MVC是Spring框架的一部分，专注于构建Web应用。它采用MVC（模型-视图-控制器）设计模式，分离了应用的不同层。</li>
<li><strong>知识点</strong>：控制器、视图解析器、数据绑定、请求处理等。</li>
</ul>
</li>
<li><p><strong>Spring Cloud</strong>：</p>
<ul>
<li><strong>介绍</strong>：Spring Cloud是为分布式系统提供工具的框架，支持微服务架构的开发。它提供了服务发现、负载均衡、配置管理等功能。</li>
<li><strong>知识点</strong>：Eureka（服务发现）、Ribbon（负载均衡）、Hystrix（熔断器）、Config Server（配置管理）等。</li>
</ul>
</li>
</ol>
<p><strong>区别对比</strong>：</p>
<ul>
<li><strong>功能范围</strong>：Spring是基础框架，Spring Boot简化配置，Spring MVC专注于Web开发，Spring Cloud支持微服务。</li>
<li><strong>应用场景</strong>：Spring适合通用Java开发，Spring Boot适合快速开发，Spring MVC用于构建Web应用，Spring Cloud用于构建分布式系统。</li>
</ul>
<p>如果想深入某一部分，随时告诉我！</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><h3 id="HTTP协议-请求类型："><a href="#HTTP协议-请求类型：" class="headerlink" title="HTTP协议&amp;请求类型："></a>HTTP协议&amp;请求类型：</h3><p>根据 HTTP 标准的不同，HTTP 请求可以使用多种请求方法。<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<blockquote>
<p>GET,POST,PUT,DELETE使用较多</p>
</blockquote>
<ol>
<li><strong>GET</strong>：获取资源</li>
<li><strong>POST</strong>：传输请求实体</li>
<li><strong>PUT</strong>：传输文件</li>
<li><strong>DELETE</strong>：删除文件</li>
<li>HEAD：获得报文首部</li>
</ol>
<h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>将后端程序进行分离，划分为三个不同的层次</p>
<ol>
<li>Controller 控制层：负责接受前端发生的请求，对请求进行处理并响应数据</li>
<li>Service 业务逻辑层：处理具体的业务逻辑，例如将读取到的数据进行过滤</li>
<li>Data Access Object DAO 数据访问层：负责数据访问操作，即常规的增删改查</li>
</ol>
<h3 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h3><ol>
<li>控制反转 Inversion Of Control IOC 对象的创建控制权由程序本身转移到外部容器中</li>
<li>依赖注入 Dependency Injection DI 容器为应用程序提供运行时所依赖的资源</li>
<li>Bean对象 IOC容器中创建、管理的对象，称之为bean</li>
</ol>
<h4 id="Bean的声明"><a href="#Bean的声明" class="headerlink" title="Bean的声明"></a>Bean的声明</h4><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">说明</th>
<th align="left">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Component</td>
<td align="left">声明bean的基础注解</td>
<td align="left">不属于以下三类，使用该注解(例如一些工具类)</td>
</tr>
<tr>
<td align="left">@Controller</td>
<td align="left">@Component的衍生注解</td>
<td align="left">属于控制权类</td>
</tr>
<tr>
<td align="left">@Service</td>
<td align="left">@Component的衍生注解</td>
<td align="left">属于业务逻辑类</td>
</tr>
<tr>
<td align="left">@Repository</td>
<td align="left">@Component的衍生注解</td>
<td align="left">属于数据访问类(由于与mabatis整合，用的少)</td>
</tr>
</tbody></table>
<h4 id="Resource和Autowired的区别"><a href="#Resource和Autowired的区别" class="headerlink" title="Resource和Autowired的区别"></a>Resource和Autowired的区别</h4><ol>
<li>Autowired是spring框架提供的注解，Resource是JDK提供的注解</li>
<li>Autowired默认按类型注入，Resource默认按类名称注入</li>
</ol>
<h2 id="Swagger3-x版本"><a href="#Swagger3-x版本" class="headerlink" title="Swagger3.x版本"></a>Swagger3.x版本</h2><h3 id="POM导入"><a href="#POM导入" class="headerlink" title="POM导入"></a>POM导入</h3><blockquote>
<p>由于Java17以上版本使用的Spring框架为3.x版本，因此需要使用新版本的Swagger以完成api文档接口</p>
</blockquote>
<p>首先是POM文件的导入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-doc-last-new-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>#注意，此处和swagger2的依赖名有区别，需要进行区分。</span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;knife4j-last-new-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="资源包中yaml的配置"><a href="#资源包中yaml的配置" class="headerlink" title="资源包中yaml的配置"></a>资源包中yaml的配置</h3><p>然后是在资源包当中进行依赖的配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Swagger配置</span></span><br><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">api-docs:</span></span><br><span class="line">    <span class="comment"># 是否开启文档功能</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># swagger后端请求地址</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/v3/api-docs</span></span><br><span class="line">  <span class="attr">swagger-ui:</span></span><br><span class="line">    <span class="comment"># 是否开启ui功能</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 自定义swagger前端请求路径</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/swagger-ui.html</span></span><br><span class="line">  <span class="comment"># 包扫描路径</span></span><br><span class="line">  <span class="attr">packages-to-scan:</span> <span class="string">com.sky.controller</span></span><br><span class="line">  <span class="comment"># 请求参数使用对象包装时以分散的参数生成api文档</span></span><br><span class="line">  <span class="attr">default-flat-param-object:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="comment"># 开启增强配置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 开启生产环境屏蔽（如果是生产环境，需要把下面配置设置true）</span></span><br><span class="line">  <span class="comment"># production: true</span></span><br><span class="line">  <span class="attr">setting:</span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh_cn</span></span><br></pre></td></tr></table></figure>

<h3 id="常用注解发送变化"><a href="#常用注解发送变化" class="headerlink" title="常用注解发送变化"></a>常用注解发送变化</h3><p>在新版本的Swagger当中，常用注解发生了改变</p>
<blockquote>
<p>因为原本的swagger使用的是springfox为基础，而新架构的swagger是集成到Springboot框架当中的，使用的是springdoc依赖，因此注解会发生改变</p>
</blockquote>
<table>
<thead>
<tr>
<th>注解名</th>
<th>作用区域</th>
</tr>
</thead>
<tbody><tr>
<td>Tag</td>
<td>作用于类，用于描述类的作用</td>
</tr>
<tr>
<td>Operation</td>
<td>作用于方法，用于描述方法的作用和形参列表</td>
</tr>
<tr>
<td>Scheme</td>
<td>作用于字段，用于描述字段的含义和作用</td>
</tr>
</tbody></table>
<ul>
<li><p>Tag <strong>配置文档标题及归类，就是在Controller上配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注解：<span class="meta">@Tag</span> 可以用于对接口进行分类和归类，便于开发人员组织和管理 API 文档</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：name：表示标签的名称，必填属性，也得注意多个Controller上的name不要写一样的，这样就会把它们归类在一起。</span><br><span class="line">        ②：description：表示标签的描述信息，非必填属性。</span><br><span class="line">        ③：externalDocs：用于指定URL地址文档信息来追加描述接口的信息。非必填属性。</span><br><span class="line">        示例：</span><br><span class="line">            <span class="meta">@Tag(</span></span><br><span class="line"><span class="meta">                    name = &quot;StudentControllerAPI&quot;,</span></span><br><span class="line"><span class="meta">                    description = &quot;学生控制器接口&quot;,</span></span><br><span class="line"><span class="meta">                    externalDocs = @ExternalDocumentation(</span></span><br><span class="line"><span class="meta">                            description = &quot;这是一个接口文档介绍&quot;,</span></span><br><span class="line"><span class="meta">                            url = &quot;https://www.cnblogs.com/antLaddie/&quot;))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Operation <strong>配置文档下的每一个接口信息，就是Controller里的每一个RequestMapping</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">注解：<span class="meta">@Operation</span>用于对API操作（即方法）进行描述和标记。就是我们熟知的Controller下的一个个请求的方法上。</span><br><span class="line">    具体可以参考 io.swagger.v3.oas.annotations。</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：summary：用于简要描述API操作的概要。</span><br><span class="line">        ②：description：用于详细描述API操作的描述信息。</span><br><span class="line">        ③：parameters：用于指定API操作的参数列表，包括路径参数、请求参数、请求头部等。可以使用<span class="meta">@Parameter</span>注解进一步定义参数。</span><br><span class="line">        ④：operationId：用于指定API操作的唯一标识符，可以用于生成客户端代码或文档等。</span><br><span class="line">            说明：第三方工具使用operationId来唯一标识此操作。（具体我也没用过）</span><br><span class="line">        ⑤：requestBody：用于定义API操作的请求体，可以使用<span class="meta">@RequestBody</span>注解进一步定义请求体。</span><br><span class="line">            说明：这里的<span class="meta">@RequestBody</span>注解是<span class="meta">@io</span>.swagger.v3.oas.annotations.parameters.RequestBody包里的</span><br><span class="line">        ⑥：responses：用于定义 API 操作的响应列表，包括成功响应和错误响应。可以使用<span class="meta">@ApiResponse</span>注解进一步定义响应。</span><br><span class="line">        ⑦：security：用于对API操作进行安全控制，可以使用<span class="meta">@SecurityRequirement</span>注解进一步定义安全需求。（后面说）</span><br><span class="line">        ⑧：deprecated：表示该API操作已经过时或不推荐使用。</span><br><span class="line">        <span class="meta">@Operation(</span></span><br><span class="line"><span class="meta">                summary = &quot;根据Id查询学生信息&quot;,</span></span><br><span class="line"><span class="meta">                description = &quot;根据ID查询学生信息，并返回响应结果信息&quot;,</span></span><br><span class="line"><span class="meta">                parameters = &#123;</span></span><br><span class="line"><span class="meta">                        @Parameter(name = &quot;id&quot;, description = &quot;学生ID&quot;, required = true, example = &quot;1&quot;)</span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                responses = &#123;</span></span><br><span class="line"><span class="meta">                        @ApiResponse(</span></span><br><span class="line"><span class="meta">                                responseCode = &quot;200&quot;,</span></span><br><span class="line"><span class="meta">                                description = &quot;响应成功&quot;,</span></span><br><span class="line"><span class="meta">                                content = @Content(</span></span><br><span class="line"><span class="meta">                                        mediaType = &quot;application/json&quot;,</span></span><br><span class="line"><span class="meta">                                        schema = @Schema(</span></span><br><span class="line"><span class="meta">                                                title = &quot;AjaxResul和StudentVO组合模型&quot;,</span></span><br><span class="line"><span class="meta">                                                description = &quot;返回实体，AjaxResult内data为StudentVO模型&quot;,</span></span><br><span class="line"><span class="meta">                                                anyOf = &#123;AjaxResult.class, StudentVO.class&#125;)</span></span><br><span class="line"><span class="meta">                                )</span></span><br><span class="line"><span class="meta">                        )</span></span><br><span class="line"><span class="meta">                &#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Scheme <strong>配置请求接口参数信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">注解：<span class="meta">@Schema</span> 是用于描述数据模型的基本信息和属性，具体可以参考“io.swagger.v3.oas.annotations.media”</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：description：用于描述该类或属性的作用。</span><br><span class="line">        ②：name：指定属性名。该属性只对属性有效，对类无效。</span><br><span class="line">        ③：title：用于显示在生成的文档中的标题。</span><br><span class="line">        ④：requiredMode：用于指定该属性是否必填项。枚举Schema.RequiredMode内可选值如下：</span><br><span class="line">            默认AUTO：可有可无；REQUIRED：必须存在此字段(会加红色*)；NOT_REQUIRED：不需要存在此字段</span><br><span class="line">        ⑤：accessMode：用于指定该属性的访问方式。</span><br><span class="line">            包括AccessMode.READ_ONLY（只读）、AccessMode.WRITE_ONLY（只写）、AccessMode.READ_WRITE（读写）</span><br><span class="line">        ⑥：format：用于指定该属性的数据格式。例如：日期格式、时间格式、数字格式。</span><br><span class="line">        ⑦：example：为当前的属性创建一个示例的值，后期测试可以使用此值。</span><br><span class="line">        ⑧：deprecated：用于指定该属性是否为已过时的属性，默认为<span class="literal">false</span>。</span><br><span class="line">        ⑨：defaultValue：用于指定该属性的默认值。</span><br><span class="line">        ⑩：implementation：用于显示为该类或属性引入具体的实体路径，这代表当前指定的类或者属性将参考引入的实体。</span><br><span class="line">            就是说有个实体类，这个类里面有个teacher属性，这时里面的teacher属性可以指定具体的实体类，如下：</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="meta">@Schema(description = &quot;老师信息&quot;,implementation = Teacher.class)</span></span><br><span class="line">                <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">    其它属性：</span><br><span class="line">        ①：type：用于指定数据类型（Data Type）或者元素类型（Element Type）</span><br><span class="line">            基本类型：取值为相应的 Java 类型名，例如 <span class="type">int</span>、<span class="type">long</span>、<span class="type">float</span>、<span class="type">double</span>、<span class="type">boolean</span> 等。</span><br><span class="line">            包装类型：与基本类型相同，取值为相应的Java包装类型名，例如Integer、Long、Float、Double、Boolean等。</span><br><span class="line">            字符串类型：取值为string。</span><br><span class="line">            数组类型：取值为 array。对于数组类型，还可以使用 schema 属性指定其元素类型的 Schema 信息。</span><br><span class="line">            对象类型：不用指定type，可以通过implementation属性引入。</span><br><span class="line">            枚举类型：取值为<span class="keyword">enum</span>。对于枚举类型，还需要使用enumAsRef属性指定是否将其定义为一个独立的引用类型。</span><br><span class="line">            其它类型：不用指定type，可以通过implementation属性引入。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Schema</span>注解：提供了四个属性来描述复杂类型，分别是allOf、anyOf、oneOf和not。</span><br><span class="line">    这四个属性可以用于组合不同的JSON Schema以描述一个复杂类型，具体如下：</span><br><span class="line">    ①：allOf: 表示当前schema是多个其它schema的并集。</span><br><span class="line">        例如，如果一个Java类型同时实现了两个接口，那么可以使用allOf来表示这个Java类型继承了这两个接口的所有属性和方法。</span><br><span class="line">    ②：anyOf: 表示当前schema可以匹配其中任意一个schema，其本身也是一个组合体，可以嵌套使用。</span><br><span class="line">        例如，一个返回类型可能是多个Java类型中的任意一个，可以使用anyOf来描述这种情况。</span><br><span class="line">    ③：oneOf: 表示当前schema只能匹配其中一个schema，其本身也是一个组合体，可以嵌套使用。</span><br><span class="line">        例如，一个Java类型只能是多个子类型中的任意一个，可以使用oneOf来描述这种情况。</span><br><span class="line">    ④：not: 表示当前Schema不能匹配某个schema。</span><br><span class="line">        例如，一个Java类型不能是某个子类型，可以使用not来描述这种情况。</span><br><span class="line">    但是总感觉这个Swagger无法满足我特定要求的实体，具体解决如下：</span><br><span class="line">        比如我现在有个AjaxResult类（code，msg，data），其中data为Object或其它类型，这时我返回的数据里data为其它类型的</span><br><span class="line">        实体，所以我这里不理解如何返回的实体中，通过点击data而显示另外实体，我只能通过anyOf方式来实现（加上注解）</span><br><span class="line">        <span class="meta">@ApiResponse(</span></span><br><span class="line"><span class="meta">                responseCode = &quot;200&quot;,</span></span><br><span class="line"><span class="meta">                description = &quot;响应成功&quot;,</span></span><br><span class="line"><span class="meta">                content = @Content(</span></span><br><span class="line"><span class="meta">                        mediaType = &quot;application/json&quot;,</span></span><br><span class="line"><span class="meta">                        schema = @Schema(</span></span><br><span class="line"><span class="meta">                                description = &quot;返回实体，AjaxResult内data为StudentVO模型&quot;,</span></span><br><span class="line"><span class="meta">                                anyOf = &#123;AjaxResult.class, StudentVO.class&#125;)</span></span><br><span class="line"><span class="meta">                )</span></span><br><span class="line"><span class="meta">        )</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Configuration配置"><a href="#Configuration配置" class="headerlink" title="Configuration配置"></a>Configuration配置</h3><p>以黑马的苍穹外卖为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*需要导入的jar包*/</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Contact;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.License;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springdoc.core.models.GroupedOpenApi;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerOpenAiConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以GroupedOpenApi➕package路径来将不同类别的controller对象进行分组以生成API文档*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">adminOpenApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .packagesToScan(<span class="string">&quot;com.sky.controller.admin&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">userOpenApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .packagesToScan(<span class="string">&quot;com.sky.controller.user&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;准备生成接口文档...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>()</span><br><span class="line">                .name(<span class="string">&quot;蔡桂&quot;</span>)</span><br><span class="line">                .email(<span class="string">&quot;1468664118@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">License</span> <span class="variable">license</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">License</span>()</span><br><span class="line">                .name(<span class="string">&quot;Apache 2.0&quot;</span>)</span><br><span class="line">                .url(<span class="string">&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;</span>)</span><br><span class="line">                .identifier(<span class="string">&quot;Apache-2.0&quot;</span>)</span><br><span class="line">                .extensions(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                .title(<span class="string">&quot;苍穹外卖项目-API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .license(license);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="注入中的ByName和ByType"><a href="#注入中的ByName和ByType" class="headerlink" title="注入中的ByName和ByType"></a>注入中的ByName和ByType</h2><ol>
<li>ByName依据的是Bean在IOC容器中的name（id）来匹配</li>
<li>ByType依据的是变量类型与Bean的Class类型进行匹配</li>
</ol>
<h3 id="AutoWired"><a href="#AutoWired" class="headerlink" title="AutoWired"></a>AutoWired</h3><blockquote>
<p>由Spring提供，默认是byType方式进行注入，即注入时会到容器中去匹配Bean的类型，因此Autowired注入的对象必须在IOC容器中存在（除非加上属性 required &#x3D; false，以忽略当前要注入的Bean）</p>
</blockquote>
<p>关于Autowired的警告：</p>
<ol>
<li><p>不推荐使用字段注入：</p>
<p>平常最常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用上面的注入方式，可能会出现三种问题：</p>
<ol>
<li><p>对象的外部可见性：即，无法在容器外实例化TestService（在测试类中无法注入该组件），无法脱离容器访问目标对象，当在其他地方使用实例化的TestService对象时，会出现空指针异常（错误不明显）</p>
</li>
<li><p>循环的依赖注入：</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestA</span>()&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestB testB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestB</span>()&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestA testA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在可以idea中不会报错，但是在编译时，会造成循环的依赖注入死锁，即当前Bean已作为循环引用的一部分注入到了其他Bean中，无法被使用，造成死锁。</p>
</li>
<li><p>无法注入final对象，也无法注入static变量</p>
</li>
</ol>
</li>
<li><p>官方推荐的注入方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(DiscoveryClient discoveryClient , RestTemplate restTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="built_in">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Spring中前后端数据交互的方式"><a href="#Spring中前后端数据交互的方式" class="headerlink" title="Spring中前后端数据交互的方式"></a>Spring中前后端数据交互的方式</h2><p>前端两种请求方式：<strong>GET</strong>，<strong>POST</strong></p>
<ol>
<li>GET：有请求参数，没有请求体<ol>
<li>使用场景：仅仅需要查询数据库内容，前端到后端数据库<strong>获取get</strong>数据</li>
</ol>
</li>
<li>POST：有请求体，也可以有请求参数<ol>
<li>使用场景：前端需要<strong>交付数据</strong>，并对数据库的内容进行<strong>增删改</strong></li>
</ol>
</li>
</ol>
<p>请求和响应都具备四部分内容：</p>
<ol>
<li><strong>请求行（响应行）</strong></li>
<li><strong>请求头（响应头）</strong>：有一个重要的header——content-type：告诉接收方如何解析对象的body数据。</li>
<li><strong>空行</strong></li>
<li><strong>请求体（响应体）</strong></li>
</ol>
<p>在Java中，可以使用json实现前后端数据交互</p>
<p>json有两种形式：json字符串和json对象</p>
<p>后端controller层接受请求时，常用两个注解：</p>
<ol>
<li>@RequestParam（请求参数）：常用于get方法</li>
<li>@RequestBody（请求体）：常用于post方法</li>
</ol>
<blockquote>
<p>不使用注解也可以获取到请求参数（请求体）数据，因为SpringMVC会自动映射</p>
</blockquote>
<h1 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h1><blockquote>
<p>一款由Spring提供的任务调度工具，定时任务框架，可以按照约定时间自动执行某个代码逻辑</p>
</blockquote>
<p>定时自动执行某段Java代码</p>
<h2 id="核心部分：cron表达式"><a href="#核心部分：cron表达式" class="headerlink" title="核心部分：cron表达式"></a>核心部分：cron表达式</h2><blockquote>
<p>一个字符串，通过cron表达式可以定义任务触发时间</p>
</blockquote>
<p><strong>构成规则：</strong></p>
<p>1. </p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><ol>
<li>将业务中的所有功能进行集成，集中到一个项目中进行开发，并打包到一个jar&#x2F;war包进行部署。</li>
<li>优点：架构简单，部署成本低</li>
<li>缺点：<ol>
<li>团队协作成本高</li>
<li>系统发布效率低（编译一个大型的单体架构项目所需时间及其旧）</li>
<li>系统可用性差</li>
</ol>
</li>
</ol>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><ol>
<li>将一个项目以业务需求进行拆分，分成一个个小型的项目，再进行连接</li>
</ol>
<h3 id="服务拆分的原则："><a href="#服务拆分的原则：" class="headerlink" title="服务拆分的原则："></a>服务拆分的原则：</h3><h4 id="何时拆："><a href="#何时拆：" class="headerlink" title="何时拆："></a>何时拆：</h4><ol>
<li>创业型项目：先使用单体架构快速开发，随着规模的扩大再逐渐拆分</li>
<li>确定的大型项目：资金充足的情况下，项目的架构清晰明了，可以直接使用微服务，避免后续的拆分，先难后易</li>
</ol>
<h4 id="怎么拆"><a href="#怎么拆" class="headerlink" title="怎么拆"></a>怎么拆</h4><ol>
<li><p>高内聚：职责尽量单一，业务关联度和完整度高</p>
</li>
<li><p>低耦合：每个微服务的功能相对独立，降低对其他服务的依赖</p>
</li>
<li><p>拆分方式：</p>
<ol>
<li><strong>纵向</strong>：按照业务模块进行拆分</li>
<li><strong>横向</strong>：抽取公共服务，提高复用性</li>
</ol>
</li>
</ol>
<h4 id="实际拆分服务"><a href="#实际拆分服务" class="headerlink" title="实际拆分服务"></a>实际拆分服务</h4><ol>
<li>工程结构：<ol>
<li>独立Project</li>
<li>maven聚合</li>
</ol>
</li>
</ol>
<h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><blockquote>
<p>在进行服务拆分的时候不可避免的需要有A服务的业务需要调用B服务的业务下的数据库，但是为了进行功能的拆分解耦，又不能出现B服务的业务代码，因此可以参考前后端联调的方式，由A服务向B服务发出一个http的get请求，B服务正常的响应请求，返回数据。</p>
</blockquote>
<p>在Java中使用远程调用，可以通过调用RestTemplate接口，通过实例化一个RestTemplate的对象，进而发出http请求，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于XxxApplication类本身就是一个注册类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<p>所以可以直接在XxxApplication当中将RestTemplate注册到Bean容器当中</p>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h4><ol>
<li><p>服务提供者：暴露接口服务，供其他服务调用</p>
</li>
<li><p>服务消费者：调用其他服务提供的接口</p>
</li>
<li><p>注册中心：记录并监控微服务各个实例的状态，推送服务变更信息（心跳机制）</p>
<ol>
<li><p>心跳机制：<a target="_blank" rel="noopener" href="https://blog.csdn.net/aspnet_lyc/article/details/37318861">参考的原文链接</a></p>
<p>就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。</p>
<p>发包方：可以是客户也可以是服务端，看哪边实现方便合理。<br>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。</p>
</li>
</ol>
</li>
</ol>
<h4 id="消费者如何得知提供者地址"><a href="#消费者如何得知提供者地址" class="headerlink" title="消费者如何得知提供者地址"></a>消费者如何得知提供者地址</h4><p>服务提供者会在启动时注册自己的信息到注册中心，消费者可以从注册中心订阅和拉取服务信息</p>
<h4 id="消费者如何得知服务状态的变更"><a href="#消费者如何得知服务状态的变更" class="headerlink" title="消费者如何得知服务状态的变更"></a>消费者如何得知服务状态的变更</h4><p>服务提供者通过心跳机制来向注册中心报告自己的健康状态，当心跳异常时，注册中心会将异常的服务剔除（登记死亡），并通知订阅了服务的消费者。</p>
<h4 id="在提供者有多个实例时，如何选择："><a href="#在提供者有多个实例时，如何选择：" class="headerlink" title="在提供者有多个实例时，如何选择："></a>在提供者有多个实例时，如何选择：</h4><p>消费者根据负载均衡算法从多个实例选择一个。</p>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Feign%E5%AE%A2%E6%88%B7%E7%AB%AF&spm=1001.2101.3001.7020">OpenFeign客户端</a>是一个web声明式http远程调用工具，直接可以根据服务名称去注册中心拿到指定的服务IP集合，提供了接口和注解方式进行调用，内嵌集成了Ribbon本地负载均衡器。</p>
<p>定义一个接口，用以订阅某个服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span> <span class="comment">//声明服务的名称（即需要拉取的实例的所属的服务的名称）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span><span class="comment">//声明http请求的类型为Get 模仿生成请求url</span></span><br><span class="line">    <span class="comment">/*声明请求的返回值类型*/</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">( <span class="comment">/*请求url的请求参数*/</span> <span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OpenFeign的最佳实践"><a href="#OpenFeign的最佳实践" class="headerlink" title="OpenFeign的最佳实践"></a>OpenFeign的最佳实践</h4><p>为了防止出现重复的代码（当需要在Xxx服务当中使用Item-service时，就需要在Xxx服务当中去引入以上这些相同的代码，造成了代码的冗余与维护的不便。）</p>
<ol>
<li><p>可以将OpenFeign的实践代码放入Item-service本身，将这部分当做item-service的一个模块，将ItemClient设置为对外的一个功能接口，当需要使用时直接用模块坐标，通过pom导入即可使用。</p>
<p>当这样子，会把项目结构复杂化，会把原来一个简单的模块变得更加复杂。</p>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Spring/" data-id="cm7pnj29j002wucv299yq0pny" data-title="spring相关内容" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/实习/简历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/%E7%AE%80%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.134Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.mujicv.com/">木及简历</a></p>
<p>::: left</p>
<p>icon:info 蔡桂滨&#x2F;男&#x2F;2003.09</p>
<p>icon:weixin moru_wxid</p>
<p>icon:phone 15322625838</p>
<p>icon:email2 <a href="mailto:&#x31;&#x34;&#x36;&#x38;&#x36;&#x36;&#52;&#49;&#x31;&#56;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;">1468664118@qq.com</a></p>
<p>icon:blog 广东汕头</p>
<p>icon:fa-arrow-alt-circle-right 求职意向：Java后端开发 | 一周内到岗</p>
<p>:::</p>
<p>::: right</p>
<p>:::</p>
<h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p><strong>华南理工大学(985) - 软件工程 - 本科在校生</strong></p>
<p>主修课程：数据结构、计算机网络、操作系统、数据库系统、软件体系架构</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul>
<li><p><strong>计算机基础</strong>：掌握计算机网络、数据结构和算法、操作系统</p>
</li>
<li><p><strong>Java</strong>：掌握 Java 集合、异常处理、并发，了解 JVM <strong>内存结构、垃圾回收机制、类加载机制</strong></p>
</li>
<li><p><strong>数据库</strong>：</p>
<p>熟悉 MySQL 数据库及库表设计，熟悉部分<strong>优化方法</strong>（索引、SQL语句优化、分库分表），</p>
<p>熟悉 Redis 常见数据结构，了解缓存<strong>穿透、雪崩、击穿</strong></p>
</li>
<li><p><strong>框架</strong>：熟悉SSM+Spring Boot开发框架，了解 <strong>IOC&#x2F;DI</strong>、<strong>面向切面编程</strong>、<strong>Spring事务管理</strong>等知识</p>
</li>
<li><p><strong>开发工具</strong>：熟练使用Git、IDEA、Docker。</p>
</li>
</ul>
<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>::: left</p>
<p><strong>BookDone - 后端</strong></p>
<p><strong>后端技术栈</strong>：SpringBoot、MyBatisPlus、Redis、SSE、Redisson</p>
<p><strong>项目角色</strong>：后端开发核心成员</p>
<p>:::</p>
<p>:::right</p>
<p>2024-08 ~ 2024-11</p>
<p>:::</p>
<p>项目介绍：BookDone 是一个智能学练阅读平台，通过知识可视化技术，将复杂文本转化为动态结构，为学习者个性化构建阅读学练生态。</p>
<p>核心功能有：图书上传与解析、拆解图书章节、构建图书章节树、构建图书章节知识点、构建知识树、智能生成与评判章节自测题并确定用户章节掌握状态</p>
<p>技术亮点：</p>
<ul>
<li><p>使用 <strong>Redis</strong> 缓存书本章节内容、知识点、知识树等数据、避免了频繁了查表操作，提高系统的响应与用户体验</p>
</li>
<li><p>应用 <strong>责任链</strong> 模式，针对图书上传解析的每个步骤设计 Handler 类，遵循单一职责原则和模块化设计，提高了代码的可扩展性和可维护性</p>
</li>
<li><p>通过构建了<strong>核心线程池与普通线程池</strong>进行了<strong>业务分级</strong>，确保核心业务优先执行，避免资源的竞争，提高了业务的整体执行效率。</p>
</li>
<li><p>应用<strong>对象存储服务</strong>来存储上传的图书，结合 STS 服务获取自定义时效和访问权限的临时身份凭证以访问云资源，提高了系统的安全性</p>
</li>
<li><p>使用<strong>SSE</strong>技术实时返回给前端章节知识点原文、知识点自生成、章节自测题等内容。</p>
</li>
<li><p>使用<strong>Redisson</strong>分布式锁保证只有一个线程在生成章节自测题，避免题目重复生成的情况。</p>
</li>
</ul>
<h2 id="校园经历"><a href="#校园经历" class="headerlink" title="校园经历"></a>校园经历</h2><p>::: left</p>
<p>获得 IBM 的 Cloud Business Practitioner Certificate</p>
<p>参加学校勤工助学，担任大学图书馆办公室人事助理，组织管理图书馆人员录取与退岗事宜。</p>
<p>:::</p>
<p>:::right</p>
<p>2024-07</p>
<p>2024-06~至今</p>
<p>:::</p>
<h2 id="获奖简历"><a href="#获奖简历" class="headerlink" title="获奖简历"></a>获奖简历</h2><p>::: left</p>
<p>全国大学生数学建模竞赛三等奖</p>
<p>MathorCup 高校数学建模挑战赛二等奖</p>
<p>:::</p>
<p>:::right</p>
<p>2023-11</p>
<p>2024-07</p>
<p>:::</p>
<h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p><strong>抗压能力较好</strong>，在期末周紧张的时间内组织安排多场图书馆助理面试、与多部门老师协调寒假开馆事宜、期末考试复习，且能够有序安排好每一项工作。</p>
<p><strong>沟通协调能力较强</strong>，能够与各部门的老师与同学积极有效展开工作交流，促使馆内事务顺利开展。</p>
<p><strong>有良好适应力和亲和力</strong>，能够积极主动的融入集体，与新集体中的成员都能够快速建立友善关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/%E7%AE%80%E5%8E%86/" data-id="cm7pnj29f002bucv2d4uf735p" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/实习/实习面试经验" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.133Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="实习面试经验"><a href="#实习面试经验" class="headerlink" title="实习面试经验"></a>实习面试经验</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li>面试的算法题模式？面试的 oj 是什么样的<ul>
<li>import java.util.* 是否可以。</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="锴东哥建议："><a href="#锴东哥建议：" class="headerlink" title="锴东哥建议："></a>锴东哥建议：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/belongtocode/article/details/102989685">LRU算法详解-CSDN博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" data-id="cm7pnj29d001yucv26vli92at" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/实习/Java随笔" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/Java%E9%9A%8F%E7%AC%94/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.132Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/Java%E9%9A%8F%E7%AC%94/">Java随笔</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JAVA面试"><a href="#JAVA面试" class="headerlink" title="JAVA面试"></a>JAVA面试</h1><h1 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h1><ul>
<li><p>java 的特点：</p>
<ul>
<li>平台无关性：java编译器将java源代码编译成与平台无关的字节码文件，在执行时再交由 jvm 进行解释翻译，转换成对应平台的机器码执行程序。（所以jvm是有不同平台的版本区别的）</li>
<li>强面向对象性：一门严格的面向对象语言，几乎一切多事对象。OOP 特性使代码易于维护和重用，class 类，object 对象，abstraction 抽象，inheritance 继承，encapsulation 封装，polymorphism 多态</li>
<li>内存管理：有垃圾回收机制，无需程序员手动管理内存，尽量避免了内存泄露或其他内存问题。</li>
</ul>
</li>
<li><p>java 为什么可以跨平台：</p>
<ul>
<li>主要依赖于 jvm</li>
<li>编译生成的字节码文件与平台无关，无法直接执行，而是必须通过 jvm 再次翻译成相当于的机器码才能执行，不同平台下编译成的字节码都是相同的，但翻译出的机器码是不一样的。</li>
</ul>
</li>
<li><p>jvm、jre、jdk 三者的关系</p>
<ul>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011229283.png" alt="image-20240725230247664"></li>
<li>jvm 是 java 虚拟机，java程序运行的环境。负责将java字节码解释或编译成机器码，并执行程序。jvm 提供了内存管理，垃圾回收，安全性等功能，使得java程序具有跨平台性</li>
<li>jre 是 java 运行时环境，是java程序运行所需的最小环境。包括了 jvm 和一组 java 类库，用于支持 java 程序的执行，jre 不包括开发工具，只提供 java 程序运行所需的运行环境</li>
<li>jdk 是 java 开发工具包，是开发 java 程序所需的工具集合，包含了 jvm、编译器、调试器（jdb）等开发工具，以及一系列类库。jdk 提供了开发、编译、调试和运行java程序所需的所有工具和环境。</li>
</ul>
</li>
<li><p>JDK8 的新特性：</p>
<ol>
<li>元空间代替永久代</li>
<li>引入 Lambda 表达式</li>
<li>引入日期类，引入接口 default 方法和静态方法</li>
<li>新增 Stream 流式接口</li>
<li>引入 Optional 类</li>
<li>新增 CompletableFuture 、StampedLock 等并发实现类。</li>
</ol>
</li>
<li><p>元空间替代永久代</p>
<p>JDK8 要把 JRockit 虚拟机和 Hotspot 虚拟机融合，而 JRockit 没有永久代，所以把 Hotspot 永久代给去了（本质也是永久代回收效率太低）。元空间是分配在直接内存中，解决永久代存在的内存不足、GC效率低的问题</p>
<p><a target="_blank" rel="noopener" href="https://www.mianshiya.com/question/1780933295228350466">为什么 Java8 移除了永久代，加了元空间？</a></p>
</li>
<li><p>引入 Lambda 表达式</p>
<p>一种匿名函数，可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）</p>
</li>
<li><p>引入日期类</p>
<p>引入了新的日期和时间 API（位于 java.time 包中）</p>
<p>原本的 <code>Date</code>、<code>Calendar</code> 都是可变类且线程不安全；且<code>Date</code> 本身不包含时区信息，必须使用 <code>Calendar</code> 类来处理时区，但使用起来非常复杂且容易出错。</p>
<p>而新的日期类都是不可变的，一旦创建就不能修改，这样可以避免意外的修改，提升代码的安全性和可维护性；新的APi提供了专门的时区类如( <code>ZonedDateTime</code>, <code>OffsetDateTime</code>, <code>ZoneId</code> 等），简化了时区处理，并且这些类的方法更加直观和易用。</p>
</li>
<li><p>引入接口 default 方法和静态方法</p>
</li>
<li><p>新增 Stream 流式接口</p>
<p>Stream API 更方便处理集合操作，<code>过滤</code>、<code>排序</code>、<code>分组</code>、<code>映射</code>操作等。它支持链式操作、惰性求值和并行处理。</p>
</li>
<li><p>引入 Optional 类</p>
<p><code>Optional</code> 类用来解决可能出现的 <code>NullPointerException</code> 问题，提供了一种优雅的方式来处理可能为空的值。</p>
<p><a target="_blank" rel="noopener" href="https://www.mianshiya.com/bank/1787463103423897602/question/1800345746421391361">《什么是 Optional 类？》 这题</a></p>
</li>
<li><p>新增 CompletableFuture 、StampedLock 等并发实现类。</p>
<p>CompletableFuture 提供了一个新的异步编程模型，简化了异步任务的编写和管理。</p>
<p><a target="_blank" rel="noopener" href="https://www.mianshiya.com/question/1780933294947332098">《StampedLock 用过吗？》</a> </p>
</li>
<li><p>序列化与反序列化</p>
<ul>
<li><p><strong>序列化</strong>：将对象转换成字节流的过程，因为字节流对象可以进行网络传输、持久化存储或缓存，java提供了接口 <code>java.io.Serializable</code> 来支持序列化，类实现该接口即可将该类的对象序列化。</p>
</li>
<li><p><strong>反序列化</strong>：将字节流重新转换成对象的过程，即从存储中读取数据并重新创建对象。</p>
</li>
<li><p>主要应用场景：</p>
<ul>
<li>网络传输</li>
<li>远程调用</li>
<li>持久化存储</li>
<li>分布式系统中数据交换</li>
</ul>
</li>
<li><p>Java序列化关键类和接口：</p>
<ul>
<li><code>ObjectOutputStream</code> 用于序列化</li>
<li><code>ObjectInputStream</code> 用于反序列化</li>
<li>类必须实现接口 <code>Serializable</code> 才能序列化</li>
</ul>
</li>
<li><p><code>transient</code> 关键字：序列化过程中有些字段不需要被序列化，通过 <code>transient</code> 关键字标记的字段不会被序列化</p>
</li>
<li><p><code>serialVersionUID</code> ：每个实现了 <code>Serializable</code> 接口的类都应该定义一个 <code>serialVersionUID</code> ，用于在反序列化时校验版本一致性，如果没有明确指定，会根据类的定义自动生成（当类发现改变时，可能会因为版本不匹配导致反序列化失败）。</p>
</li>
<li><p>序列化性能问题： Java 的默认序列化机制可能比较慢，尤其对于大规模分布式系统，可能会选择更加高效的序列化框架（Protobuf，Kryo）</p>
</li>
<li><p>安全性：反序列化是一个潜在的安全风险，恶意构造的字节流可以会加载不安全的类或执行不期望的代码。</p>
</li>
<li><p>序列化与反序列化的理解</p>
<p>序列化可以理解成一个扁平化的过程，对象在 JVM 中可以认为是一个“立体”的存在，由于在传输过程中只关心具体的数值而不关心数值在发送端的具体存储地址等信息。反序列化即是按照预先规定好的规则将字节序列重新转换成对象存储在内存中<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011229789.png" alt="image-20250221163325854"></p>
</li>
<li><p>Serializable 接口的意义</p>
<ul>
<li><p>Serializable 这个接口本身没有什么实际功能，起到<strong>标记作用</strong></p>
</li>
<li><p>serialVersionUID的作用：</p>
<ul>
<li><p><code>private static final long serivalVersionUID = 1L;</code></p>
<p>这行代码就是用来验证序列化的对象和反序列化对应的对象的 ID 是否一致，这个字段的值并不重要，重要的是序列化时用的 UID 和反序列化时的 UID 需要一致。</p>
</li>
<li><p>显式声明的原因是人为确定，否则编译器根据类信息自动生成的 UID ，会因为类的内容的变化导致反序列化失败，因为类的结构发生了改变，serialVersionUID 也会发生改变</p>
</li>
<li><p>验证作用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Java 序列化不包括静态变量</p>
<ul>
<li>即序列化之后存储的内容不包括静态变量的值</li>
<li>原因：<ul>
<li>静态变量的本质上属于类而非任何一个实例，所有对象实例共享一个静态变量，生命周期与类加载&#x2F;卸载相关</li>
<li>序列化的目的是保存对象的状态，而静态变量不属于对象，因此不需要纳入序列化当中</li>
<li>逻辑上，静态变量不单独属于某一个对象实例，如果将静态变量作为对象实例的属性进行序列号，在反序列化时可能会引起对静态变量的擅自修改</li>
<li>更具体的说序列化是通过调用对象的 writeObject 方法和 readObject 来实将对象写入输出流和读取输入流的，而静态变量由于不属于对象的一部分，因此调用这两个方法时候静态变量都不参与其中，也就是所谓的序列化无法存储静态变量的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>什么不可变类</p>
<ul>
<li><p>创建后其状态（对象的属性）无法被修改的类。一旦对象被创建，它的所有属性都不能被更改。这种类的实例在整个生命周期中保持不变。</p>
</li>
<li><p>关键特征：</p>
<ul>
<li><p>声明类为 final ，防止子类继承</p>
</li>
<li><p>类的所有字段都是 private 和 final ，确保在初始化后不会被更改</p>
</li>
<li><p>通过构造函数初始化所有字段</p>
</li>
<li><p>不提供如何修改对象状态的方法（如 setter 方法）</p>
</li>
<li><p>如果类包含可变对象的引用，确保这些引用在对象外部无法被修改。例如 getter 方法中返回对象的副本(new 一个新的对象)来保护可变对象字段。</p>
</li>
<li><p>Java中经典的不可变类：包装类、BigDecimal、LocalDate 等</p>
</li>
<li><p><strong>优点</strong>：</p>
</li>
</ul>
</li>
<li><p><strong>线程安全</strong>：由于不可变对象的状态不能被修改，它们先天就是线程安全的，在并发环境下无需同步</p>
</li>
<li><p><strong>缓存友好</strong>：不可变对象可以安全地被缓存和共享，如 String 的字符串常量池。</p>
</li>
<li><p><strong>防止状态不一致</strong>：不可变类可以有效避免因意外修改对象状态而导致的不一致问题。</p>
<ul>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>性能问题</strong>：不可变对象需要在每次状态变化时创建新的对象，可能造成性能开销，尤其对大规模对象或频繁修改的场景（ String 的频繁拼接）</li>
</ul>
</li>
<li><p>String 举例</p>
<p>String就是常见的不可变类，当创建一个 String 对象后该对象无法修改</p>
<p>因此当执行 <code>str += &quot;a&quot;</code> 的操作时，其实返回的是一个新的 String 对象，而原本的对象不会发生改变，只是 str 的引用指向了新的对象。</p>
<p>综上不要在有频繁拼接字符串的场景使用 String ，会造成大量无效对象的创建。</p>
</li>
<li><p>实现一个不可变类</p>
<ul>
<li><p>使用 final 修饰类</p>
</li>
<li><p>使用 private 和 final 修饰字段（使用 final 限制，但）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableClassExample</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CHarSequence &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>八种数据类型：</p>
<ul>
<li>整型 默认为 int 需要加上 l 或 L 声明为 long<ul>
<li>byte 1字节</li>
<li>short 2字节</li>
<li>int 4字节</li>
<li>long 8字节</li>
</ul>
</li>
<li>浮点数 默认为 double 需要加上 f 或 F 声明为 float<ul>
<li>float 4字节</li>
<li>double 8字节</li>
</ul>
</li>
<li>字符<ul>
<li>char 2字节：无符号的，取值从 0 开始</li>
</ul>
</li>
<li>布尔类型<ul>
<li>boolean 2字节</li>
</ul>
</li>
</ul>
</li>
<li><p>数据类型转换</p>
<ul>
<li><strong>隐式转换</strong>：自动类型转换，适用于从小范围类型到大范围类型，安全</li>
<li><strong>显式转换</strong>：强制类型转换，适用于从大范围类型到小范围类型，会发生丢失或溢出，不安全</li>
<li><strong>字符串与其他类型的转换</strong>：<ul>
<li>字符串 -&gt; 其他类型：使用包装类的 <code>parseXxx()</code> 方法 或 <code>valueOf()</code> 方法</li>
<li>其他类型 -&gt; 字符串：使用 <code>String.valueOf()</code> 方法 或 <code>toString()</code> 方法 或 字符串拼接；</li>
</ul>
</li>
<li><strong>包装类与其对应的基本类型的转换</strong>：通过自动装箱和拆箱实现。</li>
<li><strong>字符与整数的转换</strong>：通过强制类型转换实现。</li>
<li><strong>数组与集合的转换</strong>：<ul>
<li>数组 -&gt; 集合：使用 <code>Arrays.asList()</code> </li>
<li>集合 -&gt; 数组：使用<code>toArray()</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><p>类型间互转会出现的问题</p>
<ul>
<li>数据丢失：整型中范围大的转小的</li>
<li>精度损失：浮点数中 float 转 double 精度可能会丢失</li>
<li>类型不匹配导致的错误</li>
</ul>
</li>
<li><p>使用 BigDecimal </p>
<ul>
<li>浮点数的二进制表示问题：在计算机以二进制的形式存储、只能表示 1&#x2F;(2^n) 的和的组合，0.1 这种无法精确表示。</li>
<li>Decimal 是精确计算，一般用于与金钱相关的计算</li>
<li>创建 Decimal 对象时使用字符串初始化</li>
</ul>
</li>
<li><p>自动装箱&#x2F;拆箱：（java1.5 之前需要手动进行装箱和拆箱，1.5之后由编译器自动完成装箱和拆箱）</p>
<ul>
<li>赋值</li>
<li>方法调用</li>
<li>弊端：<ul>
<li>在一个循环中如果某个操作 包装类 不适用则会重复进行 装箱和拆箱操作，中途会产生大量无用的 包装类对象</li>
</ul>
</li>
</ul>
</li>
<li><p>java 为什么要有包装类</p>
<ul>
<li>基本数据类型无法用于泛型</li>
<li>类型转换，如：在java中不能直接将一个 int 转换成 String，需要先 int 转换成 Integer 再转换成 String</li>
<li>把数据和处理数据的方法结合起来</li>
<li>支持 null 值</li>
<li>集合框架只能存储对象，无法存储基本数据类型。</li>
</ul>
</li>
<li><p>包装类与基本数据类型相比的优点（以int为例）</p>
<ul>
<li>基本类型和引用类型：<ul>
<li>基本类型是 java 中最基本的数据类型，预定义的，无需实例化即可使用。</li>
<li>引用类型需要通过实例化对象才能使用。</li>
<li>即，基本类型无需额外的内存分配，而引用类型需要为对象分配内存</li>
</ul>
</li>
<li>自动装箱和拆箱<ul>
<li>包装类实现了自动装箱和拆箱</li>
</ul>
</li>
<li>空指针异常：int变量可以直接赋值为0，但引用类型变量必须通过实例化对象来赋值，如果对一个未初始化的引用类型变量操作，会出现空指针异常，因为此时的变量值为null，而null值无法自动装箱和拆箱。</li>
</ul>
</li>
<li><p>Java 中的参数传递时按值还是按引用</p>
<p>在 Java 中，参数传递只有按值传递，不管是基本类型还是引用类型</p>
<ul>
<li>基本数据类型传递的是值的副本，即数值本身，因此对方法参数的任何修改都不会影响原值</li>
<li>引用数据类型，传递的是引用的副本，即对象引用的内存地址，因此，方法内可以通过修改引用对象的属性，但不会影响对象引用本身的地址。</li>
</ul>
<p>基本类型存储在 <strong>栈内存</strong> 中；引用类型的变量存储的是对象在 <strong>堆内存</strong> 中的地址。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011229579.png" alt="image-20250225231804306"></p>
</li>
<li><p>Java 中 String、StringBuffer 和 StringBuilder 的区别是什么:</p>
<p>三者都是 Java 中处理字符串的类，区别在于<strong>可变性、线程安全和性能</strong>上：</p>
<p>String：</p>
<ul>
<li>不可变</li>
<li>线程安全，因为不可变</li>
<li>性能较低，也因为不可变</li>
</ul>
<p>StringBuffer：</p>
<ul>
<li>可变，可以较快进行字符串的追加、删除、插入等操作。</li>
<li>线程安全：内部使用了 synchronized 关键字修饰方法，保证了多线程环境下的安全性</li>
<li>适用于多线程环境中频繁修改字符串的场景</li>
</ul>
<p>StringBuilder：</p>
<ul>
<li>可变，可以较快进行字符串的追加、删除、插入等操作。</li>
<li>非线程安全</li>
<li>适用于单线程环境中频繁修改字符串的场景</li>
</ul>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 二者都继承了 <code>AbstractStringBuilder</code> ，底层都是利用可修改的 <code>char</code> 数组(JDK 9 以后是 <code>byte</code> 数组)。</p>
<p>如果我们有大量的字符串拼接，如果能预知大小的话最好在 <code>new StringBuffer</code> 或者 <code>StringBuilder</code> 的时候设置好 <code>capacity</code>，避免多次扩容的开销（扩容要抛弃原有数组，还要进行数组拷贝创建新的数组）</p>
</li>
<li><p>剖析 StringBuilder 的实现</p>
<ul>
<li>内部使用字符数组 (char[] value) 来存储字符序列</li>
<li>通过方法如 append()、insert() 等操作，直接修改内部的字符数组，而不会像 String 那样创建新的对象。</li>
<li>每次进行字符串操作时，如果当前容量不足，它会通过扩展数组容量来容纳新的字符，按 2 倍的容量扩展，以减少扩展次数，提高性能。</li>
</ul>
<p>String 底层不也是用的 char 数组存放吗？两者有啥区别：String 被 final 修饰，且内部的 char 也被 private 和 final 修饰了</p>
<p>StringBuilder 底层是用 char 数组存放字符，而数组是连续内存结构，为了防止频繁地复制和申请内存</p>
<p>append 操作：先看看 append 的 int值转成 char 需要占数组的几位，然后计算一下现在的数组够不够放，如果不够就扩容一下，然后再把 int 转成 char 放进去，再更新现有的字符数。</p>
<ul>
<li><p>扩容由 <code>ensureCapacityInternal</code> 这个方法的实现</p>
</li>
<li><p><code>Integer.stringSize</code> 方法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230151.png" alt="image-20250226002256198"> </p>
</li>
<li><p>int 是如何转换成 char 然后插入到数组中的，<code>Integer.getChars</code>方法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230152.png" alt="image-20250226002417214">  </p>
<p><code>DigitOnes、DigitTens</code>这两个数组了，还是查表法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230632.png" alt="image-20250226002424244"></p>
</li>
<li><p>insert 操作：</p>
<p><img src="D:\Blog\source_posts\后端开发\实习\Java随笔.assets\image-20250226234406661.png" alt="image-20250226234406661"> </p>
</li>
<li><p>delete 操作：</p>
</li>
<li><p>StringBuilder 的内部实现就是对数组的操作，而数组的特性就是内存连续，下标访问快。</p>
</li>
<li><p>没有实现缩容操作。</p>
</li>
<li><p>char 数组是可以优化的，底层可以用 byte 数组+一个 coder 标志位来实现，这样更节省内存，因为 char 占用两个字节，这样对于 latin 系的字符来说，太大了，就很浪费，所以用 byte 数组，然后配备一个 coder 来标识所用的编码。</p>
</li>
</ul>
</li>
<li><p>面向对象</p>
<ul>
<li>封装继承多态</li>
<li>一种编程范式，主要思想是将现实世界中的事物抽象为对象，以对象为中心，通过对象间的交互来完成功能的实现，具有灵活性和可扩展性</li>
<li>java 面向对象的三大特点：<ul>
<li>封装：将对象的属性、行为结合在一起，对外隐藏内部细节，仅仅开放操作接口与外界交互，增加了安全性和独立性</li>
<li>继承：子类自动共享父类数据结构和方法的机制，代码复用的重要手段，通过抽象出实体间的关系来构建继承关系，结构清晰明了</li>
<li>多态：允许不同类的对象对同一信息做出响应，即同一个接口在接受不同实例时会执行不同的操作<ul>
<li>编译时多态：方法重载</li>
<li>运行时多态：方法重写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法重载和方法重写的区别</p>
<ul>
<li>方法重载是发生在同一个类内的，同名方法具有不同形参列表，不受访问符影响，可以是静态或非静态，可以各自具有不同的异常处理</li>
<li>方法重写是发生在继承或实现关系中的，由子类重新定义将继承自父类的或实现接口的方法，方法名和形参列表必须相同，子类对修饰符不能比父类更严格（但可以更宽松），只能是非静态的，子类的重写方法不能抛出比父类更多的异常。注意需要使用 @Override 注解，编译器可以帮助检查是否正确实现了重写，以防误操作。</li>
</ul>
<p>重载与返回值没关系，仅仅是方法名和参数列表</p>
</li>
<li><p>多态的实现方式：</p>
<ul>
<li><p>方法重载 编译时多态 静态多态：在编译时确定方法的调用</p>
<ul>
<li>同名方法，但又不同的形参列表，根据传入参数的不同，编译器在编译器在编译时会确定使用哪个方法</li>
</ul>
</li>
<li><p>方法重写 运行时多态 动态多态：在运行时确定方法的调用</p>
<ul>
<li>子类对父类同名方法的具体实现，在运行时，jvm 会根据对象的实际类型确定调用哪个版本的方法</li>
</ul>
</li>
<li><p>接口与实现</p>
<ul>
<li>多个类实现同一个接口，并且用接口类型的引用来调用这些类的方法，同样是在运行时根据实际对象的类型来决定使用哪一个方法，多态绑定（dynamic binding）</li>
</ul>
</li>
<li><p>向上转型和向下转型</p>
<ul>
<li><p>向上转型 <strong>Upcasting</strong>：子类对象转换成父类类型，隐式转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转型</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 隐式转换为父类 Animal 类型</span></span><br><span class="line">animal.eat();   <span class="comment">// 输出 &quot;Dog is eating&quot;（动态绑定，调用子类方法）</span></span><br><span class="line"><span class="comment">// animal.bark(); // 编译错误！父类引用无法访问子类特有方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安全的，因为子类对象一定是父类实例</li>
<li>代码灵活简单</li>
<li>只能访问父类中定义的属性和方法，无法调用子类特有的方法，但子类可以重写分类方法。</li>
</ul>
</li>
<li><p>向下转型 <strong>Downcasting</strong>：父类引用创建的子类对象重新强制转换成子类类型，显式转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.display();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        <span class="comment">//Animal类中原本没有 eat方法，在向下转型之前如果调用eat方法会报错</span></span><br><span class="line">        <span class="comment">//向下转型为子类Dog类后，就可以调用子类中特有的方法，而不会报错</span></span><br><span class="line">      	animal.eat(); <span class="comment">// 编译报错，因为本质还是父类的实例，并不具备子类的特有方法</span></span><br><span class="line">        animal = (Dog)animal;</span><br><span class="line">        ((Dog) animal).eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有转换风险，必须确保父类引用实际指向的目标是子类对象，否则会抛出异常</p>
</li>
<li><p><strong>安全做法</strong>：</p>
<p>使用 <code>instanceof</code> 检查类型后再转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>编程中面向对象思维和面向过程思维的区别：</p>
<p>OOP：是一种以对象为中心的编程范式&#x2F;风格，将类作为最基本的单元来组织代码，在前人的代码实践中总结出：封装、继承、多态三大特性；</p>
<p>面向过程：是一种以过程或函数为中心的编程范式&#x2F;风格，以逻辑的执行过程作为基本的单元来组织代码，函数与数据是分开的</p>
<ul>
<li><strong>面向对象的优缺点</strong>：<ul>
<li><strong>优点</strong>：高复用性、扩展性、维护性强，适合复杂系统的开发。</li>
<li><strong>缺点</strong>：开发和理解成本较高，对于简单项目可能显得繁琐。</li>
</ul>
</li>
<li><strong>面向过程的优缺点</strong>：<ul>
<li><strong>优点</strong>：开发简单，代码执行速度快，适合小型项目。</li>
<li><strong>缺点</strong>：可维护性差，代码复用性低，扩展性差。</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象设计的六大原则：</p>
<ul>
<li><p>单一职责原则 SRP Single Responsibility Principle </p>
<p>一个类应该只有一个引起它变化的原因，即一个类只负责一个职责</p>
<p>目的是：功能聚焦，减少耦合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：一个类同时处理订单和日志</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123; <span class="comment">/* 处理订单逻辑 */</span> &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">logOrder</span><span class="params">()</span> &#123; <span class="comment">/* 记录日志逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：拆分职责</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123; <span class="comment">/* 处理订单逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123; <span class="comment">/* 记录日志逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开发封闭原则 OCP Open Closed Principle </p>
<p>软件实体应该对扩展开放，对修改封闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展新功能时无需修改已有类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123; <span class="comment">/* 计算圆面积 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123; <span class="comment">/* 计算正方形面积 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>里氏替换原则 LSP Liskov Substitution Principle</p>
<p>子类对象应该能够替换所有父类对象</p>
<p>确保继承合理性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：鸟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">/* 飞行逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：企鹅是鸟但不能飞，违反LSP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;企鹅不能飞！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：拆分接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123; <span class="comment">/* 实现飞行 */</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123; <span class="comment">/* 不实现Flyable */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口隔离原则 ISP Interface Segregation Principle</p>
<p>客户端不应该依赖那些不需要的接口，即接口应该小而专</p>
<p>避免接口臃肿 </p>
</li>
<li><p>依赖倒置原则 DIP Dependency Inversion  Principle</p>
<p>高层模块不应该依赖于低层模块，二者应该依赖于抽象；</p>
<p>抽象不应该依赖于细节，细节应该依赖于抽象 </p>
<p>解耦高层和低层模块</p>
</li>
<li><p>最少知识原则 LOD Law of Demeter</p>
<p>减少对象间依赖</p>
<p>一个对象当前对其他对象有最少的了解，只与其直接的朋友交互</p>
</li>
</ul>
</li>
<li><p>为什么 Java 不支持多重继承</p>
<p>主要是因为多继承会产生<strong>菱形继承</strong>问题，会导致继承了两个不同类的子类在调用方法时参数歧义</p>
</li>
<li><p>为什么接口可以多实现</p>
<p>Java8 之前接口无法定义具体方法实现，所以即使继承了多个接口，子类也必须先实现接口中的方法，不会造成歧义</p>
<p>Java8 之后接口可以定义默认方法，Java 规定多个接口有相同默认方法的情况下，子类必须重写方法，否则会在编译期间报错</p>
</li>
<li><p>抽象类和普通类的区别</p>
<ul>
<li>实例化：普通类可以实例化对象，抽象类不能实例化，只能被继承</li>
<li>方法实现：普通类中的方法可以有具体实现；抽象类中的方法可以有实现也可以没有；</li>
</ul>
</li>
<li><p>抽象类和接口的区别</p>
<ul>
<li>抽象类用于描述类的共同特征和行为，可以有<strong>成员变量、构造方法和具体方法</strong>，适用于有明显继承关系的场景</li>
<li>接口用于定义行为规范，可以多实现，只有常量和抽象方法（Java8 之后可以有默认方法和静态方法）。适用于定义类的能力或功能</li>
<li>区别：<ul>
<li>一个类可以实现多个接口，使用关键字 implements；一个类只能继承一个抽象类，使用关键字 extends</li>
<li>接口只有定义，不能有方法的实现（java8 之后可以定义 default方法体）；抽象类可以有方法的定义和方法的实现</li>
<li>接口成员变量默认修饰符为 <code>public static final</code> 必须赋初值且不能被修改，成员方法都是 <code>public</code>、<code>abstract</code>；抽象类中成员变量默认 <code>default</code> 可在子类中被重新定义且重新赋值，抽象方法是被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号</li>
<li>接口只能包含常量（静态常量）；抽象类可以包含实例变量和静态变量</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象类不能加 final 修饰，因为抽象类就是用来作为基类被继承的，而 final 修饰符禁止类被继承或方法被重写，因此，抽象类和 final 修饰符互斥，不可同时使用</p>
</li>
<li><p>接口可以定义的方法：</p>
<ul>
<li><p>抽象方法</p>
<p>接口的核心部分，所有实现接口的类都必须实现这些方法，默认修饰符为： <code>public abstract</code></p>
</li>
<li><p>默认方法</p>
<p>java 8 引入，<code>default</code> 修饰符，允许接口提供默认实现，实现类可以选择重写</p>
</li>
<li><p>静态方法</p>
<p>java 8 引入，属于接口本身，可以通过接口名调用</p>
</li>
<li><p>私有方法</p>
<p>Java 9 中引入，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用</p>
</li>
</ul>
</li>
<li><p>抽象类本身不能被实例化，但是可以有构造器，抽象类构造器在子类实例化时被调用，以便进行必要的初始化。</p>
<p>但是也不会直接实例化抽象类，而是创建了子类实例后，间接使用抽象类的构造器。</p>
</li>
<li><p>接口不可以包含构造方法，编译器会提示报错，因为接口无法实例化，也就不需要构造方法，构造方法在初始化 class 的属性或方法时使用，即通过 new 关键字调用，而接口无法使用 new 关键字，无法实例化，也就没必要有构造方法。</p>
</li>
<li><p>解释静态变量和静态方法</p>
<ul>
<li>Java中，静态变量和静态方法是与类本身相关联的，而不与类的实例关联，在内存中只存有一份，可以被所有类实例共享访问</li>
</ul>
<p><strong>静态变量&#x2F;类变量</strong>：是类中使用 <code>static</code> 声明的变量，属于类而不是任何一个实例</p>
<ul>
<li>共享性：所有类实例共享同一个静态变量，其他一个实例修改了静态变量，其他实例对其具有可见性</li>
<li>初始化：静态变量在类被加载时即初始化，只会对其分配一次内存</li>
<li>访问方式：可以通过<strong>类名访问</strong>，也可以通过<strong>实例访问</strong></li>
<li>作用域：在整个类内可见，类的任何方法内部或外部都可访问静态变量</li>
</ul>
<p><strong>静态方法</strong>：在类中使用 static 声明的方法，类似于静态变量，同样属于类，</p>
<ul>
<li>无实例依赖：可以直接通过类名调用，静态方法不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例</li>
<li>访问静态成员：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员</li>
<li>多态性：静态方法不支持重写，但可以被隐藏(<code>Hide</code>)</li>
<li>不能使用 this 关键字，因为没有当前对象的引用</li>
<li>在类加载时初始化</li>
</ul>
<p>通常建议使用类名来访问静态变量和方法，因为它们与类相关联，而不是与特定对象实例相关。</p>
<p>扩展：</p>
<p><strong>静态块</strong>：用于在类加载时执行静态初始化操作。通常用于执行一些与静态成员变量相关的初始化任务，或类加载时执行一些必要设置</p>
<p>如 bookdone 项目中使用静态代码块对两个线程池进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 核心业务 线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Getter</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor corePool;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 普通线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Getter</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor normalPool;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">/**等待执行的线程队列*/</span></span><br><span class="line">     BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">     corePool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(DEFAULT_CORE_POOL_SIZE</span><br><span class="line">             , DEFAULT_CORE_POOL_SIZE</span><br><span class="line">             , <span class="number">0</span></span><br><span class="line">             , TimeUnit.SECONDS</span><br><span class="line">             , workQueue</span><br><span class="line">             , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;coreBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">             , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line">  </span><br><span class="line">     BlockingQueue&lt;Runnable&gt; workQueueNormal = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">     normalPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(NORMAL_CORE_POOL_SIZE</span><br><span class="line">             , DEFAULT_MAXIMUM_POOL_SIZE</span><br><span class="line">             , NORMAL_KEEP_ALIVE_SECONDS</span><br><span class="line">             , TimeUnit.SECONDS</span><br><span class="line">             , workQueueNormal</span><br><span class="line">             , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;normalBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">             , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个静态块，按照在类内的顺序依次执行。</p>
<p>使用静态变量实现单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 使用静态变量来存储单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共静态方法，用于获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 的内部类是什么，有什么作用：是类内定义的类，有多种形式：成员内部类，局部内部类，匿名内部类和静态内部类</p>
<p>主要作用：</p>
<ul>
<li>封装性</li>
<li>访问外部类成员</li>
<li>简化代码</li>
<li>事件处理</li>
</ul>
</li>
<li><p>内部类的类型</p>
<ul>
<li><strong>成员内部类</strong>：非静态类，作为外部类的一个成员。它可以直接访问外部类的所有成员，包括私有成员。</li>
<li><strong>静态内部类</strong>：定义为 <code>static</code>，无法访问外部类的非静态成员，只能访问外部类的静态成员，其实它就等于一个顶级类，可以独立于外部类使用，所以更多的只是表明类结构和命名空间。</li>
<li><strong>局部内部类</strong>：定义在方法或代码块中的类，仅在该方法或代码块内可见，通常用于临时的对象构建，可以访问外部类的成员以及方法中的局部变量（需要声明为 final 或 effectively final）。</li>
<li><strong>匿名内部类</strong>：没有类名的内部类，通常用于创建短期使用的类实例，尤其是在接口回调或事件处理时被广泛使用。</li>
</ul>
<p>常用成员内部类、静态内部类和匿名内部类。</p>
<p>实际上内部类是一个编译层面的概念，像一个语法糖一样，经过编译器之后其实内部类会提升为外部顶级类，和外部类没有任何区别，所以<strong>在 JVM 中是没有内部类的概念的</strong>。</p>
</li>
<li><p>普通内部类和静态内部类</p>
<ul>
<li><p>普通内部类依赖于外部类的实例，静态内部类不依赖于外部类的实例</p>
</li>
<li><p>普通内部类可以访问外部类的实例变量和方法；静态内部类只能访问外部类的静态成员</p>
</li>
<li><p>普通内部类不能定义静态成员；静态内部类可以定义静态成员</p>
</li>
<li><p>普通内部类在外部类实例化后才实例化；静态内部类可以独立实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.<span class="type">StaticInnerClass</span> <span class="variable">staticInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通内部类可以访问外部类的私有成员；静态内部类不能直接访问外部类的私有成员，必须通过实例化外部类来访问。</p>
</li>
</ul>
</li>
<li><p>非静态内部类可以直接访问外部方法，编译器怎么做到的？</p>
<ul>
<li>因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用</li>
<li>这个引用使非静态内部类可以访问外部类的实例变量和方法。</li>
<li>编译器在生成非静态内部类的构造方法时，将外部实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</li>
</ul>
</li>
<li><p>父类和子类都有静态成员变量、构造方法和静态方法，new 了一个子类对象，加载顺序是怎么样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行顺序为：</p>
<p><img src="/.%5CJava%E9%9A%8F%E7%AC%94.assets%5Cimage-20250225161221459.png" alt="image-20250225161221459"> </p>
<ol>
<li>父类静态成员变量，静态代码块</li>
<li>子类静态成员变量，静态代码块</li>
<li>父类构造函数</li>
<li>子类构造函数</li>
</ol>
</li>
</ul>
</li>
<li><p>深拷贝和浅拷贝</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230747.png" alt="image-20250225161255882"></p>
<p>浅拷贝：只复制了对象和其内部的值类型字段，但不会复制对象内部的引用类型字段，即只是创建一个新的指向源对象引用对象的对象。</p>
<p>深拷贝：在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不会共享引用，生成的是一个全新的对象。</p>
</li>
<li><p>深拷贝的三种方式：</p>
<ul>
<li>实现 <strong>Cloneable</strong> 接口重写 clone 方法</li>
<li>使用序列化和反序列化</li>
<li>手动递归复制</li>
</ul>
</li>
<li><p>泛型</p>
<p>它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p>
<p><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230774.png" alt="image-20250225163623522"> </p>
</li>
<li><p>java创建对象的方法：</p>
<ul>
<li><p>new 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Class 类的 newInstance() 方法 java9 已经弃用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br><span class="line">    System.out.println(obj); <span class="comment">// Output: MyClass&#123;value=0&#125;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Constructor 类的 newInstance() 方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">    System.out.println(obj); <span class="comment">// Output: MyClass&#123;value=10&#125;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 clone() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用反序列化创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.getDeclaredConstructor().newInstance(); <span class="comment">// 推荐</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>new 出的对象何时回收</p>
<p>通过过关键字 new 创建的对象，由Java的垃圾回收器(Garbage Collector)负麦回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p>
<p>Java 对象的回收时机由垃圾回收器根据一些算法来决定，具体有：</p>
<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
<li>终结器 Finalizer</li>
</ul>
</li>
<li><p>反射</p>
<p>Java 反射机制是：在运行状态中，对任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，即动态获取某个类的信息以及动态调用对象的方法的功能</p>
<ul>
<li><p>运行时类信息访问：运行程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等</p>
</li>
<li><p>动态对象创建：可以使用反射 API 动态创建对象实例，即使编译时不知道具体类名——通过Class类的newInstance() 方法或 Constructor 对象的 newInstance() 方法实现的。</p>
</li>
<li><p>动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过 Method 类的 invoke() 方法实现，允许程序员传入对象实例和参数值来执行方法。</p>
</li>
<li><p>访问和修改字段值：允许程序在运行时访问和修改对象的字段值，即使是私有变量，通过 Filed 类的 get() 和 set() 方法实现的。</p>
</li>
<li><p>因为涉及到动态解析，所以性能开销一般比较大，建议在调用对应的动态解析方法后，把解析的结果缓存起</p>
<p>来，这样之后要使用的时候就无需再次动态解析，节省性能</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230768.png" alt="image-20250225170523863"></p>
</li>
</ul>
</li>
<li><p>反射在平时编码或框架中的应用场景</p>
<ul>
<li><p>加载数据库驱动</p>
</li>
<li><p>配置文件加载</p>
<p>Spring 框架的 IOC （动态加载管理 Bean），Spring 通过文件配置各种各样的 Bean，需要用到哪些 bean 就装载哪些，spring 容器会根据开发者需求去动态加载</p>
<p>Spring 通过 xml 配置模式装载 Bean 的过程：</p>
<ul>
<li>将程序中所有 xml 或 properties 配置文件加载入内存</li>
<li>Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码及相关的属性信息</li>
<li>使用反射机制，根据 xml 中获取的字符串获取某个类的 Class 实例</li>
<li>动态配置实例的属性</li>
</ul>
</li>
</ul>
</li>
<li><p>能讲一讲 Java 注解的原理吗？</p>
<p>注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时时生成的动态代理类</p>
<p>通过反射获取注解时，返回的时Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法，该方法会从 memberValues 这个 Map 索引找出对应的值（memberValues 来源是 Java 的常量池）</p>
</li>
<li><p>注解的作用域</p>
<p>注解的 Scope 是指注解可以应用在哪些程序元素上，如 类、方法、字段等，注解作用域分为：</p>
<ul>
<li>类级别：用于描述类的注解，通常放在类定义上面，用来指定类的一些属性，如访问级别、继承关系、注释等，框架中则是可以用来引入某种功能</li>
<li>方法级别：用于描述方式的注解，通常放置在方法定义的上面，用来指定方法的某些属性</li>
<li>字段级别：用于描述字段的注解，通常放置在字段定义的上面，用来指定字段的某些属性</li>
</ul>
</li>
<li><p>异常</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011230234.png" alt="image-20250225173045241"></p>
<ul>
<li><p>异常构成：</p>
<ul>
<li>Throwable类</li>
<li>两个重要子类：Exception 异常 和 Error 错误</li>
<li>Exception 的子类和 Error 的子类</li>
</ul>
</li>
<li><p>Error：严重错误，通常是 JVM 层次内系统级的、无法预料的错误，程序无法通过代码进行处理或恢复。例如内存耗尽（<code>OutOfMemoryError</code>）、栈溢出（<code>StackOverflowError</code>）</p>
<p><code>Error</code> 不应该被程序捕获或处理，因为一般出现这种错误时程序无法继续运行。</p>
</li>
<li><p>Exception 程序中可处理的异常，表示程序逻辑或外部环境中的问题，可以通过代码进行恢复或处理</p>
<ul>
<li>常见子类有：<code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code> 等。</li>
<li>运行时异常 Unchecked ：通常由程序逻辑错误导致,常见的如 <code>NullPointerException</code>、<code>IllegalArgumentException</code> 等，继承自 <code>RuntimeException</code>。</li>
<li>非运行时异常 Checked ：通常是程序编译阶段就被捕获或抛出，通常是外部错误：文件不存在；类未找到等。非运行时异常必须被处理，如 <code>IOException</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java 异常处理：</p>
<ul>
<li>try-catch 语句块：try 块中有可能会抛出异常的代码；catch用于捕获 try 块抛出的异常，可以设置多个catch块来处理不同类型的异常</li>
<li>throw 语句：手动抛出异常</li>
<li>throws 关键字：在方法声明中声明可能抛出的异常类型</li>
<li>finally 块：用于定义无论是否发生异常都会执行的代码块，通常用于释放资源，确保资源的正常关闭。</li>
</ul>
<p>注意点：</p>
<ol>
<li>尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常。</li>
<li>不要 “吞” 异常</li>
<li>不要延迟处理异常</li>
<li>只在需要 try-catch 的地方 try-catch，try-catch 的范围能小则小</li>
<li>不要通过异常来控制程序流程</li>
<li>不要在 finally 代码块中处理返回值或直接 return</li>
</ol>
</li>
<li><p>什么情况不需要在方法签名使用 throws 抛出异常？</p>
<ul>
<li>未检查异常 Unchecked Exceptions 继承自 RuntimeException 类或 Error 类的异常，编译器不强制要求进行异常处理，此类异常不需要在方法签名中使用 throws 来声明。</li>
<li>捕获和处理异常：在方法内部捕获了可能抛出的异常，并在方法内处理了异常，这种情况不需要通过 throws 子句抛出异常传递给调用者，无需在</li>
</ul>
</li>
<li><p>try{return a} finally{return b} 这条语句最终返回的是 b ，因为 finally 块中的return语句会覆盖 try 块中的 return 返回。</p>
</li>
<li><p>“&#x3D; &#x3D;” 和 equals 有什么区别：对于字符串常量来说，“&#x3D; &#x3D;” 和 “equals” 比较字符串时，其比较方法不同。“&#x3D; &#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址；“equals“ 比较字符串包含的内容是否相同。</p>
<p>对于非字符常量来说，如果没有对 equals 进行重写，则 “&#x3D; &#x3D;” 和 equals 方法的作用相同，都是比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。</p>
</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/Java%E9%9A%8F%E7%AC%94/" data-id="cm7pnj29d0020ucv250iggh2i" data-title="Java随笔" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/实习/bookdone" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.131Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Bookdone开发日记"><a href="#Bookdone开发日记" class="headerlink" title="Bookdone开发日记"></a>Bookdone开发日记</h1><h2 id="第一个工作：redis缓存"><a href="#第一个工作：redis缓存" class="headerlink" title="第一个工作：redis缓存"></a>第一个工作：redis缓存</h2><p>redis缓存一般只用于对于更新不算特别频繁但是前端又需要频繁调用的数据，为了提供更好的用户即时交互体验。</p>
<p>在本次任务中，我编写了对于知识点的缓存：</p>
<ol>
<li><p>为了提高数据的响应效率，对于根据固定文章内容生成的基本不变的知识点内容列表，可以考虑使用缓存技术以提高用户的反复查询体验。</p>
</li>
<li><p>本次需求实现采用的是redis 非关系型数据库作为缓存工具，基本流程为：</p>
<ol>
<li>根据用户查询的chapterId进入redis中进行查询</li>
<li>假如得到正确的返回结果，则直接将结果返回或进行流传输</li>
<li>假如返回结果为空，说明缓存中不存在该内容，则进入到Dao层进行数据库查询</li>
<li>将数据库查询出的内容进行redis缓存并设置键值对有效周期为 30min，以便用户短时间内频繁切换不同章节时可以更快的展示。</li>
</ol>
</li>
<li><p>开发过程中遇到的问题：</p>
<ol>
<li>最好将数据库查询操作与redis缓存操作进行原子化，原因是，只有在每次缓存中查找不到信息时才会进入DAO层查询数据库，而在进入DAO层查询数据库时就应当顺便做完缓存操作</li>
<li>本次开发犯的问题是，原本是为了将redis缓存操作放在流传输之后，但是由于没有考虑到如果未与数据库查询操作进行原子化，就会频繁进行redis的更新，增加了无端的内存开销。</li>
</ol>
</li>
<li><p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;KnowledgeNode&gt; <span class="title function_">getKnowledgeNodeList</span><span class="params">(Long chapterId)</span> &#123;</span><br><span class="line">    List&lt;KnowledgeNode&gt; knowledgeNodeList;</span><br><span class="line">   </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisKeyConstant.KNOWLEDGE_NODE + chapterId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dataJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果 redis 中有知识点列表，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNoneBlank(dataJson))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            knowledgeNodeList = objectMapper.readValue(dataJson, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;KnowledgeNode&gt;&gt;()&#123;&#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JsonProcessingException e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;反序列化知识点异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;获取知识点异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果 redis 中没有知识点列表，从数据库中查询</span></span><br><span class="line">        knowledgeNodeList = knowledgeNodeMapper.selectList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;KnowledgeNode&gt;()</span><br><span class="line">                        .eq(<span class="string">&quot;chapter_id&quot;</span>, chapterId)</span><br><span class="line">                        .eq(<span class="string">&quot;is_deleted&quot;</span>, WhetherEnum.NO.getType())</span><br><span class="line">                        .orderByAsc(<span class="string">&quot;sort&quot;</span>));</span><br><span class="line">        <span class="comment">// 查询到知识点列表后，缓存到 redis</span></span><br><span class="line">        cache4Redis(key, knowledgeNodeList);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> knowledgeNodeList;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cache4Redis</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, objectMapper.writeValueAsString(value), <span class="number">30L</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;序列化缓存失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="简历可能提问准备："><a href="#简历可能提问准备：" class="headerlink" title="简历可能提问准备："></a>简历可能提问准备：</h2><h3 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h3><ol>
<li><p>进行 redis 缓存采用的 key 是怎么设计的： </p>
<p>根据具体的业务场景来定义常量</p>
<p>例如 CHAPTER_ORIGINAL_CONTENT &#x3D; “book:chapter_original_content:” ➕ 全局分布式唯一ID 的形式设置为 key，确保了 key 的唯一性。</p>
</li>
<li><p>redis 相关的好处</p>
</li>
</ol>
<h3 id="Redisson："><a href="#Redisson：" class="headerlink" title="Redisson："></a>Redisson：</h3><ul>
<li><p>分布式锁实现：</p>
<p>Redisson 基于 Redis 的 Lua 脚本和 Pub&#x2F;Sub 机制实现分布式锁</p>
<ul>
<li>可重入锁</li>
<li>自动续期</li>
<li>公平锁&#x2F;非公平锁</li>
</ul>
</li>
</ul>
<p>Redisson 和 SENTNX 的对比</p>
<h3 id="责任链相关"><a href="#责任链相关" class="headerlink" title="责任链相关"></a>责任链相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookUploadContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户 id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件原名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String originalFilename;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析操作是否完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean finished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件存储在 oss 的 url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件哈希值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileHash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * oss 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OssTypeEnum ossType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * book id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long bookId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本解析结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BookAnalysisDTO bookAnalysisDTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 知识点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;KnowledgeNode&gt; knowledgeNodeList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String contentType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lang;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>责任链是如何设计的：</p>
<p>责任链全流程为：</p>
<ul>
<li>用户上传电子书</li>
<li>查询是否存在可重用的书本<ul>
<li>计算当前电子书哈希值</li>
<li>查表，看看是否有相同的且解析完成的书本</li>
<li>如果存在则插入新用户的书本相关内容，如章节、章节关系、章节摘要、章节知识点、知识点关系</li>
<li>如果不存在则直接返回，进入下一个处理器</li>
</ul>
</li>
<li>文件云存储，该步骤如果失败终止后续</li>
<li>将拆解后的章节内容落表存储</li>
<li>章节知识处理</li>
</ul>
</li>
</ol>
<h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h3><h3 id="OSS-服务相关"><a href="#OSS-服务相关" class="headerlink" title="OSS 服务相关"></a>OSS 服务相关</h3><p>STS 服务为什么更安全：</p>
<ul>
<li><p><strong>传统长期密钥的风险</strong><br>长期有效的AccessKey一旦泄露（如代码泄露、员工误操作），攻击者可在密钥有效期内无限次访问云资源，造成数据泄露或资源滥用。</p>
<p>STS生成<strong>短期有效的临时凭证</strong>（默认15分钟~36小时），即使凭证被截获，攻击窗口期也大幅缩短</p>
</li>
<li><p><strong>动态权限控制</strong><br>每次生成临时凭证时，可附加<strong>细粒度的权限策略</strong>，仅授予执行当前任务所需的最小权限。</p>
</li>
<li><p><strong>客户端无长期密钥存储</strong><br>在移动端或浏览器端场景中，应用可通过STS动态获取临时凭证，无需在客户端存储长期AccessKey</p>
</li>
</ul>
<h2 id="主要业务："><a href="#主要业务：" class="headerlink" title="主要业务："></a>主要业务：</h2><h3 id="UserController-用户管理接口"><a href="#UserController-用户管理接口" class="headerlink" title="UserController 用户管理接口"></a>UserController 用户管理接口</h3><h3 id="FileController-书本文件上传接口"><a href="#FileController-书本文件上传接口" class="headerlink" title="FileController 书本文件上传接口"></a>FileController 书本文件上传接口</h3><p>书本上传功能的实现类为： FileServiceImpl</p>
<p>文件的上传涉及到的技术为：对象存储服务，在 bookdone 项目中使用的对象存储服务是 阿里云对象存储服务。</p>
<p>文件的上传需要获取 oss 上传临时凭证，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;获取 oss 上传临时凭证&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/oss-temp-credential&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;OssTempCredentialVO&gt; <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(fileService.getOssTempCredential());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> OssTempCredentialVO <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliOssUtil.getOssTempCredential();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssTempCredentialVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String expiration; <span class="comment">// 临时凭证的过期时间。</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId; <span class="comment">// 临时访问密钥ID。</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret; <span class="comment">// 临时访问密钥。</span></span><br><span class="line">    <span class="keyword">private</span> String securityToken; <span class="comment">// 安全令牌。</span></span><br><span class="line">    <span class="keyword">private</span> String requestId; <span class="comment">// 请求的唯一标识符。</span></span><br><span class="line">    <span class="keyword">private</span> String bucket; <span class="comment">// OSS存储桶的名称。</span></span><br><span class="line">    <span class="keyword">private</span> String region; <span class="comment">// OSS存储桶所在的区域。</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint; <span class="comment">// OSS服务的访问端点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OssTempCredentialVO <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">OssTempCredentialVO</span> <span class="variable">ossTempCredentialVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OssTempCredentialVO</span>();</span><br><span class="line">      ossTempCredentialVO.setBucket(aliOssProperties.getBucketName());</span><br><span class="line">      ossTempCredentialVO.setRegion(aliOssProperties.getRegion());</span><br><span class="line">      ossTempCredentialVO.setEndpoint(aliOssProperties.getEndpoint());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STS服务接入点，例如sts.cn-hangzhou.aliyuncs.com。您可以通过公网或者VPC接入STS服务。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;sts.cn-guangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line">      <span class="comment">// 从环境变量中获取步骤1生成的RAM用户的访问密钥（AccessKey ID和AccessKey Secret）。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOssProperties.getAccessKeyId();</span><br><span class="line">      <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOssProperties.getAccessKeySecret();</span><br><span class="line">      <span class="comment">// 从环境变量中获取步骤3生成的RAM角色的RamRoleArn。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">roleArn</span> <span class="operator">=</span> aliOssProperties.getStsArn();</span><br><span class="line">      <span class="comment">// 自定义角色会话名称，用来区分不同的令牌，例如可填写为SessionTest。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">roleSessionName</span> <span class="operator">=</span> <span class="string">&quot;bookdone-upload-session&quot;</span>;</span><br><span class="line">      <span class="comment">// 临时访问凭证将获得角色拥有的所有权限。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 临时访问凭证的有效时间，单位为秒。最小值为900，最大值以当前角色设定的最大会话时间为准。当前角色最大会话时间取值范围为3600秒~43200秒，默认值为3600秒。</span></span><br><span class="line">      <span class="comment">// 在上传大文件或者其他较耗时的使用场景中，建议合理设置临时访问凭证的有效时间，确保在完成目标任务前无需反复调用STS服务以获取临时访问凭证。</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">durationSeconds</span> <span class="operator">=</span> <span class="number">3600L</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发起STS请求所在的地域。建议保留默认值，默认值为空字符串（&quot;&quot;）。</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">regionId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">          <span class="comment">// 添加endpoint。适用于Java SDK 3.12.0及以上版本。</span></span><br><span class="line">          DefaultProfile.addEndpoint(regionId, <span class="string">&quot;Sts&quot;</span>, endpoint);</span><br><span class="line">          <span class="comment">// 添加endpoint。适用于Java SDK 3.12.0以下版本。</span></span><br><span class="line">          <span class="comment">// DefaultProfile.addEndpoint(&quot;&quot;,regionId, &quot;Sts&quot;, endpoint);</span></span><br><span class="line">          <span class="comment">// 构造default profile。</span></span><br><span class="line">          <span class="type">IClientProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);</span><br><span class="line">          <span class="comment">// 构造client。</span></span><br><span class="line">          <span class="type">DefaultAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line">          <span class="keyword">final</span> <span class="type">AssumeRoleRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AssumeRoleRequest</span>();</span><br><span class="line">          <span class="comment">// 适用于Java SDK 3.12.0及以上版本。</span></span><br><span class="line">          request.setSysMethod(MethodType.POST);</span><br><span class="line">          request.setRoleArn(roleArn);</span><br><span class="line">          request.setRoleSessionName(roleSessionName);</span><br><span class="line">          request.setPolicy(policy);</span><br><span class="line">          request.setDurationSeconds(durationSeconds);</span><br><span class="line">          <span class="keyword">final</span> <span class="type">AssumeRoleResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getAcsResponse(request);</span><br><span class="line">          System.out.println(<span class="string">&quot;Expiration: &quot;</span> + response.getCredentials().getExpiration());</span><br><span class="line">          ossTempCredentialVO.setExpiration(response.getCredentials().getExpiration());</span><br><span class="line">          System.out.println(<span class="string">&quot;Access Key Id: &quot;</span> + response.getCredentials().getAccessKeyId());</span><br><span class="line">          ossTempCredentialVO.setAccessKeyId(response.getCredentials().getAccessKeyId());</span><br><span class="line">          System.out.println(<span class="string">&quot;Access Key Secret: &quot;</span> + response.getCredentials().getAccessKeySecret());</span><br><span class="line">          ossTempCredentialVO.setAccessKeySecret(response.getCredentials().getAccessKeySecret());</span><br><span class="line">          System.out.println(<span class="string">&quot;Security Token: &quot;</span> + response.getCredentials().getSecurityToken());</span><br><span class="line">          ossTempCredentialVO.setSecurityToken(response.getCredentials().getSecurityToken());</span><br><span class="line">          System.out.println(<span class="string">&quot;RequestId: &quot;</span> + response.getRequestId());</span><br><span class="line">          ossTempCredentialVO.setRequestId(response.getRequestId());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Failed：&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Error code: &quot;</span> + e.getErrorCode());</span><br><span class="line">          System.out.println(<span class="string">&quot;Error message: &quot;</span> + e.getErrorMessage());</span><br><span class="line">          System.out.println(<span class="string">&quot;RequestId: &quot;</span> + e.getRequestId());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ServerException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.aliyuncs.exceptions.ClientException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ossTempCredentialVO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><h4 id="初始化-OssTempCredentialVO-对象"><a href="#初始化-OssTempCredentialVO-对象" class="headerlink" title="初始化 OssTempCredentialVO 对象"></a>初始化 <code>OssTempCredentialVO</code> 对象</h4><p>首先通过注入了配置文件信息的 <code>private AliOssProperties aliOssProperties</code> 来初始化 <code>OssTempCredentialVO</code> 对象</p>
<h4 id="STS-服务配置"><a href="#STS-服务配置" class="headerlink" title="STS 服务配置"></a>STS 服务配置</h4><p><strong>STS（Security Token Service，安全令牌服务）</strong> 是阿里云提供的一种服务，用于生成和管理临时访问凭证（临时安全令牌）。这些临时凭证可以代替长期有效的访问密钥（AccessKey），用于访问阿里云的资源（如OSS、ECS、RDS等），从而提高系统的安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STS服务接入点，例如sts.cn-hangzhou.aliyuncs.com。您可以通过公网或者VPC接入STS服务。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;sts.cn-guangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 从环境变量中获取步骤1生成的RAM用户的访问密钥（AccessKey ID和AccessKey Secret）。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOssProperties.getAccessKeyId();</span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOssProperties.getAccessKeySecret();</span><br><span class="line"><span class="comment">// 从环境变量中获取步骤3生成的RAM角色的RamRoleArn。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">roleArn</span> <span class="operator">=</span> aliOssProperties.getStsArn();</span><br><span class="line"><span class="comment">// 自定义角色会话名称，用来区分不同的令牌，例如可填写为SessionTest。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">roleSessionName</span> <span class="operator">=</span> <span class="string">&quot;bookdone-upload-session&quot;</span>;</span><br><span class="line"><span class="comment">// 临时访问凭证将获得角色拥有的所有权限。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<p>主要分为两个上传方式：</p>
<p><code>upload</code></p>
<ul>
<li>功能：上传文件、计算文件哈希值、检查文件是否已存在、解析文件内容、保存文件到本地、创建图书记录、异步处理文件上传和解析任务。</li>
</ul>
<p>代码流程：</p>
<ol>
<li><p>用户登陆检验</p>
<p>如果用户未登陆会抛出异常 <code>RuntimeException(&quot;用户未登录&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> Optional.ofNullable(UserContextHolder.getCurrentUser())</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件非空检查</p>
<p>如果文件为空，抛出异常 <code>RuntimeException(&quot;文件为空&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = Optional.ofNullable(file)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件为空&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算文件哈希值</p>
<ul>
<li>使用 <code>DigestUtils.md5DigestAsHex</code> 计算文件的 MD5 哈希值；如果哈希值计算失败抛出异常 <code>RuntimeException(&quot;文件 hash 计算失败&quot;)</code></li>
<li>检查数据库中是否已存在相同哈希值的文件（避免重复上传）。</li>
<li>如果文件已存在，抛出业务异常 <code>BusinessException(ErrorCode.BOOK_EXIST_ERROR, &quot;该书已存在&quot;)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String fileHash;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileHash = DigestUtils.md5DigestAsHex(file.getInputStream());</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> bookMapper.selectFileHashCount(fileHash, currentUser.getId());</span><br><span class="line">    ThrowUtils.throwIf(count &gt; <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.BOOK_EXIST_ERROR, <span class="string">&quot;该书已存在&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;文件 hash 计算失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件 hash 计算失败&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;文件已存在&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.BOOK_EXIST_ERROR, <span class="string">&quot;该书已存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件类型检查</p>
<ul>
<li>提取文件扩展名，并检查是否为 <code>EPUB</code> 格式。</li>
<li>如果文件类型不符合要求，抛出业务异常 <code>BusinessException(ErrorCode.File_TYPE_ERROR, &quot;文件类型错误，必须为 epub&quot;)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">ThrowUtils.throwIf(StringUtils.isBlank(filename), <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件名为空&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">ThrowUtils.throwIf(!FileExtentionEnum.EPUB.getDesc().equals(fileExtension.toLowerCase()), </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.File_TYPE_ERROR, <span class="string">&quot;文件类型错误，必须为 epub&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户解析额度检查</p>
</li>
<li><p>文件解析</p>
<ol>
<li>调用 <code>analyzeBook</code> 方法解析文件内容。</li>
</ol>
</li>
<li><p>文件存储</p>
<ol>
<li><p>先生成分布式唯一图书 ID</p>
</li>
<li><p>构建文件本地保存路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCAL_DIR</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;upload&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其中 System.getProperty(“user.dir”) 是当前工作目录（即运行 Java 程序的目录）。</p>
<p><code>File.separator</code>: 系统文件路径分隔符（在 Windows 上是 <code>\</code>，在 Linux 和 macOS 上是 <code>/</code>）。</p>
<p><code>&quot;upload&quot;</code>: 在项目根目录下创建一个名为 <code>upload</code> 的文件夹，用于存储上传的文件。</p>
<p>综上 LOCAL_DIR 的值为：<code>&lt;项目根目录&gt;/upload</code></p>
</li>
<li><p>构建用户和图书的目录结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">localFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(LOCAL_DIR + File.separator + userId + File.separator + bookId + filename);</span><br></pre></td></tr></table></figure>

<p>根据以上逻辑最终存储路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;项目根目录&gt;/upload/userId/bookId+filename.epub</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>创建图书记录</p>
<ul>
<li>创建 <code>Book</code> 对象并设置相关属性（ID、文件哈希值、状态、OSS 类型、语言等）。</li>
<li>提取封面图片并上传到阿里云 OSS。</li>
<li>设置书名并保存图书信息到数据库。</li>
</ul>
</li>
<li><p>保存用户-图书关系</p>
<ul>
<li>创建 <code>UserBook</code> 对象并设置用户 ID 和图书 ID。</li>
<li>保存用户-图书关系到数据库。</li>
</ul>
</li>
<li><p>异步处理上传和解析任务</p>
<ul>
<li>创建 <code>BookUploadTask</code> 任务，并使用责任链模式调用多个处理器处理上传和解析任务。</li>
<li>将任务提交到线程池 <code>CoreBusinessPoolHolder</code> 中异步执行。</li>
</ul>
</li>
<li><p>返回生成的唯一图书 UID</p>
</li>
</ol>
<p><code>uploadV2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="书本和用户的关系"><a href="#书本和用户的关系" class="headerlink" title="书本和用户的关系"></a>书本和用户的关系</h3><h3 id="ChapterController-章节相关接口"><a href="#ChapterController-章节相关接口" class="headerlink" title="ChapterController 章节相关接口"></a>ChapterController 章节相关接口</h3><h4 id="获取章节知识点"><a href="#获取章节知识点" class="headerlink" title="获取章节知识点"></a>获取章节知识点</h4><p>简单的根据章节 id 到数据库获取知识点，组装入 vo 对象直接返回给前端处理即可</p>
<h4 id="获取章节知识树"><a href="#获取章节知识树" class="headerlink" title="获取章节知识树"></a>获取章节知识树</h4><h5 id="技术使用："><a href="#技术使用：" class="headerlink" title="技术使用："></a>技术使用：</h5><ol>
<li><strong>redis</strong>： 知识树内容不多，选择缓存知识树，减少对数据库的查询，快速响应用户阅览<ul>
<li>缓存优先：首先从 redis 中根据 key 获取知识树，如果缓存命中则直接返回</li>
<li>未命中再从数据库或算法服务中获取数据，并将结果缓存到 Redis。</li>
</ul>
</li>
<li><h2 id="分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。"><a href="#分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。" class="headerlink" title="分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。"></a><strong>分布式锁</strong>：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。</h2></li>
<li><strong>自定义异常处理</strong>：</li>
</ol>
<h4 id="获取章节摘要"><a href="#获取章节摘要" class="headerlink" title="获取章节摘要"></a>获取章节摘要</h4><h4 id="获取章节知识点原文"><a href="#获取章节知识点原文" class="headerlink" title="获取章节知识点原文"></a>获取章节知识点原文</h4><h4 id="获取章节知识点自生成内容"><a href="#获取章节知识点自生成内容" class="headerlink" title="获取章节知识点自生成内容"></a>获取章节知识点自生成内容</h4><h4 id="章节自测题-SelftTest"><a href="#章节自测题-SelftTest" class="headerlink" title="章节自测题 SelftTest"></a>章节自测题 SelftTest</h4><p>总共三个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;生成章节自测题&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/gen-self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Void&gt; <span class="title function_">generateSelfTest</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;chapterId&quot;)</span> Long chapterId,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;是否重新生成：0-否；1-是，不传默认为 0&quot;)</span> <span class="meta">@RequestParam(value = &quot;reGenerate&quot;, required = false)</span> Integer reGenerate,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;生成选择题数量，不传默认为 2&quot;)</span> <span class="meta">@RequestParam(value = &quot;choiceQuestionNum&quot;, required = false)</span> Integer choiceQuestionNum,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;生成判断题数量，不传默认为 2&quot;)</span> <span class="meta">@RequestParam(value = &quot;judgeQuestionNum&quot;, required = false)</span> Integer judgeQuestionNum)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(chapterContentService.generateSelfTest(chapterId, reGenerate, choiceQuestionNum, judgeQuestionNum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;获取章节自测题&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;ChapterTestQuestionVO&gt; <span class="title function_">getSelfTest</span><span class="params">(<span class="meta">@RequestParam(&quot;chapterId&quot;)</span> Long chapterId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(chapterContentService.getSelfTest(chapterId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;判断用户是否掌握此章节&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;SelfTestResultVO&gt; <span class="title function_">judgeSelfTest</span><span class="params">(<span class="meta">@RequestBody</span> SelfTestSubmitReq selfTestSubmitReq)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(chapterContentService.judgeSelfTest(selfTestSubmitReq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生成自测问题"><a href="#生成自测问题" class="headerlink" title="生成自测问题"></a>生成自测问题</h5><p>采用了线程池技术进行<strong>异步生成对应章节的自测题</strong>。</p>
<ul>
<li><p>首先创建 <code>GenTestQuestionTask</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenTestQuestionTask</span> <span class="variable">genTestQuestionTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenTestQuestionTask</span>(questionMapper, redisIdWorker, algConfig, knowledgeNodeMapper, chapterId, redissonClient);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将 <code>GenTestQuestionTask</code> 对象放入核心业务线程池中执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoreBusinessPoolHolder.execute(genTestQuestionTask);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenTestQuestionTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br></pre></td></tr></table></figure>

<p>由于 <code>GenTestQuestionTask</code> 实习了接口 <code>Runnable</code> ，因此将该任务放入线程池后，线程池会自动调用 <code>run</code> 方法，从而实现异步生成章节自测题。</p>
</li>
<li><p><code>GenTestQuestionTask</code> 中实现的 <code>run</code> 方法：</p>
<p>首先获取分布式锁：</p>
<p>确保同一个章节的自测题生成任务不会出现并发执行，防止重复生成或造成数据不一致</p>
<p><strong>实现细节</strong>：</p>
<ul>
<li>在获取 lock 时使用的是 <code>tryLock</code> 方法，该方法是非阻塞式的，也就意味着 “<strong>尝试获取锁，但不会无限期等待</strong>”。允许调用者在获取锁失败时立即返回或执行其他逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;chapter:content:question:lock:&quot;</span> + chapterId);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;章节 &#123;&#125; 生成自测题任务已被其他线程执行&quot;</span>, chapterId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而后查询章节下的知识点列表、封装好请求参数后</p>
<p>使用 <code>OkHttpClient</code> 发送 POST 请求到算法端，调用算法端服务生成题目</p>
<p>获取算法端解析完毕的响应，得到生成好的对应章节的题目列表</p>
<p>将获取到的题目列表封装到 Question 的列表中而后落表存储题目数据</p>
<p>最后释放分布式锁</p>
</li>
</ul>
<h5 id="获取章节自测题"><a href="#获取章节自测题" class="headerlink" title="获取章节自测题"></a>获取章节自测题</h5><p>根据请求的 <code>chapterId</code>，在数据库中查询在章节下是否已经有对应的自测题</p>
<p>如果有封装成 <code>List&lt;CommonQuestionVO&gt;</code> 封装入 <code>ChapterTestQuestionVO</code> 对象后直接返回。</p>
<p>如果没有会进入 生成自测题 的业务，生成自测题后再重新获取数据库中的题目列表再返回给前端。</p>
<p><strong>实现细节</strong>:</p>
<ul>
<li><p>在获取 lock 时使用的是 <code>tryLock</code> 方法，该方法是非阻塞式的，也就意味着 “<strong>尝试获取锁，但不会无限期等待</strong>”。允许调用者在获取锁失败时立即返回或执行其他逻辑</p>
</li>
<li><p>同时自定义锁的获取策略：设置好了重试次数、重试间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isLocked) &#123;</span><br><span class="line">    <span class="comment">// 获取不到锁，说明有其他线程在生成题目</span></span><br><span class="line">    log.info(<span class="string">&quot;chapterId: &#123;&#125; 等待其他线程生成题目&quot;</span>, chapterId);</span><br><span class="line">    CoreBusinessPoolHolder.executeNormal(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retryTimes</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRetryTimes</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!questionsGenerated.get()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;chapterId: &#123;&#125; 轮询第 &#123;&#125; 次尝试获取锁&quot;</span>, chapterId, retryTimes++);</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; maxRetryTimes) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;chapterId: &#123;&#125; 轮询尝试获取锁超过最大次数&quot;</span>, chapterId);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;获取题目失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line">                    questionsGenerated.set(<span class="literal">true</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line"><span class="comment">//                    &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//                        lock.unlock();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有获取到锁，短暂休眠</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;获取锁异常&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待后台线程轮询</span></span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取到锁的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    log.info(<span class="string">&quot;chapterId: &#123;&#125; 题目未生成，主线程执行生成题目任务&quot;</span>, chapterId);</span><br><span class="line">	    <span class="comment">// 如果成功获取锁，说明题目未生成</span></span><br><span class="line">	    <span class="type">GenTestQuestionTask</span> <span class="variable">genTestQuestionTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenTestQuestionTask</span>(questionMapper, redisIdWorker, algConfig, knowledgeNodeMapper, chapterId, redissonClient);</span><br><span class="line">	    <span class="comment">// 在主线程运行</span></span><br><span class="line">	    genTestQuestionTask.run();</span><br><span class="line">	    <span class="comment">// 标记题目已生成</span></span><br><span class="line">	    questionsGenerated.set(<span class="literal">true</span>);</span><br><span class="line">	    <span class="comment">// 计数器减一</span></span><br><span class="line">	    latch.countDown();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (!questionsGenerated.get()) lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体逻辑为：</p>
<ul>
<li>假设有 A、B、C 三个请求到达</li>
<li>A 先获取到了分布式锁</li>
<li>那么 B、C 获取不到锁进入到 if 代码块，A 进入 else 代码块</li>
<li>A 执行了生成自测题的逻辑，B、C 进入轮询获取锁资源的逻辑</li>
<li>假设 A 在 5s 内成功完了自测题的生成，那么 A 释放了锁资源同时将计算器减一</li>
<li>而 B、C 任一获取到锁资源后说明 A 已经成功将自测题生成了，那么就可以将变量 <code>questionsGenerated</code> 设置为true</li>
<li>直接到数据库层获取已经生成的题目列表即可。</li>
</ul>
</li>
</ul>
<h5 id="判断用户是否掌握此章节，自测题答题情况"><a href="#判断用户是否掌握此章节，自测题答题情况" class="headerlink" title="判断用户是否掌握此章节，自测题答题情况"></a>判断用户是否掌握此章节，自测题答题情况</h5><p>业务流程：</p>
<ul>
<li><p>接收用户的答题情况，章节 id 和题目列表（题目 id 和 用户答案）</p>
</li>
<li><p>将用户的答案落库存储，而后对用户的答案进行评定</p>
</li>
<li><p>评定过程：</p>
<ul>
<li><p>先读取已经更新过的 question 库，其中包括了一系列参数，封装到了 <code>List&lt;FullQuestionMetaDTO&gt;</code> 后再封装到 <code>LearningStateEvaParamDTO</code> 当中作为 http:GET 请求的参数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> q.question <span class="keyword">as</span> question,</span><br><span class="line">q.sort <span class="keyword">as</span> sort,</span><br><span class="line">q.type <span class="keyword">as</span> type,</span><br><span class="line">q.analysis <span class="keyword">as</span> analysis,</span><br><span class="line">q.answer <span class="keyword">as</span> answer,</span><br><span class="line">q.user_answer <span class="keyword">as</span> userAnswer,</span><br><span class="line">kn.id <span class="keyword">as</span> knowledgeNodeId,</span><br><span class="line">kn.name <span class="keyword">as</span> name,</span><br><span class="line">kn.original_content <span class="keyword">as</span> originalContent</span><br><span class="line"><span class="keyword">from</span> question q</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> knowledge_node kn <span class="keyword">on</span> q.knowledge_node_id <span class="operator">=</span> kn.id</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;questionIdList != null and questionIdList.size() &gt; 0&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">and</span> q.id <span class="keyword">in</span></span><br><span class="line">    <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;questionIdList&quot; item<span class="operator">=</span>&quot;questionId&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot; separator<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">        #&#123;questionId&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">and</span> q.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">and</span> kn.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过发送 http 请求到算法端请求 用户学习状态的评估结果 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 okhttp 客户端</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .readTimeout(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">        .writeTimeout(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build();</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(learningStateEvaParamDTO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求体</span></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> RequestBody.create(json, MediaType.get(<span class="string">&quot;application/json; charset=utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从配置获取 url</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> algConfig.getBaseUrl() + algConfig.getLearningStateEvaluateUrl();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 post 请求</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line"></span><br><span class="line">ThrowUtils.throwIf(!response.isSuccessful(), <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;判断用户学习状态异常&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Objects.requireNonNull(response.body()).string();</span><br></pre></td></tr></table></figure>
</li>
<li><p>而后更新用户的 chapter 数据库，记录其正确回答了哪些题目，并向前端返回其正确回答的题目。</p>
</li>
</ul>
</li>
</ul>
<h2 id="项目技术"><a href="#项目技术" class="headerlink" title="项目技术"></a>项目技术</h2><h3 id="SSE-Server-Sent-Events"><a href="#SSE-Server-Sent-Events" class="headerlink" title="SSE Server-Sent Events"></a>SSE Server-Sent Events</h3><p>使用到哪些技术，为什么要使用到这门技术，为什么这么设计，用到的技术都去学一遍</p>
<p>看看数据库表，怎么设计的，有哪些表，哪些有设计索引，为啥这么设计</p>
<h4 id="为什么要使用-SSE"><a href="#为什么要使用-SSE" class="headerlink" title="为什么要使用 SSE"></a>为什么要使用 SSE</h4><ul>
<li>SSE 是一种基于 HTTP 的服务器向客户端实时推送数据的技术。可以通过构建长连接实现服务器向客户端进行单向的数据推送。</li>
<li>使用的是纯文本格式进行数据传输，在本项目采用的是常见的 JSON 格式</li>
<li>长连接 Long Polling：<ul>
<li>通过保持 HTTP 连接打开，可以实现服务器向客户端的实时数据推送</li>
<li>减少了不必要的请求和响应开销</li>
</ul>
</li>
<li>事件驱动型：<ul>
<li>SSE 支持事件驱动，服务器可以发送多个事件，客户端通过监听事件来处理数据</li>
</ul>
</li>
<li>重连机制：<ul>
<li>可以通过预设重连机制来进行错误恢复</li>
</ul>
</li>
<li>浏览器支持，框架支持</li>
</ul>
<h4 id="TODO-项目独特优化"><a href="#TODO-项目独特优化" class="headerlink" title="TODO 项目独特优化"></a>TODO 项目独特优化</h4><ol>
<li><strong>连接管理</strong>：限制最大连接数，定期清理无效连接。</li>
<li><strong>消息推送</strong>：异步重试机制，配置化重试参数。</li>
<li><strong>心跳机制</strong>：定期发送心跳消息，检测客户端状态。</li>
<li><strong>异常处理</strong>：集中处理异常，分类处理不同类型异常。</li>
<li><strong>性能优化</strong>：批量推送消息，使用 HTTP&#x2F;2。</li>
<li><strong>安全性</strong>：客户端身份验证，启用 HTTPS。</li>
</ol>
<h4 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h4><ul>
<li>类型：<code>ConcurrentHashMap&lt;String, SseEmitter&gt;</code>。</li>
<li>作用：存储客户端 ID 和对应的 <code>SseEmitter</code> 对象，用于管理客户端的长连接。</li>
<li>线程安全：使用 <code>ConcurrentHashMap</code> 确保多线程环境下的线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器，保存连接，用于输出返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, SseEmitter&gt; sseCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><h5 id="创建-SSE-长连接"><a href="#创建-SSE-长连接" class="headerlink" title="创建 SSE 长连接"></a>创建 SSE 长连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SseEmitter <span class="title function_">createSseConnect</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置超时时间，0表示不过期。默认30秒，超过时间未完成会抛出异常：AsyncRequestTimeoutException</span></span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">0L</span>); <span class="comment">// 超时时间为 0，表示连接永不过期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*是否需要给客户端推送ID</span></span><br><span class="line"><span class="comment">    if (StringUtils.isBlank(clientId)) &#123;</span></span><br><span class="line"><span class="comment">        clientId = IdUtil.simpleUUID();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">    sseEmitter.onCompletion(completionCallBack(clientId));</span><br><span class="line">    sseCache.put(clientId, sseEmitter);</span><br><span class="line">    log.info(<span class="string">&quot;创建新的sse连接，当前用户：&#123;&#125;&quot;</span>, clientId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sseEmitter.send(SseEmitter.event().id(clientId).data(<span class="string">&quot;连接创建成功&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;SseEmitterServiceImpl[createSseConnect]: 创建长链接异常，客户端ID:&#123;&#125;&quot;</span>, clientId, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sseEmitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关闭指定客户端的-SSE-连接。"><a href="#关闭指定客户端的-SSE-连接。" class="headerlink" title="关闭指定客户端的 SSE 连接。"></a>关闭指定客户端的 SSE 连接。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeSseConnect</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> sseCache.get(clientId);</span><br><span class="line">    <span class="keyword">if</span> (sseEmitter != <span class="literal">null</span>) &#123;</span><br><span class="line">        sseEmitter.complete();</span><br><span class="line">        removeUser(clientId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="根据客户端-ID-获取-SseEmitter-对象。"><a href="#根据客户端-ID-获取-SseEmitter-对象。" class="headerlink" title="根据客户端 ID 获取 SseEmitter 对象。"></a>根据客户端 ID 获取 <code>SseEmitter</code> 对象。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据客户端id获取SseEmitter对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SseEmitter <span class="title function_">getSseEmitterByClientId</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sseCache.get(clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="检查客户端是否存在。"><a href="#检查客户端是否存在。" class="headerlink" title="检查客户端是否存在。"></a>检查客户端是否存在。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkClientIsExist</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(getSseEmitterByClientId(clientId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="向指定客户端推送消息。"><a href="#向指定客户端推送消息。" class="headerlink" title="向指定客户端推送消息。"></a>向指定客户端推送消息。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgToClientByClientId</span><span class="params">(String clientId, String eventName, Object data)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 客户Id 获取 SseEmitter</span></span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> getSseEmitterByClientId(clientId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sseEmitter == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]: 推送消息失败：客户端&#123;&#125;未创建长链接,失败消息:&#123;&#125;&quot;</span>,</span><br><span class="line">                    clientId, data.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;该连接通道不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SseEmitter.SseEventBuilder sendData = SseEmitter.event().id(SseEmitterConstant.TASK_RESULT).data(data, MediaType.APPLICATION_JSON);</span></span><br><span class="line">        SseEmitter.<span class="type">SseEventBuilder</span> <span class="variable">sendData</span> <span class="operator">=</span> SseEmitter.event().id(clientId).name(eventName).data(data, MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sseEmitter.send(sendData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 推送消息失败，记录错误日志，进行重推</span></span><br><span class="line">            log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]: clientId:&#123;&#125; 推送消息失败：&#123;&#125;，尝试进行重推，事件名称:&#123;&#125;&quot;</span>, clientId, data, eventName, e);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 推送消息失败后，每隔 10s 推送一次，推送 5 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    sseEmitter = sseCache.get(clientId);</span><br><span class="line">                    <span class="keyword">if</span> (sseEmitter == <span class="literal">null</span>) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推失败，未创建长链接&quot;</span>, clientId, i + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sseEmitter.send(sendData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推失败&quot;</span>, clientId, i + <span class="number">1</span>, ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推成功,&#123;&#125;&quot;</span>, clientId, i + <span class="number">1</span>, data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Jwt令牌认证"><a href="#Jwt令牌认证" class="headerlink" title="Jwt令牌认证"></a>Jwt令牌认证</h3><h3 id="阿里云对象存储"><a href="#阿里云对象存储" class="headerlink" title="阿里云对象存储"></a>阿里云对象存储</h3><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>使用<strong>Redis</strong>来缓存电子书章节内容、知识点、知识树等数据，提高系统的响应速度</p>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h3 id="完整规范的自定义异常处理"><a href="#完整规范的自定义异常处理" class="headerlink" title="完整规范的自定义异常处理"></a>完整规范的自定义异常处理</h3><h3 id="分布式唯一-Id，"><a href="#分布式唯一-Id，" class="headerlink" title="分布式唯一 Id，"></a>分布式唯一 Id，</h3><p>基于 Redis 的分布式 ID 生成器，借鉴了分布式雪花算法，用于生成全局唯一 ID。结合了时间戳和 Redis 的自增序列号来生成 ID，</p>
<h4 id="核心设计："><a href="#核心设计：" class="headerlink" title="核心设计："></a>核心设计：</h4><ul>
<li><strong>时间戳部分</strong>：使用当前时间与固定起始时间（<code>BEGIN_TIMESTAMP</code>）的差值作为 ID 的高位部分</li>
<li><strong>序列号部分</strong>：使用 Redis 的自增操作生成唯一的序列号，作为 ID 的低位部分</li>
<li><strong>拼接方式</strong>：将时间戳与 redis 序列号拼接组成最终的 ID。</li>
</ul>
<h4 id="常量定义："><a href="#常量定义：" class="headerlink" title="常量定义："></a>常量定义：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到今年第一天的秒数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">COUNT_TIMESTAMP</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成时间戳</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成序列号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">today</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;irc:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + today);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_TIMESTAMP | count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拼接的核心逻辑</strong>:</p>
<p><strong>左移操作 (<code>&lt;&lt;</code>)</strong>:</p>
<ul>
<li><code>timeStamp &lt;&lt; COUNT_TIMESTAMP</code> 将时间戳左移 32 位，腾出低 32 位给序列号。</li>
<li>左移后，时间戳部分占据了 ID 的高 32 位。</li>
<li>用于 <code>timestamp</code> 是 <code>long</code> 类型，因此当 <code>timestamp</code> 变量左移 32 位后原本的高 32 位被丢弃，同时挪出低 32 位来拼接 <code>count</code></li>
</ul>
<p><strong>按位或操作 (<code>|</code>)</strong>:</p>
<ul>
<li><code>timeStamp &lt;&lt; COUNT_TIMESTAMP | count</code> 将左移后的时间戳与序列号进行按位或操作，拼接成一个 64 位的长整型 ID。</li>
</ul>
<h3 id="为什么分布式雪花算法"><a href="#为什么分布式雪花算法" class="headerlink" title="为什么分布式雪花算法"></a>为什么分布式雪花算法</h3><h3 id="文件解析处理业务——责任链模式"><a href="#文件解析处理业务——责任链模式" class="headerlink" title="文件解析处理业务——责任链模式"></a>文件解析处理业务——责任链模式</h3><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011231185.png" alt="image-20250222230854595"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011231233.png" alt="OssUploadHandler"></p>
<p>对于书本文件的解析采用了责任链模式：</p>
<p>责任链模式（Chain of Responsibility Pattern）允许多个对象有机会处理请求，从而避免请求的发送者与接收者之间的耦合。责任链模式将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为止。</p>
<p>本项目的责任链模式被用于处理图书上传的多个步骤。每个步骤由一个处理器（Handler）负责，处理器之间通过链式调用依次执行。</p>
<p>在 SpringBoot 项目当中可以通过 @Order 注解来实现责任链模式，以本项目为例：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011231771.png" alt="diagram"></p>
<p>实现同一个接口 <code>BookUploadHandler</code></p>
<h4 id="定义抽象的处理器接口"><a href="#定义抽象的处理器接口" class="headerlink" title="定义抽象的处理器接口"></a>定义抽象的处理器接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookUploadHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器是否适配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否适配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否可以执行 Handle 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 判断结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBookUploadHandler</span> <span class="keyword">implements</span> <span class="title class_">BookUploadHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义处理器子类实现"><a href="#定义处理器子类实现" class="headerlink" title="定义处理器子类实现"></a>定义处理器子类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookCacheHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractBookUploadHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssUploadHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractBookUploadHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="封装组合责任链"><a href="#封装组合责任链" class="headerlink" title="封装组合责任链"></a>封装组合责任链</h4><ul>
<li>通过 @Autowired 修饰责任链（处理器的集合），spring 会按照 @Order 的顺序组装成一个有序的 list 集合。</li>
<li>@Order 注解里面的数组越小代表优先级越高</li>
</ul>
<h4 id="使用责任链模式的好处"><a href="#使用责任链模式的好处" class="headerlink" title="使用责任链模式的好处"></a>使用责任链模式的好处</h4><ul>
<li><p>职责分离:每个处理器类负责各自己的独立任务，有助于代码的模块化与可维护性</p>
</li>
<li><p>易于扩展:如果需要添加或修改某个功能，只需要添加一个处理器类或者在单个处理器类内进行修改</p>
</li>
<li><p>灵活性高:通过调整处理器在链中的顺序，可以改变处理流程</p>
</li>
<li><p>减少耦合度:各个处理器之间是松耦合的,降低了系统的复杂性与依赖关系</p>
</li>
</ul>
<h4 id="使用模式的缺点"><a href="#使用模式的缺点" class="headerlink" title="使用模式的缺点"></a>使用模式的缺点</h4><ul>
<li>增加了程序的复杂度，需要根据实际业务需求评估后再决定是否使用，不能为了设计模式而设计。</li>
</ul>
<h3 id="线程池设计与任务"><a href="#线程池设计与任务" class="headerlink" title="线程池设计与任务"></a>线程池设计与任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoreBusinessPoolHolder</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务器核心数动态计算的默认核心线程池大小</span></span><br><span class="line"><span class="comment">     * 默认为 CPU 核心数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CORE_POOL_SIZE</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程池的最大线程数</span></span><br><span class="line"><span class="comment">     * 经验最佳数量（具体最佳最大线程数需要压测） = 2* CPU数目 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">2</span> * DEFAULT_CORE_POOL_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL_CORE_POOL_SIZE</span> <span class="operator">=</span> DEFAULT_CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超过核心线程后，空闲线程等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DEFAULT_KEEP_ALIVE_SECONDS</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NORMAL_KEEP_ALIVE_SECONDS</span> <span class="operator">=</span> <span class="number">60L</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列长度</span></span><br><span class="line"><span class="comment">     * 默认：最大线程池大小*3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAIT_QUEUE_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心业务 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor corePool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor normalPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/**等待执行的线程队列*/</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">        corePool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(DEFAULT_CORE_POOL_SIZE</span><br><span class="line">                , DEFAULT_CORE_POOL_SIZE</span><br><span class="line">                , <span class="number">0</span></span><br><span class="line">                , TimeUnit.SECONDS</span><br><span class="line">                , workQueue</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;coreBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueueNormal = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">        normalPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(NORMAL_CORE_POOL_SIZE</span><br><span class="line">                , DEFAULT_MAXIMUM_POOL_SIZE</span><br><span class="line">                , NORMAL_KEEP_ALIVE_SECONDS</span><br><span class="line">                , TimeUnit.SECONDS</span><br><span class="line">                , workQueueNormal</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;normalBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心业务执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        corePool.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通业务执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">executeNormal</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        normalPool.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于管理和执行核心业务和普通业务的异步任务。它通过静态初始化块创建了两个线程池：<strong>核心业务线程池</strong>和<strong>普通业务线程池</strong>，并提供了执行任务的方法。</p>
<h4 id="类功能"><a href="#类功能" class="headerlink" title="类功能"></a>类功能</h4><ul>
<li><strong>核心功能</strong>:<ul>
<li>创建并管理两个线程池：<code>corePool</code>（核心业务线程池）和 <code>normalPool</code>（普通业务线程池）。</li>
<li>提供静态方法 <code>execute</code> 和 <code>executeNormal</code>，用于提交任务到对应的线程池中执行。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>适用于需要异步执行任务的场景，例如文件上传、数据处理、任务调度等。</li>
<li>通过区分核心业务和普通业务，可以更好地管理线程资源，确保核心业务的高优先级执行。</li>
</ul>
</li>
</ul>
<h4 id="关于线程池知识拓展"><a href="#关于线程池知识拓展" class="headerlink" title="关于线程池知识拓展"></a>关于线程池知识拓展</h4><h5 id="ThreadPoolExecutor-主要有以下几个参数"><a href="#ThreadPoolExecutor-主要有以下几个参数" class="headerlink" title="ThreadPoolExecutor 主要有以下几个参数:"></a>ThreadPoolExecutor 主要有以下几个参数:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="线程池的配置，参数详解"><a href="#线程池的配置，参数详解" class="headerlink" title="线程池的配置，参数详解"></a>线程池的配置，参数详解</h5><ol>
<li><strong>corePoolSize 核心线程数</strong></li>
<li><strong>maximumPoolSize 最大线程数</strong></li>
<li><strong>keepAliveTime 空闲线程存活时间</strong></li>
<li><strong>TimeUnit 时间单位</strong></li>
<li><strong>workQueue 任务队列</strong></li>
<li><strong>threadFactory 线程工厂</strong></li>
<li><strong>RejectedExecutionHandler 拒绝策略</strong></li>
</ol>
<h4 id="整个业务流程"><a href="#整个业务流程" class="headerlink" title="整个业务流程"></a>整个业务流程</h4><ol>
<li><strong>初始化线程池</strong>：<ul>
<li>在 <code>CoreBusinessPoolHolder</code> 的静态代码块中，初始化核心业务线程池和普通业务线程池。</li>
</ul>
</li>
<li><strong>创建任务</strong>：<ul>
<li>创建 <code>BookUploadContext</code> 对象，并设置任务的相关属性。</li>
<li>创建 <code>BookUploadTask</code> 对象，传入上下文和处理器列表。</li>
</ul>
</li>
<li><strong>提交任务</strong>：<ul>
<li>调用 <code>CoreBusinessPoolHolder.execute(task)</code>，将任务提交到核心业务线程池。</li>
</ul>
</li>
<li><strong>任务执行</strong>：<ul>
<li>线程池中的线程从队列中取出任务，调用 <code>BookUploadTask.run()</code> 方法。</li>
<li>遍历处理器列表，依次处理任务。</li>
</ul>
</li>
<li><strong>异常处理</strong>：<ul>
<li>如果任务执行过程中发生异常，记录错误日志。</li>
</ul>
</li>
</ol>
<p><strong>模式优点</strong></p>
<ol>
<li><strong>高并发处理</strong>：通过线程池提高任务处理能力。</li>
<li><strong>职责分离</strong>：线程池管理、任务定义和任务提交逻辑分离，代码结构清晰。</li>
<li><strong>扩展性强</strong>：通过责任链模式，可以灵活扩展任务处理器。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/" data-id="cm7pnj29e0024ucv25dj164ls" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/Java基础➕高阶/JUC学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JUC%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.102Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JUC%E5%AD%A6%E4%B9%A0/">JUC学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JUC学习"><a href="#JUC学习" class="headerlink" title="JUC学习"></a>JUC学习</h1><blockquote>
<p>java.util.concurrent java并发编程，简称 JUC 包，Java 1.5 引入的。涵盖了多线程、同步、锁、并发容器、线程池等相关组件</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>存储在静态资源当中的程序（数据与指令集合）运行起来时的一种状态，即运行的程序就是进程</p>
<p>是系统<strong>进行资源分配和调度的基本单位</strong></p>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>一个进程中可以分配多个线程！！</p>
<p>线程是一个指令流，将指令流中的一条条指令交给 cpu 运行。</p>
<p>线程是<strong>是操作系统能够进行运算调度的最小单位</strong>。</p>
<blockquote>
<p>首先由系统分配资源给一个进程，而后在进程内部再由线程来调度资源的使用</p>
</blockquote>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>每一个进程间是独立的，但线程都存在于同一个进程中</li>
<li>同一天计算机的进程通信称为 IPC(inter-process communication)；不同计算机之间的进程通信则需要通过网络与协议，例如常见的 http 等等</li>
<li>线程通信相对简单，因为共享进程内的内存，多个线程可以访问同一个共享变量，上下文切换成本低于进程</li>
</ul>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>同一时间，多个指令在单个 CPU 上交替执行</p>
<p>单核 cpu 下，线程本质上都是串行执行的，由操作系统的任务调度器组件，将 cpu 的执行时间切成时间片（win 时间片最小为 15ms）分给不同的程序使用，<strong>微观串行，宏观并行</strong>。</p>
<p>一个核心轮流执行各个线程，线程轮流使用 CPU 的行为称为并发，concurrent</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>同一时间，多个指令在多个 CPU 上同时执行</p>
<p>多个核心同一时间执行不同的线程</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>需要等待结果返回，才能运行即为同步</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>无需等待结果返回，也能运行即为异步</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ul>
<li><p>新建状态**(NEW)**</p>
<ul>
<li>使用new关键字和Thread类或子类建立一个线程对象A后，则线程对象A处于新建状态。一直到进程<code>start()</code>这个线程。</li>
</ul>
</li>
<li><p>就绪状态**(RUNNABLE)**</p>
<ul>
<li>有执行资格，没有执行权</li>
<li>当线程对象A调用<code>start()</code>方法后，线程进入就绪状态、参与到等待队列中，等待JVM中线程调度器的调度的调度。</li>
</ul>
</li>
<li><p>运行状态</p>
<ul>
<li>有执行资格也有执行权</li>
<li>如果处于就绪状态的线程获取到了CPU资源，则执行<code>run()</code>方法，此时线程处于运行状态。处于运行状态的线程较为复杂，它有三种变化情况：阻塞、就绪与死亡状态。</li>
</ul>
</li>
<li><p>阻塞状态**(BLOCKED)**</p>
<ul>
<li>无执行资格也无执行权</li>
<li>一个线程执行了<code>sleep()</code> （睡眠）、<code>suspend()</code>（挂起）等方法后，失去了当前抢占的资源，进入阻塞状态，当睡眠时间或阻塞条件结束后，重新进入就绪状态，再次参与CPU资源的抢夺，在抢夺成功后才可以继续执行阻塞方法下面的其他代码。</li>
<li>阻塞分为：<ul>
<li>等待阻塞**(WAITING)**：运行状态中的线程执行了<code>wait()</code>方法；</li>
<li>同步阻塞：线程在获取<code>synchronized</code>同步锁失败（因同步锁被其他线程占用；</li>
<li>其他阻塞：通过调用线程的<code>sleep()</code> **(TIMED_WAITING)**或 <code>join()</code>发出了<code>I/O</code>请求时，线程进入阻塞状态。当<code>sleep()</code>状态超时，<code>join()</code>等待下次终止或超时，或者<code>I/O</code>处理完毕，线程重新进入就绪状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>死亡状态**(TERMINATED)**</p>
<ul>
<li>线程死亡，变成垃圾，被垃圾回收机回收</li>
<li>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到死亡 状态。</li>
</ul>
</li>
</ul>
<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\image-20250223113515244.png" alt="image-20250223113515244"></p>
<img src="D:\Blog\source\_posts\后端开发\Java基础➕高阶\JUC学习.assets\image-20250223113544705.png" alt="image-20250223113544705" style="zoom:80%;" />



<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ul>
<li>竞态条件（Race Condition）</li>
<li>内存可见性问题（Memory Visibility）</li>
<li>指令重排序（Reordering）</li>
</ul>
<h3 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p><strong>内存可见性 memory visibility</strong>：是指当某个线程正在使用 对象A 的状态而另一个线程也在同一时间修改 对象A 的状态。需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<p><strong>可见性错误</strong>：当 read 和 write 在不同线程中执行时，无法确保执行 read 的线程能及时看到其他线程 write 的值。</p>
<p>Java提供的一个同步机制，volatile 变量，用来确保将变量的更新操作通知到其他线程，相当于一个轻量级当不互斥的锁，无法保证变量状态的原子性操作。</p>
<h4 id="何为原子性"><a href="#何为原子性" class="headerlink" title="何为原子性"></a>何为原子性</h4><p>即操作不可再分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，这个类的操作就不具有原子性，主要是 <code>serialNumber++</code> 操作，其本质分为：</p>
<ul>
<li>读取 serialNumber 当前值</li>
<li>serialNumber 的值加 1</li>
<li>将新值写会 serialNumber 的内存块中。</li>
</ul>
<p>由于这三个步骤不是原子的，因此在多线程环境下，可能会出现以下问题：</p>
<ul>
<li><p>竞态条件（Race Condition）</p>
<ul>
<li><p><strong>线程 A</strong> 读取 <code>serialNumber</code> 的值为 <code>0</code>。</p>
</li>
<li><p><strong>线程 B</strong> 也读取 <code>serialNumber</code> 的值为 <code>0</code>。</p>
</li>
<li><p><strong>线程 A</strong> 将 <code>serialNumber</code> 的值加 1，并写回 <code>1</code>。</p>
</li>
<li><p><strong>线程 B</strong> 也将 <code>serialNumber</code> 的值加 1，并写回 <code>1</code>。</p>
</li>
<li><p>最终，<code>serialNumber</code> 的值是 <code>1</code>，而不是预期的 <code>2</code></p>
</li>
</ul>
</li>
<li><p>数据不一致</p>
<ul>
<li>由于多个线程同时修改 <code>serialNumber</code>，可能导致 <code>serialNumber</code> 的值不符合预期。</li>
</ul>
</li>
</ul>
<h4 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h4><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h4><p>Thread 创建线程方式：</p>
<p>创建线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li>
<li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li>
<li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li>
</ul>
<p>Thread 构造器：</p>
<ul>
<li><code>public Thread()</code></li>
<li><code>public Thread(String name)</code></li>
</ul>
<p>继承 Thread 类的优缺点：</p>
<ul>
<li>优点：编码简单</li>
<li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li>
</ul>
<p>Thread 类本身也是实现了 Runnable 接口，具有 Runnable 的属性，执行线程 run 方法底层也是调用的 Runnable 实例的 run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h4><p>Runnable 创建线程方式</p>
<p>创建线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">				t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名内部类方式</p>
<p>Thread 的构造器：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
<li><code>public Thread(Runnable target, String name)</code></li>
</ul>
<h5 id="Runnable-方式的优缺点"><a href="#Runnable-方式的优缺点" class="headerlink" title="Runnable 方式的优缺点"></a>Runnable 方式的优缺点</h5><p>缺点：代码复杂一点。</p>
<p>优点</p>
<ol>
<li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p>
</li>
<li><p>同一个线程任务对象可以被包装成多个线程对象</p>
<ul>
<li><p><strong>任务与线程分离</strong>：<code>Runnable</code> 对象代表任务逻辑，可以被多个 <code>Thread</code> 对象共享。</p>
</li>
<li><p><strong>资源复用</strong>：同一个 <code>Runnable</code> 实例可以被多个线程执行，减少对象创建开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(); <span class="comment">// 任务对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task); <span class="comment">// 线程1</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task); <span class="comment">// 线程2</span></span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>适合多个线程去共享同一个资源</p>
<ul>
<li><p><strong>共享资源</strong>：多个线程可以共享同一个 <code>Runnable</code> 实例，从而共享实例中的资源（如变量、状态等）。</p>
</li>
<li><p><strong>线程安全</strong>：需要额外注意共享资源的线程安全问题（如使用同步机制）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SharedTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedTask</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p>
<p>即第 2 点，将任务对象与线程对象解耦，任务可以被多个线程共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务可以被多个线程共享</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>


</li>
<li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务到线程池</span></span><br><span class="line">executor.submit(task);</span><br><span class="line">executor.submit(task);</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Callable-接口和-Future"><a href="#Callable-接口和-Future" class="headerlink" title="Callable 接口和 Future"></a>Callable 接口和 Future</h4><p>实现 Callable 接口：</p>
<ol>
<li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li>
<li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li>
<li>创建一个 Callable 的线程任务对象</li>
<li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li>
<li>把未来任务对象包装成线程对象</li>
<li>调用线程的 start() 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">      	<span class="type">Callable</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(callableDemo);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        t1.start();</span><br><span class="line">      	<span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> task.get();</span><br><span class="line">          System.out.println(i.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写线程任务类方法</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p>
<ul>
<li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li>
<li>线程池部分详解了 FutureTask 的源码</li>
</ul>
<p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>
<ul>
<li>get() 线程会阻塞等待任务执行完成</li>
<li>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：同 Runnable，并且能得到线程执行的结果</li>
<li>缺点：编码复杂</li>
</ul>
<h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><p>Thread 类 API：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public void start()</code></td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td align="left"><code>public void run()</code></td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td align="left"><code>public void setName(String name)</code></td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td align="left"><code>public void getName()</code></td>
<td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td align="left"><code>public static Thread currentThread()</code></td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td align="left"><code>public static void sleep(long time)</code></td>
<td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td align="left"><code>public static native void yield()</code></td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td align="left"><code>public final int getPriority()</code></td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td align="left"><code>public final void setPriority(int priority)</code></td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td align="left"><code>public void interrupt()</code></td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td align="left"><code>public static boolean interrupted()</code></td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td align="left"><code>public boolean isInterrupted()</code></td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td align="left"><code>public final void join()</code></td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td align="left"><code>public final void join(long millis)</code></td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td align="left"><code>public final native boolean isAlive()</code></td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td align="left"><code>public final void setDaemon(boolean on)</code></td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<h4 id="run-和-start"><a href="#run-和-start" class="headerlink" title="run 和 start"></a>run 和 start</h4><p>run：称为<strong>线程体</strong>，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p>
<p>start：使用 start 是<strong>启动新的线程</strong>，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p>
<p>说明：<strong>线程控制资源类</strong></p>
<p>run() 方法中的异常不能抛出，只能 try&#x2F;catch 捕获</p>
<ul>
<li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li>
<li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li>
</ul>
<h4 id="sleep-和-yield"><a href="#sleep-和-yield" class="headerlink" title="sleep 和 yield"></a>sleep 和 yield</h4><p>sleep：</p>
<ul>
<li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>
<li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行，<strong>需要抢占 CPU</strong></li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
<p>yield：</p>
<ul>
<li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
<li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li>
</ul>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果目标线程仍在运行</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(millis); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></li>
<li>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</li>
<li>调用了 A线程 的 join 方法的 main线程 会进入阻塞，直到 A线程 执行完之后释放后才会执行 main线程 里的其他代码。</li>
</ul>
<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\v2-8d1ed7f5621e6a4411486e8952b72139_1440w.jpg" alt="img"></p>
<p>等待线程结束</p>
<p>线程同步</p>
<ul>
<li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul>
<li>需要外部共享变量，不符合面向对象封装的思想</li>
<li>必须等待线程结束，不能配合线程池使用</li>
</ul>
</li>
<li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul>
<li>main 线程接收结果</li>
<li>get 方法是让调用线程同步等待</li>
</ul>
</li>
</ul>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>打断线程</p>
<p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p>
<p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p>
<p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p>
<p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p>
<p>当线程在阻塞状态（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>）时被中断，会抛出 <code>InterruptedException</code>，并 <strong>清除中断状态</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompareAndSwap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断状态： &#123;&#125;&quot;</span> + t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\image-20250223154404619-1740296646655-11.png" alt="image-20250223154404619"></p>
<h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：<strong>每个线程启动后，虚拟机就会为其分配一块栈内存</strong></p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前正在执行的那个方法</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park 等方法</li>
</ul>
<p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p>
<ul>
<li>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</li>
<li><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</li>
</ul>
<p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><img src="D:\Blog\source\_posts\后端开发\Java基础➕高阶\JUC学习.assets\image-20250223133248781.png" alt="image-20250223133248781" style="zoom:50%;" />





<h2 id="线程池（核心）"><a href="#线程池（核心）" class="headerlink" title="线程池（核心）"></a>线程池（核心）</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p><strong>线程池</strong>：一个容纳多个线程都容器，容器中的线程可以重复使用，省去了繁琐的创建与销毁对象的操作</p>
<p><strong>线程池作用</strong>：</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<p><strong>核心思想</strong>：线程的复用，避免重复创建和销毁线程对象，同一个线程可以被重复利用来处理多个任务。</p>
<p><strong>池化技术 Pool</strong>：一种编程思想，核心是资源的重复利用，在请求量比较大时优化性能，降低系统频繁的资源开销</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>有界队列和无界队列</p>
<ul>
<li>有界队列：有固定大小的队列，如设定大小固定的 <code>LinkedBlockingQueue</code></li>
<li>无界队列：没有设定固定大小，可以直接入队，知道溢出（超过 <code>Integer.MAX_VALUE</code>），相当于无界</li>
</ul>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的<strong>有界</strong>阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的<strong>无界</strong>（默认大小 Integer.MAX_VALUE）的阻塞队列</li>
<li>PriorityBlockQueue：支持优先级排序的<strong>无界</strong>阻塞队列</li>
<li>DelayedWorkQueue：使用优先级队列实现的延迟<strong>无界</strong>阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li>
<li>LinkedTransferQueue：由链表结构组成的<strong>无界</strong>阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li>
</ul>
<p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p>
<ul>
<li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li>
<li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li>
</ul>
<h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入（尾）</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（头）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查（队首元素）</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常组：<ul>
<li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</li>
<li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li>
</ul>
</li>
<li>特殊值组：<ul>
<li>插入方法：成功 true，失败 false</li>
<li>移除方法：成功返回出队列元素，队列没有就返回 null</li>
</ul>
</li>
<li>阻塞组：<ul>
<li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li>
</ul>
</li>
<li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队：尾插"><a href="#入队：尾插" class="headerlink" title="入队：尾插"></a>入队：尾插</h5><ul>
<li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新节点入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 从右向左计算</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\JUC-LinkedBlockingQueue入队流程.png" alt="img"></p>
<h5 id="出队：出队头节点。FIFO"><a href="#出队：出队头节点。FIFO" class="headerlink" title="出队：出队头节点。FIFO"></a>出队：出队头节点。FIFO</h5><ul>
<li><p>出队源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取临头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 自己指向自己，help GC</span></span><br><span class="line">    h.next = h;</span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 出队的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 【当前节点置为 Dummy 节点】</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>h = head</code> → <code>first = h.next</code></p>
<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\JUC-LinkedBlockingQueue出队流程1.png" alt="img"></p>
</li>
<li><p><code>h.next = h</code> → <code>head = first</code></p>
<p><img src="D:\Blog\source_posts\后端开发\Java基础➕高阶\JUC学习.assets\JUC-LinkedBlockingQueue出队流程2.png" alt="img"></p>
<ul>
<li><code>first.item = null</code>：当前节点置为 Dummy 节点</li>
</ul>
</li>
</ul>
<p>Executor 框架</p>
<p>ThreadPoolExecutor 参数详解：</p>
<ul>
<li>核心线程数、最大线程数</li>
<li>任务队列（<code>BlockingQueue</code>）</li>
<li>拒绝策略（<code>RejectedExecutionHandler</code>）</li>
</ul>
<p>Executors 工具类：</p>
<ul>
<li>newFixedThreadPool</li>
<li>newCachedThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newScheduledThreadPool</li>
</ul>
<h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><p><code>RecursiveTask</code> 和 <code>RecursiveAction</code></p>
<p>工作窃取（Work-Stealing）算法</p>
<h2 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源称为临界资源</p>
<p>临界区：访问临界资源的代码块</p>
<p>竞争条件：多个线程在临界区内执行，由于代码的执行顺序不同，导致结果不可预测，称之为竞争条件</p>
<p>一个程序运行多个线程是没有问题，</p>
<p>多个线程 read 共享资源也没有问题，</p>
<p>多个线程 read-And-write 共享资源操作时发生指令交错，就会出现问题</p>
<h4 id="为了避免竞态条件发生-解决线程安全问题"><a href="#为了避免竞态条件发生-解决线程安全问题" class="headerlink" title="为了避免竞态条件发生&#x2F;解决线程安全问题"></a>为了避免竞态条件发生&#x2F;解决线程安全问题</h4><ul>
<li>阻塞式的解决方案：synchronized，lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h4 id="对象锁-synchronized"><a href="#对象锁-synchronized" class="headerlink" title="对象锁 synchronized"></a>对象锁 synchronized</h4><p>保证了临界区内代码的原子性，采用互斥的方式让同一个时刻至多有一个线程能够持有对象锁，其他线程会阻塞在获取对象锁上，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p>互斥和同步都可以采用 synchronized 来完成，区别：</p>
<ul>
<li>互斥是，临界区的竞争条件一定会发生，但是保证了同一时刻只有一个线程的临界区代码在执行</li>
<li>同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个节点</li>
</ul>
<p>性能：</p>
<ul>
<li>线程安全，性能差</li>
<li>线程不安全，性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li>
</ul>
<h3 id="syn-ed"><a href="#syn-ed" class="headerlink" title="syn-ed"></a>syn-ed</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>锁对象：理论上可以是任意到唯一对象</p>
<p>synchronized 是可重入、不公平的重量级锁</p>
<p>原则上：</p>
<ul>
<li>锁对象建议使用共享资源</li>
<li>实例方法中使用 this 作为锁对象，锁住的 this 正好是关系对象</li>
<li>静态方法中使用 类名.class 字节码作为锁对象，静态成员属于类，被所有实例对象共享，所以需要锁住类</li>
</ul>
<ol>
<li><strong>内置锁（Synchronized）</strong>：<ul>
<li>同步代码块和方法</li>
<li>锁的升级（偏向锁 → 轻量级锁 → 重量级锁）</li>
</ul>
</li>
<li><strong>显式锁</strong>：<ul>
<li><code>Lock</code> 接口</li>
<li><code>ReentrantLock</code>（可重入锁）</li>
<li><code>ReentrantReadWriteLock</code>（读写锁）</li>
<li><code>StampedLock</code>（乐观读锁）</li>
</ul>
</li>
<li><strong>锁的优化与工具</strong>：<ul>
<li>公平锁 vs 非公平锁</li>
<li><code>Condition</code> 条件变量</li>
<li><code>LockSupport</code>（线程阻塞工具）</li>
</ul>
</li>
</ol>
<h2 id="原子操作和无锁编程"><a href="#原子操作和无锁编程" class="headerlink" title="原子操作和无锁编程"></a>原子操作和无锁编程</h2><h3 id="原子类-java-util-concurrent-atmoic"><a href="#原子类-java-util-concurrent-atmoic" class="headerlink" title="原子类(java.util.concurrent.atmoic)"></a>原子类(java.util.concurrent.atmoic)</h3><p>在 Java 中可以通过 java.util.concurrent.atmoic 包提供的具有原子性操作的类来保证变量的线程安全</p>
<ul>
<li><p>基础类型：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></p>
</li>
<li><p>引用类型：<code>AtomicReference</code>、<code>AtomicStampedReference</code>（解决 ABA 问题）</p>
</li>
<li><p>数组类型：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code></p>
</li>
<li><p>字段更新器：<code>AtomicIntegerFieldUpdater</code></p>
</li>
<li><p>AtomicMarkableReference</p>
</li>
<li><p>AtomicReferenceArray</p>
</li>
</ul>
<h3 id="CAS-CompareAndSwap"><a href="#CAS-CompareAndSwap" class="headerlink" title="CAS CompareAndSwap"></a>CAS CompareAndSwap</h3><blockquote>
<p>既解决了原子性问题,又解决了内存可见性问题</p>
</blockquote>
<p>用于管理对共享数据的并发访问。,是一种无锁的非阻塞算法的实现</p>
<p><strong>核心思想</strong>是“比较并交换”，通过硬件指令保证操作的原子性。</p>
<h4 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作:"></a>核心操作:</h4><ul>
<li><strong>CAS 操作包含三个操作数</strong>：<ol>
<li><strong>内存地址（V）</strong>: 需要更新的变量。</li>
<li><strong>期望值（A）</strong>: 变量的当前值。</li>
<li><strong>新值（B）</strong>: 希望将变量更新为的值。</li>
</ol>
</li>
<li><strong>CAS 的操作逻辑</strong>：<ul>
<li>如果内存地址 <code>V</code> 中的值等于期望值 <code>A</code>，则将 <code>V</code> 的值更新为 <code>B</code>。</li>
<li>如果 <code>V</code> 的值不等于 <code>A</code>，则不做任何操作。</li>
</ul>
</li>
<li><strong>执行过程</strong><ol>
<li>读取内存地址 <code>V</code> 的当前值。</li>
<li>比较 <code>V</code> 的值是否等于期望值 <code>A</code>。</li>
<li>如果相等，则将 <code>V</code> 的值更新为 <code>B</code>，并返回 <code>true</code>。</li>
<li>如果不相等，则返回 <code>false</code>，表示更新失败。</li>
</ol>
</li>
<li><strong>重试机制</strong>:<ul>
<li>如果 CAS 操作失败（即 <code>V</code> 的值不等于 <code>A</code>），通常会通过循环重试，直到操作成功。</li>
<li>这种机制称为 <strong>自旋（Spin）</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">CAS</span><span class="params">(V, A, B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (V == A) &#123;</span><br><span class="line">        V = B;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS具有原子性"><a href="#CAS具有原子性" class="headerlink" title="CAS具有原子性:"></a>CAS具有原子性:</h4><ul>
<li>CAS 操作是原子的，即在执行过程中不会被其他线程打断。</li>
<li>这确保了在多线程环境下，CAS 操作是线程安全的。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>无锁</strong><ul>
<li>是一种无锁 lock-free 机制,避免了线程阻塞和上下文切换的开销</li>
</ul>
</li>
<li><strong>高效</strong><ul>
<li>低竞争环境下,性能优于传统锁机制</li>
</ul>
</li>
<li><strong>可扩展下</strong><ul>
<li>适用于多核处理器和高并发</li>
</ul>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p><strong>ABA 问题</strong></p>
<ul>
<li>在 CAS 操作中，如果变量的值从 <code>A</code> 变为 <code>B</code>，然后又变回 <code>A</code>，CAS 会误认为变量没有被修改过。</li>
<li>解决方法：使用版本号或时间戳（如 <code>AtomicStampedReference</code>）</li>
</ul>
</li>
<li><p><strong>自旋开销</strong>:</p>
<ul>
<li>在高竞争的情况下，CAS 的自旋重试会导致 CPU 资源浪费</li>
</ul>
</li>
<li><p><strong>复杂性</strong>:</p>
<ul>
<li>实现无锁数据结构需要复杂的逻辑，容易出错。</li>
</ul>
</li>
</ul>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h3 id="并发集合："><a href="#并发集合：" class="headerlink" title="并发集合："></a>并发集合：</h3><h3 id="ConcurrentHashMap（分段锁、CAS-优化）"><a href="#ConcurrentHashMap（分段锁、CAS-优化）" class="headerlink" title="ConcurrentHashMap（分段锁、CAS 优化）"></a>ConcurrentHashMap（分段锁、CAS 优化）</h3><p>线程安全的 hash 表,每一段都是一个独立的锁</p>
<p>java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能</p>
<p>ConcurrentHashMap 同步容器类是 Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</p>
<p>包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、 ConcurrentSkipListMap、 ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。</p>
<h3 id="CopyOnWriteArrayList（写时复制）"><a href="#CopyOnWriteArrayList（写时复制）" class="headerlink" title="CopyOnWriteArrayList（写时复制）"></a>CopyOnWriteArrayList（写时复制）</h3><h3 id="ConcurrentLinkedQueue（无界非阻塞队列）"><a href="#ConcurrentLinkedQueue（无界非阻塞队列）" class="headerlink" title="ConcurrentLinkedQueue（无界非阻塞队列）"></a>ConcurrentLinkedQueue（无界非阻塞队列）</h3><h3 id="BlockingQueue-接口："><a href="#BlockingQueue-接口：" class="headerlink" title="BlockingQueue 接口："></a>BlockingQueue 接口：</h3><ul>
<li><code>ArrayBlockingQueue</code>（有界阻塞队列）</li>
<li><code>LinkedBlockingQueue</code>（可选有界）</li>
<li><code>PriorityBlockingQueue</code>（优先级队列）</li>
<li><code>SynchronousQueue</code>（直接传递队列）</li>
<li><code>DelayQueue</code>（延迟队列）</li>
</ul>
<h3 id="并发工具类："><a href="#并发工具类：" class="headerlink" title="并发工具类："></a>并发工具类：</h3><h3 id="ConcurrentSkipListMap（跳表实现的有序-Map）"><a href="#ConcurrentSkipListMap（跳表实现的有序-Map）" class="headerlink" title="ConcurrentSkipListMap（跳表实现的有序 Map）"></a>ConcurrentSkipListMap（跳表实现的有序 Map）</h3><h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><ol>
<li><strong>闭锁与计数器</strong>：<ul>
<li><code>CountDownLatch</code>（等待多个任务完成）</li>
<li><code>CyclicBarrier</code>（可重用的栅栏）</li>
<li><code>Phaser</code>（更灵活的屏障，支持阶段控制）</li>
</ul>
</li>
<li><strong>信号量</strong>：<ul>
<li><code>Semaphore</code>（控制并发线程数）</li>
</ul>
</li>
<li><strong>交换器</strong>：<ul>
<li><code>Exchanger</code>（线程间交换数据）</li>
</ul>
</li>
<li><strong>Future 与异步编程</strong>：<ul>
<li><code>Future</code> 和 <code>FutureTask</code></li>
<li><code>CompletableFuture</code>（链式异步编程）</li>
</ul>
</li>
</ol>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ol>
<li><strong>等待&#x2F;通知机制</strong>：<ul>
<li><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code></li>
</ul>
</li>
<li><strong>线程局部变量</strong>：<ul>
<li><code>ThreadLocal</code>（线程私有数据）</li>
</ul>
</li>
<li><strong>中断机制</strong>：<ul>
<li><code>interrupt()</code>、<code>isInterrupted()</code>、<code>InterruptedException</code></li>
</ul>
</li>
</ol>
<h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><ol>
<li><strong>并发设计模式</strong>：<ul>
<li>生产者-消费者模式</li>
<li>线程池模式</li>
<li>Master-Worker 模式</li>
</ul>
</li>
<li><strong>无锁数据结构</strong>：<ul>
<li>无锁队列（<code>ConcurrentLinkedQueue</code>）</li>
<li>无锁栈</li>
</ul>
</li>
<li><strong>性能优化</strong>：<ul>
<li>减少锁竞争（减小锁粒度、锁分离）</li>
<li>避免死锁（锁顺序、超时机制）</li>
</ul>
</li>
<li><strong>工具与调试</strong>：<ul>
<li><code>jstack</code> 分析线程状态</li>
<li><code>jconsole</code> 监控线程</li>
<li>使用 <code>ThreadDump</code> 诊断死锁</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JUC%E5%AD%A6%E4%B9%A0/" data-id="cm7pnj29h002hucv2h7p8chxa" data-title="JUC学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发/Java基础➕高阶/JAVA学习2_0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JAVA%E5%AD%A6%E4%B9%A02_0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.101Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JAVA%E5%AD%A6%E4%B9%A02_0/">Java基础学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="JAVA的基本程序设计结构"><a href="#JAVA的基本程序设计结构" class="headerlink" title="JAVA的基本程序设计结构"></a>JAVA的基本程序设计结构</h2><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><ol>
<li><strong>strictfp</strong>关键字：使用该关键字定义类或方法，则（类中所有的）方法都会使用严格的浮点计算</li>
<li>常量使用关键字<strong>final</strong>（JAVA仍然有保留关键字“<strong>const</strong>”，但并没有使用</li>
</ol>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>JAVA的字符串是Unicode字符序列</p>
</blockquote>
<p>String是不可变字符串</p>
<h4 id="码点和代码单元"><a href="#码点和代码单元" class="headerlink" title="码点和代码单元"></a>码点和代码单元</h4><p>JAVA的字符串底层是一个char值序列组成的，而每个char类型是一个采用了UTF-16编码表示的Unicode码点的代码单元。大多数情况下，单个char就可以表示我们日常所使用的单个字符；但当特殊情况下，某个字符需要一对代码单元时，就会出现问题。</p>
<ol>
<li><p>如果需要遍历一个字符串，并且依次查看每一个码点</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cp</span> <span class="operator">=</span> sentence.codePointAt(i);</span><br><span class="line"><span class="keyword">if</span>(Character.isSupplementaryCodePoint(cp)) i+=<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> i++;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JAVA%E5%AD%A6%E4%B9%A02_0/" data-id="cm7pnj29e0026ucv21sjw66jo" data-title="Java基础学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/typora/">typora</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E9%A9%AC-%E5%90%8E%E7%AB%AF/">黑马:后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E5%9F%BA%E7%A1%80/" rel="tag">Vue基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html%E5%9F%BA%E7%A1%80/" rel="tag">html基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%BA%95%E5%B1%82/" rel="tag">java底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80/" rel="tag">js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" rel="tag">单体架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%B3%E6%B3%95/" rel="tag">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" rel="tag">闲杂经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC/" rel="tag">黑马</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDBC/" style="font-size: 11.67px;">JDBC</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Vue%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Vue基础</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/html%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">html基础</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/java%E5%BA%95%E5%B1%82/" style="font-size: 10px;">java底层</a> <a href="/tags/java%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">java框架</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">js基础</a> <a href="/tags/juc/" style="font-size: 10px;">juc</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">关系型</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" style="font-size: 11.67px;">单体架构</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.33px;">后端</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">基础</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 16.67px;">大学专业课</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" style="font-size: 13.33px;">学习规划</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.33px;">数据库</a> <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="font-size: 20px;">期末复习</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" style="font-size: 15px;">计算机四大件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">设计架构</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件架构设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">软件项目管理</a> <a href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">闲杂经验</a> <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">非关系型</a> <a href="/tags/%E9%AB%98%E9%98%B6/" style="font-size: 10px;">高阶</a> <a href="/tags/%E9%BB%91%E9%A9%AC/" style="font-size: 11.67px;">黑马</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/LeetCode/">Leetcode刷题题解</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>