<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-校内课程学习笔记/计算机专业课/编译原理复习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.263Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/">编译原理期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="编译原理突击复习"><a href="#编译原理突击复习" class="headerlink" title="编译原理突击复习"></a>编译原理突击复习</h1><h2 id="为什么要编译"><a href="#为什么要编译" class="headerlink" title="为什么要编译"></a>为什么要编译</h2><p>电脑只能执行机器语言</p>
<p>但高级编程语言易于给人类进行编辑与开发</p>
<p>因而需要将人类易于阅读的高级编程语言转换成机器语言</p>
<p>这个转换的过程就是编译</p>
<h2 id="什么是编译器"><a href="#什么是编译器" class="headerlink" title="什么是编译器"></a>什么是编译器</h2><p>一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言</p>
<h2 id="解释器-interpreter"><a href="#解释器-interpreter" class="headerlink" title="解释器 interpreter"></a>解释器 interpreter</h2><p>另一种常见的语言处理器，不通过翻译的方式生成目标程序</p>
<h2 id="编译器和解释器的异同"><a href="#编译器和解释器的异同" class="headerlink" title="编译器和解释器的异同"></a>编译器和解释器的异同</h2><h3 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h3><p>都是语言实现系统</p>
<h3 id="不同："><a href="#不同：" class="headerlink" title="不同："></a>不同：</h3><ol>
<li>编译器先翻译后执行，编译器做拓展性的预处理，大部分都是考编译器实现的</li>
<li>解释器边翻译边执行，解释器执行程序很少或没有预处理</li>
</ol>
<h3 id="JVM的原理："><a href="#JVM的原理：" class="headerlink" title="JVM的原理："></a>JVM的原理：</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240621080928578.png" alt="image-20240621080928578"></p>
<h2 id="语言处理系统全过程"><a href="#语言处理系统全过程" class="headerlink" title="语言处理系统全过程"></a>语言处理系统全过程</h2><p><img src="E:\DeskTable\博客学习截图传输\image-20240621075846648.png" alt="image-20240621075846648"></p>
<h2 id="编译器全过程"><a href="#编译器全过程" class="headerlink" title="编译器全过程"></a>编译器全过程</h2><p><img src="E:\DeskTable\博客学习截图传输\image-20240621080342776.png" alt="image-20240621080342776"></p>
<h3 id="各板块及其功能"><a href="#各板块及其功能" class="headerlink" title="各板块及其功能"></a>各板块及其功能</h3><ol>
<li>词法分析：识别描述逻辑块</li>
<li>语法分析：识别逻辑之间如何相互有关系</li>
<li>语义分析：识别整个结构的意义</li>
<li>中间代码生成：设计一个可能符合的结构</li>
<li>中间代码优化：简化生成的目的结构</li>
<li>代码生成：产生目的结构</li>
<li>机器相关代码优化：优化最终结构</li>
</ol>
<p>编译器中间的四大流程又与 </p>
<ol>
<li>Literal table 语法表；</li>
<li>Symbol table 符号表；</li>
<li>Error handler 错误处理器</li>
</ol>
<h1 id="词法分析-Lexical-analysis"><a href="#词法分析-Lexical-analysis" class="headerlink" title="词法分析 Lexical analysis"></a>词法分析 Lexical analysis</h1><h2 id="词素"><a href="#词素" class="headerlink" title="词素"></a>词素</h2><p>我们从原始程序中创建token的那一部分称为词 lexeme 词素</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>是从源代码中读取出来的逻辑条目</p>
<p>Token可以复制，即存储一些特殊信息</p>
<h2 id="词法分析器任务"><a href="#词法分析器任务" class="headerlink" title="词法分析器任务"></a>词法分析器任务</h2><ol>
<li>读入的源代码的输入字符，将其组成词素，生成并输出一个token序列，每一个token对应着一个词素</li>
<li>一个token由：token名和可选的属性值组成</li>
</ol>
<p>每一个字符都经过扫描转换成一个token 词法单元，如一个标识符 int a ，会被记录为：&lt;id,entry&gt; id是identify的抽象符号，entry指的是 标识符a 对应的条目号码。</p>
<h2 id="正则表达式-Regular-Expression"><a href="#正则表达式-Regular-Expression" class="headerlink" title="正则表达式 Regular Expression"></a>正则表达式 Regular Expression</h2><p>用来捕获一类描述</p>
<p>具有可读性</p>
<h3 id="串的术语"><a href="#串的术语" class="headerlink" title="串的术语"></a>串的术语</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240621101823881.png" alt="image-20240621101823881"> </p>
<h3 id="复合正则表达式"><a href="#复合正则表达式" class="headerlink" title="复合正则表达式"></a>复合正则表达式</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240621101905529.png" alt="image-20240621101905529"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621102021241.png" alt="image-20240621102021241"> </p>
<p>还有正闭包$R^+$​，即至少有一个R</p>
<p>一个正则表达式的例子：<img src="E:\DeskTable\博客学习截图传输\image-20240621102049198.png" alt="image-20240621102049198"> </p>
<p>alphabet 字母表</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621103430822.png" alt="image-20240621103430822"></p>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h3 id="实现正则表达式RE"><a href="#实现正则表达式RE" class="headerlink" title="实现正则表达式RE"></a>实现正则表达式RE</h3><p>RE可以使用有限状态机FA进行表示</p>
<h3 id="NFA-非确定的有限状态机"><a href="#NFA-非确定的有限状态机" class="headerlink" title="NFA 非确定的有限状态机"></a>NFA 非确定的有限状态机</h3><p>非确定性有限状态机中,每个输入符号可以有多个状态转换,这意味着在任何给定时间,NFA可以处以多种状态之一</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110132100.png" alt="image-20240621110132100"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110104122.png" alt="image-20240621110104122"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110124293.png" alt="image-20240621110124293"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110118970.png" alt="image-20240621110118970"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110150891.png" alt="image-20240621110150891"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240621110201703.png" alt="image-20240621110201703"></p>
<h3 id="扫描的二义性"><a href="#扫描的二义性" class="headerlink" title="扫描的二义性"></a>扫描的二义性</h3><p>最长匹配的词素来解决二义性问题</p>
<ol>
<li>Convert expressions to NFAs. 将正则表达式转换为NFA</li>
<li>Run all NFAs in parallel, keeping track of the last match.<br>所有的NFA都并行运行,保持最后match的轨迹</li>
<li>When all automata get stuck, report the last match and restart the<br>search at that point.<br>所以的自动机都发生堵塞,报告最后的match,然后从这一点重新开始</li>
</ol>
<p>有多条可以匹配上的规则：设置优先级。通过选择优先级更高的匹配来打破平局</p>
<p>没有可以匹配上的规则：设置一台用于报错的状态机，但是优先级设置为最低，有一个通用规则来处理错误。</p>
<ol>
<li>如何将词素和标记关联起来<ol>
<li>标记定义</li>
<li>扫描输入</li>
</ol>
</li>
<li>有多条扫描路径，如何选择<ol>
<li>最长匹配优先</li>
<li>设置优先级</li>
</ol>
</li>
</ol>
<h3 id="DFA-确定的有限状态机"><a href="#DFA-确定的有限状态机" class="headerlink" title="DFA 确定的有限状态机"></a>DFA 确定的有限状态机</h3><p>在确定性有限状态机中,每个输入符号都只有唯一的状态转换,这样就意味着DFA只能处于一种状态;</p>
<p>每个状态对于一个确定的输入只能转换到一个新的状态，不可能存在多个状态或多种转换transition</p>
<p>在DFA的存在周期当中只能有一个state存在。</p>
<p>空集转换是不合法的</p>
<p>DFA仅需要线性时间即可匹配一个长度为 m 的字符串 O(m)的复杂度</p>
<h3 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h3><p>将NFA中一类状态对应成DFA中的一个状态</p>
<p>将NFA中一类状态到另一类状态的转换对应到DFA中两个转换间的转换——</p>
<p>用DFA的一个状态来表示通过单个字符输入从某个状态可以到达的其他状态的集合</p>
<p>一个DFA的状态代表NFA的一个状态集合,DFA的转化就是NFA的状态集合之间的转化</p>
<ol>
<li>通过空转换可到达的所有状态组成的集合为同一个DFA中的一个状态 ε-closure </li>
<li>通过一步从空状态 非空转换可到达的所有状态组成的集合为一个状态 $I_{xxx}$​</li>
</ol>
<h3 id="最小化算法"><a href="#最小化算法" class="headerlink" title="最小化算法"></a>最小化算法</h3><ol>
<li>消除多余状态</li>
<li>合并等价状态</li>
</ol>
<h1 id="语法分析-Syntax-analysis-Parsing"><a href="#语法分析-Syntax-analysis-Parsing" class="headerlink" title="语法分析 Syntax analysis(Parsing)"></a>语法分析 Syntax analysis(Parsing)</h1><p>语法分析后，得到一系列token，需要解释这些token的含义</p>
<p>恢复token原本描述的句子结构——即语法；token无法组成符合语法的顺序结构时，报错</p>
<h2 id="Context-free-Grammar-CFG（上下文无关文法）"><a href="#Context-free-Grammar-CFG（上下文无关文法）" class="headerlink" title="Context-free Grammar CFG（上下文无关文法）"></a>Context-free Grammar CFG（上下文无关文法）</h2><p>将文法规则转换成可以用来解析代码的方法</p>
<p>分为两种分析方法：Top-down parsing 和 Bottom-up parsing</p>
<blockquote>
<p>正则表达式对于词法的分析是线性的；使用ParsingTree对语法进行分析是递归的</p>
</blockquote>
<p><strong>CF展示信息和进行结构构造的能力强于RE，同时RE表达能力较弱，无法进行记忆与回溯，因而无法对语法进行分析</strong></p>
<p>语法分析最终的输出是一颗语法树，语法分析的目的也是构造一颗显式或隐式的语法树，语法树中每个节点都包含编译过程中reminder需要的对象</p>
<p>树的递归式结构符合语法递归式的定义结构</p>
<p>一个文法在编译原理当中即可视为一系列产生式的结合</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240622152759993.png" alt="image-20240622152759993"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240622152814903.png" alt="image-20240622152814903"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240622152928330.png" alt="image-20240622152928330"> </p>
<h3 id="RE-和-CFG的对比"><a href="#RE-和-CFG的对比" class="headerlink" title="RE 和 CFG的对比"></a>RE 和 CFG的对比</h3><p>CFG使用递归语句来实现RE中的闭包操作，即：<br><img src="E:\DeskTable\博客学习截图传输\image-20240622153128171.png" alt="image-20240622153128171"> 可以转换成右图： <img src="E:\DeskTable\博客学习截图传输\image-20240622153134704.png" alt="image-20240622153134704" style="zoom:50%;" /> </p>
<p>CFG具有更广泛的表示形式</p>
<p>通过使用CFG进行推导即可知道token组成的句子符合文法，是否正确</p>
<p>句型 sentential form：既包含终结符又包含非终结符，即从开始符号 S 开始的</p>
<p>句子 sentence ：只包含终结符</p>
<ol>
<li><p>The root node is labeled with the start symbol S<br>树的每一片叶子由空或者terminal进行标记</p>
</li>
<li><p>Each leaf node is labeled with a terminal or with ε<br>每一个非叶子节点都代表一个非终结符</p>
</li>
<li><p>Each nonleaf node is labeled with a nonterminal</p>
</li>
<li><p>If a node with label A ∈ VN has n children with labels X1,X2,…,Xn<br>(which may be terminals or nonterminals), then A → X1X2…Xn∈P</p>
</li>
</ol>
<p>一条推理derivation是由一系列产生式所得的句型 sentential forms：S ⇒ … ⇒ …</p>
<h3 id="最左推导-Leftmost-derivation"><a href="#最左推导-Leftmost-derivation" class="headerlink" title="最左推导 Leftmost derivation"></a>最左推导 Leftmost derivation</h3><p>每一步中，最左的非终结符被置换推导，并进入到下一步中</p>
<p>分析树的先序遍历</p>
<h3 id="AST-Abstract-Syntax-Tree"><a href="#AST-Abstract-Syntax-Tree" class="headerlink" title="AST Abstract Syntax Tree"></a>AST Abstract Syntax Tree</h3><p>将生成的Parsing Tree转换成AST</p>
<p>将分析树简化成抽象语法树，最终也只是将抽象语法树作为输入传递到下一个阶段当中</p>
<h2 id="二义性问题-Ambiguity"><a href="#二义性问题-Ambiguity" class="headerlink" title="二义性问题 Ambiguity"></a>二义性问题 Ambiguity</h2><p>同一个串出现了两颗语法树，即存在两种可匹配该句子的语法</p>
<p>正常来说，不同的推导过程最后会得到相同的语法树和抽象语法树</p>
<p>但是有些语法：<img src="E:\DeskTable\博客学习截图传输\image-20240623010419663.png" alt="image-20240623010419663"> 会导致因为推导顺序的不同而出现不同的语法树</p>
<p>STring&#x3D;“i-i*i” </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623010445883.png" alt="image-20240623010445883"></p>
<p>int - int - int</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623010914178.png" alt="image-20240623010914178"> </p>
<h3 id="两种处理二义性的方法"><a href="#两种处理二义性的方法" class="headerlink" title="两种处理二义性的方法"></a>两种处理二义性的方法</h3><h4 id="添加规则Rule"><a href="#添加规则Rule" class="headerlink" title="添加规则Rule"></a>添加规则Rule</h4><ol>
<li>添加优先级</li>
<li>左联系</li>
</ol>
<h4 id="重写文法"><a href="#重写文法" class="headerlink" title="重写文法"></a>重写文法</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20240623011243650.png" alt="image-20240623011243650"> </p>
<p>左结合和右结合</p>
<ol>
<li>左结合</li>
</ol>
<h2 id="什么是预测性分析"><a href="#什么是预测性分析" class="headerlink" title="什么是预测性分析"></a>什么是预测性分析</h2><p>基于剩余的input，预测可能被使用的产生式</p>
<h3 id="两种预测性分析的方法"><a href="#两种预测性分析的方法" class="headerlink" title="两种预测性分析的方法"></a>两种预测性分析的方法</h3><p>一种递归向下分析</p>
<p>一种向前看一步 Look-ahead one token</p>
<h1 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h1><h2 id="LL-1-文法-First和Follow-set"><a href="#LL-1-文法-First和Follow-set" class="headerlink" title="LL(1)文法 First和Follow set"></a>LL(1)文法 First和Follow set</h2><h3 id="First-set"><a href="#First-set" class="headerlink" title="First set"></a>First set</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240623015518332.png" alt="image-20240623015518332"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623100137169.png" alt="image-20240623100137169"></p>
<h3 id="Follow-Set"><a href="#Follow-Set" class="headerlink" title="Follow Set"></a>Follow Set</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240623015531401.png" alt="image-20240623015531401"> </p>
<h3 id="判断一个文法是否符合LL-1-文法"><a href="#判断一个文法是否符合LL-1-文法" class="headerlink" title="判断一个文法是否符合LL(1)文法"></a>判断一个文法是否符合LL(1)文法</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20240623101056096.png" alt="image-20240623101056096"></p>
<p>有左公因子或左递归一定不是</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623105054041.png" alt="image-20240623105054041"> </p>
<h2 id="递归向下分析"><a href="#递归向下分析" class="headerlink" title="递归向下分析"></a>递归向下分析</h2><h2 id="LL-1-分析（非递归分析）"><a href="#LL-1-分析（非递归分析）" class="headerlink" title="LL(1)分析（非递归分析）"></a>LL(1)分析（非递归分析）</h2><h2 id="分析表"><a href="#分析表" class="headerlink" title="分析表"></a>分析表</h2><h1 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h1><p>规约&#x2F;化简都是从左侧区域的最右边开始的</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623160909316.png" alt="image-20240623160909316"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623160948167.png" alt="image-20240623160948167"> </p>
<p>所有的规约动作都只发生在左区域的最右部分</p>
<p>将分析栈中部分符号弹出匹配，并重新压入正确的非终结符，即将右部倒推回左部</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623161416454.png" alt="image-20240623161416454"> </p>
<p>大多数时候查看栈顶无法满足规约需求，可能pop出更深的位置去进行规约</p>
<h2 id="LR分析器"><a href="#LR分析器" class="headerlink" title="LR分析器"></a>LR分析器</h2><h3 id="寻找handle"><a href="#寻找handle" class="headerlink" title="寻找handle"></a>寻找handle</h3><p>LR解析器维护状态（Sm）来跟踪我们在解析中的位置。状态总结了下面堆栈中包含的信息</p>
<p>存储“$S0X1S1……XmSm”，其中Xi是一个语法符号，而Si是一个状态。在每次推送一个符号后，新的状态号都会被推到解析堆栈中</p>
<h3 id="LR功能较弱的原因"><a href="#LR功能较弱的原因" class="headerlink" title="LR功能较弱的原因"></a>LR功能较弱的原因</h3><ol>
<li>LR (0)只接受没有正确上下文的语言</li>
<li>我们的移位&#x2F;减少解析器只看句柄的左边，而不是向右边</li>
<li></li>
</ol>
<h2 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a>SLR(1)</h2><h1 id="语义分析-Semantic-analysis"><a href="#语义分析-Semantic-analysis" class="headerlink" title="语义分析 Semantic analysis"></a>语义分析 Semantic analysis</h1><p>静态语义</p>
<p>动态语义</p>
<p>属性文法</p>
<p>语法自导翻译 SDD Syntax Directed Definitions </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240623200808980.png" alt="image-20240623200808980"> </p>
<h2 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h2><h3 id="综合属性的判断："><a href="#综合属性的判断：" class="headerlink" title="综合属性的判断："></a>综合属性的判断：</h3><p>非终结符可以有综合属性和继承属性，</p>
<p>文法开始符S没有继承属性</p>
<p>终结符只有综合属性，由词法程序提供</p>
<p>S属性文法是只含有综合属性的属性文法</p>
<p>一个属性文法称之为、L-属性文法，</p>
<p>如果属性来自于产生式的左部的，</p>
<p>且该属性的值是由右部的属性或其它属性的确定的，就是综合属性</p>
<h3 id="继承属性的判断"><a href="#继承属性的判断" class="headerlink" title="继承属性的判断"></a>继承属性的判断</h3><p>如果属性来自于产生式的右部的</p>
<p>且由左边属性或右边属性任意文法符号确定（包括自己）</p>
<h2 id="综合属性和继承属性的计算：向上综合，向下继承"><a href="#综合属性和继承属性的计算：向上综合，向下继承" class="headerlink" title="综合属性和继承属性的计算：向上综合，向下继承"></a>综合属性和继承属性的计算：向上综合，向下继承</h2><h3 id="计算顺序："><a href="#计算顺序：" class="headerlink" title="计算顺序："></a>计算顺序：</h3><ol>
<li>先放上终结符的数值</li>
<li>综合：再自底向上地传递综合属性的值</li>
<li>继承：兄弟和父亲节点的继承属性一步步向下传递值</li>
</ol>
<h3 id="阐述语义功能"><a href="#阐述语义功能" class="headerlink" title="阐述语义功能"></a>阐述语义功能</h3><p>观察每一个属性文法的公式，看看其把什么转化成了什么，最终是否有输出</p>
<h1 id="中间代码生成-Intermediate-code-generation"><a href="#中间代码生成-Intermediate-code-generation" class="headerlink" title="中间代码生成 Intermediate code generation"></a>中间代码生成 Intermediate code generation</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" data-id="cm7pnj29o003nucv2haha3vqa" data-title="编译原理期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/计算机专业课/离散数学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.262Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="逻辑和证明"><a href="#逻辑和证明" class="headerlink" title="逻辑和证明"></a>逻辑和证明</h2><h3 id="1-命题逻辑"><a href="#1-命题逻辑" class="headerlink" title="1. 命题逻辑"></a>1. 命题逻辑</h3><p><code>proposition</code> <code>命题</code> <strong>prop</strong> </p>
<p>逻辑关系:</p>
<p><strong>1.否定、合取、析取、条件、双条件（同或）、异或、条件否定、与非、或非</strong> </p>
<p>条件语句</p>
<p><code>implication</code> <code>蕴含</code> <strong>implies</strong> </p>
<p>$P \rightarrow Q \Leftrightarrow \neg P \or Q $ </p>
<h3 id="2-命题的等价"><a href="#2-命题的等价" class="headerlink" title="2. 命题的等价"></a>2. 命题的等价</h3><h4 id="2-1-Tautology-and-Contradiction"><a href="#2-1-Tautology-and-Contradiction" class="headerlink" title="2.1 Tautology and Contradiction"></a>2.1 Tautology and Contradiction</h4><h4 id="2-2-常见的等价语句"><a href="#2-2-常见的等价语句" class="headerlink" title="2.2 常见的等价语句"></a>2.2 常见的等价语句</h4><p>Identity：$p \and T \Leftrightarrow p $ </p>
<p>Domination：</p>
<h2 id="9-Relations"><a href="#9-Relations" class="headerlink" title="9.Relations"></a>9.Relations</h2><p>自反性：关系矩阵的主<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/search?word=%E5%AF%B9%E8%A7%92%E7%BA%BF&fr=iknow_pc_qb_highlight">对角线</a>上元素全部为1<br>反自反：关系矩阵的主对角线上元素全部为0<br>对称性：关系矩阵关于主对角线对称<br>反对称：关系矩阵关于主对角线不对称或者非主对角线上元素全部为0<br>传递性：这个得用矩阵的乘法，很难直接看出来</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231019102750160.png" alt="image-20231019102750160" style="zoom:67%;" /> 

<h4 id="9-3-Representing-Relations"><a href="#9-3-Representing-Relations" class="headerlink" title="9.3 Representing Relations"></a>9.3 Representing Relations</h4><p>集合 A &#x3D; { a , b , c , d } </p>
<p>关系 R &#x3D; { &lt; a , b &gt; , &lt; b , a &gt; , &lt; b , c &gt; , &lt; c , d &gt; } </p>
<ol>
<li>求关系 R 的自反闭包 r ( R ) , 对称闭包 s ( R ) , 传递闭包 t ( R )</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20201008113403863.png#pic_center" alt="img" style="zoom:67%;" /> 

<ol start="2">
<li>求自反闭包 : 就是给每个顶点加上环 :</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20201008115427713.png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" /> 

<ol start="3">
<li>求对称闭包 : 将 顶点间单向边改成双向边 , 不管顶点间双向边和顶点间没有边的情况 ;</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020100811544842.png#pic_center" alt="在这里插入图片描述"> </p>
<h3 id="图论三大证明方法"><a href="#图论三大证明方法" class="headerlink" title="图论三大证明方法"></a>图论三大证明方法</h3><ol>
<li>构造法</li>
<li></li>
</ol>
<h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p><strong>欧拉路径：<strong>图 $G$ 上有一条经过所有顶点、所有边的</strong>简单路径</strong>（边不重复，点可以重复）</p>
<p><strong>欧拉回路：<strong>图 $G$ 上有一条经过所有顶点、所有边的</strong>简单回路</strong>（边不重复，点可以重复）</p>
<p>**欧拉图：<strong>有欧拉回路的连通</strong>无向图 ** </p>
<p><strong>欧拉有向图：<strong>有欧拉回路的连通</strong>有向图</strong> </p>
<h2 id="二、定理"><a href="#二、定理" class="headerlink" title="二、定理"></a><strong>二、定理</strong></h2><p>**定理1：**设 $G$ 是连通无向图。 $G$ 是欧拉图，当且仅当 $G$ 的结点都为&#x3D;&#x3D;偶结点&#x3D;&#x3D; 。</p>
<p>**定理2：**设 $G &#x3D;⟨V,E,φ⟩ 为$连通无向图，且 $v_1,v_2∈V$，则 $G$ 有一条从 $v_1$ 至 $v_2$ 的欧拉路径当且仅当 $G$ 恰有两个奇结点 $v_1$ 和 $v_2$ 。</p>
<p><strong>定理3:</strong> 设 $G$ 为弱连通有向图。$G$ 是欧拉有向图，当且仅当 $G$ 所有结点的出度等于入度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" data-id="cm7pnj29n003gucv26e17c0au" data-title="离散数学学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/计算机专业课/数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.261Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库期末复习"><a href="#数据库期末复习" class="headerlink" title="数据库期末复习"></a>数据库期末复习</h1><h2 id="CH1-DBMS"><a href="#CH1-DBMS" class="headerlink" title="CH1 DBMS"></a>CH1 DBMS</h2><p>相关数据的集合<br>访问数据的程序集<br>方便高效的使用环境</p>
<h3 id="文件系统来存储数据的缺点："><a href="#文件系统来存储数据的缺点：" class="headerlink" title="文件系统来存储数据的缺点："></a>文件系统来存储数据的缺点：</h3><ol>
<li>数据冗余和不一致性<ul>
<li>多种文件格式：即同一个文件夹内存在多种存储数据的文件格式，其中存储的数据信息可能都相同只是因为文件格式不同导致了冗余</li>
<li>复制不同文件中的信息：不同文件之间进行数据查拷贝时，容易出现数据不一致的现象</li>
</ul>
</li>
<li>访问数据困难<ul>
<li>需要编写一个新的程序来执行每一个新的任务：文件系统对于用户来说缺乏一个统一的接口来进行数据的访问和操作。</li>
</ul>
</li>
<li>数据隔离————多种文件和格式</li>
<li>完整性问题<ul>
<li>完整性约束（例如，帐户余额&gt; 0）被“隐藏”在程序代码中，而不是被显式地声明</li>
<li>很难添加新的约束条件或更改现有的约束条件</li>
</ul>
</li>
<li>更新的原子性<ul>
<li>失败可能会使数据库处于不一致的状态，并执行了部分更新</li>
</ul>
</li>
<li>由多个用户的并发访问<ul>
<li>执行性能所需的并发访问权限</li>
<li>不受控制的并发访问可能会导致不一致</li>
</ul>
</li>
<li>安全问题<ul>
<li>难以限制用户对数据的访问范围</li>
</ul>
</li>
</ol>
<h3 id="抽象层级-Abstraction-Levels"><a href="#抽象层级-Abstraction-Levels" class="headerlink" title="抽象层级 Abstraction Levels"></a>抽象层级 Abstraction Levels</h3><ul>
<li><strong>Physical Level</strong>物理层：描述在物理硬件层次上，一条数据记录是如何存储，涉及实际的存储介质和数据结构，比如硬盘、SSD、数据块等。</li>
<li><strong>Logical Level</strong>逻辑层：概念性地描述数据存储在数据库中，且阐明数据间的关系，关注的是数据的结构和组织方式</li>
<li><strong>View Level</strong>视图层：对逻辑层进行封装，仅仅暴露出用户可理解的视觉层面的应用程序，隐藏了数据类型的细节、也隐藏了数据信息（为了安全性）</li>
<li>图例：</li>
</ul>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251158.png" alt="image-20241102115006858" style="zoom: 50%;" />



<h3 id="Schemas-and-Instances-实例和模式"><a href="#Schemas-and-Instances-实例和模式" class="headerlink" title="Schemas and Instances 实例和模式"></a>Schemas and Instances 实例和模式</h3><blockquote>
<p>类似于编程语言中的类型和变量</p>
</blockquote>
<p><strong>Schemas 模式</strong>：对数据库的逻辑结构的定义，描述数据的组织方式，如table，filed，data type，constraint。相当于抽象类</p>
<p><strong>Instance 实例</strong>：数据库在某一特定时间的实例</p>
<p><strong>Physical Data Independence 物理数据独立性</strong>：指在数据库系统中，用户和应用程序不需要关注数据的物理存储方式或存储介质的变化，即使底层存储的实现发生变化，应用程序和用户依然可以按照原有的方式访问和操作数据。通俗来讲即是，只要有数据库的文件 xxx.db 即使换了一台电脑，在那台电脑上数据的存储在完全不同的物理硬件上，但是依旧可以像在原来的电脑上去操作数据库，而不需要担心物理硬件的改变会对数据库产生影响</p>
<h3 id="Data-Model-数据模型"><a href="#Data-Model-数据模型" class="headerlink" title="Data Model 数据模型"></a>Data Model 数据模型</h3><ul>
<li><strong>Data（数据）</strong>：指的是需要存储和管理的信息。数据模型提供了描述这些数据的结构和类型的方法，例如数字、文本、日期等。</li>
<li><strong>Data relationships（数据关系）</strong>：指的是数据之间的关联或联系。数据模型定义了不同数据实体之间的关系，例如一对一、一对多或多对多的关系。这些关系帮助理解和组织数据的结构，使得数据能够相互关联。</li>
<li><strong>Data semantics（数据语义）</strong>：指的是数据的含义或解释。数据模型不仅描述数据的结构和关系，还定义了数据的业务含义，确保数据的使用者能够正确理解和使用这些数据。例如，一个“客户”实体的语义可以包括客户的姓名、地址和联系方式等信息。</li>
<li><strong>Data constraints（数据约束）</strong>：指的是对数据的限制或规则，以确保数据的有效性和一致性。数据模型定义了可以存储的数据类型、数据值的范围、唯一性约束等。这些约束确保了数据的完整性，防止无效或错误的数据被存储。</li>
</ul>
<h3 id="Relational-Model（关系模型）"><a href="#Relational-Model（关系模型）" class="headerlink" title="Relational Model（关系模型）"></a>Relational Model（关系模型）</h3><p>关系模型的几个关键特征：</p>
<ol>
<li><strong>表（关系）</strong>：数据以表的形式存储，每个表由行和列组成。每一行代表一个数据记录（或元组），每一列代表一个属性（或字段）。表的结构是固定的，即每个表都有预定义的列及其数据类型。</li>
<li><strong>主键</strong>：每个表都有一个主键，用于唯一标识表中的每一行数据。主键确保每条记录的唯一性，通常由一个或多个字段组合而成。</li>
<li><strong>外键</strong>：外键是一个表中的一个字段，它引用另一个表的主键，从而建立两个表之间的关系。外键使得不同表之间的数据能够相互关联。</li>
<li><strong>数据完整性</strong>：关系模型通过定义约束（如主键约束、外键约束、唯一性约束等）来确保数据的完整性和一致性。这些约束防止了无效数据的插入和更新。</li>
<li><strong>关系操作</strong>：关系模型支持多种操作，包括选择（SELECT）、插入（INSERT）、更新（UPDATE）和删除（DELETE）。这些操作通常通过结构化查询语言（SQL）来实现。</li>
<li><strong>抽象性</strong>：关系模型提供了物理数据独立性，用户可以通过逻辑结构访问数据，而无需关心数据的物理存储细节。</li>
</ol>
<h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><p>什么是<strong>Data Manipulation Language (DML)</strong>：被定义来用于访问和操作数据的一种语言</p>
<p><strong>DML的两类语言</strong></p>
<ul>
<li><strong>Procedural 过程式</strong>：用户指定需要哪些数据以及如何获取这些数据</li>
<li><strong>Declarative 声明式</strong>：用户指定需要哪些数据，而不指定如何获取这些数据，SQL即是声明式<strong>Declarative</strong></li>
</ul>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>例：查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> <span class="string">&#x27;22222</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>应用程序通常通过以下方式之一访问数据库：</p>
<ol>
<li>允许嵌入 SQL 的语言扩展 应用程序接口（例如 ODBC&#x2F;JDBC）</li>
<li>允许将 SQL 查询发送到数据库</li>
</ol>
<h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><p>什么是<strong>Data Definition Language (DDL)</strong>：用于定义数据库模式的规范表示法</p>
<p><strong>DDL Compiler（DDL编译器）</strong>：DDL编译器是负责处理数据定义语言语句的组件。当用户使用DDL命令（如创建表、修改表结构等）时，DDL编译器会解析这些命令并生成相应的<strong>表模板</strong>。</p>
<p><strong>Table Templates（表模板）</strong>：表模板是对数据库表结构的定义，包括表名、列名、数据类型、约束等信息。DDL编译器会根据用户输入的DDL语句创建这些模板，表明数据将以何种结构存储。</p>
<p><strong>Data Dictionary（数据字典）</strong>：数据字典是数据库中的一个特殊存储区域，用于保存数据库的元数据（metadata）。</p>
<ul>
<li>元数据是关于数据的数据，它描述了数据库中数据的<ul>
<li>数据库模式 database schema</li>
<li>完整性约束 integrity constraints，如：Primary key，Referential integrity</li>
<li>权限信息</li>
</ul>
</li>
</ul>
<p><strong>Metadata（元数据）</strong>：元数据包含有关数据的数据。例如，元数据可以包括表的名称、列的名称和数据类型、索引、约束、视图、存储过程等信息。这些信息帮助数据库管理系统和用户理解数据的组织方式和结构。</p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ul>
<li><strong>归一化理论</strong><ul>
<li>正式确定哪些设计不好，并对其进行测试</li>
</ul>
</li>
<li><strong>实体关系模型</strong></li>
</ul>
<h3 id="存储管理-storage-management"><a href="#存储管理-storage-management" class="headerlink" title="存储管理 storage management"></a>存储管理 storage management</h3><ul>
<li>存储管理器是一个程序模块，它提供存储在数据库中的</li>
<li>低级数据与提交给系统的应用程序和查询之间的接口。</li>
<li>存储管理器负责以下任务：<ul>
<li>与文件管理器交互</li>
<li>高效存储、检索和更新数据</li>
</ul>
</li>
<li>需要解决的问题：<ul>
<li>存储访问</li>
<li>文件组织</li>
<li>索引和散列</li>
</ul>
</li>
</ul>
<h3 id="查询处理-query-processing"><a href="#查询处理-query-processing" class="headerlink" title="查询处理 query processing"></a>查询处理 query processing</h3><ol>
<li>sql翻译</li>
<li>优化</li>
<li>执行</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251739.png" alt="Query Processing"></p>
<ul>
<li>评估给定查询的替代方法<ul>
<li>等价表达式</li>
<li>每个操作都有不同的算法</li>
</ul>
</li>
<li>评估查询的好方法和坏方法之间的成本差异可能是巨大的</li>
<li>需要估算运营成本<ul>
<li>很大程度上取决于数据库必须维护的关系的统计信息</li>
<li>需要估计中间结果的统计数据以计算复杂表达式的成本</li>
</ul>
</li>
</ul>
<h3 id="事务管理-transaction-management"><a href="#事务管理-transaction-management" class="headerlink" title="事务管理 transaction management"></a>事务管理 transaction management</h3><ul>
<li>如果系统出现故障怎么办？</li>
<li>如果多个用户同时更新相同的数据怎么办？</li>
<li>事务是在数据库应用程序中执行单个逻辑功能的操作的集合</li>
<li>事务管理组件确保即使出现系统故障（例如电源故障和操作系统崩溃）和事务失败，数据库仍保持一致（正确）状态。</li>
<li>并发控制管理器控制并发事务之间的交互，以保证数据库的一致性。</li>
</ul>
<h3 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h3><p>数据库系统的架构很大程度上取决于运行数据库的操作系统的架构</p>
<ul>
<li>集中</li>
<li>CS 架构(Client-Server)</li>
<li>并行（多处理器）</li>
<li>分布式</li>
</ul>
<h2 id="CH2-关系模型"><a href="#CH2-关系模型" class="headerlink" title="CH2 关系模型"></a>CH2 关系模型</h2><h3 id="关系-Relation"><a href="#关系-Relation" class="headerlink" title="关系 Relation"></a>关系 Relation</h3><h4 id="属性值-Attribute-types"><a href="#属性值-Attribute-types" class="headerlink" title="属性值 Attribute types"></a>属性值 Attribute types</h4><ul>
<li>每个属性允许的值集合称为属性的域(domain)。</li>
<li>属性值（通常）要求是原子(atomic)的，即不可分割的。</li>
<li>特殊值 null 是每个域的成员。</li>
<li>null 值在许多操作的定义中引起了复杂性。</li>
</ul>
<h4 id="关系模式和实例-relation-and-instance"><a href="#关系模式和实例-relation-and-instance" class="headerlink" title="关系模式和实例 relation and instance"></a>关系模式和实例 relation and instance</h4><ul>
<li>关系模式是关系数据库中表的结构定义，它规定了表的列名、数据类型和约束条件。描述了表的属性和属性间的关系</li>
<li>关系实例是关系模式的具体实例化，即表中的具体数据。是由行和列组成的二维表格，每行代表一条记录，每列代表一种属性</li>
<li>总之，关系模式定义了表的结构；关系实例则是实际存储在表中的数据</li>
</ul>
<blockquote>
<ul>
<li><p>例如：A1是属性名，D1是A1的取值范围，a1是A1中的一个元素</p>
</li>
<li><p>A1,A2,A3,…,An就是属性(attribute)</p>
</li>
<li><p>R&#x3D;(A1,A2,…,An)</p>
<p>是一个关系模式(relation schema)</p>
<ul>
<li>例如 instrutor&#x3D;(ID,name,dept_name,salary)</li>
</ul>
</li>
<li><p>对于给定的若干个集合D1,D2,…,Dn，一个关系r是D1×D2×…×Dn的子集</p>
</li>
</ul>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>一个数据库由多个关系组成</li>
</ul>
<p>例：关于一个大学的信息被分解成不同部分，学生、教师、教室、课程安排…</p>
<h3 id="键-Key"><a href="#键-Key" class="headerlink" title="键 Key"></a>键 Key</h3><ul>
<li>设 K⊆R，(其中 R 是一个关系模式，由多个属性组成)。</li>
<li>如果 K 的值足以唯一标识每个可能的关系 r(R) 中的元组，则 K 是 R 的<code>超键(superkey)</code>。<ul>
<li>例如，{ID} 和 {ID,name}都是 instructor 关系的超键。</li>
</ul>
</li>
<li>如果 K 是最小的超键，则 K 是<code>候选键(candidate key)</code>。<ul>
<li>例如，{ID} 是 Instructor 的候选键。</li>
</ul>
</li>
<li>其中一个候选键被选为<code>主键(primary key)</code>。<ul>
<li>哪一个是主键？</li>
</ul>
</li>
<li>外键约束(Foreign key)：一个关系中的值必须出现在另一个关系中。<ul>
<li>引用关系(Referencing relation)：包含外键的关系。</li>
<li>被引用关系(Referenced relation)：被外键引用的关系。</li>
</ul>
</li>
</ul>
<h3 id="关系查询语言-relational-query-languages"><a href="#关系查询语言-relational-query-languages" class="headerlink" title="关系查询语言 relational query languages"></a>关系查询语言 relational query languages</h3><ul>
<li>过程式 procedural &amp;非过程式&#x2F;声明式 non-procedural&#x2F;declarative</li>
<li>“纯”语言：<ul>
<li><code>关系代数 relational algebra</code></li>
<li>元组关系演算 tuple relational calculus</li>
<li>域关系演算 domain relational calculus</li>
</ul>
</li>
<li>关系操作符 relational operators</li>
</ul>
<ol>
<li>σ 选择操作符</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251963.png" alt="Selection of tuples"></p>
<ol start="2">
<li>⊓ 投影操作符</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252420.png" alt=" Selection of Columns (Attributes)"></p>
<ol start="3">
<li>X 笛卡尔积</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252013.png" alt="Joining two relations – Cartesian Product"></p>
<ol start="4">
<li>∪ 并运算</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252795.png" alt=" Union of two relations"></p>
<ol start="5">
<li><ul>
<li>差运算</li>
</ul>
</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252918.png" alt="Set difference of two relations"></p>
<ol start="6">
<li>∩ 交运算</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252947.png" alt=" Set Intersection of two relations"></p>
<blockquote>
<p>合并两个关系 - 自然连接</p>
<ul>
<li>假设 <em>r</em> 和 <em>s</em> 是分别基于模式 <em>R</em> 和 <em>S</em> 的关系。那么，关系 R 和 S 的“自然连接”是基于模式 $R ∪ S$ 的关系，过程如下：<ul>
<li>对于 <em>r</em> 中的每个元组 $t_r$ 和 <em>s</em> 中的每个元组 $t_s$，考虑每对元组。</li>
<li>如果 $t_r$ 和 $t_s$ 在 $R∩S$ 中的每个属性上有相同的值，则将一个元组 t 添加到结果中。其中：<ul>
<li>t 和 $t_r$​在 <em>r</em> 上有相同的值</li>
<li>t 和 $t_s$在 <em>s</em> 上有相同的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>简而言之，自然连接操作是基于两个关系中共同属性的值相等的元组进行并。结果是一个新的关系，包含了具有相同共同属性值的元组。</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252536.png" alt="Natural Join Example"></p>
<h4 id="关系代数总览"><a href="#关系代数总览" class="headerlink" title="关系代数总览"></a>关系代数总览</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252183.png" alt="Relational algebra"></p>
<h2 id="CH3-SQL"><a href="#CH3-SQL" class="headerlink" title="CH3 SQL"></a>CH3 SQL</h2><h3 id="SQL-DDL"><a href="#SQL-DDL" class="headerlink" title="SQL DDL"></a>SQL DDL</h3><ul>
<li>SQL 数据定义语言 data-definition language ,DDL 允许指定关于关系的信息，包括：<ul>
<li>每个关系的模式。</li>
<li>每个属性关联的值域。</li>
<li>完整性约束。</li>
<li>此外，我们稍后将看到，还可以包括其他信息，例如：<ul>
<li>每个关系要维护的索引集合。</li>
<li>每个关系的安全性和授权信息。</li>
<li>每个关系在磁盘上的物理存储结构。</li>
</ul>
</li>
</ul>
</li>
<li>简而言之，SQL 的数据定义语言（DDL）提供了一种定义关系的信息的方式，包括关系模式、属性的值域以及与关系相关的完整性约束等。它还允许指定索引、安全性和授权信息以及关系在磁盘上的物理存储结构。</li>
</ul>
<h2 id="CH6-形式关系查询语言"><a href="#CH6-形式关系查询语言" class="headerlink" title="CH6 形式关系查询语言"></a>CH6 形式关系查询语言</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>关系代数（Relational Algebra）、元组关系演算（Tuple Relational Calculus）和域关系演算（Domain Relational Calculus）是用于关系数据库的不同查询语言和形式。它们的主要区别如下：</p>
<ol>
<li>关系代数（Relational Algebra）：<br>关系代数是一种基于集合论的查询语言，用于操作关系数据库中的关系。它使用一组操作符，如选择（selection）、投影（projection）、连接（join）、并（union）、差（difference）等来执行关系操作。关系代数提供了一种形式化的方法来描述和操作关系数据库中的关系。</li>
<li>元组关系演算（Tuple Relational Calculus）：<br>元组关系演算是一种基于逻辑的查询语言，用于描述关系数据库中的查询。它使用逻辑谓词（predicate）来描述所需的元组集合。元组关系演算的查询结果是满足指定谓词的关系中的元组集合。元组关系演算描述了所需的结果，而不是如何计算结果。</li>
<li>域关系演算（Domain Relational Calculus）：<br>域关系演算也是一种基于逻辑的查询语言，用于描述关系数据库中的查询。它使用逻辑谓词来描述所需的属性集合。域关系演算的查询结果是满足指定谓词的关系中的属性集合。域关系演算描述了所需的属性，而不是如何计算结果。</li>
</ol>
<h3 id="关系代数-relational-algebra"><a href="#关系代数-relational-algebra" class="headerlink" title="关系代数 relational algebra"></a>关系代数 relational algebra</h3><ul>
<li>过程语言(Procedural language)</li>
<li>六个基本运算子：<ul>
<li>查询(Selection)：σ</li>
<li>投影(Projection)：Π</li>
<li>集合并(Union)：∪</li>
<li>差集(Set difference)：−</li>
<li>笛卡尔积(Cartesian product)：×</li>
<li>重命名(Reanme)：ρ</li>
</ul>
</li>
</ul>
<h3 id="六大基本运算符"><a href="#六大基本运算符" class="headerlink" title="六大基本运算符"></a>六大基本运算符</h3><h4 id="查询-select"><a href="#查询-select" class="headerlink" title="查询 select"></a>查询 select</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252770.png" alt="Selction操作"></p>
<ul>
<li>基本形式：$σ_p(R)$</li>
<li>p称为选择谓词，可以由多个独立的命题通过∧,∨等符号连接</li>
<li>被定义为：$σ_p(r)&#x3D; {t∣t∈r<del>and</del>p(t)}$</li>
<li>例如：$σ_{dept \underline{} name}&#x3D;^”Physics^”(instructor)$</li>
</ul>
<h4 id="投影-project"><a href="#投影-project" class="headerlink" title="投影 project"></a>投影 project</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252631.png" alt="Project操作"></p>
<ul>
<li>基本形式：$Π_{\alpha_1,\alpha_2,…\alpha_n}(r)$</li>
<li>其中$a_1,…,a_n$是属性名称，$r$是关系名称</li>
<li>由于关系是集合，因此从结果中删除了重复行</li>
<li>例如： $Π_{ID,name,salary}(instructor)$</li>
</ul>
<h4 id="集合并-union"><a href="#集合并-union" class="headerlink" title="集合并 union"></a>集合并 union</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252044.png" alt="Union操作"></p>
<ul>
<li>基本形式 $r∪s$</li>
<li>定义为：$r∪s &#x3D; { t|t \in r<del>or</del>t\in s  }$</li>
<li>$r∪s$需要满足两个条件：<ul>
<li>$r,s$必须具有相同的属性数量 arity</li>
<li>属性域必须兼容（例如：r的第k列和s的第k列处理相同类型的值）</li>
</ul>
</li>
<li>例如，查找 2009 年秋季学期或 2010 年春季学期或两者都教授的所有课程：<ul>
<li>$Π_{course_id}(σ_{semester&#x3D;”Fall” \and year&#x3D;2009(section)} ∪  Π_{course_id}(σ_{semester&#x3D;”Spring”\and year&#x3D;2010(section)}))$</li>
</ul>
</li>
</ul>
<h4 id="差集-Set-difference"><a href="#差集-Set-difference" class="headerlink" title="差集 Set difference"></a>差集 Set difference</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253318.png" alt="Set difference"></p>
<ul>
<li>基本形式：$r-s$</li>
<li>定义为：$r-s &#x3D; { t|t\in r<del>and</del>t\notin s }$</li>
<li>和集合并一样，必须有一样的属性数量和兼容的属性域</li>
</ul>
<h4 id="笛卡尔积-Cartesian-Product"><a href="#笛卡尔积-Cartesian-Product" class="headerlink" title="笛卡尔积 Cartesian-Product"></a>笛卡尔积 Cartesian-Product</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253737.png" alt="Cartesian-Product"></p>
<ul>
<li>基本形式：$r \times s$</li>
<li>定义为：$r \times s&#x3D;{ t,q|t\in r<del>and</del>q\in s}$</li>
<li>假设$r(R)$和$s(S)$的属性是不相交的（即，$R∩S&#x3D;\varnothing$）。如果$r(R)$和$s(S)$的属性相交，则必须使用重命名</li>
</ul>
<h4 id="重命名-Rename"><a href="#重命名-Rename" class="headerlink" title="重命名 Rename"></a>重命名 Rename</h4><h4 id="自然连接-Natural-join"><a href="#自然连接-Natural-join" class="headerlink" title="自然连接 Natural-join"></a>自然连接 Natural-join</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253535.png" alt="Natural-Join"></p>
<ul>
<li><p>基本形式：$r\bowtie s$</p>
</li>
<li><p>设$r$和$s$分别是基于模式$R$和$S$的关系。那么，$r\bowtie S$是基于模式$R∪S$的关系，获取方式如下：</p>
<p>考虑每对元组 t：</p>
<ul>
<li>如果来自$r$的元组$t_r$和来自$s$的元组$t_s$在$R∩S$的每个属性上具有相同的值，则将一个元组 t 添加到结果中，<ul>
<li>其中t在r上具有与$t_r$相同的值;</li>
<li>t在s上具有与$t_s$相同的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>在没有公共属性的情况下会退化成笛卡尔积</p>
</li>
<li><p>如：</p>
</li>
</ul>
<p>$$<br>R&#x3D;(A,B,C,D) \ S&#x3D;(E,B,D) \ \mit Result~schema \mit &#x3D; (A,B,C,D,E) \<br>r \bowtie s &#x3D; \begin{matrix} \prod_{r.A,r.B,r.C,r.D,r.E(\sigma_{r.B&#x3D;s.B\and r.D&#x3D;s.D}(r\times s))} \end{matrix}<br>$$</p>
<h4 id="连接-Theta-join"><a href="#连接-Theta-join" class="headerlink" title="连接 Theta join"></a>连接 Theta join</h4><ul>
<li>定义为：$r \bowtie_{\theta} s &#x3D; \sigma_{\theta}(r \times s)$</li>
<li>例：假设一个顾客顾客要购买一个车模和一个船模，但不想为船花费比车更多的钱。那么可以有$ car \bowtie_{car_pirce&lt;Boat_price}boat$</li>
<li>当$\theta$为等号时，又称为相等连接 equi join(基于两个表中列的值相等)</li>
</ul>
<h4 id="外连接-outer-join"><a href="#外连接-outer-join" class="headerlink" title="外连接 outer join"></a>外连接 outer join</h4><blockquote>
<p>有left outer join 左外连接，左连接和 right outer join 右外连接，右连接</p>
</blockquote>
<ul>
<li>一种扩展的连接操作，避免了信息的丢失。</li>
<li>首先计算连接操作，然后将一方关系中与另一方关系中的元组不匹配的元组添加到连接结果中。</li>
<li>使用空值（null）：<ul>
<li>空值表示值是未知的或不存在的。</li>
<li>所有涉及空值的比较（粗略地说）根据定义都是 false。</li>
<li>我们将在后面详细研究与空值的比较的确切含义。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253989.png" alt="Outer Join –Example"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253637.png" alt="Outer Join –Example2"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253741.png" alt="Outer Join –Example3"> </p>
<blockquote>
<p>空值(Null Values)</p>
<ul>
<li>某些属性的元组可能具有空值（null）。</li>
<li>空值表示一个未知的值或值不存在。<ul>
<li>任何涉及空值的算术表达式的结果都是空值。</li>
<li>聚合函数简单地忽略空值（与 SQL 中类似）。</li>
<li>在去重和分组中，空值被视为任何其他值，并且假设两个空值是相同的（与 SQL 中类似）。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>Join 之解析</p>
<ul>
<li>连接主要由连接方向、连接类型组成</li>
<li>连接方向包括：左右内外</li>
<li>连接类型包括：自然连接、ON 子句和 HAVING 子句</li>
</ul>
</blockquote>
<h2 id="CH7-实体关系模型-Entity-Relationship-Model"><a href="#CH7-实体关系模型-Entity-Relationship-Model" class="headerlink" title="CH7 实体关系模型 Entity-Relationship Model"></a>CH7 实体关系模型 Entity-Relationship Model</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ul>
<li><p>一个数据库可以被抽象建模为：</p>
<ul>
<li>实体集合</li>
<li>实体间的关系</li>
</ul>
<blockquote>
<p>即若干个实体与这些实体间的关系组成的一个抽象概念</p>
</blockquote>
</li>
</ul>
<h3 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h3><ul>
<li><strong>实体 entity</strong> 是存在的对象，并且可与其他对象区分开</li>
<li>实体具有属性 attribute</li>
<li><strong>实体集 entity set</strong> 是一组具有相同属性的同类实体的集合</li>
</ul>
<h3 id="关系集"><a href="#关系集" class="headerlink" title="关系集"></a>关系集</h3><ul>
<li><strong>关系 relationship</strong>：$t&#x3D;(e_1,…,e_n),~e_1 \in E_1,…,e_n \in E_n$，是一种多个实体间的联系</li>
<li><strong>关系集 relationship set</strong>：$L \subseteq E_1 \times E_2 \times … \times E_n$​，是一种多个实体之间的数学关系，关系集本身也具有属性。</li>
</ul>
<p>关系用方框，关系集拥椭圆</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253537.png" alt="Attribute of  Relationship Sets"></p>
<h4 id="关系集的度-degree"><a href="#关系集的度-degree" class="headerlink" title="关系集的度 degree"></a>关系集的度 degree</h4><ul>
<li>二元关系涉及两个实体集，度为2</li>
<li>在数据库系统中，大多数关系集是二元的，可以通过间接产生关系</li>
<li>两个以上实体集之间的关系较为少见</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>实体由一组属性表示，属性是实体集的所有成员（记录）所具有的描述性特征。</li>
<li>域 domain —— 每个属性允许的取值范围（值域）</li>
<li>属性类型：<ul>
<li>简单simple 属性和复合composite 属性</li>
<li>单值single-valued 属性和多值multi-valued 属性</li>
<li>派生derived 属性：可以从其他属性计算得出的，如age可以根据prod_date和now_date计算得出。</li>
</ul>
</li>
</ul>
<h4 id="映射基数约束-Mapping-Cardinality-Constrants"><a href="#映射基数约束-Mapping-Cardinality-Constrants" class="headerlink" title="映射基数约束 Mapping Cardinality Constrants"></a>映射基数约束 Mapping Cardinality Constrants</h4><ul>
<li><p>表达通过关系集可以将另一个实体关联到的实体数量。</p>
</li>
<li><p>在描述二元关系集时最有用。</p>
</li>
<li><p>对于二元关系集，映射基数必须是以下类型之一：</p>
<ul>
<li>一对一</li>
<li>一对多</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253891.png" alt="Mapping Cardinalities"></p>
<ul>
<li>多对一</li>
<li>多对多</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253136.png" alt="Mapping Cardinalities"></p>
</li>
</ul>
<h4 id="键-Keys"><a href="#键-Keys" class="headerlink" title="键 Keys"></a>键 Keys</h4><ul>
<li><p>实体集和<strong>超键super-key</strong>是一组一个或多个属性，其值可以唯一确定关系中的一个实体（记录）</p>
</li>
<li><p>实体集的<strong>候选词candidate-key</strong>是最小的超键</p>
<p>如：</p>
<ul>
<li>teacher_id是指导教师的候选词</li>
<li>course_id是课程的候选词</li>
</ul>
</li>
<li><p>虽然可能存在多个候选词，但是选择其他一个候选词作为<strong>主键primary-key</strong></p>
</li>
</ul>
<p><strong>基数映射关系中的主键选择</strong></p>
<p><strong>一对一关系</strong>：选择主表（或主数据表）中的候选键作为主键，附表可以通过外键引用主表的主键。</p>
<p><strong>一对多关系</strong>：选择”一”方的候选键作为主键，”多”方的表通过外键引用”一”方的主键。</p>
<p><strong>多对多关系</strong>：通过创建关联表，通常使用关联表中两个外键的组合作为联合主键，或者使用单独的主键。</p>
<h4 id="冗余属性-redundant-attributes"><a href="#冗余属性-redundant-attributes" class="headerlink" title="冗余属性 redundant attributes"></a>冗余属性 redundant attributes</h4><p>假设我们有以下实体集和关系：</p>
<ul>
<li>instructor，包括属性 ID、姓名、部门名和薪水。</li>
<li>department，包括属性部门名、建筑和预算。</li>
<li>关系 inst_dept，关联 instructor 和 department。</li>
<li>实体 instructor 中的属性部门名是冗余的，因为已经存在一个明确的关系 inst_dept，将教师与部门关联起来。<ul>
<li>该属性复制了关系中存在的信息，应从 instructor 中删除。</li>
<li>但是：在某些情况下，在转换回表格时，该属性可能会重新引入，我们将在后面看到</li>
</ul>
</li>
</ul>
<h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p><img src="https://chiichen.github.io/assets/image-4-CSXuXJc3.png" alt="E-R图"></p>
<ul>
<li><strong>矩形</strong>表示实体集。</li>
<li><strong>菱形</strong>表示关系集。</li>
<li><strong>实体矩形</strong>内列出属性。</li>
<li><strong>下划线表示主键</strong>属性。</li>
</ul>
<p><strong>带有复合、多值和派生属性的实体集E-R图</strong></p>
<p><img src="https://chiichen.github.io/assets/image-5-GZhZidTi.png" alt="Entity With Composite, Multivalued, and Derived Attributes"></p>
<p><strong>带有属性的关系实体集</strong></p>
<p><img src="https://chiichen.github.io/assets/image-6-BkgRSeNn.png" alt="Relationship Sets with Attributes"></p>
<p><strong>带有三元关系 ternary-relationship的E-R图</strong></p>
<p><img src="https://chiichen.github.io/assets/image-14-CAvppGpr.png" alt="E-R Diagram with a Ternary Relationship"></p>
<p><strong>一个数据库的E-R图示例</strong>：</p>
<p><img src="https://chiichen.github.io/assets/image-16-C_jrNPoi.png" alt="E-R图示例"></p>
<h4 id="角色-Role"><a href="#角色-Role" class="headerlink" title="角色 Role"></a>角色 Role</h4><ul>
<li>关系的实体集不一定是不同的</li>
<li>每个实体集的出现在关系中扮演一个“角色”。“course_id”和“prereq_id”这些标签被称为角色</li>
</ul>
<h4 id="基数约束-Cardinality-Constrants"><a href="#基数约束-Cardinality-Constrants" class="headerlink" title="基数约束 Cardinality Constrants"></a>基数约束 Cardinality Constrants</h4><ul>
<li><p>我们通过在关系集和实体集之间绘制有向线（→）表示“一”或无向线（——）表示“多”。来表达基数约束。</p>
</li>
<li><p>一对一关系：</p>
<p><img src="https://chiichen.github.io/assets/image-8-B7EFTDas.png" alt="One-to-One Relationship"></p>
</li>
<li><p>一对多关系：</p>
<p><img src="https://chiichen.github.io/assets/image-9-Dbhss_U0.png" alt="One-to-Many Relationship"></p>
</li>
<li><p>多对一关系：</p>
<p><img src="https://chiichen.github.io/assets/image-10-BTDbYSIm.png" alt="Many-to-One Relationships"></p>
</li>
<li><p>多对多关系：</p>
<p><img src="https://chiichen.github.io/assets/image-11-D8XTAE7M.png" alt="Many-to-Many Relationship"></p>
</li>
</ul>
<p>下图表示学生有且只有一名指导老师，而老师可以指导$0…n$名学生</p>
<p><img src="https://chiichen.github.io/assets/image-13-BuoQZq5b.png" alt="Alternative Notation for Cardinality Limits"></p>
<h3 id="强实体集"><a href="#强实体集" class="headerlink" title="强实体集"></a>强实体集</h3><ul>
<li>其实例的存在<strong>不依赖</strong>于任何其他实体类型的实例；有自己<strong>独立的主键</strong>，唯一性地标识它的每个实例。</li>
</ul>
<h3 id="弱实体集-weak-entity-sets"><a href="#弱实体集-weak-entity-sets" class="headerlink" title="弱实体集 weak entity sets"></a>弱实体集 weak entity sets</h3><blockquote>
<p>弱实体集每一条记录的产生必然依赖于已有的强实体集</p>
<p>弱实体集的主键都是组合主键（由其他实体集的主键组层）</p>
</blockquote>
<ul>
<li>其实例的存在<strong>依赖</strong>于其它实体类型的实例；其主键包括它所依赖的实体类型的主键。</li>
<li>没有主键的实体集</li>
<li><strong>弱实体集</strong>的存在依赖于**强实体集（也称为标识实体集）**的存在。弱实体集需要和强实体一起组合使用，才能唯一标识每个实例。</li>
<li><strong>通过部分键标识</strong>：弱实体集通常会有一个部分键（partial key），该键只能在与强实体关联时才能唯一标识实体实例。</li>
<li>标识联系 identifying relationship：<ul>
<li>弱实体集 —&gt; 标识实体集</li>
<li>多对一关系</li>
<li>弱实体集完全参与关系</li>
</ul>
</li>
<li><strong>ER图中的表示</strong>：<ul>
<li>弱实体集通常用<strong>双矩形框</strong>表示。</li>
<li>弱实体集与强实体之间的关系用<strong>双菱形框</strong>表示，表示依赖关系。</li>
<li>弱实体集的部分键用<strong>虚线矩形</strong>表示。</li>
</ul>
</li>
<li>弱实体集的鉴别器（或部分键）是区分弱实体集中所有实体的属性集。</li>
<li>弱实体集的主键由以下形式组成：（标识实体集的主键，弱实体集的鉴别器）</li>
<li>我们用<strong>虚线下划线标记弱实体集的鉴别器</strong>。</li>
<li>我们将弱实体的标识关系放在一个双菱形中。</li>
</ul>
<p><strong>以示例了解何为弱实体类</strong>：</p>
<p><strong>1、教务系统数据库设计</strong></p>
<p>业务需求是这样的：</p>
<p>一周有七天，每一天有11节。</p>
<p>则设计时，首先有三个实体（不管强或弱实体）：<code>Day、Week、Section</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 教务系统实体关系图</span><br><span class="line">---</span><br><span class="line">erDiagram</span><br><span class="line"></span><br><span class="line">	Week&#123;</span><br><span class="line">		int weekNum</span><br><span class="line">		Long id PK</span><br><span class="line">	&#125;</span><br><span class="line">	Day&#123;</span><br><span class="line">		int dayOfweek</span><br><span class="line">		Lond id PK</span><br><span class="line">	&#125;</span><br><span class="line">	Section&#123;</span><br><span class="line">		int sectionNum</span><br><span class="line">		Long id PK</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Week ||--o&#123; Day : &quot;has&quot;</span><br><span class="line">  Day ||--o&#123; Section :&quot;has&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="关系的种类"><a href="#关系的种类" class="headerlink" title="关系的种类"></a><strong>关系的种类</strong></h4><p>E-R 图中最常见的关系类型是 <strong>一对一</strong>（1:1）、<strong>一对多</strong>（1:N） 和 <strong>多对多</strong>（M:N）。这些类型通过连线的标注来表示：</p>
<h5 id="一对一（1-1）"><a href="#一对一（1-1）" class="headerlink" title="一对一（1:1）"></a>一对一（1:1）</h5><ul>
<li><p>每个实体 A 只能与另一个实体 B 的一个实例相关联，反之亦然。</p>
</li>
<li><p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTITY_A ──────|── ENTITY_B</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例：</p>
<p>一个人有一个身份证</p>
<p>。</p>
<h5 id="一对多（1-N）"><a href="#一对多（1-N）" class="headerlink" title="一对多（1:N）"></a>一对多（1:N）</h5><ul>
<li><p>一个实体 A 可以与多个实体 B 的实例相关联，而实体 B 的每个实例只能与一个实体 A 相关联。</p>
</li>
<li><p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTITY_A ──────&lt;── ENTITY_B</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例：</p>
<p>一个部门有多个员工</p>
<h5 id="多对多（M-N）"><a href="#多对多（M-N）" class="headerlink" title="多对多（M:N）"></a>多对多（M:N）</h5><ul>
<li><p>实体 A 的多个实例可以与实体 B 的多个实例相关联。</p>
</li>
<li><p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTITY_A ──────&lt;──&gt;── ENTITY_B</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例：</p>
<p>学生和课程的关系</p>
<p>（一个学生可以选修多门课程，而一门课程可以被多个学生选修）。</p>
<hr>
<h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><p>连线上可能标注一些约束条件，例如：</p>
<ul>
<li><p><strong>参与度</strong>：</p>
<ul>
<li>全部参与（Total Participation）：连线上用双线表示。<ul>
<li>示例：所有员工都必须属于一个部门。</li>
</ul>
</li>
<li>部分参与（Partial Participation）：连线上用单线表示。<ul>
<li>示例：某些员工可以没有项目参与。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基数（Cardinality）</strong>：</p>
<ul>
<li><p>用数字或符号表示一个实体参与关系的数量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1..N 表示一对多</span><br><span class="line">1 表示一对一</span><br><span class="line">M..N 表示多对多</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="弱实体的连线"><a href="#弱实体的连线" class="headerlink" title="弱实体的连线"></a>弱实体的连线</h4><ul>
<li><strong>弱实体</strong>：如果一个实体不能独立存在（依赖于另一个实体），它的连线通常连接到其“拥有”实体的主键，表示其依赖性。</li>
<li>通常，弱实体的连线会带有一个菱形（表示标识关系）。</li>
</ul>
<hr>
<h4 id="关系的属性"><a href="#关系的属性" class="headerlink" title="关系的属性"></a>关系的属性</h4><ul>
<li><p>连线上的菱形代表关系，如果关系有属性，这些属性会与菱形相连。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STUDENT ────── ENROLLS ────── COURSE</span><br><span class="line">                   |</span><br><span class="line">                  DATE</span><br></pre></td></tr></table></figure>

<p>示例中，<code>DATE</code>是<code>ENROLLS</code>关系的属性。</p>
</li>
</ul>
<h2 id="CH8-关系数据库设计-relational-database-design"><a href="#CH8-关系数据库设计-relational-database-design" class="headerlink" title="CH8 关系数据库设计 relational database design"></a>CH8 关系数据库设计 relational database design</h2><h3 id="分解-decompose"><a href="#分解-decompose" class="headerlink" title="分解 decompose"></a>分解 decompose</h3><p><img src="https://chiichen.github.io/assets/image-2-DIfBlPe0.png" alt="Example"></p>
<ul>
<li><p>如果分解后无法重建原始信息，那么就是有损分解lossy decomposition，反之则无损分解Lossless-join decompose</p>
<p><img src="https://chiichen.github.io/assets/image-Bp1Kkm8r.png" alt="有损分解"></p>
<p><img src="https://chiichen.github.io/assets/image-1-wIOyu-C4.png" alt="无损分解"></p>
</li>
<li><p>所以我们需要一个理论来告诉我们怎么合理的分解关系。好的分解要做到：</p>
<ul>
<li>无损分解</li>
<li>依赖保存</li>
</ul>
</li>
<li><p>BCNF分解可以保证无损，3NF可以保证依赖保存，但是3NF无法保证没有冗余，因此需要在BCNF和3NF间权衡</p>
</li>
</ul>
<h3 id="第一范式-first-normal-form"><a href="#第一范式-first-normal-form" class="headerlink" title="第一范式 first normal form"></a>第一范式 first normal form</h3><ul>
<li>如果一个域的元素被认为是不可分割的单元，则该域是原子的</li>
<li>非原子域的示例：<ul>
<li>名称集合，复合属性</li>
<li>可以分解为部分的标识号，例如CS101</li>
</ul>
</li>
<li>如果关系模式 R 的所有属性的域都是原子的，则关系模式 R 符合第一范式</li>
<li>非原子值会使存储变得复杂，并导致数据的冗余（重复存储）<ul>
<li>如：每个客户存储一组账户，每个账户都存储一组所有者</li>
</ul>
</li>
</ul>
<blockquote>
<p>原子性</p>
<ul>
<li>原子性实际上是与域的元素如何使用相关的属性。</li>
<li>例如，字符串通常被认为是不可分割的。</li>
<li>假设学生被赋予类似 SE0012 或 EE1127 的字符串形式的学号。</li>
<li>如果提取前两个字符来确定学院，那么学号的域就不是原子的。</li>
<li>这样做是一个坏主意：会导致信息被编码在应用程序而不是数据库中。</li>
</ul>
</blockquote>
<h3 id="第二范式-second-normal-form"><a href="#第二范式-second-normal-form" class="headerlink" title="第二范式 second normal form"></a>第二范式 second normal form</h3><blockquote>
<p><strong>主键</strong>：能够唯一标识表中一行的字段或字段组合。</p>
<p><strong>非主属性</strong>：除了主键之外的其他字段。</p>
<p><strong>部分依赖</strong>：非主属性依赖于主键的一部分，而不是整个主键。</p>
</blockquote>
<ol>
<li><p>首先需要满足第一范式 1NF：表中所有字段值都是原子值，每个字段的值是不可再分的最小单位。</p>
</li>
<li><p>消除部分依赖：</p>
<ul>
<li>表中的所有非主属性必须完全依赖于主键PK，不能依赖于主键的一部分</li>
</ul>
<blockquote>
<p>部分依赖：在复合主键中，某些非主属性仅依赖于主键的一部分，而不是整个主键</p>
</blockquote>
</li>
</ol>
<ul>
<li>数据库表中不存在非关键字段对任一候选键的部分函数依赖，也即所有非关键字都完全依赖于任意一组候选关键字。</li>
<li>2NF 的违例只会出现在候选键由超过一个字段构成的表中，因为对单关键字字段不存在部分依赖问题。</li>
</ul>
<blockquote>
<p>例子</p>
<p>给定关系模式的函数依赖集合如下：</p>
<ol>
<li>学号课程名称姓名年龄成绩学分{(学号,课程名称)→(姓名,年龄,成绩,学分)}</li>
<li>课程名称学分{(课程名称)→(学分)}</li>
<li>学号姓名年龄{(学号)→(姓名,年龄)}</li>
</ol>
<p>在这个例子中，候选键只有一个，即学号课程名称(学号,课程名称)，因此主键也是学号课程名称(学号,课程名称)。</p>
<p>我们可以观察到，属性姓名、年龄和学分是部分依赖于主键的，而属性成绩成绩是完全依赖于主键的。由于存在部分依赖关系，这个关系模式不满足第二范式。</p>
<p>为了使关系模式满足第二范式，我们需要进行分解，将属性姓名姓名、年龄年龄和学分学分从主关系模式中分离出来，形成新的关系模式。最终的关系模式可能如下：</p>
<p>关系模式 1: 学号课程名称成绩(学号,课程名称,成绩)</p>
<p>关系模式 2: 课程名称学分(课程名称,学分)</p>
<p>关系模式 3: 学号姓名年龄(学号,姓名,年龄)</p>
<p>这样，每个关系模式都满足第二范式，并且保留了原始关系模式的函数依赖。</p>
</blockquote>
<h3 id="函数依赖-functional-dependencies"><a href="#函数依赖-functional-dependencies" class="headerlink" title="函数依赖 functional dependencies"></a>函数依赖 functional dependencies</h3><blockquote>
<p>函数依赖用于表明某些属性的值可以通过其他属性的值唯一确定。即可以通过决定因素确定被决定因素的值</p>
</blockquote>
<ul>
<li><p>在一个关系模式 $R(A,B,C,…)$中，假设 $X$ 和 $Y$ 是属性的子集：</p>
<ul>
<li><p>如果对于关系 $R$ 的任意两个元组 $t_1$ 和 $t_2$，当$t_1[X]&#x3D;t_2[X]$时，一定有$t_1[Y]&#x3D;t_2[Y]$，则称 $X$ 函数确定 $Y$，记作：</p>
<p>$X \rightarrow Y$</p>
</li>
<li><p>$X$：称为决定因素 determinant</p>
</li>
<li><p>$Y$：称为被决定因素 dependent</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>换而言之，给定$X$值即可唯一确定$Y$的值</p>
</blockquote>
<ul>
<li>函数依赖是对合法关系集合的约束条件。</li>
<li>函数依赖是对键的概念的一种推广</li>
<li>定义：$\alpha \rightarrow \beta $ 等价于<ol>
<li>$\alpha$是模式$(\alpha,\beta)$ 的超码super-key</li>
<li>属性 $\alpha$ 的取值决定 $\beta$ 的取值</li>
</ol>
</li>
<li>在函数依赖 $\alpha \rightarrow \beta$ 中，如果 $\beta \subseteq \alpha$，我们就称它是<code>平凡trivial</code>的。因为对于任意的关系<em>R</em>它总是成立的。<ul>
<li>例：$ID,name \rightarrow ID$ 是平凡的 $name \rightarrow name $ 也是平凡的</li>
</ul>
</li>
<li>在函数依赖 $\alpha \rightarrow \beta$中，如果对于 $\alpha$ 的任何一个真子集 $\alpha^{‘}$，都有 $\alpha^{‘} \nrightarrow$ 那么就称$\beta$对$\alpha$有完全函数依赖</li>
<li>在函数依赖 $\alpha \rightarrow \beta$中，如果$\beta$不完全函数依赖于$\alpha$就称$\beta$对$\alpha$部分函数依赖</li>
</ul>
<h4 id="函数依赖与超键"><a href="#函数依赖与超键" class="headerlink" title="函数依赖与超键"></a>函数依赖与超键</h4><ul>
<li><p>当且仅当 $K \rightarrow R$，$K$是关系模式$R$的超键</p>
</li>
<li><p>当且仅当满足以下条件时，$K$是$R$的候选键：</p>
<ul>
<li>$K \rightarrow R$，并且对于任何$\alpha \subset K$，都不满足$\alpha \rightarrow R$。</li>
</ul>
</li>
<li><p>函数依赖允许我们表达无法使用超键来表示的约束。考虑以下模式：</p>
<ul>
<li><p>$$<br>inst_dept(ID,name,salary,dept_name,building,budget)<br>$$</p>
</li>
<li><p>期望以下函数依赖成立：</p>
<p>$$<br>dept_name \rightarrow building \<br>ID \rightarrow building<br>$$</p>
</li>
<li><p>但是不期望以下函数依赖成立<br>$$<br>dept_name \rightarrow salary<br>$$</p>
</li>
</ul>
</li>
</ul>
<h4 id="函数依赖的作用"><a href="#函数依赖的作用" class="headerlink" title="函数依赖的作用"></a>函数依赖的作用</h4><p>我们使用函数依赖来进行以下操作：</p>
<ul>
<li><p>检验关系是否在给定的函数依赖集合下合法</p>
<ul>
<li>如果关系 $r$ 在函数依赖集合 $F$ 下是合法的，则 $r$ 满足satisfy $F$。</li>
</ul>
</li>
<li><p>指定对合法关系集的约束</p>
<ul>
<li>如果在关系模式 $R$ 上的所有合法关系都满足函数依赖集合 $F$，我们说 $F$ 在模式 $R$ 上成立holds-on。</li>
</ul>
</li>
</ul>
<p>注：一个关系模式的特定实例可能满足一个函数依赖，即使该函数依赖不在所有合法实例上成立，例：$instructor$关系模式的一个特定实例可能恰好满足$name \rightarrow ID$。</p>
<p>无损连接于分解 lossess-join decomposition</p>
<ul>
<li>对于关系 $R&#x3D;(R_1,R_2)$的情况，我们要求对于满足$r&#x3D;\begin{matrix} \prod_{R_1}(r) \end{matrix} \bowtie \begin{matrix} \prod_{R_2}(r) \end{matrix}$式子的所有可能的关系$r$</li>
<li>如果一个从$R$分解成$R_1$和$R_2$的分解是无损的，那么式子$R_1 ∩ R_2 \rightarrow R_1$或$R_1 ∩ R_2 \rightarrow R_2$至少有一个在$F^+$中。</li>
<li>上述是保证无损分解的充分条件。</li>
</ul>
<h4 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h4><ul>
<li>$F^+$表示所有能从函数依赖$F$中推出的函数依赖闭包</li>
<li>如果两个函数依赖集的闭包相等，则两个函数依赖集是等价的</li>
<li>可以通过反复应用 Armstrong 公理来找到 $F^+$<ul>
<li><strong>自反性</strong>：如果$\beta$是$\alpha$的子集，那么$\alpha \rightarrow \beta$。</li>
<li><strong>扩充性</strong>：如果$\alpha \rightarrow \beta$，那么对于任意$\gamma$，都有$\gamma \alpha \rightarrow \gamma \beta$。</li>
<li><strong>传递性</strong>：如果$\alpha \rightarrow \beta$，且$\beta \rightarrow \gamma$，那么$\alpha \rightarrow \gamma$。</li>
</ul>
</li>
<li>以上三点规则是完备且合理的</li>
<li>附加规则：<ul>
<li><strong>并集规则</strong>：如果$\alpha \rightarrow \beta$成立且$\alpha \rightarrow \gamma$成立，则$\alpha \rightarrow \beta \gamma$也成立。</li>
<li><strong>分解规则</strong>：如果$\alpha \rightarrow \beta \gamma$成立，则$\alpha \rightarrow \beta$和$\alpha \rightarrow \gamma$成立。</li>
<li><strong>伪传递性规则</strong>：如果$\alpha \rightarrow \beta$成立且$\gamma \beta \rightarrow \delta$成立，则$\alpha \gamma \rightarrow \delta$</li>
</ul>
</li>
<li>附加规则是可以通过 armstrong 公理推导的。</li>
</ul>
<h4 id="属性集闭包-closure-of-attribute-sets"><a href="#属性集闭包-closure-of-attribute-sets" class="headerlink" title="属性集闭包 closure of attribute sets"></a>属性集闭包 closure of attribute sets</h4><ul>
<li>定义为：$\alpha^+ &#x3D; { A|(\alpha \rightarrow A \subseteq F^+}$，即通过函数依赖确定$\alpha$可以决定的所有属性</li>
</ul>
<p><img src="https://chiichen.github.io/assets/image-4-CH5gmXtS.png" alt="属性集闭包计算示例"></p>
<h4 id="属性闭包与函数依赖"><a href="#属性闭包与函数依赖" class="headerlink" title="属性闭包与函数依赖"></a>属性闭包与函数依赖</h4><p>在基于：$\alpha \rightarrow \beta \leftrightarrow \beta \subseteq \alpha^+$关系，可以通过计算属性集闭包来计算函数依赖</p>
<h4 id="属性集闭包和超键"><a href="#属性集闭包和超键" class="headerlink" title="属性集闭包和超键"></a>属性集闭包和超键</h4><p>在基于：$\alpha is superkey \leftrightarrow R \subseteq \alpha^+$，可以通过属性集闭包来判定$\alpha$是不是超键</p>
<h4 id="属性集闭包和函数依赖闭包"><a href="#属性集闭包和函数依赖闭包" class="headerlink" title="属性集闭包和函数依赖闭包"></a>属性集闭包和函数依赖闭包</h4><p>通过属性集闭包计算函数依赖闭包：</p>
<ol>
<li>$F^+ \leftarrow F$</li>
<li>对于每个 $\gamma \subseteq R$，计算$\gamma^+$</li>
<li>对于每个$S \subseteq \gamma^+$，计算$F^+ \leftarrow {\gamma \rightarrow S } ∪ F^+$</li>
<li>输出$F^+$</li>
</ol>
<h3 id="规范化的目标"><a href="#规范化的目标" class="headerlink" title="规范化的目标"></a>规范化的目标</h3><ul>
<li>给定一个关系模式 $R$ 和函数依赖集 $F$，判断关系模式 $R$ 是否处于“良好”的形式</li>
<li>如果关系模式 $R$ 不处于“良好”的形式，则将其分解为一组关系模式$(R_1,R_2,…,R_n)$，其中每个关系模式都处于良好形式。</li>
<li>分解应该是无损连接lossless-join的——通过连接分解后的关系模式可以恢复到原始关系模式</li>
<li>最好的情况是分解应该是依赖保持的——在分解后的每个关系模式上仍然能够保持原始的函数依赖关系。</li>
</ul>
<h3 id="规范覆盖-Canonical-Cover"><a href="#规范覆盖-Canonical-Cover" class="headerlink" title="规范覆盖 Canonical Cover"></a>规范覆盖 Canonical Cover</h3><ul>
<li><p>规范覆盖canonical-cover是指函数依赖集中的一组“最小”等价函数依赖，它不包含冗余的依赖关系或冗余的依赖关系部分。函数依赖集$F$的规范覆盖记作$F_c$，它满足以下条件：</p>
<ul>
<li>$F \Leftrightarrow F_c$</li>
<li>$F_c$ 中的每个函数依赖都不包含冗余属性</li>
<li>$F_c$ 中的每个函数依赖的左侧是唯一的，不会存在相同的左侧，即没有：$\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$，只能是$\alpha \rightarrow \beta \gamma$​</li>
</ul>
</li>
<li><p>函数依赖集中的依赖关系可能存在冗余的依赖关系，可以从其他依赖关系中推导出来。例如，在集合{A-&gt;B,B-&gt;C,A-&gt;C}中，A-&gt;C就是冗余的</p>
</li>
<li><p>函数依赖的部分可能也是冗余的。例如，在右侧的依赖集合{A-&gt;B,B-&gt;C,A-&gt;CD}可以简化为{A-&gt;B,B-&gt;C,A-&gt;D}；在左侧的依赖集合{A-&gt;B,B-&gt;C,AC-&gt;D}可以简化为{A-&gt;B,B-&gt;C,A-&gt;D}。</p>
</li>
<li><p>直观地说，规范覆盖是等价于函数依赖集合F的一组“最小”函数依赖，它不包含冗余的依赖关系或冗余的依赖关系部分。规范覆盖的目的是简化函数依赖集合，使其更加简洁和有效。</p>
</li>
</ul>
<h4 id="计算规范覆盖"><a href="#计算规范覆盖" class="headerlink" title="计算规范覆盖"></a>计算规范覆盖</h4><ul>
<li>计算函数依赖集合$F$的规范覆盖步骤：<ul>
<li>重复以下步骤：<ol>
<li>使用并集规则（union rule）替换F中的任何函数依赖，例如将函数依赖α1-&gt;β1和α1-&gt;β2替换为α1-&gt;β1 β2。</li>
<li>查找具有冗余属性的函数依赖α-&gt;β，冗余属性可能存在于α或β中。注意：对冗余属性的测试是使用F_c而不是F进行的</li>
<li>如果找到冗余属性，则从α-&gt;β中删除它。</li>
</ol>
</li>
<li>直到F不再发生变化为止。</li>
</ul>
</li>
<li>需要注意的是，删除一些冗余属性后，可能会使并集规则再次适用，因此需要重新应用并集规则。</li>
<li>通过执行上述步骤，最终得到的函数依赖集合F_c就是原函数依赖集合F的规范覆盖。</li>
</ul>
<p><img src="https://chiichen.github.io/assets/image-9-BD14r9EV.png" alt="计算规范覆盖"></p>
<h3 id="冗余属性-extraneous-attributes"><a href="#冗余属性-extraneous-attributes" class="headerlink" title="冗余属性 extraneous attributes"></a>冗余属性 extraneous attributes</h3><ul>
<li>冗余属性 extraneous-attribute 是指在给定的函数依赖集合中，某个属性在依赖关系中是冗余的，可以被删除而不影响函数依赖的表达。</li>
<li>例如，给定函数依赖集合F&#x3D;{A-&gt;C,AB-&gt;C}，我们要判断属性B是否是冗余的。通过删除属性B，得到新的依赖集合H&#x3D;{A-&gt;C}。如果满足F&lt;&#x3D;&gt;H，那么属性B就是冗余的。</li>
<li>对于函数依赖集$F$ 中的函数依赖 $\alpha x \rightarrow \beta$，如果删除属性$x$后得到的新的函数依赖集$H$满足F&lt;&#x3D;&gt;(F-{$\alpha x$-&gt;$\beta$})∪{$\alpha$-&gt;$\beta$}，那么属性$x$就是冗余的。</li>
<li>需要注意的是，上述情况中，逆向的蕴含关系在每种情况下都是显而易见的，因为“更强”的函数依赖总是蕴含着“更弱”的函数依赖</li>
</ul>
<blockquote>
<p><strong>函数依赖强弱的定义</strong></p>
<ul>
<li><p>更强的函数依赖</p>
<p>：如果一个函数依赖的左侧属性集更大或者更具体，那么它的约束更强。例如：</p>
<ul>
<li>$AB \to C$ 比 $A \to C$ 更强，因为 $AB$ 包含了 $A$，需要更多的条件（$A$ 和 $B$ 同时成立）来确定$C$。</li>
</ul>
</li>
<li><p>更弱的函数依赖</p>
<p>：如果一个函数依赖的左侧属性集更小或者更宽松，那么它的约束更弱。例如：</p>
<ul>
<li>$A \to C$ 比 $AB \to C$ 更弱，因为只需要 $A$ 成立就能确定 $C$，而不需要考虑 $B$。</li>
</ul>
</li>
</ul>
<p><strong>蕴含关系</strong></p>
<p>函数依赖 $X \to Y$表示：如果属性集$X$的值确定，那么$Y$的值也是确定的。</p>
<ul>
<li>如果我们有一个更强的依赖（例如 $AB \to C$），它的前提条件更严格，因此它一定能够保证更弱的依赖（例如 $A \to C$）的成立。</li>
<li>这是因为，如果 $AB \to C$ 成立，那么满足 $AB$ 的任何情况，也必然满足 $A \to C$ 中更宽松的条件。</li>
</ul>
</blockquote>
<h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h3><blockquote>
<p>满足第二范式，且不存在依赖传递，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。</p>
</blockquote>
<ul>
<li>在第二范式的基础上，数据库中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式</li>
<li>一个关系模式 R 在第三范式中，如果对 F 中的所有$\alpha \to \beta$，至少满足以下条件：<ul>
<li>$\alpha$是R的super-key</li>
<li>$\alpha \subseteq \beta$，则$\beta$也是超键</li>
<li>$\beta \to \alpha$中的每个属性 A 都包含在 R 的候选键中（注：每个属性可能在不同的候选键中）</li>
</ul>
</li>
</ul>
<blockquote>
<p>平凡函数依赖</p>
<p>非平凡函数依赖：$X→Y$ 是非平凡的，指的是 $Y$ 不是 $X$​ 的子集。</p>
</blockquote>
<p>- </p>
<h3 id="BCNF范式-boyce-codd-normal-form"><a href="#BCNF范式-boyce-codd-normal-form" class="headerlink" title="BCNF范式 boyce-codd normal form"></a>BCNF范式 boyce-codd normal form</h3><ul>
<li>关系模式 R 在 BCNF 中，如果对于 R 中的存在的所有函数依赖关系 F，形式为 $\alpha \to \beta$，其中$\alpha \subseteq R$且$\beta \subseteq R$，至少满足以下条件之一：<ul>
<li>$\alpha \subseteq \beta$</li>
<li>$\alpha $是R的super-key</li>
</ul>
</li>
<li></li>
</ul>
<blockquote>
<p>范式之间的关系</p>
<p>第一范式(1NF)<br>非码的非平凡 | ↓ 消除非主属性对码的部分函数依赖<br>第二范式(2NF)<br>↓ 消除非主属性对码的传递函数依赖<br>第三范式(3NF)<br>↓ 消除主属性对码的部分和传递函数依赖<br>BC 范式(BCNF)<br>↓ 消除非平凡且非函数依赖的多值依赖<br>第四范式(4NF)<br>↓ 消除不是由候选码所蕴含的连接依赖<br>第五范式(5NF)</p>
</blockquote>
<h2 id="CH10-存储和文件结构"><a href="#CH10-存储和文件结构" class="headerlink" title="CH10 存储和文件结构"></a>CH10 存储和文件结构</h2><h3 id="物理存储媒介-physical-storage-media"><a href="#物理存储媒介-physical-storage-media" class="headerlink" title="物理存储媒介 physical storage media"></a>物理存储媒介 physical storage media</h3><ul>
<li><p>磁盘</p>
<ul>
<li>1 block &#x3D; 多个连续的 sector</li>
<li>1 个文件(哈希文件除外)&#x3D; 多个连续的 block</li>
</ul>
</li>
<li><p>磁头与磁盘</p>
<ul>
<li>磁头往磁盘读写数据的最小单位是 sector</li>
</ul>
</li>
<li><p>内存与磁盘</p>
<ul>
<li>内存与磁盘交换信息的最小单位是 block</li>
</ul>
</li>
<li><p>开销&#x3D;寻道时间 + 旋转时间 + 传输时间</p>
</li>
<li><p>数据库只关注:</p>
<ul>
<li>寻道次数</li>
<li>传输磁盘块个数</li>
</ul>
</li>
<li><p>设访问的磁盘块依次分别是: B1, B2</p>
<ul>
<li><p>寻道次数 : 如果 B1, B2 相邻, 则寻道 1 次</p>
</li>
<li><p>传输磁盘块的个数: 无论相邻与否, 都是 2.</p>
<p><img src="https://chiichen.github.io/assets/image-DlrztMBS.png" alt="磁盘结构示意图"></p>
</li>
</ul>
</li>
</ul>
<h3 id="缓冲管理-buffer-management"><a href="#缓冲管理-buffer-management" class="headerlink" title="缓冲管理 buffer-management"></a>缓冲管理 buffer-management</h3><ul>
<li>当程序需要从磁盘中获取一个块时，它会调用缓冲管理器。<ul>
<li>如果该块已经在缓冲区中，则缓冲管理器会返回该块在主内存中的地址。</li>
<li>如果该块不在缓冲区中，缓冲管理器会执行以下操作：<ul>
<li>在缓冲区中为该块分配空间。<ul>
<li>如果需要，替换（抛弃）其他块，以为新块腾出空间。</li>
<li>仅当被替换的块在最近一次写入&#x2F;从磁盘获取时被修改后，才将其写回磁盘。</li>
</ul>
</li>
<li>从磁盘中读取该块到缓冲区，并将该块在主内存中的地址返回给请求者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="缓冲替换策略-buffer-replacement-policies"><a href="#缓冲替换策略-buffer-replacement-policies" class="headerlink" title="缓冲替换策略 buffer-replacement-policies"></a>缓冲替换策略 buffer-replacement-policies</h4><ul>
<li>大多数操作系统使用<code>最近最少使用（LRU）</code>策略替换块。</li>
<li>LRU 的思想是利用过去的块引用模式作为对未来引用的预测器。</li>
<li>查询具有明确定义的访问模式（例如顺序扫描），数据库系统可以利用用户查询中的信息来预测未来的引用。</li>
<li>对于涉及<strong>重复数据</strong>扫描的某些访问模式，LRU 可能是一个不好的策略。<ul>
<li>例如：计算两个关系$r$和$s$的连接操作时，通过嵌套循环进行：<ul>
<li>对于$r$的每个元组$t_r$，</li>
<li>对于$s$的每个元组$t_s$，</li>
<li>如果元组 $t_r$ 和 $t_s$ 匹配…</li>
</ul>
</li>
<li>在这种情况下，使用立即丢弃（Toss-immediate）策略更可取。</li>
</ul>
</li>
<li>固定的块(Pinned block) - 不能写回磁盘的内存块。</li>
<li>立即丢弃（Toss-immediate）策略 - 在处理完块的最后一个元组后，立即释放该块占用的空间。</li>
<li>最近使用（Most recently used (MRU) strategy）策略 - 系统必须固定当前正在处理的块。在处理完该块的最后一个元组后，取消固定该块，并使其成为最近使用的块。</li>
<li>缓冲管理器可以使用关于请求将引用特定关系的概率的统计信息。<ul>
<li>例如，数据字典经常被访问。启发式方法：将数据字典块保留在主内存缓冲区中。</li>
</ul>
</li>
<li>缓冲管理器还支持强制输出块(forced output)以进行恢复的目的（有关更多信息，请参阅第 16 章）</li>
</ul>
<h3 id="文件组织-file-organization"><a href="#文件组织-file-organization" class="headerlink" title="文件组织 file-organization"></a>文件组织 file-organization</h3><blockquote>
<p>数据库以文件集合的形式存储。每个文件是一系列记录，而记录则是一系列字段的序列。</p>
</blockquote>
<p>一个数据库被映射为多个不同的文件file，文件由OS来维护，永久存储在磁盘中</p>
<p>一个文件在逻辑上组织成记录的序列。每个文件分成定长的存储单元—— 块 block</p>
<p>block是存储分配和数据传输的基本单元，多数数据库默认使用4-8KB大小的块。当创建数据库时，可以指定块大小。</p>
<p>一个块可以包含多条记录。要求每条记录存储在单个块中，即：没有一条记录是部分包含在一个块中的，以加速数据访问。</p>
<p>关系数据库中，不同关系的元组通常具有不同的大小，记录可分为<strong>定长记录和变长记录</strong>。</p>
<h4 id="定长记录-fixed-length-records"><a href="#定长记录-fixed-length-records" class="headerlink" title="定长记录 fixed-length records"></a>定长记录 fixed-length records</h4><ul>
<li><p>一种方法是：</p>
<ul>
<li>假设记录大小是固定的。</li>
<li>每个文件只包含一种特定类型的记录。</li>
<li>不同的文件用于不同的关系。</li>
</ul>
</li>
<li><p>这种情况最容易实现；稍后我们将考虑可变长度的记录</p>
<p><img src="D:\Blog\source_posts\校内课程学习笔记\计算机专业课\数据库.assets\image-1-Co9_fsVz.png" alt="Fixed-Length Records"> </p>
</li>
<li><p>用空闲链表来存储空余空间</p>
<p><img src="https://chiichen.github.io/assets/image-2-CyvBTO7J.png" alt="Free Lists">  </p>
</li>
<li><p>从这个结构中删除一条记录很困难。删除的记录所占用的空间必须由文件的其它记录填充或者标记该空间为忽略。</p>
<ul>
<li>方法一：删除一条记录后，依次将后面的记录往前挪。<br>缺点：需要额外的块访问操作。</li>
<li>方法二：将被删除的记录的存储空间用来存储新插入的记录。这就需要标记该空间。引入如下结构：<ul>
<li>在文件的开始处，分配一定数量的字节作为文件头（file header）。</li>
<li>令文件头中除了文件的相关信息外，还包括被删除的第一条记录的地址。</li>
<li>在第一条被删除的记录处，来存储第二条被删除的记录的地址。以此类推。</li>
<li>&#x3D;&#x3D;&gt;形成了有一个空闲列表（free list）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="变长记录-variable-length-records：slotted-page-structure"><a href="#变长记录-variable-length-records：slotted-page-structure" class="headerlink" title="变长记录 variable-length-records：slotted-page-structure"></a>变长记录 variable-length-records：slotted-page-structure</h4><p><img src="https://chiichen.github.io/assets/image-3-DOPpOuNL.png" alt="Slotted Page Structure"> </p>
<ul>
<li>插槽页头(Slotted page header)包含以下内容：<ul>
<li>记录条目的数量</li>
<li>块中空闲空间的结束位置</li>
<li>每个记录的位置和大小</li>
</ul>
</li>
<li>可以在页面内部移动记录，以保持它们的连续性，中间没有空白空间；页头中的条目必须更新。</li>
<li>指针不应直接指向记录，而应指向页头中记录对应的条目。</li>
</ul>
<h4 id="文件内的记录组织"><a href="#文件内的记录组织" class="headerlink" title="文件内的记录组织"></a>文件内的记录组织</h4><ul>
<li><p><code>堆（Heap）</code>- 记录可以放置在文件中的任何有空间的位置。</p>
</li>
<li><p><code>顺序（Sequential）</code>- 根据每个记录的搜索键值，按顺序存储记录。</p>
<p><img src="https://chiichen.github.io/assets/image-4-CBozuB4y.png" alt="顺序组织"> </p>
<p><img src="https://chiichen.github.io/assets/image-5-_5H_oOZN.png" alt="顺序组织"> </p>
</li>
<li><p><code>哈希（Hashing）</code>- 对每个记录的某个属性计算哈希函数；结果指定了记录应该放置在文件的哪个块中。</p>
</li>
<li><p>每个关系的记录可以存储在单独的文件中。在<code>多表聚集文件组织(multitable clustering file organization)</code>中，多个不同关系的记录可以存储在同一个文件中。</p>
</li>
<li><p>动机：将相关的记录存储在同一个块中，以最小化 I&#x2F;O 操作</p>
<p><img src="https://chiichen.github.io/assets/image-6-ZLXExafy.png" alt="多表聚集文件组织(multitable clustering file organization)"></p>
<p><img src="https://chiichen.github.io/assets/image-7-bBX0JNym.png" alt="多表聚集文件组织(multitable clustering file organization)"></p>
</li>
</ul>
<h3 id="数据字典存储-data-dictionary-storage"><a href="#数据字典存储-data-dictionary-storage" class="headerlink" title="数据字典存储 data-dictionary-storage"></a>数据字典存储 data-dictionary-storage</h3><p>数据字典（也称为系统目录）存储元数据，即关于数据的数据，例如：</p>
<ul>
<li>关于关系的信息<ul>
<li>关系的名称</li>
<li>每个关系的属性的名称和类型</li>
<li>视图的名称和定义</li>
<li>完整性约束</li>
</ul>
</li>
<li>用户和账户信息，包括密码</li>
<li>统计和描述性数据<ul>
<li>每个关系中的元组数量</li>
</ul>
</li>
<li>物理文件组织信息<ul>
<li>关系的存储方式（顺序&#x2F;哈希&#x2F;…）</li>
<li>关系的物理位置</li>
</ul>
</li>
<li>关于索引的信息（第 11 章中介绍）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="cm7pnj29p003pucv261b5hf4k" data-title="数据库期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/计算机专业课/操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.260Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统突击复习"><a href="#操作系统突击复习" class="headerlink" title="操作系统突击复习"></a>操作系统突击复习</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>早期引入批处理系统通过减少人工操作的时间，以提高处理效率</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><strong>进程的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次活动</strong></p>
<p>当进程被创建时，会给予进程一个不重复的独一无二的PID。</p>
<p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h3 id="Process-和-Program-的不同"><a href="#Process-和-Program-的不同" class="headerlink" title="Process 和 Program 的不同"></a>Process 和 Program 的不同</h3><p><strong>程序 (Program):</strong></p>
<ul>
<li>是一系列集合指令，是一个静态概念；</li>
<li>永久存在，直到被删除；</li>
<li>一个程序可以被多个进程执行。</li>
</ul>
<p><strong>进程 (Process):</strong></p>
<ul>
<li><p>描述并发、动态的概念；</p>
</li>
<li><p>进程包括程序、数据和进程控制块 (PCB)；</p>
</li>
<li><p>是暂时的，会随进程的终止而消失；</p>
</li>
<li><p>进程可以创建其他进程；</p>
</li>
<li><p>进程可以调用多个程序。</p>
</li>
<li><p>进程是CPU调度的基本单位</p>
</li>
</ul>
<h2 id="Process-States"><a href="#Process-States" class="headerlink" title="Process States"></a>Process States</h2><ul>
<li>三种基本状态：<ul>
<li>运行 running state</li>
<li>就绪 ready state</li>
<li>阻塞 blocked state  </li>
<li>三种基本状态的转换</li>
</ul>
</li>
</ul>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240611092655834.png" alt="image-20240611092655834"> </p>
<ul>
<li>其他状态<ul>
<li>New state</li>
<li>Exit state</li>
</ul>
</li>
<li>挂起<ul>
<li>阻塞挂起状态</li>
<li>就绪挂起状态</li>
</ul>
</li>
</ul>
 <img src="E:\DeskTable\博客学习截图传输\image-20240610172240806.png" alt="image-20240610172240806" style="zoom:50%;" /> 

<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>一个进程内的执行顺序流</p>
<h3 id="Thread-和-process-的异同"><a href="#Thread-和-process-的异同" class="headerlink" title="Thread 和 process 的异同"></a>Thread 和 process 的异同</h3><h4 id="不同："><a href="#不同：" class="headerlink" title="不同："></a>不同：</h4><ul>
<li><strong>资源分配角度</strong>： <ul>
<li>进程是资源分配的基本单位,所有与该进程有关的资源分配情况均记录在进程控制块PCB中,进程也是分配主存的基本单位,它拥有一个完整的虚拟地址空间。</li>
<li>而线程与<strong>资源分配无关</strong>,它属于某一个进程,并与该进程内的<strong>其它线程一起共享</strong>进程的资源。</li>
</ul>
</li>
<li><strong>地址空间</strong>：<ul>
<li>不同的进程拥有不同的虚拟地址空间,</li>
<li>而同一进程中的多个线程共享同一地址空间。</li>
</ul>
</li>
<li><strong>进程间切换和线程间切换开销不同</strong>：<ul>
<li>进程调度的切换将涉及到有关资源指针的保存及进程地址空间的转换等问题。</li>
<li>而线程的切换将不涉及资源指针的保存和地址空间的变化。</li>
<li>线程切换的开销要比进程切换的开销小得多。</li>
</ul>
</li>
<li><strong>调度者的不同</strong>：<ul>
<li>进程的调度与切换都是由操作系统内核完成</li>
<li>而线程则既可由操作系统内核完成,也可由用户程序进行。</li>
</ul>
</li>
</ul>
<h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><ul>
<li>**都具有创建的功能：**进程可以动态创建进程。被进程创建的线程也可以创建其它线程。</li>
<li>**有相似的生命周期：**进程有创建、执行、消亡的生命周期。线程也有类似的生命周期。</li>
</ul>
<h3 id="线程的实现-implementation"><a href="#线程的实现-implementation" class="headerlink" title="线程的实现 implementation"></a>线程的实现 implementation</h3><p><strong>三种实现方式：</strong></p>
<ul>
<li><strong>用户级：</strong><ul>
<li>线程完全处于用户空间中，内核不知道有该线程存在</li>
<li>用户级线程管理由用户级线程库完成</li>
<li>高效：线程切换<strong>不需要内核权限</strong>，用户级线程<strong>创建和管理速度快</strong>。</li>
<li>问题：如果内核是单线程的，那么任何执行阻塞系统调用的用户级线程都将导致整个进程阻塞。</li>
</ul>
</li>
<li>内核级<ul>
<li>内核支持:内核在内核空间中执行线程创建、调度和管理。</li>
<li>没有线程库，内核提供API</li>
<li>内核维护进程和线程的上下文</li>
<li>线程切换需要内核</li>
<li>线程是Scheduler的基本单位。</li>
<li>缺点是：资源花销太大</li>
</ul>
</li>
<li>混合实现</li>
</ul>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2><h3 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h3><p>对多个相关进程在执行次序上的协调,用于保证这种关系的相应机制称为进程同步。</p>
<p>相互合作的一组并发进程在一些关键点上可能需要互相等待与互通消息,相互制约的等待与互通消息称为进程同步。</p>
<ul>
<li><p>进程间竞争 race：</p>
<ul>
<li>防止竞争的出现关键在于禁止多个进程同时读写共享数据。</li>
</ul>
</li>
<li><p>互斥 Mutual exclusion：确保一个进程使用某共享资源时，其他进程无法访问这个变量</p>
</li>
</ul>
<h3 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h3><ul>
<li>**临界资源：**一次仅允许一个进程访问的资源称之为临界资源</li>
</ul>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>**临界区：**程序中访问临界资源的部分称为临界区域或临界段</p>
<p><strong>临界区四个性质要求：</strong></p>
<ol>
<li><strong>没有两个进程同时</strong>处于临界区域</li>
<li>没有对cpu的速度或数量做任何假设</li>
<li>任何在<strong>临界区域外运行的进程</strong>都<strong>不能阻塞</strong>另一个进程</li>
<li>没有进程必须<strong>永远等待</strong>才能进入其临界区域</li>
</ol>
<h3 id="实现互斥"><a href="#实现互斥" class="headerlink" title="实现互斥"></a>实现互斥</h3><h4 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h4><ul>
<li>在进入临界区后禁用所有中断，并在离开临界区之前重新启用它们。</li>
<li>禁用中断后，不会发生时钟中断，因为CPU只有在时钟中断时才可以进行进程的切换，禁用后就不会发生切换了。</li>
</ul>
<h4 id="锁变量：使用一个简单的锁变量来表示临界区是否被占用。"><a href="#锁变量：使用一个简单的锁变量来表示临界区是否被占用。" class="headerlink" title="锁变量：使用一个简单的锁变量来表示临界区是否被占用。"></a>锁变量：使用一个简单的锁变量来表示临界区是否被占用。</h4><ol>
<li><p>两个(或更多)进程可以同时进入它们的临界区。这可能违反性质1。</p>
</li>
<li><p><img src="E:\DeskTable\博客学习截图传输\image-20240619221903004.png" alt="image-20240619221903004"> </p>
<p>这些执行序列需要是原子的。原子性意味着代码在执行期间不能被中断。</p>
</li>
</ol>
<ul>
<li>进程在进入临界区之前检查该变量：</li>
<li>如果它没有被锁定，则设置它为锁定状态并进入临界区；</li>
<li>如果被锁定，则等待。该方法存在忙等待问题，并且容易出现竞争条件。</li>
</ul>
<h4 id="严格的轮换法："><a href="#严格的轮换法：" class="headerlink" title="严格的轮换法："></a>严格的轮换法：</h4><p>用于两个进程之间的互斥。进程交替进入临界区。一个进程完成后设置一个标志，允许另一个进程进入临界区。</p>
<ul>
<li><p>缺点是会导致不必要的等待，即使一个进程不需要进入临界区，另一个进程也必须等待。</p>
</li>
<li><p>这个方法可能违反性质3——任何在<strong>临界区域外的进程不能</strong>阻塞另一个进程</p>
<p>由于进程必须严格交替进入它们的临界区，因此想要连续两次进入其临界区的进程将被阻塞，直到另一个进程决定进入(和离开)其临界区。</p>
</li>
</ul>
<h4 id="Peterson算法："><a href="#Peterson算法：" class="headerlink" title="Peterson算法："></a>Peterson算法：</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20240619222146871.png" alt="image-20240619222146871"> </p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240619222634630.png" alt="image-20240619222634630"> </p>
<p>互斥：</p>
<p>当且仅当其他进程不希望进入临界区；</p>
<p>当且仅当其他进程想要进入，但轮到你；</p>
<p>一个进程可以两次进入它的临界区。</p>
<p>在临界区域外运行的进程不能阻塞另一个进程。</p>
<h4 id="Test-and-Set-Lock-TSL-："><a href="#Test-and-Set-Lock-TSL-：" class="headerlink" title="Test-and-Set Lock (TSL)："></a>Test-and-Set Lock (TSL)：</h4><ul>
<li><p>硬件必须支持一个特殊的指令，tsl，它在一个原子动作中做两件事:<br>TSL register，flag</p>
<ul>
<li>copy a value in memory (flag) to a CPU register</li>
<li>set flag to 1.</li>
</ul>
</li>
<li><pre><code class="language-c">// 伪代码
boolean lock = false;

boolean TestAndSet(boolean *target) &#123;
    boolean rv = *target;
    *target = true;
    return rv;
&#125;

while (true) &#123;
    while (TestAndSet(&amp;lock));
    critical_section();
    lock = false;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Sleep and Wakeup：</span><br><span class="line"></span><br><span class="line">当一个进程不能进入临界区时，它会进入sleep状态（其实就是blocked），直到另一个进程唤醒wake up它。该方法避免了忙等待问题。</span><br><span class="line"></span><br><span class="line">#### 互斥导致的忙等待： </span><br><span class="line"></span><br><span class="line">1. Peterson算法 和 TSL方法 会造成忙等待，即执行入口代码的进程会一直处于一个紧循环的状态，消耗CPU周期，一般般测试某些条件是否成立，直到为真</span><br><span class="line">2. 如果使用简单的优先级调度来调度进程，着忙等待会导致优先级反转的问题 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 信号量和PV操作</span><br><span class="line"></span><br><span class="line">信号量的作用：</span><br><span class="line"></span><br><span class="line">1. 互斥访问临界资源</span><br><span class="line">2. 处理同步问题</span><br><span class="line"></span><br><span class="line">信号量的值包括：</span><br><span class="line"></span><br><span class="line">- 0 表示没有保存唤醒</span><br><span class="line">- 正值:一个或多个唤醒正在等待中</span><br><span class="line"></span><br><span class="line">信号量是一个结构体变量，变量属性包括：</span><br><span class="line"></span><br><span class="line">- COUNT：整型变量</span><br><span class="line">  - 初始值表示资源的数量</span><br><span class="line">  - 当S.count&lt;0后，count的绝对值等于等待资源的进程数；</span><br><span class="line">  - 计数信号量：0...N（初始化为N）</span><br><span class="line">  - 二元信号量：0,1（初始化为1）</span><br><span class="line">- Q：存放被阻塞进程PID的queue</span><br><span class="line"></span><br><span class="line">对于信号量的两种操作 P 和 V</span><br><span class="line"></span><br><span class="line">信号量的操作具有原子性</span><br><span class="line"></span><br><span class="line">- P /wait /down ：用来获取资源且count自减</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    P(S):</span><br><span class="line">    	S.count--;</span><br><span class="line">    	if(S.count&lt;0)&#123;</span><br><span class="line">    		block(P);</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>V &#x2F;signal &#x2F;up ：用来释放资源且count自增</p>
<ul>
<li><pre><code>v(s):
    S.count++
    if(S.count&lt;=0)&#123;
        wakeup(P) for some process P in S.Q;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 等于0的目的是，在count==-1时，我们是先自增，在进行释放，所以需要让count等于0时仍释放资源；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二元信号量</span><br><span class="line"></span><br><span class="line">一种最简单的信号量</span><br><span class="line"></span><br><span class="line">Mutex被用于互斥，一个变量具有两种状态：Lock 和Unlock</span><br><span class="line"></span><br><span class="line">- 二元信号量初始值为1</span><br><span class="line">- 在访问临界区之前进行 P 操作</span><br><span class="line">- 在访问临界区之后进行 V 操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于N个并行进程来说：互斥信号量的取值范围是：1 ~ 1-N</span><br><span class="line"></span><br><span class="line">### 生产者消费者问题</span><br><span class="line"></span><br><span class="line">![image-20240611105623704](E:\DeskTable\博客学习截图传输\image-20240611105623704.png) </span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;E:\DeskTable\博客学习截图传输\image-20240611105632543.png&quot; alt=&quot;image-20240611105632543&quot; style=&quot;zoom: 80%;&quot; /&gt;  </span><br><span class="line"></span><br><span class="line">当缓冲区大小大于1时，必须专门设置一个互斥信号量来保证互斥访问缓冲区</span><br><span class="line"></span><br><span class="line">当缓冲区大小为1时，有可能不需要设置互斥信号量就可以互斥访问缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;E:\DeskTable\博客学习截图传输\image-20240611105032126.png&quot; alt=&quot;image-20240611105032126&quot; style=&quot;zoom: 50%;&quot; /&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>设置汽车启动与否信号量 start&#x3D;0</p>
<p>设置售票员开关门信号量 open&#x3D;0</p>
<p>P(start)<br> 启动车辆<br> 正常行驶<br> 到站停车<br>V(open)</p>
<p>关门<br>V(start)<br>售票<br>P(open)<br>开门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 哲学家问题</span><br><span class="line"></span><br><span class="line">![image-20240611105756523](E:\DeskTable\博客学习截图传输\image-20240611105756523.png) </span><br><span class="line"></span><br><span class="line">![image-20240611105809072](E:\DeskTable\博客学习截图传输\image-20240611105809072.png) </span><br><span class="line"></span><br><span class="line">![image-20240619224401269](E:\DeskTable\博客学习截图传输\image-20240619224401269.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240619224341265](E:\DeskTable\博客学习截图传输\image-20240619224341265.png) </span><br><span class="line"></span><br><span class="line">## Reader and Writers Problem</span><br><span class="line"></span><br><span class="line">![image-20240611141105820](E:\DeskTable\博客学习截图传输\image-20240611141105820.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore db = 1;</span><br><span class="line">int rs = 0;</span><br><span class="line"></span><br><span class="line">void reader()&#123;</span><br><span class="line"></span><br><span class="line">	while(true)&#123;</span><br><span class="line">		down(&amp;mutex);</span><br><span class="line">		rs++;</span><br><span class="line">		if(rs == 1) down(&amp;db);</span><br><span class="line">		up(&amp;mutex);</span><br><span class="line">	</span><br><span class="line">		reading();</span><br><span class="line">	</span><br><span class="line">		down(&amp;mutex);</span><br><span class="line">		rs--;</span><br><span class="line">		if(rs == 0) up(&amp;db);</span><br><span class="line">		up(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer()&#123;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">        down(&amp;db);</span><br><span class="line">        wirting();</span><br><span class="line">        up(&amp;db);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程调度算法-Process-Scheduling-Algorithm"><a href="#进程调度算法-Process-Scheduling-Algorithm" class="headerlink" title="进程调度算法 Process Scheduling Algorithm"></a>进程调度算法 Process Scheduling Algorithm</h2><h3 id="批处理系统（Batch-Systems）"><a href="#批处理系统（Batch-Systems）" class="headerlink" title="批处理系统（Batch Systems）"></a>批处理系统（Batch Systems）</h3><h4 id="先来先服务（First-Come-First-Served-FCFS）FIFO："><a href="#先来先服务（First-Come-First-Served-FCFS）FIFO：" class="headerlink" title="先来先服务（First Come First Served, FCFS）FIFO："></a>先来先服务（First Come First Served, FCFS）FIFO：</h4><ul>
<li><strong>特点</strong>：按到达顺序调度进程，第一个到达的进程先执行，直到完成。</li>
<li><strong>优点</strong>：简单易实现，调度公平。</li>
<li><strong>缺点</strong>：可能导致长时间等待，容易产生“<strong>Convoy Effect</strong>”护航效应：处理时间短的进程在长的进程后面（一组短进程被一个长进程阻塞）。</li>
<li>平均等待时间：所有进程的等待时间相加再除以进程数量</li>
</ul>
<h4 id="最短作业优先（Shortest-Job-First-SJF）："><a href="#最短作业优先（Shortest-Job-First-SJF）：" class="headerlink" title="最短作业优先（Shortest Job First, SJF）："></a>最短作业优先（Shortest Job First, SJF）：</h4><ul>
<li>需要提前知道运行时间</li>
<li>No-Preemptive非抢占式：如果所有进程同时到达，则为最优；但是当所有进程并非同时到达时，则不一定是最优的</li>
<li>Preemptive抢占式：则可以更优，因为不会有CPU的浪费。</li>
<li><strong>特点</strong>：优先调度预计运行时间最短的进程，非抢占式。</li>
<li><strong>优点</strong>：平均等待时间最短，有效提高系统吞吐量。</li>
<li><strong>缺点</strong>：需要准确预测作业时间，可能导致“<strong>饥饿</strong>”问题（长作业得不到调度）。</li>
</ul>
<h3 id="交互式系统（Interactive-Systems）"><a href="#交互式系统（Interactive-Systems）" class="headerlink" title="交互式系统（Interactive Systems）"></a>交互式系统（Interactive Systems）</h3><h4 id="轮转调度（Round-Robin-RR）："><a href="#轮转调度（Round-Robin-RR）：" class="headerlink" title="轮转调度（Round Robin, RR）："></a>轮转调度（Round Robin, RR）：</h4><ul>
<li><strong>特点</strong>：所有进程按时间片轮流执行，每个进程在每轮中最多执行一个时间片。</li>
<li><strong>优点</strong>：简单，公平，适合时间片较短的交互式系统，响应时间较好。</li>
<li><strong>缺点</strong>：时间片选择不当会影响性能，过短增加上下文切换开销，过长则响应变慢。</li>
</ul>
<h4 id="优先级调度（Priority-Scheduling）："><a href="#优先级调度（Priority-Scheduling）：" class="headerlink" title="优先级调度（Priority Scheduling）："></a>优先级调度（Priority Scheduling）：</h4><ul>
<li><strong>特点</strong>：根据进程的优先级调度，优先级高的进程先执行，可以是抢占式或非抢占式。</li>
<li><strong>优点</strong>：能保证高优先级的关键任务及时处理。</li>
<li><strong>缺点</strong>：可能导致低优先级进程“<strong>饥饿</strong>”，需要引入老化机制防止饥饿。</li>
<li><strong>优先级设置依据</strong>:<ul>
<li>进程的开销 Cost to user</li>
<li>进程的重要性 Importance of user</li>
<li>进程的类型 Process type</li>
<li>对资源的要求 Requirement to resource</li>
<li>Aging</li>
<li>最近的CPU使用时间比例 Percentage of CPU time used in last X hours.</li>
</ul>
</li>
</ul>
<h4 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h4><p>通过设置优先级和时间片不同的队列，并事先将进程进行优先级分类，进程进入相应的优先级队列中进行调度。</p>
<h4 id="多级反馈队列调度（Multi-Queue-Multi-level-Feedback-Queue）："><a href="#多级反馈队列调度（Multi-Queue-Multi-level-Feedback-Queue）：" class="headerlink" title="多级反馈队列调度（Multi Queue &amp; Multi-level Feedback Queue）："></a>多级反馈队列调度（Multi Queue &amp; Multi-level Feedback Queue）：</h4><ul>
<li>优先级和轮循的混合</li>
<li><strong>特点</strong>：将进程按优先级或特性分配到不同队列，每个队列使用不同的调度策略。多级反馈队列允许进程在不同队列间移动，以动态调整优先级。</li>
<li>优先级从高到低为：第一级、第二级、第三级、…</li>
<li><img src="E:\DeskTable\博客学习截图传输\image-20240611160619733.png" alt="image-20240611160619733" style="zoom:80%;" /> </li>
<li>当低级的队列正在执行时，如果此时高级的队列来了进程，高级队列内的进程进行抢占，先执行完高优先级队列中的进程再重新执行低优先级的队列中的进程，同时被抢占的处于低优先级的队列的进程重新放回队列的队首。在最低级队列仍然没有消耗完所需运行时间，则重新回到最低级的队列重新再分配时间片</li>
<li>第一级队列：FIFO原则<ul>
<li>分配第一级队列的时间片，用完后</li>
<li>如果完成着完成</li>
<li>如果没有完成着进入下一级队列的队尾</li>
</ul>
</li>
<li>第二级队列：<ul>
<li>执行队列内的进程</li>
</ul>
</li>
<li>第三级队列：</li>
<li><strong>优点</strong>：灵活，适应性强，能平衡短进程响应和长进程的公平性。</li>
<li><strong>缺点</strong>：复杂度高，实现困难，需要精心调整参数。</li>
</ul>
<h4 id="保证调度（Guaranteed-Scheduling）："><a href="#保证调度（Guaranteed-Scheduling）：" class="headerlink" title="保证调度（Guaranteed Scheduling）："></a>保证调度（Guaranteed Scheduling）：</h4><ul>
<li><strong>特点</strong>：确保所有进程在一段时间内得到一定比例的CPU时间，通常使用比例分配算法。</li>
<li><strong>优点</strong>：公平，避免饥饿现象。</li>
<li><strong>缺点</strong>：实现复杂，需精确控制资源分配。</li>
</ul>
<h4 id="彩票调度（Lottery-Scheduling）："><a href="#彩票调度（Lottery-Scheduling）：" class="headerlink" title="彩票调度（Lottery Scheduling）："></a>彩票调度（Lottery Scheduling）：</h4><ul>
<li><strong>特点</strong>：给每个进程分配一定数量的“彩票”，调度时随机抽取一张彩票，拥有该彩票的进程获得CPU时间。</li>
<li><strong>优点</strong>：灵活性高，容易实现公平性和资源分配的动态调整。</li>
<li><strong>缺点</strong>：不确定性，可能导致短期内调度不均衡。</li>
</ul>
<h4 id="公平共享调度（Fair-Sharing-Scheduling）："><a href="#公平共享调度（Fair-Sharing-Scheduling）：" class="headerlink" title="公平共享调度（Fair Sharing Scheduling）："></a>公平共享调度（Fair Sharing Scheduling）：</h4><ul>
<li><strong>特点</strong>：将CPU时间按用户或用户组公平分配，确保每个用户获得相同的资源份额。</li>
<li><strong>优点</strong>：适合多用户系统，确保每个用户公平使用资源。</li>
<li><strong>缺点</strong>：可能导致进程级别的调度不公平，复杂度较高。</li>
</ul>
<p>每种调度算法都有其适用的场景和局限性。选择合适的调度算法可以有效提高系统的性能和用户体验。批处理系统主要关注作业吞吐量和等待时间，而交互式系统更注重响应时间和用户体验。</p>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="存储管理："><a href="#存储管理：" class="headerlink" title="存储管理："></a>存储管理：</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>The smaller the allocation unit, the larger the bitmap.</p>
<p>使用0标识空闲的内存块，每当有新进程到达，寻找符合进程需求大小的连续0空间</p>
<p>位图是一种简单的数组，每个元素对应内存中的一个固定大小的块（称为一个单位或块）。数组中的每个元素是一个位（bit），表示对应的内存块是否已分配。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表中的每个节点表示一个hole(free segment)或者process(allocated segment)，包含该块的起始地址、大小以及指向下一个节点的指针。</p>
<h2 id="存储放置策略"><a href="#存储放置策略" class="headerlink" title="存储放置策略"></a>存储放置策略</h2><h3 id="First-Fit"><a href="#First-Fit" class="headerlink" title="First Fit"></a>First Fit</h3><p>原理：找到的第一个满足请求要求的空闲块就进行分配</p>
<p>问题：留下许多小的空闲块，导致碎片化问题</p>
<h3 id="Next-Fit"><a href="#Next-Fit" class="headerlink" title="Next Fit"></a>Next Fit</h3><p>原理：每次从上一次分配结束的位置继续搜索空闲块，找到的第一个满足的即分配，而不是从头开始。</p>
<p>问题：整体性能比First Fit略差，可能造成中间部分碎片化问题</p>
<h3 id="Best-Fit"><a href="#Best-Fit" class="headerlink" title="Best Fit"></a>Best Fit</h3><p>**原理：**遍历所有空闲块，找到满足要求大小的最小的空闲块进行分配</p>
<p>**缺点：**遍历空闲块耗费时间太多，开销太大；还是会可能出现碎片化问题，且可能产生许多小的不可用的碎片。</p>
<h3 id="Worst-Fit"><a href="#Worst-Fit" class="headerlink" title="Worst Fit"></a>Worst Fit</h3><p>**原理：**遍历所有空闲块，找到最大的空闲块进行分配</p>
<p>**缺点：**可能浪费了大的空闲块，降低了利用率</p>
<h3 id="Quick-Fit"><a href="#Quick-Fit" class="headerlink" title="Quick Fit"></a>Quick Fit</h3><p><strong>原理</strong>：维护一些常见大小请求的单独空闲块列表，当有内存请求时，直接从相应的列表中分配内存块。</p>
<p><strong>优点</strong>：分配速度非常快，因为直接从列表中获取空闲块。</p>
<p><strong>缺点</strong>：当需要合并空闲块时，操作可能会比较复杂和耗时。</p>
<h2 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h2><p>MMU负责将虚拟地址转化为物理地址</p>
<h3 id="页式"><a href="#页式" class="headerlink" title="页式"></a>页式</h3><p>查页表将虚拟地址转换成物理地址</p>
<p>最常见</p>
<p>**MMU memory management unit:**将虚拟地址转换成物理地址</p>
<p>操作系统维护一张由虚拟地址映射到物理地址的map表</p>
<p>引用未映射的页面会导致CPU向操作系统发送trap——page fault</p>
<p>页表 page table：虚拟地址和物理地址间的映射关系表</p>
<p>virtual address分成：page number 和 page offset</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240612102741723.png" alt="image-20240612102741723"> </p>
<p>page offset就是页内偏移量，即页的大小</p>
<h4 id="页表一个项的组成"><a href="#页表一个项的组成" class="headerlink" title="页表一个项的组成"></a>页表一个项的组成</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20240612103022865.png" alt="image-20240612103022865"> </p>
<h4 id="TLB-Translation-Look-aside-Buffers"><a href="#TLB-Translation-Look-aside-Buffers" class="headerlink" title="TLB Translation Look-aside Buffers"></a>TLB Translation Look-aside Buffers</h4><p>存储在cache中的虚存表，用来查找</p>
<p>TLB表结构</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240612115006473.png" alt="image-20240612115006473"> </p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>稀疏的地址空间和更容易分页</p>
<p>将一个32位逻辑地址分为：20bits的页号和12bits的页内offset</p>
<p>其中再把20bits的页号进一步分为10bits的页号和10bits的页偏移量</p>
<p>由于每个级别都存储在内存中的单独表中，因此在四级分页中将逻辑地址转换为物理地址可能需要进行五次内存访问。</p>
<p>优点：</p>
<ul>
<li>缩减页表大小</li>
<li>可以不把不需要的页表放在内存中</li>
</ul>
<h4 id="倒页表-Inverted-Page-Tables"><a href="#倒页表-Inverted-Page-Tables" class="headerlink" title="倒页表 Inverted Page Tables"></a>倒页表 Inverted Page Tables</h4><p><strong>原理：</strong> </p>
<ul>
<li><p>一个PTE对应一个物理页；</p>
</li>
<li><p>物理页码用作表的索引；</p>
</li>
<li><p>哈希(Vpage, pid)到page#</p>
</li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li>小页表的大地址空间</li>
</ul>
<p><strong>缺点:</strong> </p>
<ul>
<li><p>查找很困难</p>
</li>
<li><p>管理哈希链的开销等</p>
</li>
</ul>
<h3 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h3><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><h3 id="获取策略"><a href="#获取策略" class="headerlink" title="获取策略"></a>获取策略</h3><h2 id="页表存在的问题"><a href="#页表存在的问题" class="headerlink" title="页表存在的问题"></a>页表存在的问题</h2><h3 id="使用单个页表使用一组寄存器来组成："><a href="#使用单个页表使用一组寄存器来组成：" class="headerlink" title="使用单个页表使用一组寄存器来组成："></a>使用单个页表使用一组寄存器来组成：</h3><ol>
<li>优点：简单易实现</li>
<li>缺点：<ol>
<li>如果页表很大，则十分昂贵</li>
<li>并且要每次切换页表都需要载入整个页表，性能差</li>
</ol>
</li>
</ol>
<h3 id="将页表放在内存——只用一个寄存器指针指向这个页表"><a href="#将页表放在内存——只用一个寄存器指针指向这个页表" class="headerlink" title="将页表放在内存——只用一个寄存器指针指向这个页表"></a>将页表放在内存——只用一个寄存器指针指向这个页表</h3><ol>
<li>优点：易于切换，开销小</li>
<li>读取表项时会有一个或多个内存引用</li>
</ol>
<h2 id="TLB-Translation-Look-aside-Buffers-Associative-Memory"><a href="#TLB-Translation-Look-aside-Buffers-Associative-Memory" class="headerlink" title="TLB Translation Look-aside Buffers&#x2F;Associative Memory"></a>TLB Translation Look-aside Buffers&#x2F;Associative Memory</h2><p><img src="E:\DeskTable\博客学习截图传输\image-20240619233109821.png" alt="image-20240619233109821"> </p>
<p>有效位，虚拟页号，修改位（脏位），保护位，物理页框</p>
<p>TLB中每一个项是PTE page table entry</p>
<p>TLB失效：在TLB中找不到需要的PTE或有效位为0</p>
<p>则：载入页项进入TLB，软件执行页错误处理方法，重启CPU等待重新取页</p>
<h2 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h2><p>好处：</p>
<ol>
<li>减小表的大小。</li>
<li>不在内存中保留不需要的页表</li>
</ol>
<h2 id="页置换算法"><a href="#页置换算法" class="headerlink" title="页置换算法"></a>页置换算法</h2><p>目标：降低页错误率；减少页错误的延迟</p>
<p>流程：</p>
<ol>
<li><p>Find location of page on disk<br>查找页在磁盘上的位置</p>
</li>
<li><p>Find a free page frame<br>在内存寻找一个空闲页</p>
<ol>
<li>If there is a free page frame then use it<br>如果找到了直接将新的页加载进去即可</li>
<li>Otherwise, select a victim frame using the page replacement algorithm<br>如果没有，使用页置换算法去选择一个页框进行替换</li>
</ol>
</li>
<li><p>Write the selected page to the disk if necessary and update any necessary tables<br>如果有需要，还要将被替换的页写入disk，更新一些必要的表项</p>
</li>
<li><p>Read the requested page from the disk.<br>从disk读取请求的页</p>
</li>
<li><p>Restart the user process.</p>
<p>重新启动用户进程。</p>
</li>
</ol>
<h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><h4 id="最优算法-不可能实现-The-Optimal-Algorithm-OPT-or-MIN"><a href="#最优算法-不可能实现-The-Optimal-Algorithm-OPT-or-MIN" class="headerlink" title="最优算法-不可能实现 The Optimal Algorithm (OPT or MIN)"></a>最优算法-不可能实现 The Optimal Algorithm (OPT or MIN)</h4><p>Replace the page that will not be used again the farthest time in the future.<br>替换将来最远时间内不会再次使用的页面。</p>
<p>该算法不可能实现，因为无法知道未来的页的引用情况；</p>
<h4 id="FIFO-First-in-First-Out-Algorithm"><a href="#FIFO-First-in-First-Out-Algorithm" class="headerlink" title="FIFO (First-in First-Out) Algorithm"></a>FIFO (First-in First-Out) Algorithm</h4><p>Replace the page that has been in primary memory the longest<br>替换在主内存中存在时间最长的页</p>
<p>被引用的页进入一个队列当中，当队列满了以后，每当来一个新的页，则队头出列，新的页进入队尾</p>
<p><strong>优点</strong>：易于实现</p>
<p><strong>缺点</strong>：在内存中存在时间最长（但是可能最常被使用）的页可能被替换</p>
<p><strong>Belady现象</strong> ：只出现在 FIFO 当中</p>
<p>随着页框的增多，page fault 反而会增加，算法的性能会下降</p>
<h4 id="Second-Chance-Algorithm：对FIFO进行修正"><a href="#Second-Chance-Algorithm：对FIFO进行修正" class="headerlink" title="Second Chance Algorithm：对FIFO进行修正"></a>Second Chance Algorithm：对FIFO进行修正</h4><p>Variant of FIFO<br>FIFO的变体</p>
<p><strong>引入 R bit</strong>：如果 R &#x3D; 0，将页置换；如果 R &#x3D; 1，将 R 置零，而后将页放在队尾，相当于这个页是重新被载入到页queue当中</p>
<p><strong>优点</strong>：改善了FIFO的性能，减少了不必要的页面替换。</p>
<p><strong>缺点</strong>：实现较复杂，需要额外的硬件支持。</p>
<h4 id="Clock-Algorithm"><a href="#Clock-Algorithm" class="headerlink" title="Clock Algorithm"></a>Clock Algorithm</h4><p>Better implementation of second chance<br>更好地实施 第二次机会算法</p>
<p><strong>原理</strong>：</p>
<p>时钟算法的核心思想是通过一个循环队列和指针来模拟时钟指针的移动，从而管理页面的替换。每个页面都有一个使用位（Use Bit）：</p>
<ol>
<li><strong>使用位为1</strong>：表示该页面最近被访问过，给予它第二次机会。</li>
<li><strong>使用位为0</strong>：表示该页面没有被访问过，优先考虑替换该页面。</li>
</ol>
<p><strong>操作步骤</strong>：</p>
<ol>
<li>页面被访问时，其使用位置1。</li>
<li>当需要替换页面时，操作系统检查指针所指向的页面：<ul>
<li>如果使用位为0，替换该页面。</li>
<li>如果使用位为1，清零使用位并将指针移动到下一个页面，然后继续检查。</li>
</ul>
</li>
<li>重复上述过程，直到找到一个使用位为0的页面并进行替换。</li>
</ol>
<h4 id="NRU-Not-Recently-Used-Algorithm"><a href="#NRU-Not-Recently-Used-Algorithm" class="headerlink" title="NRU (Not Recently Used) Algorithm"></a>NRU (Not Recently Used) Algorithm</h4><p>Enhanced second chance<br>增加第二次机会</p>
<p>周期性地(在每个时钟间隔(20msec))清除R位。(即R &#x3D; 0)。</p>
<ol>
<li><strong>Class 0</strong>：使用位为0，修改位为0。</li>
<li><strong>Class 1</strong>：使用位为0，修改位为1。</li>
<li><strong>Class 2</strong>：使用位为1，修改位为0。</li>
<li><strong>Class 3</strong>：使用位为1，修改位为1。</li>
</ol>
<p>在进行页面替换时，NRU算法优先淘汰属于 Class 0的页面，然后是 Class 1、Class 2和最后是 Class 3。目的是尽量保留长时间没有被使用且没有被修改过的页面，减少对经常使用或被修改的页面的替换频率。</p>
<p><strong>操作步骤</strong>：</p>
<ol>
<li><p><strong>初始化</strong>：将所有页面的使用位和修改位清零。</p>
</li>
<li><p><strong>页面访问</strong>：当页面被访问时，设置其使用位为1。</p>
</li>
<li><p><strong>页面修改</strong>：当页面被修改时，设置其修改位为1。</p>
</li>
<li><p><strong>页面替换</strong>：当需要替换页面时，按照Class的优先级进行替换：</p>
<ul>
<li>首先替换Class 0中的页面。</li>
<li>如果Class 0没有页面，则替换Class 1中的页面。</li>
<li>如果Class 1没有页面，则替换Class 2中的页面。</li>
<li>如果Class 2没有页面，则替换Class 3中的页面。</li>
</ul>
</li>
</ol>
<h4 id="LRU-Least-Recently-Used-Algorithm"><a href="#LRU-Least-Recently-Used-Algorithm" class="headerlink" title="LRU (Least Recently Used) Algorithm"></a>LRU (Least Recently Used) Algorithm</h4><p>Replace the page that has not been used for the longest time<br>替换最长时间没有被使用的页</p>
<p>优先淘汰最长时间没有被访问过的页面，以此来减少页面错误率。</p>
<p>LRU算法维护一个页面访问顺序的队列，每当页面被访问时，将该页面移动到队列的末尾。当需要替换页面时，选择队列头部的页面进行替换，即替换最久未被访问的页面。</p>
<p><strong>操作步骤</strong>：</p>
<ol>
<li><strong>页面访问</strong>：当页面被访问时，将该页面移动到队列的末尾。</li>
<li><strong>页面替换</strong>：当需要替换页面时，选择队列头部的页面进行替换，即替换最久未被访问的页面。</li>
</ol>
<p>LRU算法的实现可以通过以下几种方式来完成：</p>
<ul>
<li><strong>使用链表</strong>：维护一个双向链表，链表中的节点表示页框，每当页面被访问，将其移动到链表的末尾。当需要替换页面时，选择链表头部的节点进行替换。</li>
<li><strong>使用散列表和堆</strong>：利用散列表存储页框和其在队列中的位置信息，利用最小堆（Min-Heap）来维护页面的访问顺序。每次页面被访问时，更新其在堆中的位置，需要替换页面时，选择堆顶的页面进行替换。</li>
</ul>
<p>硬件方案二:</p>
<p>对于有 n 个页面帧的机器，保持 n x n 位的矩阵。</p>
<p>当页面帧K被引用时：</p>
<ol>
<li>将第K行设置为全1。</li>
<li>设K列全为0。</li>
<li>二进制值最小的行就是LRU页面。</li>
</ol>
<h4 id="NFU-Not-Frequently-Used-Algorithm"><a href="#NFU-Not-Frequently-Used-Algorithm" class="headerlink" title="NFU (Not Frequently Used) Algorithm"></a>NFU (Not Frequently Used) Algorithm</h4><p>Replace the page that is used least often, simulated LRU<br>替换使用频率最少的页，模拟LRU</p>
<p>在每个时钟中断时，R位被添加到与每个页面相关的计数器中。</p>
<ul>
<li>当发生页错误时，将替换具有最低计数器的页。</li>
<li>问题:NFU永远不会忘记，所以很久以前引用的页面频率可能有最高的计数器。</li>
</ul>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240615110322734.png" alt="image-20240615110322734"> </p>
<h4 id="Aging-Algorithm"><a href="#Aging-Algorithm" class="headerlink" title="Aging Algorithm"></a>Aging Algorithm</h4><p>Modified NFU</p>
<p>老化算法，模拟NFU</p>
<h4 id="Working-Set-Algorithm"><a href="#Working-Set-Algorithm" class="headerlink" title="Working Set Algorithm"></a>Working Set Algorithm</h4><p>Keep in memory those pages that the process is actively using</p>
<p>当出现 page fault 时，查找不在工作集中的页并将其排除。</p>
<p>为每一个页都维护一个上一次调用时间 LTU 和一个 R 位，R位 Reference bit 用来表示页面的访问状态，即页面是否被访问过。</p>
<p><strong>访问页面时</strong>：</p>
<ul>
<li>如果页面被访问，更新页面的 LTU（设置为当前时间）和 R 位（设置为1）。</li>
<li>如果页面没有被访问，只更新 R 位为1。</li>
</ul>
<p><strong>周期性更新</strong>：</p>
<ul>
<li>定期检查所有页面的 R 位。</li>
<li>如果页面的 R 位为1，表示页面在最近的一段时间内被访问过，可以保留在当前工作集中，重置 R 位为0。</li>
<li>如果页面的 R 位为0，表示页面较长时间未被访问，可能不属于当前工作集，可以考虑置换出去。</li>
</ul>
<img src="E:\DeskTable\博客学习截图传输\image-20240615112652039.png" alt="image-20240615112652039" style="zoom:80%;" />  

<p><img src="E:\DeskTable\博客学习截图传输\image-20240615132707682.png" alt="image-20240615132707682"> </p>
<h4 id="WS-Clock-Algorithm"><a href="#WS-Clock-Algorithm" class="headerlink" title="WS Clock Algorithm"></a>WS Clock Algorithm</h4><p>The modified working set algorithm based on clock algorithm</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240615133923108.png" alt="image-20240615133923108"> </p>
<h2 id="页大小"><a href="#页大小" class="headerlink" title="页大小"></a>页大小</h2><h3 id="Small-page-size"><a href="#Small-page-size" class="headerlink" title="Small page size"></a>Small page size</h3><h4 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h4><ul>
<li><p>less internal fragmentation<br>更少的内部碎片</p>
</li>
<li><p>less unused program in memory<br>减少内存中未使用的程序</p>
</li>
</ul>
<h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ul>
<li>programs need many pages, larger page tables<br>一个程序需要很多个页，页表太大</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h3><ul>
<li>从头开始读取</li>
<li>不能跳转，可以倒带或后退</li>
<li>当介质是磁带时很方便</li>
</ul>
<p>顺序访问是一种按照顺序逐个访问文件内容的方式。从文件的开头开始，依次读取或写入数据，直到文件末尾。这种访问方式通常适用于文本文件或者需要按照顺序处理数据的场景。</p>
<h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><ul>
<li>可以从任意位置开始读取</li>
<li>Two methods are used for specifying where to start reading.<ul>
<li>read and then move file marker</li>
<li>move file marker (seek), then read (UNIX, Windows)</li>
</ul>
</li>
</ul>
<p>随机访问允许程序员以任意顺序访问文件中的数据。这意味着可以跳转到文件中的任何位置读取或写入数据，而不必按照顺序逐步读取。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>用于组织和管理文件的一种结构。目录中可以包含文件和其他目录。</p>
<ol>
<li>文件系统有目录或文件夹来跟踪文件。</li>
<li>目录是包含文件名和文件位置之间对应关系的文件</li>
<li>目录项包含有关文件的信息，即它的属性</li>
<li>目录项在创建它们所描述的文件时创建，在删除文件时删除</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>一级目录：root拥有所有的文件</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615141108351.png" alt="image-20240615141108351" style="zoom:50%;" /> 

<p>二级目录：有一个root目录和一个user目录</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615141139500.png" alt="image-20240615141139500" style="zoom:67%;" /> 

<p>多级目录：有一个root目录和任意数量的子目录</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615141333276.png" alt="image-20240615141333276" style="zoom:50%;" /> 

<p>在文件目录树中，叶子节点是文件</p>
<p>文件系统定义块大小</p>
<ol>
<li><p>块大小&#x3D; 2 *扇区大小</p>
</li>
<li><p>连续的扇区被分配到一个块中</p>
</li>
</ol>
<p>文件系统将磁盘视为一个块阵列</p>
<ol>
<li><p>必须为文件分配块吗</p>
</li>
<li><p>必须管理磁盘上的可用空间</p>
</li>
</ol>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>将每个文件存储为连续的数据块</p>
<p>目录中记录的是 文件的 start 和 length</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>易于实现</li>
<li>读能力的表现很好</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>外部碎片问题：</li>
</ul>
<h4 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h4><p>是指内存或存储设备上零散的、不可利用的空闲空间。</p>
<h4 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h4><p>已分配的内存或存储空间内部未被使用的空间。</p>
<h3 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h3><p>将文件存储为磁盘块的链表，块可能分散在磁盘上的任何地方。</p>
<p>每个块的第一个字被用作指向下一个的指针。</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615154514388.png" alt="image-20240615154514388" style="zoom: 80%;" /> 

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>没有外部碎片</li>
<li>目录项简单（仅需要开始地址）</li>
<li>文件可以增加，只要有足够的空闲的块</li>
<li>有利于顺序访问</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>随机访问速度慢</li>
<li>块中的数据量不是2的幂</li>
</ul>
<h4 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h4><p>从每个块中取出表指针word，并将它们放入索引表FAT(文件分配表)中。</p>
<p>尽量将FAT表存放在内存中以缩短查询硬盘</p>
<p>FAT表内存储的是下一个block的start地址：如文件某一项的start为217，则FAT表中217中存放的是下一个block的start地址：618，以此类推</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615163530220.png" alt="image-20240615163530220" style="zoom:67%;" /> 

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对于数据来说整个快都是可利用的</li>
<li>支持随机访问</li>
<li>目录项仅需要一个数组</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>整个FAR必须同时在内存中</p>
<h3 id="Indexed-Allocation-I-Node"><a href="#Indexed-Allocation-I-Node" class="headerlink" title="Indexed Allocation I-Node"></a>Indexed Allocation I-Node</h3><p>将一个文件的所有块的指针集中到一个索引块当中，这个索引块相当于一个目录，存放文件的每一个块的首地址。</p>
<p>目录像普通文件一样存储</p>
<ul>
<li><p>目录项包含在数据块中</p>
</li>
<li><p>目录文件是目录条目的列表</p>
</li>
</ul>
<p>当文件被打开时，文件系统使用路径名来定位目录条目。</p>
<p>目录项提供查找磁盘块所需的信息。</p>
<ul>
<li><p>连续分配：整个文件的磁盘地址(连续块)</p>
</li>
<li><p>链表分配：第一个区块的编号(链表)</p>
</li>
<li><p>i节点分配：i-node数量(i-node)</p>
</li>
</ul>
<h2 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h2><p>在MS-DOS&#x2F;Windows中，使用连续分配的方式</p>
<p>在Unix中，使用 i-node 的方式</p>
<h3 id="长文件名的处理方式"><a href="#长文件名的处理方式" class="headerlink" title="长文件名的处理方式"></a>长文件名的处理方式</h3><ol>
<li><p>固定长度</p>
<ol>
<li>通常为255chars</li>
<li>简单</li>
<li>浪费空间</li>
</ol>
</li>
<li><p>目录项包括固定和可变部分</p>
<ul>
<li>固定部分以项长度 entry len 开始，然后是属性 attribute</li>
<li>变量部分有文件名</li>
<li>优缺：<ul>
<li>节省空间</li>
<li>当一个文件被删除时，一个可变大小的间隙被引入，下一个新进来的目录项可能没办法放入这个间隙里</li>
<li>单个目录项可能跨越多个页面，因此在读取文件名时可能发生页面错误</li>
</ul>
</li>
</ul>
</li>
<li><p>目录项长度固定，有一个指针指向堆中的文件名，维护一个文件名堆</p>
</li>
</ol>
<h3 id="How-to-search-files-in-each-directory"><a href="#How-to-search-files-in-each-directory" class="headerlink" title="How to search files in each directory?"></a>How to search files in each directory?</h3><ol>
<li><p>Linearly：遍历目录项，直到找到目标文件或扫描完所有目录项后未找到</p>
</li>
<li><p>Hash table：</p>
<ol>
<li>使用哈希函数将文件名映射到目录中的位置</li>
</ol>
</li>
<li><p>Cache the results of searches：用cache存储最近的搜索结果</p>
</li>
</ol>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>共享文件技术可以允许文件出现在多个目录中，目录和共享文件之间的连接称为链接</p>
<p>这种文件系统是一个有向无环图</p>
<h3 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h3><ol>
<li>如果目录中包含磁盘地址，则当链接文件时，<strong>必须把 C 目录中的磁盘地址复制到 B 目录中</strong>。</li>
<li>如果 B 或者 C 随后又向文件中添加内容，则<strong>仅在执行追加的用户的目录中显示新写入的数据块</strong>。这种变更将会对其他用户不可见，从而破坏了共享的目的。</li>
</ol>
<h3 id="解决措施："><a href="#解决措施：" class="headerlink" title="解决措施："></a>解决措施：</h3><h4 id="硬链接-hard-link"><a href="#硬链接-hard-link" class="headerlink" title="硬链接 hard link"></a>硬链接 hard link</h4><p>磁盘块地址不列入目录，而是把磁盘块放入一个小型数据结构（即inode）中。目录的目录项指向这个小型的数据结构</p>
<p><strong>指向相同的 inode</strong>：硬链接是指向相同 inode 的多个目录条目。这意味着它们共享同一个文件数据块和属性（如权限、大小、修改时间等）。</p>
<p><strong>文件内容共享</strong>：硬链接共享同一个文件内容。修改其中一个硬链接的内容，其他硬链接的内容也会相应改变。</p>
<p><strong>存储在同一文件系统</strong>：硬链接只能在同一文件系统内创建，不能跨文件系统。</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615202621306.png" alt="image-20240615202621306" style="zoom:67%;" /> 

<h4 id="软链接-soft-symbolic-link"><a href="#软链接-soft-symbolic-link" class="headerlink" title="软链接 soft&#x2F;symbolic link"></a>软链接 soft&#x2F;symbolic link</h4><p>一个目录的目录项指向文件的 i节点，</p>
<p><strong>其他目录指向文件路径</strong>：软链接是一个独立的文件，包含指向另一个文件或目录的路径。它类似于快捷方式。</p>
<p><strong>链接数不变</strong>：创建软链接不会改变源文件的链接计数，因为软链接是一个独立的文件。</p>
<p><strong>可以跨文件系统</strong>：软链接可以跨越不同的文件系统创建。</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240615202608231.png" alt="image-20240615202608231" style="zoom:67%;" /> 



<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>硬链接 (Hard Link)</th>
<th>软链接 (Soft Link)</th>
</tr>
</thead>
<tbody><tr>
<td>指向目标</td>
<td>相同的 inode</td>
<td>目标文件或目录的路径</td>
</tr>
<tr>
<td>可链接对象</td>
<td>文件</td>
<td>文件和目录</td>
</tr>
<tr>
<td>链接计数</td>
<td>创建或删除硬链接会改变链接计数</td>
<td>创建或删除软链接不会改变链接计数</td>
</tr>
<tr>
<td>跨文件系统</td>
<td>否，只能在同一文件系统内</td>
<td>是，可以跨越不同的文件系统</td>
</tr>
<tr>
<td>悬空链接</td>
<td>无，文件内容总是可访问</td>
<td>有，如果目标文件被删除，软链接会变成悬空链接</td>
</tr>
<tr>
<td>文件内容共享</td>
<td>是，所有硬链接共享相同的文件内容</td>
<td>否，软链接只是一个指向目标文件的路径，修改软链接不影响目标文件</td>
</tr>
</tbody></table>
<h2 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h2><h3 id="位图法和链表法"><a href="#位图法和链表法" class="headerlink" title="位图法和链表法"></a>位图法和链表法</h3><ol>
<li>位图需要的空间较少</li>
<li>只有当磁盘接近满时(即，只有很少的空闲块)，链表方案才会比位图方案需要更少的块</li>
</ol>
<p>我们可以保留第一个空闲块的地址和第一个块后面的空闲连续块的数目，而不是保留n个空闲磁盘地址的列表。</p>
<h2 id="文件系统的可靠性"><a href="#文件系统的可靠性" class="headerlink" title="文件系统的可靠性"></a>文件系统的可靠性</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>为了防止误删，需要进行文件的恢复</p>
<p><strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p>
<p>一种<code>增量转储(incremental dumps)</code> </p>
<p>最常见的增量转储：</p>
<ol>
<li><code>周期性</code>的做全面的备份，每天只对增量转储完成后发生变化的文件做单个备份。</li>
<li>只备份最近一次转储以来更改过的文件。极大的缩减了转储时间</li>
</ol>
<h3 id="两种转储方案"><a href="#两种转储方案" class="headerlink" title="两种转储方案"></a>两种转储方案</h3><p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。</p>
<ul>
<li><code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</li>
<li><code>逻辑转储(logical dump)</code>从一个或几个指定的目录开始，递归转储自指定日期开始后更改的文件和目录。因此，在逻辑转储中，转储磁盘上有一系列经过仔细识别的目录和文件，这使得根据请求轻松还原特定文件或目录可以实现。</li>
</ul>
<p>需要维持一个 inode 为索引的<code>位图(bitmap)</code>，每个 inode 包含了几位。随着算法的进行，位图中的这些位会被设置或清除。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p>
<p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。</p>
<h4 id="块的一致性"><a href="#块的一致性" class="headerlink" title="块的一致性"></a>块的一致性</h4><p>为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。</p>
<p>第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240620003755666.png" alt="image-20240620003755666"> </p>
<p>missing block时：在freelist加上1即可</p>
<p>duplicate freelist block 冗余空闲块，在freelist数字为2时，将数字重置为1即可</p>
<p>duplicate data block 冗余的数据块，重新分配一个块，将冗余的块复制进新的块当中，并放进文件当中，将冗余的块释放</p>
<p>既在free list又在 file data 当中：则将freelist设置为0即可。</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240615225950918.png" alt="image-20240615225950918"> </p>
<h4 id="文件的一致性"><a href="#文件的一致性" class="headerlink" title="文件的一致性"></a>文件的一致性</h4><h3 id="Unix中文件系统的介绍"><a href="#Unix中文件系统的介绍" class="headerlink" title="Unix中文件系统的介绍"></a>Unix中文件系统的介绍</h3><p>组织形式为从根开始的树</p>
<p>文件名最多14个字符，可以包含除&#x2F;和NUL以外的任何ASCII字符</p>
<p>每个目录条目有两个字段</p>
<p>文件名，以及该文件的i-node的#(2字节)</p>
<p>文件系统中的文件数量限制为64K</p>
<p>多级inode：</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240620004838451.png" alt="image-20240620004838451"> </p>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="I-O软件的目的"><a href="#I-O软件的目的" class="headerlink" title="I&#x2F;O软件的目的"></a>I&#x2F;O软件的目的</h2><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。无需为每一个特定的设备制定应用程序，而可以实现一套应用程序给每一种接入的I&#x2F;O设备使用</p>
<h3 id="统一命名-uniform-naming"><a href="#统一命名-uniform-naming" class="headerlink" title="统一命名(uniform naming)"></a>统一命名(uniform naming)</h3><p>设备的代号应该是一个整数或者是字符串，它们不应该依赖于具体的设备。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>通常情况下来说，错误应该交给<code>硬件</code>层面去处理。</p>
<h3 id="同步和异步传输"><a href="#同步和异步传输" class="headerlink" title="同步和异步传输"></a>同步和异步传输</h3><p><strong>同步传输</strong>：数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。</p>
<p><strong>异步传输</strong>：数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。</p>
<p>同步和异步特点对比：</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240615233213566.png" alt="image-20240615233213566">  </p>
<h3 id="缓冲-buffering"><a href="#缓冲-buffering" class="headerlink" title="缓冲 buffering"></a>缓冲 buffering</h3><p>从一个设备发出的数据不会直接到达最后的设备。</p>
<h3 id="共享和独占"><a href="#共享和独占" class="headerlink" title="共享和独占"></a>共享和独占</h3><p>有些 I&#x2F;O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p>
<h2 id="三种控制I-O设备的方法"><a href="#三种控制I-O设备的方法" class="headerlink" title="三种控制I&#x2F;O设备的方法"></a>三种控制I&#x2F;O设备的方法</h2><h3 id="程序控制I-O-可编程I-O"><a href="#程序控制I-O-可编程I-O" class="headerlink" title="程序控制I&#x2F;O &amp; 可编程I&#x2F;O"></a>程序控制I&#x2F;O &amp; 可编程I&#x2F;O</h3><p>CPU 在等待时会采用</p>
<ol>
<li><code>轮询(polling)</code>去查看设备的状态寄存器去确定其状态：ready，busy，error；</li>
<li><code>忙等(busy waiting)</code> 的方式去等待 I&#x2F;O ，浪费了CPU资源</li>
</ol>
<p>操作：</p>
<ul>
<li>CPU 请求 I&#x2F;O 操作</li>
<li>I&#x2F;O 模块执行响应</li>
<li>I&#x2F;O 模块设置状态位</li>
<li>CPU 会定期检查状态位</li>
<li>I&#x2F;O 不会直接通知 CPU 操作完成</li>
<li>I&#x2F;O 也不会中断 CPU</li>
<li>CPU 可能会等待或在随后的过程中返回</li>
</ul>
<h3 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I&#x2F;O"></a>中断驱动I&#x2F;O</h3><p>鉴于上面可编程 I&#x2F;O 的缺陷，我们提出一种改良方案，我们想要在 CPU 等待 I&#x2F;O 设备的同时，能够做其他事情，等到 I&#x2F;O 设备完成后，它就会产生一个中断，这个中断会停止当前进程并保存当前的状态。</p>
<p>由CPU主动询问I&#x2F;O设备是否使用改为由I&#x2F;O设备主动通知CPU自己准备就绪</p>
<h3 id="使用-DMA-的-I-O"><a href="#使用-DMA-的-I-O" class="headerlink" title="使用 DMA 的 I&#x2F;O"></a>使用 DMA 的 I&#x2F;O</h3><p>Directed Memory Access</p>
<p>CPU 授予 I&#x2F;O 模块权限在不涉及 CPU 的情况下读取或写入内存。</p>
<p>也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。</p>
<h2 id="I-O的层次结构"><a href="#I-O的层次结构" class="headerlink" title="I&#x2F;O的层次结构"></a>I&#x2F;O的层次结构</h2><ol>
<li>用户级的I&#x2F;O软件 用户空间 做I&#x2F;O调用；匹配I&#x2F;O；假脱机</li>
<li>与设备无关的I&#x2F;O软件 内核空间 命名、保护、阻塞、缓冲、分配</li>
<li>设备驱动 内核空间 设置设备寄存器、检查状态</li>
<li>中断处理程序Interrupt Handlers 内核空间 I&#x2F;O完成时唤醒驱动程序</li>
<li>硬件 执行I&#x2F;O操作</li>
</ol>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240620011403292.png" alt="image-20240620011403292"> </p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>当中断发生时，CPU保存少量状态并跳转到内存中固定地址的中断处理程序例程。</p>
<p>中断完成后，必须在软件中执行步骤</p>
<ol>
<li>保存未被中断硬件保存的regs</li>
<li>为中断服务过程设置上下文:TLB、MMU和页表等。</li>
<li>为中断服务程序建立堆栈</li>
<li>Ack中断控制器，重新启用中断</li>
<li>从保存到进程表的地方复制寄存器</li>
<li><strong>运行服务流程</strong></li>
<li>选择接下来要运行的进程。</li>
<li>为接下来要运行的进程设置MMU上下文</li>
<li>加载新的进程寄存器</li>
<li>开始运行新进程</li>
</ol>
<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><ol>
<li>接受来自OS其他部分（与设备无关的部分）的抽象读写请求<ol>
<li>把抽象的术语转换成具体的术语</li>
</ol>
</li>
<li>根据需要初始化设备</li>
<li>检查设备当前是否正用于其他请求<ol>
<li>如果是，将请求加入队列中,等待后续的处理。</li>
<li>如果此时设备是空闲的，驱动程序会检查硬件以了解请求是否能够被处理</li>
</ol>
</li>
<li>发出命令序列去控制设备</li>
<li>检查错误</li>
</ol>
<p>操作系统通常会将驱动程序归为 <code>字符设备 character device</code> 和 <code>块设备 block device</code></p>
<h3 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h3><p>设备驱动程序和与设备无关的软件之间的界限因系统和设备而异</p>
<h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h4><ol>
<li><p>设备驱动程序的统一接口</p>
<ol>
<li>好处：<ol>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>缓冲</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240616002652933.png" alt="image-20240616002652933" style="zoom: 67%;" /> 

<ol>
<li>未缓冲的输入</li>
<li>用户空间缓冲</li>
<li>在内核中进行缓冲，然后复制到用户空间</li>
<li>内核中的双缓冲</li>
</ol>
</li>
<li><p>错误报告</p>
</li>
<li><p>分配和释放专用设备</p>
</li>
<li><p>提供与设备无关的块大小<br>不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。<br>该层可以隐藏不同磁盘的物理扇区大小，并可以为更高层(如文件系统)提供固定和统一的磁盘块大小</p>
</li>
</ol>
<h2 id="磁光盘"><a href="#磁光盘" class="headerlink" title="磁光盘"></a>磁光盘</h2><p>磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p>
<p>在磁盘中，数据是<strong>随机访问</strong>的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，</p>
<p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p>
<img src="E:\DeskTable\博客学习截图传输\image-20240616003252754.png" alt="image-20240616003252754" style="zoom: 67%;" />

<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，</p>
<p>一个扇区的格式： <img src="E:\DeskTable\博客学习截图传输\image-20240616003606843.png" alt="image-20240616003606843"> </p>
<p>前导码相当于是标示扇区的开始位置，还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。</p>
<p>数据区</p>
<p>ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，可以被用于恢复读错误</p>
<h3 id="柱面斜进-cylinder-skew："><a href="#柱面斜进-cylinder-skew：" class="headerlink" title="柱面斜进 cylinder skew："></a>柱面斜进 cylinder skew：</h3><p>低级格式化后的每个 0 扇区的位置都和前一个磁道存在<code>偏移</code>：</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240616003753435.png" alt="image-20240616003753435"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240616003939044.png" alt="image-20240616003939044"></p>
<p>如果不采用这种方式，可能刚好磁头寻址到外侧，0 号扇区已经转过了磁头，所以需要旋转一圈才能等到它继续读取，通过柱面斜进的方式可以消除这一问题。</p>
<p>磁头也会存在<code>斜进(head skew)</code>，但是磁头斜进比较小。</p>
<p>计算柱面斜进：</p>
<img src="E:\DeskTable\博客学习截图传输\image-20240616004859656.png" alt="image-20240616004859656" style="zoom:67%;" /> 

<p>硬盘每分钟7200转，则有一转需要的时间为：60*1000&#x2F;7200 &#x3D; 100&#x2F;12 ms&#x2F;转</p>
<p>每一转会扫过200片扇区，1&#x2F;200 转&#x2F;片 则每一片扇区所用时间为：100&#x2F;12 * 1&#x2F;200 &#x3D; 1&#x2F;24 ms&#x2F;片</p>
<p>则说明每毫秒转过片数：24片&#x2F;ms</p>
<h3 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h3><ol>
<li>No interleaving</li>
<li>Single interleaving</li>
<li>Double interleaving</li>
</ol>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240620011716979.png" alt="image-20240620011716979"> </p>
<h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><h4 id="SSF-short-seek-first"><a href="#SSF-short-seek-first" class="headerlink" title="SSF short seek first"></a>SSF short seek first</h4><p>每次找离自己最近的那个节点，一个贪心</p>
<h4 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h4><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p>
<h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p><code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p>
<p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p>
<p>死锁与不可抢占资源有关，虽然抢占式资源也会造成死锁，不过这种情况的解决办法通常是在进程之间重新分配资源来化解。所以，我们的重点自然就会放在了不可抢占资源上。</p>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p>
<h3 id="资源死锁："><a href="#资源死锁：" class="headerlink" title="资源死锁："></a>资源死锁：</h3><p>死锁进程结合中的每个进程都在等待另一个死锁进程已经占有的资源。但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒。</p>
<h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>Mutual Exclusion 互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>Hold and Wait 保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>No Preemption 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>Circular Wait 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>四个条件同时成立，才可以发生死锁，缺一不可</p>
<p>如果一个资源分配图没有环，一定没有死锁</p>
<p>如果有环：</p>
<ol>
<li>如果每种资源仅有一个实例，则死锁</li>
<li>如果每种资源有多个实例，则不一定会死锁</li>
</ol>
<h2 id="四种解决方法"><a href="#四种解决方法" class="headerlink" title="四种解决方法"></a>四种解决方法</h2><h3 id="Ostrich-Algorithm-鸵鸟算法"><a href="#Ostrich-Algorithm-鸵鸟算法" class="headerlink" title="Ostrich Algorithm 鸵鸟算法"></a>Ostrich Algorithm 鸵鸟算法</h3><p>忽视死锁的问题。</p>
<h3 id="死锁检测-Detection-与恢复"><a href="#死锁检测-Detection-与恢复" class="headerlink" title="死锁检测 Detection 与恢复"></a>死锁检测 Detection 与恢复</h3><p>不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。</p>
<p>构造两个数组：</p>
<ol>
<li>C 表示的是<code>当前分配矩阵(current allocation matrix)</code>，<ol>
<li>Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量</li>
</ol>
</li>
<li>R 表示的是 <code>请求矩阵(request matrix)</code><ol>
<li>Rij 表示 Pi 所需要获得的资源 j 的数量</li>
</ol>
</li>
</ol>
<h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>
<h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><ol>
<li>可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。</li>
<li>一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</li>
</ol>
<h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><ol>
<li><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
</li>
<li><p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h4><p>Safe and Unsafe States</p>
<p>关键是使得每次分配完资源后，至少有一个人的need资源数量小于或等于空闲的资源数量</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20240616014126355.png" alt="image-20240616014126355"></p>
<p>如图，（a）是安全状态，因为B的need为4-2&#x3D;2小于3，意味着我可以填满他的Max，并让B顺利结束进程</p>
<p>从而找到一条进程依次结束退出的序列</p>
<p>！！！需要注意，进入不安全状态不意味着就一定会死锁，因为进程不一定会使用到MAX的资源，但是银行家算法按照最坏情况去考虑，确保不出现死锁</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>破坏死锁条件即可</p>
<h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占，则不会发生死锁。</p>
<ol>
<li>某些设备可以假脱机，如打印机<ol>
<li>只有打印机守护进程使用打印机资源</li>
<li>打印机守护进程没有请求其他资源</li>
<li>因此打印机死锁消除</li>
</ol>
</li>
</ol>
<p>但是脱机空间是有限的，所以死锁还是有可能会发生，例如两个进程各自占用了一半的脱机空间</p>
<h4 id="破坏保持和等待的条件"><a href="#破坏保持和等待的条件" class="headerlink" title="破坏保持和等待的条件"></a>破坏保持和等待的条件</h4><p>如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。</p>
<ol>
<li>一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束</li>
<li>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</li>
</ol>
<h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>这一条件可以通过强制抢占来打破</p>
<p>通过虚拟化的方式：还是假脱机，如 将打印机输出假脱机到磁盘</p>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cm7pnj29n003jucv28x1jdm6s" data-title="操作系统期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/计算机专业课/UML" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/UML/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.258Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/UML/">UML期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="UML期末复习"><a href="#UML期末复习" class="headerlink" title="UML期末复习"></a>UML期末复习</h1><h2 id="复习重点："><a href="#复习重点：" class="headerlink" title="复习重点："></a>复习重点：</h2><h3 id="考试题型："><a href="#考试题型：" class="headerlink" title="考试题型："></a>考试题型：</h3><ol>
<li><p>·选择题 十个题目 一个三分 总共三十分</p>
<img src="D:\DeskTable\博客学习截图传输\71848f12752245f42ab5ebce023e42c.jpg" alt="71848f12752245f42ab5ebce023e42c" style="zoom:50%;" />  
</li>
<li><p>名词解释 五题，一题两分，总共十分 建议英文作答</p>
<ul>
<li>OOD</li>
<li>OOP</li>
</ul>
</li>
<li><p>简答题 两题 共十五分</p>
</li>
<li><p>建模题 两个题目 十五分</p>
<ol>
<li><p>定义一些类，画一个类图</p>
</li>
<li><p>定义一个用例，写出用例文本 </p>
<ol>
<li><p>例子 重点了解：</p>
<ol>
<li>ATM机 </li>
<li>银行业务 </li>
<li>火车订票</li>
</ol>
</li>
<li><p>用例图的基本元素有4种：用例、参与者、关系和系统边界。</p>
</li>
<li><p>用例描述：</p>
<p><img src="D:\DeskTable\博客学习截图传输\image-20240606094247177.png" alt="image-20240606094247177"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249257.webp" alt="img"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>综合分析设计题 四个小题目 总共三十分</p>
<ol>
<li><p>例子：</p>
<ol>
<li>智能家居</li>
<li>汽车租赁</li>
<li>dd车</li>
</ol>
</li>
<li><p>第一题：用例模型，用例文本；领域模型（不写方法）</p>
</li>
<li><p>第二题：</p>
</li>
<li><p>第三题：</p>
</li>
<li><p>第四题：采用某一种模式，对状态图或类图做一个设计的修正</p>
</li>
</ol>
</li>
</ol>
<h3 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h3><p>名词解释和简答</p>
<p>设计模式 patern：是一套被已命名的、多数人知晓的、经过验证的经验总结而出的软件开发模式。设计模式提供了一种通用的设计方案，帮助开发者在面对常见的设计问题时，能够快速找到合适的解决办法。视频7.39</p>
<p>什么是uml：UML（Unified Modeling Language，统一建模语言）是一种用于描述、构建、文档化系统制品的可视化语言</p>
<p>UP Unified Process，统一过程：一种构造面向对象系统的迭代软件开发过程。</p>
<p>RUP（Rational Unified Process）是对统一过程的精细化，RUP采用迭代、增量和面向对象的方法，以提高软件开发的效率和质量。</p>
<p>OOA（Object-Oriented Analysis，面向对象分析）此过程把现实需求转换成领域模型问题，强调在问题领域内发现和描述对象或概念</p>
<p>OOD（Object-Oriented Design，面向对象设计）此过程将领域模型转化成逻辑框架，强调定义软件对象以及它们之间的协作方式以实现需求。</p>
<p>OOP（Object-Oriented Programming，面向对象编程）此过程根据OOD的制品进行编码以实现需求。在面向对象编程中，程序被组织为对象的集合，每个对象都包含数据（属性）和行为（方法）。</p>
<ol>
<li><p><strong>里氏替换原则（Liskov Substitution Principle，LSP）</strong>：</p>
<ol>
<li>子类必须能够替换成它们的基类是核心原则。</li>
<li>子类型必须能够替换其基类型的任何地方，并且不会导致意外的行为。换句话说，任何基类的实例都应该可以被其子类的实例替换，而程序的行为不会受到影响。</li>
<li>这确保了基类和子类之间的一致性和互换性。</li>
</ol>
</li>
<li><p><strong>开闭原则（Open&#x2F;Closed Principle，OCP）</strong>：</p>
<ol>
<li>软件实体（类、模块、函数等）应该对扩展是开放的，对修改是封闭的。这意味着应该通过扩展现有代码来添加新功能，而不是修改现有代码。</li>
</ol>
</li>
<li><p>**GRASP（General Responsibility Assignment Software Patterns，通用责任分配软件模式）**是一组设计模式，旨在帮助开发人员在面向对象设计过程中分配责任和定义类的行为。17章  P199 和 25章 P300</p>
<ol>
<li>九大类GRASP设计模型</li>
</ol>
<ul>
<li><strong>创建者（Creator）</strong>：<ul>
<li>创建者模式帮助确定哪个类负责创建某类的新实例。将创建责任委派给称为具体工厂或抽象工厂的辅助类。创建者模式推荐将创建实例的责任委派给具有相关信息的类，以避免耦合度过高。</li>
<li>相关的模式或原则：<ul>
<li>低耦合</li>
<li>具体工厂和抽象工厂</li>
</ul>
</li>
</ul>
</li>
<li><strong>信息专家（Information Expert）&#x2F; 专家（Expert）</strong>：重要<ul>
<li>把责任分配给具有实现该责任所必须的信息的对象</li>
</ul>
</li>
<li><strong>低耦合（Low Coupling）</strong>：重要<ul>
<li>低耦合模式帮助减少类之间的依赖关系。通过将依赖关系限制在少数必要的类之间，可以使系统更易于维护和修改。</li>
</ul>
</li>
<li><strong>高内聚（High Cohesion）</strong>：重要<ul>
<li>高内聚模式帮助确保类的成员之间存在良好的关联，以便于实现类的目标。高内聚的类更易于理解和维护。</li>
</ul>
</li>
<li><strong>控制器（Controller）</strong>：重要<ul>
<li>控制器模式帮助<strong>确定哪个类负责处理用户请求并调用适当的操作</strong>。控制器通常充当系统的中心协调者。</li>
</ul>
</li>
<li><strong>多态（Polymorphism）</strong>：<ul>
<li>多态模式允许对象对同一消息作出不同的响应，提高了代码的灵活性和可扩展性。</li>
</ul>
</li>
<li><strong>纯虚构（Pure Fabrication）</strong>：<ul>
<li>纯虚构模式帮助确定是否需要创建一个新的类来实现特定的功能，即使在现实世界中并不存在该类的概念。</li>
</ul>
</li>
<li><strong>间接性（Indirection</strong>：重要</li>
<li><strong>防止变异（protected variations）</strong>：</li>
<li>参见：开闭原则 </li>
<li>不和陌生人说话</li>
</ul>
</li>
<li><p>GoF设计模式，一组设计模式，由一本书中提出，分为以下三大类</p>
<ul>
<li><p><strong>工厂模式（Factory Pattern）</strong>：抽象工厂模式的简化</p>
</li>
<li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：解决如何创造实现相同接口的一族相关的类 可以定义一个工厂接口 为每一族要创建的事物定义一个具体工厂类</p>
</li>
<li><p><strong>单例模式（Singleton Pattern）</strong>：解决单实例类的对象全局可见性和单点访问 可以对类定义静态方法以返回单实例 类似私有变量通过定义静态方法返回变量值</p>
</li>
<li><p><strong>适配器模式（Adapter Pattern）</strong>：解决不相容的接口问题，为具有不同接口的类似构件提供稳定接口</p>
<p>和哪些其他模式有关系：</p>
<ol>
<li><p>隐藏外部系统的资源适配器可以视为外观对象，即与外观模式相关，资源适配器使用单一对象封装了对子系统或系统的访问，这与外观模式的本质是一致的。</p>
<p>适配器可以用来适配外观模式中不同的子系统接口，从而使得外观模式可以为客户端提供一个简化的统一接口。</p>
</li>
<li><p>适配器与代理模式，适配器模式有时可以看作是代理模式的特殊形式，特别是当适配器用来代理一个目标对象，并将其接口适配为客户端期望的接口时。</p>
</li>
<li><p>适配器与策略模式，因为某些策略方案的接口可能并不适配与</p>
</li>
<li><p>在组合模式中，适配器可以用来统一处理叶子节点和容器节点的接口，使得客户端可以一致地对待组合中的所有对象。</p>
</li>
<li><p>支持防止变异</p>
</li>
</ol>
</li>
<li><p><strong>组合模式（Composite Pattern）</strong>：</p>
</li>
<li><p><strong>外观模式（Facade Pattern）</strong>：解决对一组完全不同的实现或接口需要公共统一接口的问题 可以使用外观对象封装子系统 外观对象提供唯一和统一的接口 并负责与子系统构件进行协作</p>
</li>
<li><p><strong>代理模式（Proxy Pattern）</strong>：</p>
</li>
<li><p><strong>观察者模式（Observer Pattern）</strong>：定义“订阅者”或“监听者”接口。订阅者实现接口，发布者可以动态关注某时间的订阅者，并在事件发生时通知它们</p>
</li>
<li><p><strong>状态模式（State Pattern）</strong>：状态模式跟类图和状态图有什么关系</p>
<ol>
<li>状态图允许一个对象内部状态发生改变的时候，改变它的行为能力，一个对象的状态发生改变，相应的行为发生改变，</li>
</ol>
</li>
<li><p>**策略模式（Strategy Pattern） **：重点</p>
<p>解决设计变化但相关的算法或政策 可以在单独的类中分别定义每种算法或政策策略 差不多就是多态+细化方法和类</p>
</li>
</ul>
</li>
<li><p><strong>Subsystem和package的区别是什么?</strong>：</p>
<p>   <strong>答案:</strong> </p>
<ol>
<li>Subsystem具有行为，package不提供行为</li>
<li>Subsystem完全封装了内部实现，package没有完全封装。</li>
<li>Subsystem很容易被替换，package不一定能够容易的被替换。</li>
</ol>
</li>
</ol>
<h1 id="UML内容复习"><a href="#UML内容复习" class="headerlink" title="UML内容复习"></a>UML内容复习</h1><h2 id="课本的知识迭代方式："><a href="#课本的知识迭代方式：" class="headerlink" title="课本的知识迭代方式："></a>课本的知识迭代方式：</h2><p><img src="D:\DeskTable\博客学习截图传输\image-20240616094443039.png" alt="image-20240616094443039"></p>
<h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h2><p>UML全称为：Unified Modeling Language，统一建模语言，是用来描述、构建和文档化系统制品的可视化语言。</p>
<h2 id="UML的三种透视图"><a href="#UML的三种透视图" class="headerlink" title="UML的三种透视图"></a>UML的三种透视图</h2><ol>
<li>概念透视图 Conceptual perspective</li>
<li>规格说明透视图 Specification perspective</li>
<li>实现透视图 Implementation perspective</li>
<li><img src="D:\DeskTable\博客学习截图传输\image-20240616090655810.png" alt="image-20240616090655810"></li>
</ol>
<h3 id="不同视图中“类”的含义"><a href="#不同视图中“类”的含义" class="headerlink" title="不同视图中“类”的含义"></a>不同视图中“类”的含义</h3><p>Conceptual perspective 中称之为 domain concept 或 conceptual class，领域模型表示的就是conceptual perspective。</p>
<ol>
<li>Conceptual class：在概念透视图中使用。UP领域明显中包含概念类</li>
<li>Software class：表示软件构件在规格说明或实现透视图中的类</li>
<li>Implementation class：特定OO语言中的类</li>
</ol>
<h2 id="可视化建模的优点"><a href="#可视化建模的优点" class="headerlink" title="可视化建模的优点"></a>可视化建模的优点</h2><ol>
<li>提高沟通和理解</li>
<li>支持系统分析和设计</li>
<li>提高开发效率和质量</li>
<li>支持维护和拓展</li>
</ol>
<h2 id="OO"><a href="#OO" class="headerlink" title="OO"></a>OO</h2><h3 id="OO-面向对象"><a href="#OO-面向对象" class="headerlink" title="OO 面向对象"></a>OO 面向对象</h3><p>指的是“对象”概念的编程范式，对象可以包含属性和方法，对象是类的实例，类定义了属性和方法</p>
<h3 id="OOA-面向对象分析analysis：专注于问题领域"><a href="#OOA-面向对象分析analysis：专注于问题领域" class="headerlink" title="OOA 面向对象分析analysis：专注于问题领域"></a>OOA 面向对象分析analysis：专注于问题领域</h3><p>强调在问题领域内发现和描述对象（或概念）</p>
<h3 id="OOD-面向对象设计：专注于软件实现的分析"><a href="#OOD-面向对象设计：专注于软件实现的分析" class="headerlink" title="OOD 面向对象设计：专注于软件实现的分析"></a>OOD 面向对象设计：专注于软件实现的分析</h3><p>强调定义软件对象以及它们如何协作以实现需求</p>
<h3 id="OOP-面向对象编程：使用对象和类将OOD的制品转化为可执行的代码"><a href="#OOP-面向对象编程：使用对象和类将OOD的制品转化为可执行的代码" class="headerlink" title="OOP 面向对象编程：使用对象和类将OOD的制品转化为可执行的代码"></a>OOP 面向对象编程：使用对象和类将OOD的制品转化为可执行的代码</h3><h2 id="RUP-rational-unified-process-统一过程"><a href="#RUP-rational-unified-process-统一过程" class="headerlink" title="RUP rational unified process 统一过程"></a>RUP rational unified process 统一过程</h2><h3 id="什么是UP"><a href="#什么是UP" class="headerlink" title="什么是UP"></a>什么是UP</h3><p>UP是一种构造面向对象系统的迭代软件开发过程。最常用的是RUP</p>
<blockquote>
<p>重构 refactoring	持续集成 continuous integration</p>
</blockquote>
<p>强调<strong>迭代和增量式开发 iterative and incremental development</strong>，旨在通过一系列与定义的阶段来管理软件项目的各个方面</p>
<p>功能进行迭代升级，系统规模进行增量式增长</p>
<p>迭代开发需要得到快速反馈：来自用户、开发人员和测试的反馈</p>
<h3 id="UP项目的四个阶段："><a href="#UP项目的四个阶段：" class="headerlink" title="UP项目的四个阶段："></a>UP项目的四个阶段：</h3><ol>
<li>初始阶段 inception phase</li>
<li>细化迭代 elaboration phase</li>
<li>构造阶段 construction phase</li>
<li>移交阶段 transition phase</li>
</ol>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><blockquote>
<p>discipline 科目——知识的分支	artifact 制品</p>
</blockquote>
<h2 id="敏捷开发-agile-development"><a href="#敏捷开发-agile-development" class="headerlink" title="敏捷开发 agile development"></a>敏捷开发 agile development</h2><p>应用时间定量的迭代和进化式开发，使用自适应计划，倡导增量交付并包含其他提倡敏捷性的价值和实践</p>
<h2 id="用例模型："><a href="#用例模型：" class="headerlink" title="用例模型："></a>用例模型：</h2><p>use case model</p>
<p>撰写一个用例文本需要的东西：</p>
<p><img src="D:\DeskTable\博客学习截图传输\image-20240606142728372.png" alt="image-20240606142728372"></p>
<h2 id="UML的一些基本概念"><a href="#UML的一些基本概念" class="headerlink" title="UML的一些基本概念"></a>UML的一些基本概念</h2><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><h4 id="结构事物"><a href="#结构事物" class="headerlink" title="结构事物"></a>结构事物</h4><ol>
<li>类</li>
<li>接口</li>
<li>协作</li>
<li>用例</li>
<li>主动类</li>
<li>构件</li>
<li>节点</li>
</ol>
<h4 id="行为事物"><a href="#行为事物" class="headerlink" title="行为事物"></a>行为事物</h4><ol>
<li>交互</li>
<li>状态机</li>
<li>活动</li>
</ol>
<h4 id="分组事物"><a href="#分组事物" class="headerlink" title="分组事物"></a>分组事物</h4><ol>
<li>包</li>
</ol>
<h4 id="注销事物"><a href="#注销事物" class="headerlink" title="注销事物"></a>注销事物</h4><ol>
<li>注解</li>
</ol>
<p>用例就是需求，用例需要包含所有涉众关注点的事物</p>
<h2 id="九大种表示图"><a href="#九大种表示图" class="headerlink" title="九大种表示图"></a>九大种表示图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: UML Graph</span><br><span class="line">---</span><br><span class="line">classDiagram</span><br><span class="line">    UML图 &lt;|-- 结构图</span><br><span class="line">    UML图 &lt;|-- 行为图</span><br><span class="line">    </span><br><span class="line">    结构图 &lt;|-- 类图</span><br><span class="line">    结构图 &lt;|-- 对象图</span><br><span class="line">    结构图 &lt;|-- 组件图</span><br><span class="line">    结构图 &lt;|-- 部署图</span><br><span class="line">    </span><br><span class="line">    行为图 &lt;|-- 交互图</span><br><span class="line">    行为图 &lt;|-- 活动图</span><br><span class="line">    行为图 &lt;|-- 状态图</span><br><span class="line">    行为图 &lt;|-- 用例图</span><br><span class="line">    </span><br><span class="line">    交互图 &lt;|-- 顺序图</span><br><span class="line">    交互图 &lt;|-- 时序图</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="元模型"><a href="#元模型" class="headerlink" title="元模型"></a>元模型</h2><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249535.png" alt="image-20240607205850660"></p>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><ol>
<li>**用例图的组成元素：**参与者，参与者间的关系组成，用例，系统边界</li>
<li><strong>参与者 actors：</strong> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249617.png" alt="image-20240606135027508"> <ol>
<li>主要primary参与者：寻求服务的，首先做出动作</li>
<li>协助supporting参与者：提供服务的，响应主要参与者的动作，</li>
<li>幕后offstage参与者：不重要</li>
</ol>
</li>
<li><strong>用例 use cases：</strong> <ul>
<li>一个椭圆➕用例名称<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249906.png" alt="image-20240606135116865"> </li>
<li>用例就是一组相关的成功和失败场景的集合</li>
<li>场景 scenario：参与者和系统间的活动和交互，也可以叫做用例实例 use case instance</li>
</ul>
</li>
<li>**系统边界 system Board：**一个方形➕系统名称<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249274.png" alt="image-20240606135148086"> </li>
<li><strong>参与者间的关系 relationships：</strong><ol>
<li>关联：<ol>
<li>表示形式：一根<strong>实线</strong>连在参与者和用例中间</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250788.png" alt="image-20240606135244204"></li>
</ol>
</li>
<li>泛化：<ol>
<li>表示一个用例（子用例）继承自另一个用例（父用例），子用例继承了父用例的所有属性和行为，并可以增加新的行为或修改继承的行为。</li>
<li>表示形式：用一根带有空心三角形的实线连接</li>
<li>其实就是一种继承关系，子用例包含有父用例的功能，但是又可以有自己的特殊功能</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250687.png" alt="image-20240606135413057"></li>
</ol>
</li>
<li>包含：<ol>
<li>表示形式：一根带箭头的虚线，同时虚线上写上《include》的标签</li>
<li>包含用例一定会执行，即在录入成绩时一定会执行保存成绩，但保存成绩不一定会启动录入成绩</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250911.png" alt="image-20240606135558542"></li>
</ol>
</li>
<li>拓展：<ol>
<li>拓展关系用于描述一种可选的、条件性的行为。</li>
<li>表示形式：一根带箭头的虚线，同时虚线上写上《extend》的标签</li>
<li>拓展用例需要满足某种条件才会执行，如忘记密码功能是在登录时满足了条件“用户不记得密码”才会执行的</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250371.png" alt="image-20240606140037670"></li>
</ol>
</li>
</ol>
</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250529.png" alt="image-20240606140228153"> <ol>
<li>以上图中，教师和“录入成绩、修改成绩、删除成绩、查询成绩、登录”几个用例是关联关系，即教师可以进入这几个场景当中；</li>
<li>录入成绩、修改成绩 和 保存成绩时包含关系，因为每次录入成绩和修改成绩最终都需要将录入结果和修改结果保存，否则该操作无意义，则保存成绩一定会执行</li>
<li>登录 和 微信登录、手机登录 是泛化关系，就像父类和子类一样，子类继承有父类的特性，即无论是微信登录还是手机登录，本质都是一种登录操作，但是根据其具体场景又会有各自的特性</li>
<li>登录 和 忘记密码 是拓展关系，忘记密码是登录的拓展，但是忘记密码操作只有在满足“用户忘记了密码”这一条件时才会执行，则拓展不是一定执行的。</li>
</ol>
</li>
</ol>
<h3 id="用例种类："><a href="#用例种类：" class="headerlink" title="用例种类："></a>用例种类：</h3><ol>
<li>具体用例：由参与者发起，完成了参与者所期望的完整行为</li>
<li>抽象用例：无法单独存在，必须作为其他用例的子功能用例</li>
<li>基础用例：包含有其他用例的用例&#x2F;被其他用例拓展或泛化的用例</li>
<li>附加用例：被其他用例包含的、拓展&#x2F;泛化了其他用例的用例</li>
</ol>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>描述系统中的类，以及各个类之间的静态关系。</p>
<h3 id="组成元素"><a href="#组成元素" class="headerlink" title="组成元素"></a>组成元素</h3><ul>
<li><p>类：</p>
<ul>
<li><p>名称 必须有</p>
</li>
<li><p>属性 可见性 + 属性名称</p>
</li>
<li><p>操作</p>
</li>
<li><p>关键字</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250405.png" alt="image-20240607211351972"></p>
</li>
<li><p>构造型</p>
<p>也使用《》表示，如《stereotype》</p>
</li>
<li><p>特性：元素特征已命名的值</p>
</li>
</ul>
</li>
</ul>
<h3 id="类间的关系："><a href="#类间的关系：" class="headerlink" title="类间的关系："></a>类间的关系：</h3><h4 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h4><ol>
<li>一种<strong>继承</strong>关系，表示一般与特殊的关系，<strong>指定了子类如何继承父类</strong>的所有特征和行为。</li>
<li>从特型指向泛型</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250156.png" alt="image-20240616112009375"></li>
</ol>
<h4 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h4><ol>
<li>实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250167.png" alt="image-20240616112041542"></li>
</ol>
<h4 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h4><ol>
<li><p>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法；</p>
<ol>
<li><p>关联可以是双向的，也可以是单向的。</p>
<p>双向的关联可以有两个箭头或者没有箭头</p>
<p>单向的关联有一个箭头。</p>
</li>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250080.png" alt="image-20240616112056664"> </p>
</li>
<li><p>指的是<code>类与类之间的联接</code>，<strong><code>它使一个类知道另一个类的属性和方法（实例变量体现）</code></strong>。A类依赖于B对象,并且<code>把B作为A的一个成员变量</code>, 则A和B存在关联关系.</p>
</li>
</ol>
</li>
</ol>
<h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><p>一个A对象属于B对象，一个B对象属于A对象</p>
<h5 id="单向的一对多"><a href="#单向的一对多" class="headerlink" title="单向的一对多"></a>单向的一对多</h5><p>A类的一个实例可以关联到B类的多个实例，但是反过来不成立</p>
<p>例如：学校和学生，一个学校可以有很多个学生实例，但是一个学生只能有一个学校实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+            +-----------------+</span><br><span class="line">|      School     |<span class="number">1</span>--------&gt;* |     Student     |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| - name: String  |            | - name: String  |</span><br><span class="line">| - address: String |          | - age: <span class="type">int</span>      |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| + getStudents() |            +-----------------+</span><br><span class="line">+-----------------+            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**“1”**表示“学校”一方的一个实例。</p>
<p>**“*”**表示“学生”一方的多个实例。</p>
<h5 id="单向的多对一"><a href="#单向的多对一" class="headerlink" title="单向的多对一"></a>单向的多对一</h5><p>A类的多个实例可以关联到B类的一个实例，当反过来就不成立了</p>
<p>依旧是学生和学校的例子，只不过这一次箭头由学生指向学校</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+            +-----------------+</span><br><span class="line">|     Student     |*--------&gt;<span class="number">1</span> |      School     |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| - name: String  |            | - name: String  |</span><br><span class="line">| - age: <span class="type">int</span>      |            | - address: String |</span><br><span class="line">| - school: School|            +-----------------+</span><br><span class="line">+-----------------+            </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="双向一对多、多对一"><a href="#双向一对多、多对一" class="headerlink" title="双向一对多、多对一"></a>双向一对多、多对一</h5><ol>
<li><p>类关联，即几个类之间含有关联关系</p>
</li>
<li><p>关联类</p>
</li>
</ol>
<h4 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h4><ol>
<li>聚合是整体与部分的关系，且<strong>部分可以离开整体而单独存在</strong>。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</li>
<li>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250823.png" alt="image-20240616113555303"></li>
</ol>
<h4 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h4><ol>
<li>组合是整体与部分的关系，但<strong>部分不能离开整体而单独存在</strong>。如公司和部门是整体和部分的关系，没有公司就不存在部门</li>
<li>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250857.png" alt="image-20240616113538539"></li>
</ol>
<h4 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h4><ol>
<li>依赖是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖</li>
<li>依赖关系：指的是类与类之间的联接。依赖关系表示<code>一个类依赖于另一个类的定义</code>。一般而言，依赖关系在Java语言中体现为<code>成员变量、局域变量、方法的形参、方法返回值</code>，或者对<strong>静态方法的调用。</strong></li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250620.png" alt="image-20240616113641726"></li>
</ol>
<h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>UML对象图只能在系统某一时间段存在</p>
<p>特定的时刻捕捉到静态的系统视图。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250396.png" alt="image-20240607203205694"> </p>
<p>在名称处格式为：对象名称:类型</p>
<p>下面则为具体的属性的值</p>
<h2 id="顺序图（也称为时序图-序列图）"><a href="#顺序图（也称为时序图-序列图）" class="headerlink" title="顺序图（也称为时序图&#x2F;序列图）"></a>顺序图（也称为时序图&#x2F;序列图）</h2><h3 id="组成元素："><a href="#组成元素：" class="headerlink" title="组成元素："></a>组成元素：</h3><ol>
<li><p>对象或参与者 Objects or Participants</p>
<ol>
<li>在图的顶部，矩形框表示</li>
</ol>
</li>
<li><p>生命线 lifeline</p>
<ol>
<li>从对象或参与者延伸出来的垂直<strong>虚线</strong>，表示对象在时间上的存在</li>
</ol>
</li>
<li><p>激活：在生命线上覆盖一段矩形长条，代表对象处于活动状态</p>
<ol>
<li>一条消息代表的事件激活了一个对象，直到事件结束再次进入休眠</li>
</ol>
</li>
<li><p>消息 Message</p>
<ol>
<li>对象间传递的消息<ol>
<li><p>同步消息用实线实心三角箭头表示 </p>
<p>（注意看激活）消息发生者会阻塞以等待返回消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250296.png" alt="image-20240607203756699"> </p>
</li>
<li><p>异步消息用实线普通箭头表示 （注意看激活）</p>
<p>消息发送者不会阻塞，继续执行自己的事情，不在意返回消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250498.png" alt="image-20240607203805072"> </p>
</li>
<li><p>返回消息用虚线普通箭头表示</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250064.png" alt="image-20240607204139502"></p>
</li>
<li><p>需要强调消息发送时间（消息发送时间不可忽略）的：将消息先向下走表示</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250103.png" alt="image-20240607204250317"> </p>
</li>
<li><p>重入消息</p>
<p>相当于一种递归</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250653.png" alt="image-20240607204435728"> </p>
</li>
<li><p>无触发和无接受消息</p>
<p>和系统外有关的消息，使用无触发和无接受</p>
</li>
<li><p>对象销毁</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250435.png" alt="image-20240607204811135"> </p>
</li>
<li><p>执行控制逻辑：</p>
<ol>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250590.png" alt="image-20240607204857372"> </p>
</li>
<li><p>条件分支：一个带有虚线的方框</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250889.png" alt="image-20240607205002423"> </p>
</li>
<li><p>可选项：</p>
</li>
<li><p>循环：loop框和break框（只执行一次）</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250648.png" alt="image-20240607205052354"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对象的创建</p>
</li>
</ol>
<h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>与流程图几乎一模一样，活动图是流程图的一个扩充</p>
<p>有助于使工作流和业务过程可视化的图</p>
<p>是状态图的一种特殊形式</p>
<h4 id="组成元素-1"><a href="#组成元素-1" class="headerlink" title="组成元素"></a>组成元素</h4><ul>
<li>泳道：与执行对象挂钩，一个泳道代表一种执行对象<ul>
<li>清楚明了地列出了流程中有哪些参与者</li>
<li>每一类参与者的职责划分明确</li>
</ul>
</li>
<li>开始节点</li>
<li>结束节点</li>
<li>事件:<ul>
<li>矩形带三角<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250994.png" alt="image-20240607200419814"> 发送事件</li>
<li>矩形缺三角<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250365.png" alt="image-20240607200443625"> 接收事件</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250218.png" alt="image-20240607200512938"> 时间事件</li>
</ul>
</li>
<li>分叉和汇合</li>
<li>带箭头的实线：代表控制权的转移</li>
<li>分支和合并</li>
<li>事件机制</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250962.png" alt="image-20240607200302461"></li>
</ul>
<h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><h2 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h2><p>显示对象间的动态合作关系。</p>
<h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><p>组件和对象</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251129.png" alt="image-20240607205242219"> </p>
<p>组件图 &#x3D; 构件（Component）+接口（Interface）+关系（Relationship）+端口（Port）+连接器（Connector）。</p>
<p>组件图不描述该系统的功能，但它描述了使用这些功能的组件。</p>
<p>表示系统中构件与构件之间，类或接口与构件之间的关系图。</p>
<p>表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系。</p>
<p>由组件、接口和组件之间联系构成，描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。</p>
<h2 id="配置图"><a href="#配置图" class="headerlink" title="配置图"></a>配置图</h2><p>用来建模系统的物理部署。</p>
<p>部署图由节点以及节点之间的关系组成。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><h2 id="GRASP设计模式"><a href="#GRASP设计模式" class="headerlink" title="GRASP设计模式"></a>GRASP设计模式</h2><p>本质是一类OO设计原则</p>
<h3 id="创建者模式-Creator-Mode"><a href="#创建者模式-Creator-Mode" class="headerlink" title="创建者模式 Creator Mode"></a>创建者模式 Creator Mode</h3><ul>
<li>可以将创建 类A 实例的职责分配给 类B 的条件：<ul>
<li>B 和 A 的关系是包含或组合</li>
<li>B记录A</li>
<li>B 使用 A 很多</li>
<li>B 具有可以初始化 A 的数据</li>
</ul>
</li>
</ul>
<h3 id="专家模式-Expert-Mode"><a href="#专家模式-Expert-Mode" class="headerlink" title="专家模式 Expert Mode"></a>专家模式 Expert Mode</h3><p>给定键值，谁可以知道 类A 对象的相关信息</p>
<p>决定如何分配职责（给方法、字段等）的原则。</p>
<p>分配职责的原则是信息专家，即把职责分配 给具有完成此职责所需信息的 对象</p>
<h3 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h3><p>耦合：元素和其他元素的连接、感知以及依赖的程度的度量</p>
<p>实现低耦合的一个目的就是：减少 B类 因为 A类 发生变化而发生的变化</p>
<p>注：高耦合本身不是问题，出问题的是高耦合情况下，当耦合对象当中存在不稳定元素时，会影响整个系统</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器对象是非用户界面，负责接收或处理系统事件的对象。</p>
<p>控制器模式的主要目的是<strong>处理系统事件</strong>，即用户的输入和外部系统的请求。控制器模式通过一个中介对象来协调这些事件，使得系统的其他部分能够专注于各自的职责。</p>
<p><strong>应用场景</strong>： 控制器模式通常在以下情况下使用：</p>
<ul>
<li>当系统接收到外部输入（如用户交互、API请求）时，需要一个对象来处理这些输入并协调系统的响应。</li>
<li>通过控制器对象来封装系统的入口点，确保系统的核心逻辑与输入处理分离。</li>
</ul>
<p>问题：哪个对象要处理输入系统事件？ </p>
<p>解决方案：应该由用例控制器来处理用例所有的系统事件，也可以用在一个以上的用例。例如“创建用户”或“删除用户”的用例，可以用同一个类别，称为UserController，而不是用二个个别的用例控制器。</p>
<p>控制器需将需其他对象来完成的工作给对应对象。</p>
<h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p><strong>职责单一</strong>：</p>
<ul>
<li>一个高内聚的模块或类通常只负责一个主要功能或职责。这意味着它的所有方法和属性都围绕这个主要功能展开。</li>
</ul>
<p><strong>相关性强</strong>：</p>
<ul>
<li>模块或类内部的所有元素（如属性和方法）都应该高度相关，共同实现一个具体的功能。例如，订单类的所有方法和属性都与订单管理相关。</li>
</ul>
<p><strong>易于维护</strong>：</p>
<p><strong>低耦合</strong>：</p>
<h4 id="高内聚的优点"><a href="#高内聚的优点" class="headerlink" title="高内聚的优点"></a>高内聚的优点</h4><ol>
<li>提高代码的可维护性、</li>
<li>可读性和</li>
<li>可重用性</li>
<li>减少复杂性。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>当相关选择和行为随类型不同时，多态的操作可以相应的改变职责的分配</p>
<h3 id="纯虚构"><a href="#纯虚构" class="headerlink" title="纯虚构"></a>纯虚构</h3><p>在现实领域不存在的的，但为了将某些特定功能抽离出来所设计的纯虚构的臆想的类，不存在领域模型中，只是为了方便开放而捏造的概念。</p>
<h4 id="纯虚构的对象可以分为两类："><a href="#纯虚构的对象可以分为两类：" class="headerlink" title="纯虚构的对象可以分为两类："></a>纯虚构的对象可以分为两类：</h4><ul>
<li>通过表示解析 representational decomposition 所产生的选择：因为在系统的领域模型当中就已经明确有 ，所以进行了类对象的创建<ul>
<li>侧重于系统的静态结构，通过分解系统来展示其组成部分以及这些部分之间的关系。</li>
<li>关注的是系统的各个组成部分如何组织在一起，形成一个完整的系统</li>
</ul>
</li>
<li>通过行为解析 behavioral decomposition 所产生的选择：因为在实现系统的过程中需要某一个类，但是该类的存在在现实领域模型中找不到依据，只是为了方便开发，将一系列行为或方法组织起来（十分类似于java的工具类）<ul>
<li>侧重于系统的动态行为，通过分解系统的操作来展示其工作方式和交互过程。</li>
<li>关注系统的操作、事件和交互模式。</li>
</ul>
</li>
</ul>
<h3 id="间接性"><a href="#间接性" class="headerlink" title="间接性"></a>间接性</h3><p>为了避免多个事物间直接耦合，将职责分配给中介对象，使其作为其他构件或服务之间的媒介。引入一层中间性和多态来降低系统组件之间的耦合度，增加系统的灵活性和可扩展性。</p>
<h3 id="防止变异-PV"><a href="#防止变异-PV" class="headerlink" title="防止变异 PV"></a>防止变异 PV</h3><p>数据封装、接口、多态、间接性和标准化</p>
<p>Liskov替换原则 LSP</p>
<p>don’t talk to strangers ：不要历经远距离的对象结构路径去向远距离的间接对象发送信息，该规则的应用可以防止因结构变异而产生的变异</p>
<p>修改设计，使每个类只与其直接关联的对象交互。</p>
<h4 id="信息隐藏-information-hiding"><a href="#信息隐藏-information-hiding" class="headerlink" title="信息隐藏 information hiding"></a>信息隐藏 information hiding</h4><p>等价于PV模式</p>
<h4 id="开放-封闭原则-Open-closed-Principle-OCP"><a href="#开放-封闭原则-Open-closed-Principle-OCP" class="headerlink" title="开放-封闭原则 Open-closed Principle OCP"></a>开放-封闭原则 Open-closed Principle OCP</h4><p>基本等价于PV模式和信息隐藏</p>
<p>“对xx封闭” 意思是 X变化时不会对客户产生影响。</p>
<h2 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><blockquote>
<p>支持防止变异，因为adapter应用了接口和多态polymorphism的间接对象</p>
</blockquote>
<p>一种结构性设计模式，将类的接口转换成客户希望的另一个接口。可以使得原本由于接口不兼容不能一起工作的类可以一起工作</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p><strong>接口不兼容</strong>：当你希望使用一个已经存在的类，但它的接口并不符合你的需求。</p>
</li>
<li><p><strong>复用已有的类</strong>：在不改变已有代码的情况下，使用新的接口复用已有的类。</p>
</li>
<li><p><strong>适配不同的接口</strong>：使得两个不兼容的接口可以一起工作。</p>
</li>
</ul>
<h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul>
<li><p>目的接口 Target Interface</p>
</li>
<li><p>现有接口 Adaptee 需要被适配的接口</p>
</li>
<li><p>适配器 Adapter 一个实现了目标接口的类，包含现有接口的实例，并在目标接口的方法中调用现有接口的方法</p>
</li>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251683.png" alt="image-20240608174207705"></p>
</li>
</ul>
<h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h3><p>对于抽象工厂的一种简化就是 简单&#x2F;具体工厂。</p>
<p>在上面适配器模式的基础上，会引申出一个问题，由谁来创建这些适配器，显然，由领域对象来创建是不符合领域对象的职责的，因此需要找一个同样是纯虚构的概念类来创建这些适配器，并由领域对象来调用这个概念类以达到使用适配器的目的。</p>
<p>这个纯虚构的概念类就是“工厂”，也就是形成了所谓的工厂模式</p>
<h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><blockquote>
<p>通常用于工厂或外观模式</p>
</blockquote>
<p>细想工厂模式，适配器由工厂来创建，但是谁来创建工厂，又如何使用工厂，总不能套娃地创建一个创建工厂的工厂吧。</p>
<p>在这里需注意，我们使用工厂的目的是为了方便调度适配器同时将创建适配器的职责分离出来，意味着在整个项目当中：</p>
<ol>
<li>我们其实只需要该工厂类的<strong>一个实例</strong>；</li>
<li>同时这个实例是不由其他领域内的类创建的</li>
<li>且这个实例在整个项目的任意位置都可以被访问和使用。</li>
</ol>
<p>由以上的要求实践出了单例模式</p>
<p>即在工厂类中定义一个该工厂类的静态实例，并在工厂内进行初始化。</p>
<p>关键思想是：在类中定义<strong>静态方法getInstance</strong>，提供工厂类的唯一实例。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251071.png" alt="image-20240616104214737"> </p>
<p>下划线代表静态属性&#x2F;方法</p>
<p>在类名处写上1表示只可以创建一个实例</p>
<p>对于单例模式有两种加载方式：</p>
<ol>
<li>lazy initialization 懒加载：等待需要时再初始化工厂</li>
<li>eager initialization 预先加载：在程序编译阶段就初始化工厂</li>
</ol>
<p>adaptor、factory、singleton三种模式应用于设计</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251461.png" alt="image-20240616104710871"> </p>
<h3 id="策略-Strategy"><a href="#策略-Strategy" class="headerlink" title="策略 Strategy"></a>策略 Strategy</h3><p>策略 的创建同样可以由工厂来实现。</p>
<p>如使用一个StrategyFactory负责创建所有的策略。</p>
<p><strong>策略模式</strong>是一种行为设计模式，允许在运行时选择算法的方式。通过定义一系列算法，将每个算法封装起来，并使它们可以互换，策略模式让算法独立于使用它们的客户端变化。</p>
<h4 id="UML表示"><a href="#UML表示" class="headerlink" title="UML表示"></a>UML表示</h4><p>策略模式的UML图通常包括以下部分：</p>
<ol>
<li><strong>Context（上下文）</strong>：维护一个对策略对象的引用。</li>
<li><strong>Strategy（策略）</strong>：这是一个接口，定义了所有支持的算法的公共方法。</li>
<li><strong>ConcreteStrategy（具体策略）</strong>：实现了策略接口的具体算法。</li>
</ol>
<h3 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合 Composite"></a>组合 Composite</h3><p><strong>组合模式</strong>是一种结构设计模式</p>
<p>组合模式通过将对象组合成树形结构，使得客户端可以一致地处理单个对象和组合对象。</p>
<p>为原子对象和组合对象定义同一个父类或同一个接口，并去具体实现不同的细节，但是就可以通过统一的方法来处理原子对象和组合对象</p>
<h3 id="外观-Faced"><a href="#外观-Faced" class="headerlink" title="外观 Faced"></a>外观 Faced</h3><p>对一组完全不同的实现或接口（如子系统中的实现和接口）需要公共、统一的接口。可能会与子系统内部 的大量事物耦合</p>
<p>对子系统定义唯一的接触点——外观对象封装子系统。该外观对象提供唯一和统一的接口，并负责与子系统构件进行协作。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>外观模式的主要目的是简化复杂系统的使用，使得客户端可以通过一个简单的接口访问复杂子系统的功能，而不需要了解子系统的内部细节。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>外观模式通常包括以下角色：</p>
<ul>
<li><strong>Facade</strong>：外观类，提供简单的接口调用子系统的功能。</li>
<li><strong>Subsystem Classes</strong>：子系统类，实际实现系统功能的类，客户端直接使用这些类可能会非常复杂。</li>
</ul>
<p>外观模式通过提供一个高层接口<strong>简化</strong>了复杂系统的<strong>使用</strong>。</p>
<p>一个系统中包含有多个子系统用来完成功能的实现，但是客户不需要关心子系统具体的实现，只需要得到一个系统给的总开关即可。</p>
<h3 id="观察者-Observer（发布-订阅（Publish-Subscribe））-委派事件模型"><a href="#观察者-Observer（发布-订阅（Publish-Subscribe））-委派事件模型" class="headerlink" title="观察者 Observer（发布-订阅（Publish-Subscribe））&#x2F; 委派事件模型"></a>观察者 Observer（发布-订阅（Publish-Subscribe））&#x2F; 委派事件模型</h3><p>它定义了对象间的一对多依赖关系，使得每当一个对象改变状态时，其相关依赖对象都会被<strong>自动通知并更新</strong>。</p>
<p>观察者模式常用于实现事件处理系统，例如GUI框架中的事件监听器，或者订阅发布系统。</p>
<h3 id="代理Proxy"><a href="#代理Proxy" class="headerlink" title="代理Proxy"></a>代理Proxy</h3><h3 id="命令-Command"><a href="#命令-Command" class="headerlink" title="命令 Command"></a>命令 Command</h3><h3 id="状态-State"><a href="#状态-State" class="headerlink" title="状态 State"></a>状态 State</h3><h2 id="课本逐章笔记："><a href="#课本逐章笔记：" class="headerlink" title="课本逐章笔记："></a>课本逐章笔记：</h2><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p>课本内容：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251765.png" alt="image-20240419090210330" style="zoom:50%;" /> 

<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML：一种标准的图形表示法，统一建模语言-Unified modeling language，描述、构造和文档化系统制品的可视化语言。</p>
<p>UML不过是将面向对象的思想进行图形化的工具，学习重点关注的还是：对象的设计思想————“OOA&#x2F;D”</p>
<p>三种应用：</p>
<ol>
<li>作为草图</li>
<li>作为蓝图————相对详细的设计图<ol>
<li>逆向工程：对现有代码结构进行可视化</li>
<li>代码生成：</li>
</ol>
</li>
<li>作为编程语言</li>
</ol>
<h4 id="OOA-D原则与模式："><a href="#OOA-D原则与模式：" class="headerlink" title="OOA&#x2F;D原则与模式："></a>OOA&#x2F;D原则与模式：</h4><ol>
<li>职责驱动设计-<strong>reponsibility-driven design</strong></li>
<li>将一些经典的设计问题的解决方案提炼出来作为经典的“设计模式<strong>pattern</strong>”</li>
</ol>
<h4 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h4><p>OOD需要进行先决条件————需求分析-<strong>requirement analysis</strong>，再需求分析中通常包含用例-<strong>use case</strong>的编写。</p>
<h4 id="迭代开发、敏捷模式、敏捷UP"><a href="#迭代开发、敏捷模式、敏捷UP" class="headerlink" title="迭代开发、敏捷模式、敏捷UP"></a>迭代开发、敏捷模式、敏捷UP</h4><p>迭代开发过程</p>
<h4 id="敏捷模式："><a href="#敏捷模式：" class="headerlink" title="敏捷模式："></a>敏捷模式：</h4><p>强调以UML作为草图的应用的方式，最普通的使用UML的方法。</p>
<h4 id="三种透视图："><a href="#三种透视图：" class="headerlink" title="三种透视图："></a>三种透视图：</h4><ol>
<li>概念透视图</li>
<li>规格说明（软件）透视图：用UML图来描述软件的抽象物或具有规格说明和接口的构件</li>
<li>实现（软件）透视图：描述特定技术的软件实现</li>
</ol>
<p>在UML当中，矩形框被称为<strong>类-class</strong>。</p>
<p>在领域模式中的UML框被称为领域概念-domain concept或概念类-conceptual class，</p>
<p>OO开发中最重要的能力是软件对象职责的划分</p>
<p>分析：强调对问题和需求的调查研究，但并不是可使用的解决方案</p>
<p>设计：强调满足需求的概念上的解决方案，但并非其实现。最终设计的具体实现表达了完整的设计</p>
<p>面向对象分析：在问题领域内发现和描述对象，抽象出所面对问题当中存在的对象</p>
<p>面向对象设计：定义对象以及对象属性，定义对象间的协作方式以及实现需求</p>
<h3 id="定义领域模式"><a href="#定义领域模式" class="headerlink" title="定义领域模式"></a><strong>定义领域模式</strong></h3><blockquote>
<p>该模型是对真实世界中概念和想象的可视化，也称为“概念对象模型”</p>
</blockquote>
<p>面向对象分析的结果表示为领域模型-domain model</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251938.png" alt="image-20240419091413982" style="zoom:50%;" /> 

<blockquote>
<p>模型描述了分析出的对象、对象间的关联关系和对象的属性与行为</p>
</blockquote>
<h3 id="定义交互图"><a href="#定义交互图" class="headerlink" title="定义交互图"></a><strong>定义交互图</strong></h3><ol>
<li><p>顺序图-sequence diagram：</p>
<blockquote>
<p>uml一种交互图</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251146.png" alt="image-20240419091807866"></p>
</li>
</ol>
<h3 id="定义设计类图"><a href="#定义设计类图" class="headerlink" title="定义设计类图"></a><strong>定义设计类图</strong></h3><p><strong>design class diagram</strong>：有效表示类定义的静态视图</p>
<h3 id="迭代、进化和敏捷"><a href="#迭代、进化和敏捷" class="headerlink" title="迭代、进化和敏捷"></a>迭代、进化和敏捷</h3><blockquote>
<p>相对于顺序或“瀑布-waterfall”生命周期，迭代和进化式开发-iterative and evolutionary development对部分系统及早地引入编程和测试，并进行重复。</p>
</blockquote>
<h3 id="UP模型–Unified-process-model"><a href="#UP模型–Unified-process-model" class="headerlink" title="UP模型–Unified process model"></a>UP模型–Unified process model</h3><blockquote>
<p>UP模型具有良好的兼容性，十分灵活开放，同时鼓励引进其他迭代方法中有效的实践。</p>
<p>UP可以将普遍认可的最佳实践结起来。</p>
</blockquote>
<p><strong>软件开发过程-software development process</strong>描述了构造、部署以及维护软件的方式。</p>
<p><strong>统一过程UP</strong>：一种构造面向对象系统的迭代软件开发过程，</p>
<p><strong>Rational UP-Rational Unified Process RUP</strong>是对统一过程的详细精化。</p>
<h3 id="其他迭代方法："><a href="#其他迭代方法：" class="headerlink" title="其他迭代方法："></a>其他迭代方法：</h3><ol>
<li>极限编程-<strong>Extreme Programming XP</strong></li>
<li>Scrum</li>
<li>重构-refactoring</li>
<li>持续集成-continuous integration</li>
<li>动态系统开发方法-DSDM Dynamic Systems Development Methodogy</li>
<li>ASD-Adaptive ware Development</li>
</ol>
<h3 id="迭代与进化式开发"><a href="#迭代与进化式开发" class="headerlink" title="迭代与进化式开发"></a>迭代与进化式开发</h3><h4 id="迭代开发-iterative-development"><a href="#迭代开发-iterative-development" class="headerlink" title="迭代开发-iterative development"></a>迭代开发-iterative development</h4><ol>
<li>UP与大多数其他现代方法中的重要实践。</li>
<li>迭代的生命周期基于对经过多次迭代的系统进行持续扩张和精化，并以循环反馈和调整为核心驱动力。</li>
<li>随时间推移，系统进行了增量式地发展和完善，因而该方法也成为<strong>迭代和增量式开发</strong>-iterative and incremental development</li>
<li>也因为反馈和调整使规格说明和设计不断进化，所以这种方式也称为<strong>迭代和进化式开发</strong>-iterative and evolutionary development</li>
<li>迭代产出的是最终系统的子集，对这些子集进行整合得到最终的产品</li>
</ol>
<h3 id="瀑布生命周期"><a href="#瀑布生命周期" class="headerlink" title="瀑布生命周期"></a>瀑布生命周期</h3><blockquote>
<p>瀑布（或顺序）生命周期过程，试图在编程之前就定义所有或大部分的需求。</p>
</blockquote>
<h3 id="风险驱动和客户驱动"><a href="#风险驱动和客户驱动" class="headerlink" title="风险驱动和客户驱动"></a>风险驱动和客户驱动</h3><p>风险驱动迭代开发更为明确地包含了以<strong>架构为中心- architecture-centric迭代开发的实践。</strong></p>
<h3 id="敏捷方法及其观点"><a href="#敏捷方法及其观点" class="headerlink" title="敏捷方法及其观点"></a>敏捷方法及其观点</h3><p>具备进化式精化的计划、需求和设计的短时间定量迭代</p>
<h3 id="敏捷建模"><a href="#敏捷建模" class="headerlink" title="敏捷建模"></a>敏捷建模</h3><p>建模的目的主要是为理解，而非文档</p>
<p>建模的真正行为应该是能够对理解问题或解决方案做出帮助。</p>
<h3 id="UP阶段"><a href="#UP阶段" class="headerlink" title="UP阶段"></a>UP阶段</h3><ol>
<li>初始-Inception：大体上的构想、业务案例、范围和模糊评估</li>
<li>细化-Elaboration：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估</li>
<li>构造-Construction：对遗留下来的风险较低和比较简单的元素进行了迭代实现，准备部署</li>
<li>移交-Transition：进行beta测试和部署</li>
</ol>
<h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><h3 id="迭代开发-迭代学习"><a href="#迭代开发-迭代学习" class="headerlink" title="迭代开发+迭代学习"></a>迭代开发+迭代学习</h3><ol>
<li>第一次迭代中介绍一组核心的分析设计主题和表示法</li>
<li>第二次迭代展开介绍新理念、UML表示法和模式</li>
<li>第三次……</li>
</ol>
<h3 id="初始不是需求阶段"><a href="#初始不是需求阶段" class="headerlink" title="初始不是需求阶段"></a>初始不是需求阶段</h3><blockquote>
<p>初始阶段是建立项目共同设想和基本范围的比较简短的起始步骤。</p>
<p>初始阶段的目标并不是定义所有需求</p>
<p>初始阶段作为 UP的第一个阶段也不需要完成所有需求或建立可靠预算和计划。以上内容是在细化的过程中逐步完成的</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251050.png" alt="image-20240419170436795"> </p>
<h3 id="进化式需求"><a href="#进化式需求" class="headerlink" title="进化式需求"></a>进化式需求</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/UML/" data-id="cm7pnj29p003tucv2gdv06s18" data-title="UML期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/公共基础课/电工学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%94%B5%E5%B7%A5%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.254Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%94%B5%E5%B7%A5%E5%AD%A6%E4%B9%A0/">电工学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 align = center> 电工学 </h1>

<h2 id="2-5-结点电压法"><a href="#2-5-结点电压法" class="headerlink" title="2.5 结点电压法"></a>2.5 结点电压法</h2><h3 id="2-5-0-基本概念："><a href="#2-5-0-基本概念：" class="headerlink" title="2.5.0 基本概念："></a>2.5.0 基本概念：</h3><h2 id="2-7-戴维宁定理和诺顿定理"><a href="#2-7-戴维宁定理和诺顿定理" class="headerlink" title="2.7 戴维宁定理和诺顿定理"></a>2.7 戴维宁定理和诺顿定理</h2><h3 id="2-7-0-基本概念："><a href="#2-7-0-基本概念：" class="headerlink" title="2.7.0 基本概念："></a>2.7.0 基本概念：</h3><h4 id="二端网络："><a href="#二端网络：" class="headerlink" title="二端网络："></a>二端网络：</h4><p>有源——有电源</p>
<p>无源——无电源</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920171844352.png" alt="image-20230920171844352" style="zoom:50%;" />

<p><strong>采取的均是等效思想，等效出的电路图对于外部电路效果相同，但是内部并不一定相同</strong></p>
<h4 id="无源二端网络："><a href="#无源二端网络：" class="headerlink" title="无源二端网络："></a>无源二端网络：</h4><p>因没有电源，只需将各部分支路的电阻通过电阻串并联的规律进行等效变换、化简为一个电阻，再与二端网络之外的电阻放在电路图当中进行讨论即可</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920171932963.png" alt="image-20230920171932963" style="zoom:50%;" />

<h4 id="有源二端网络："><a href="#有源二端网络：" class="headerlink" title="有源二端网络："></a>有源二端网络：</h4><p>两个定理重点讨论的对象</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920172618732.png" alt="image-20230920172618732" style="zoom:50%;" />

<p>相对于$R_3$而言，不管$E和R_1和R_2和I_s$有多么复杂，都可以视作一个大电源。则易于进行电路的分析。</p>
<p>无论是恒压源还是恒流源均可，对于外部电路的分析而言并无太大区别，重要的是将复杂的电路进行简单化。</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920172810819.png" alt="image-20230920172810819" style="zoom:50%;" />

<img src="E:\DeskTable\博客学习截图传输\image-20230920173220030.png" alt="image-20230920173220030" style="zoom:50%;" />

<h3 id="2-7-1-戴维宁定理："><a href="#2-7-1-戴维宁定理：" class="headerlink" title="2.7.1 戴维宁定理："></a>2.7.1 戴维宁定理：</h3><p>任何一个有源二端线性网络都可以用一个电压源来等效代替——电动势为E、内阻为$R_0$ </p>
<p>求出E和$R_0$的方法</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920173739240.png" alt="image-20230920173739240" style="zoom: 67%;" />



<h2 id="14半导体器件"><a href="#14半导体器件" class="headerlink" title="14半导体器件"></a>14半导体器件</h2><h3 id="14-1-半导体的导电特性"><a href="#14-1-半导体的导电特性" class="headerlink" title="14.1 半导体的导电特性"></a>14.1 半导体的导电特性</h3><p>半导体的导电特性：</p>
<ol>
<li>热敏性：当环境温度升高时，导电能力显著增强</li>
<li>光敏性：当受到光照时, 导电能力明显变化 </li>
<li>掺杂性：往纯净的半导体中掺入某些杂质,导电能力明显改变</li>
</ol>
<h4 id="14-1-1-本征半导体"><a href="#14-1-1-本征半导体" class="headerlink" title="14.1.1 本征半导体"></a>14.1.1 本征半导体</h4><ol>
<li><p>完全纯净的、具有晶体结构的半导体，称为本征半导体。</p>
</li>
<li><p>本征半导体的导电机理：价电子在获得一定能量(温度升高或受光照)后, 即可挣脱原子核的束缚，成为<mark>自由电子</mark>(带负电), 同时共价键中留下一个空位，称为<mark>空穴</mark>（带正电）。这一现象称为本征激发。</p>
<ol>
<li>当半导体两端加上外电压时，在半导体中将出现两部分电流<ol>
<li>自由电子作定向运动 →电子电流</li>
<li>价电子递补空穴 →空穴电流</li>
</ol>
</li>
<li>自由电子和空穴都称为载流子。</li>
<li>自由电子和空穴成对地产生的同时, 又不断复合。在一定温度下，载流子的产生和复合达到动态平衡，半导体中载流子便维持一定的数目。</li>
</ol>
<p>温度愈高，晶体中产 生的自由电子便愈多。</p>
<p>注意:</p>
<ol>
<li>本征半导体中载流子数目极少, 其导电性能很差；</li>
<li>温度愈高，载流子的数目愈多,半导体的导电性能也就愈好。所以，温度对半导体器件性能影响很大。</li>
</ol>
</li>
<li><p>在外电场的作用下, 空穴<mark>吸引相邻原子</mark>的价电子来填补，而在该原子中出现一个空穴，其结果相当于空穴的运动(相当于正电荷的移动)。</p>
</li>
</ol>
<h4 id="14-1-2-N型半导体和-P-型半导体"><a href="#14-1-2-N型半导体和-P-型半导体" class="headerlink" title="14.1.2 N型半导体和 P 型半导体"></a>14.1.2 N型半导体和 P 型半导体</h4><p>在本征半导体中<mark>掺入微量的杂质</mark> (某种元素) , 形成杂质半导体。</p>
<p>无论N型或P型半导体都是中性的，<mark>对外不显电性</mark>。</p>
<ol>
<li><p>N型</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018092454281.png" alt="image-20231018092454281" style="zoom:50%;" />

<ol>
<li>掺入五价元素,掺杂后自由电子数目大量增加，自由电子导电成为这种半导体的主要导电方式，称为电子半导体或N型半导体。</li>
<li>在N 型半导体中<mark>自由电子是多数载流子</mark>，空穴是少数载流子。</li>
</ol>
</li>
<li><p>P型</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018092508259.png" alt="image-20231018092508259" style="zoom:50%;" />

<ol>
<li>掺入三价元素,掺杂后空穴数目大量增加，空穴导电成为这种半导体的主要导电方式，称为空穴半导体或 P 型半导体。</li>
<li>在P 型半导体中<mark>空穴是多数载流子,</mark> 自由电子是少数载流子。</li>
</ol>
</li>
</ol>
<h3 id="14-2-PN结及其导电性"><a href="#14-2-PN结及其导电性" class="headerlink" title="14.2 PN结及其导电性"></a>14.2 PN结及其导电性</h3><h4 id="14-2-1-PN结的形成"><a href="#14-2-1-PN结的形成" class="headerlink" title="14.2.1 PN结的形成"></a>14.2.1 PN结的形成</h4><img src="E:\DeskTable\博客学习截图传输\image-20231018092821475.png" alt="image-20231018092821475" style="zoom: 25%;" /> 

<ol>
<li><p>形成空间电荷区,空间电荷区也称 PN 结</p>
</li>
<li><p>扩散的结果使空间电荷区变宽。</p>
</li>
<li><p>内电场越强，漂移运动越强，而漂移使空间电荷区变薄。</p>
</li>
<li><p>扩散和漂移这一对相反的运动最终达到动态平衡，空间电荷区的厚度固定不变。</p>
</li>
</ol>
<h4 id="14-2-2-PN结的单向导电性"><a href="#14-2-2-PN结的单向导电性" class="headerlink" title="14.2.2  PN结的单向导电性"></a>14.2.2  PN结的单向导电性</h4><h3 id="14-3-二极管"><a href="#14-3-二极管" class="headerlink" title="14.3 二极管"></a>14.3 二极管</h3><h3 id="14-4-稳压二极管"><a href="#14-4-稳压二极管" class="headerlink" title="14.4 稳压二极管"></a>14.4 稳压二极管</h3><h3 id="14-5-双极型晶体管"><a href="#14-5-双极型晶体管" class="headerlink" title="14.5 双极型晶体管"></a>14.5 双极型晶体管</h3><h3 id="14-6-光电器件"><a href="#14-6-光电器件" class="headerlink" title="14.6 光电器件"></a>14.6 光电器件</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%94%B5%E5%B7%A5%E5%AD%A6%E4%B9%A0/" data-id="cm7pnj29m0039ucv20mraawjc" data-title="电工学" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-校内课程学习笔记/公共基础课/大学物理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.252Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/">大学物理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="14章-静电场"><a href="#14章-静电场" class="headerlink" title="14章 静电场"></a>14章 静电场</h1><h2 id="14-1-电荷-库仑定律"><a href="#14-1-电荷-库仑定律" class="headerlink" title="14-1 电荷 库仑定律"></a>14-1 电荷 库仑定律</h2><h3 id="1-电荷量子化"><a href="#1-电荷量子化" class="headerlink" title="1. 电荷量子化"></a>1. 电荷量子化</h3><ol>
<li><p>种类：正电荷、负电荷</p>
</li>
<li><p>性质：同性相斥、异性相吸</p>
</li>
<li><p>单位：库伦（C）</p>
</li>
<li><p>量子化： $q&#x3D;\pm ne$ </p>
<p>​               $e&#x3D;1.602\times10^{-19}$</p>
</li>
</ol>
<h3 id="2-电荷守恒定律："><a href="#2-电荷守恒定律：" class="headerlink" title="2. 电荷守恒定律："></a>2. 电荷守恒定律：</h3><p>不管系统中的电荷如何迁移，孤立系统的电荷的代数和保持不变（自然界的基本守恒定律之一）</p>
<h4 id="3-库仑定律："><a href="#3-库仑定律：" class="headerlink" title="3. 库仑定律："></a>3. 库仑定律：</h4><ul>
<li><p>真空中两个静止点电荷 相互作用力<strong>F</strong>的大小与这两个点电荷所带电荷 量 $q_1$ 和 $q_2$ 的乘积成正比， 与它们之间的距离<strong>r</strong>的平 方成反比</p>
</li>
<li><p>点电荷：抽象模型</p>
</li>
<li><p>库仑力大小为: $F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{q_1q_2}{r^2}$ 方向:同号相斥,异号相吸 </p>
</li>
<li><p>真空电容率: $\epsilon_0 &#x3D; 8.85\times10^{-12} C^2\cdot m^{-2}$ </p>
</li>
<li><p>两个以上的静止点电荷采用<strong>静电力的叠加原理</strong>:</p>
<ul>
<li>作用于每一个电荷上的总静电力等于其他点电荷单独存在时作 用于该电荷的静电力的矢量和。</li>
<li><img src="E:\DeskTable\博客学习截图传输\image-20231011095200807.png" alt="image-20231011095200807" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h2 id="14-2-电场-电场强度"><a href="#14-2-电场-电场强度" class="headerlink" title="14-2 电场 电场强度"></a>14-2 电场 电场强度</h2><h3 id="1-静电场"><a href="#1-静电场" class="headerlink" title="1. 静电场"></a>1. 静电场</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011095349585.png" alt="image-20231011095349585" style="zoom:50%;" />

<h3 id="2-电场强度"><a href="#2-电场强度" class="headerlink" title="2. 电场强度"></a>2. 电场强度</h3><ul>
<li><p>电场中某点处的电场强度等于位于该点处的单位试验电荷 所受的力，其<strong>方向为正电荷受力方向</strong>.</p>
</li>
<li><p>电场强度大小:$E&#x3D;\frac{F}{q_0}$ </p>
</li>
<li><p>单位: $N \cdot C^{-1}$ 或 $V \cdot m^{-1}$ </p>
</li>
<li><p>电荷在电场中受力: $F&#x3D;qE$</p>
</li>
</ul>
<h3 id="3-点电荷电场强度"><a href="#3-点电荷电场强度" class="headerlink" title="3. 点电荷电场强度"></a>3. 点电荷电场强度</h3><p>知识点和高中相似</p>
<p>$F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Qq_0}{r^2}$	$E &#x3D; \frac{F}{q_0} &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Q}{r^2}$</p>
<h3 id="4-电场强度叠加原理"><a href="#4-电场强度叠加原理" class="headerlink" title="4. 电场强度叠加原理"></a>4. 电场强度叠加原理</h3><p>4-1 点电荷$q_i$ 对 $q_0$ ,在$q_0$ 处的总电场强度:</p>
<ul>
<li>与静电力的叠加原理类似,某个电荷之外的其他电荷在该电荷的电场等于每一个电场强度的矢量和:</li>
<li>$\vec{E} &#x3D; \sum_i \vec{E_i} $</li>
</ul>
<p>4-2 连续电荷在某一点的总电场强度:</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011100812868.png" alt="image-20231011100812868" style="zoom:50%;" />

<p>$d\vec{E} &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r}$	$\vec{E} &#x3D; \int d \vec{E} &#x3D; \int \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r} $</p>
<p>体密度: $\rho &#x3D; \frac{dq}{dV}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101609517.png" alt="image-20231011101609517" style="zoom:50%;" /></p>
<p>面密度: $\sigma &#x3D; \frac{dq}{dS}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101549342.png" alt="image-20231011101549342" style="zoom: 50%;" /></p>
<p>线密度: $ \lambda &#x3D; \frac{dq}{dl} $ <img src="E:\DeskTable\博客学习截图传输\image-20231011101526062.png" alt="image-20231011101526062" style="zoom: 50%;" /></p>
<h3 id="5-外电场对电偶极子的力矩和取向作用"><a href="#5-外电场对电偶极子的力矩和取向作用" class="headerlink" title="5. 外电场对电偶极子的力矩和取向作用"></a>5. 外电场对电偶极子的力矩和取向作用</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011101656283.png" alt="image-20231011101656283" style="zoom:150%;" />

<p>相距很近,等量异号的点电荷系:</p>
<p>​	电距: $\vec{P} &#x3D; q \vec{l} $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011102016383.png" alt="image-20231011102016383" style="zoom: 67%;" />

<p>匀强电场中:</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231011102128247.png" alt="image-20231011102128247"></p>
<p>$\vec{F} &#x3D; \vec{F_+} + \vec{F_-} &#x3D; q\vec{E} - q\vec{E} &#x3D; 0$</p>
<p>$M &#x3D; q r_0 E \sin{\theta} &#x3D; pE\sin{\theta}$ </p>
<p>$\vec{M} &#x3D; \vec{p} \times \vec{E} \left{<br>\begin{array}{l}<br>\theta &#x3D; 0 \<br>\theta &#x3D; \pi<br>\end{array}<br>\right.$		$\vec{M} &#x3D; 0$</p>
<h2 id="14-3-电场强度通量-高斯定理"><a href="#14-3-电场强度通量-高斯定理" class="headerlink" title="14-3 电场强度通量 高斯定理"></a>14-3 电场强度通量 高斯定理</h2><h3 id="1-电场线"><a href="#1-电场线" class="headerlink" title="1. 电场线"></a>1. 电场线</h3><p>为了直观可视化描述电场</p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231011103714950.png" alt="image-20231011103714950"></p>
<ul>
<li>曲线上每一点切线方向为该点电场方向</li>
<li>通过垂直于电场方向单位面积的电场线的条数为该电场强度的大小      $|\vec{E}| &#x3D; E &#x3D; \frac{dN}{dS_{\perp}}$</li>
</ul>
<p>多种点电荷电场线,与高中无异</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>始于正电荷,终于负电荷(来自无穷远,去向无穷远) 在没有电荷的地方不中断</li>
<li>没有电荷的地方任意两条电场线不相交</li>
<li>电场线不闭合</li>
<li>电场线密集——电场强度较大；电场线稀疏——电场强度较小</li>
</ol>
<h3 id="2-电场强度通量"><a href="#2-电场强度通量" class="headerlink" title="2. 电场强度通量"></a>2. 电场强度通量</h3><p>通过电场中某一个面的电场线数叫做通过这个面的电场强度通量</p>
<ul>
<li><p>匀强电场:</p>
<ul>
<li><p>$\vec{E}$ 与平面垂直</p>
<p>$\Phi_e &#x3D; ES$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104246049.png" alt="image-20231011104246049"  /> </p>
</li>
<li><p>$\vec{E} $ 与平面夹角为$\theta$<br>$\Phi_e &#x3D; ES \cos{\theta} $    $\Phi_e &#x3D; \vec{E} \cdot \vec{S}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104550268.png" alt="image-20231011104550268"></p>
</li>
</ul>
</li>
<li><p>非均匀电场</p>
<ul>
<li><p>$ d \vec{S} &#x3D; dS \cdot \vec{e_n}$</p>
</li>
<li><p>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</p>
</li>
<li><p>$ \Phi_e &#x3D; \int d \Phi_e &#x3D; \int_S E \cos{\theta} dS $</p>
</li>
<li><p>$ \Phi_e &#x3D; \int_S \vec{E} \cdot d\vec{S} $</p>
</li>
<li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105921724.png" alt="image-20231011105921724"></p>
</li>
<li><p>S为封闭曲面时:</p>
<ul>
<li><p>$\theta_1 &lt; \frac{\pi}{2} , d\Phi_{e1} &gt; 0 $</p>
</li>
<li><p>$ \theta_2 &gt; \frac{\pi}{2}, d\Phi_{e2} &lt; 0$</p>
</li>
<li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105912608.png" alt="image-20231011105912608"></p>
</li>
</ul>
</li>
<li><p>闭合曲面的电场强度通量</p>
<ul>
<li>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</li>
<li>$ \oint_S \vec{E} \cdot d \vec{S} &#x3D; \oint_S E \cos{\theta} dS $</li>
<li><img src="E:\DeskTable\博客学习截图传输\image-20231011105852809.png" alt="image-20231011105852809"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-高斯定理"><a href="#3-高斯定理" class="headerlink" title="3. 高斯定理"></a>3. 高斯定理</h3><p>在真空中,通过任一闭合曲面的电场强度通量, 等于该曲面所包围的所有电荷的代数和除以 $\epsilon_0$ （与面外电荷无关，闭合曲面称为高斯面）</p>
<p>$ \Phi_e &#x3D; \oint_S \vec{E} \cdot d \vec{S} &#x3D; \frac{1}{\epsilon_0} \sum^n_{i&#x3D;1} q_i^{in}$  </p>
<p>由<strong>库仑定律</strong>和<strong>电场强度叠加原</strong>理可以导出<strong>高斯定理</strong></p>
<ul>
<li><p>闭合面外的电荷对通过闭合 面的电场强度通量没有贡献，但是对闭合面上各点的电场强度是有贡献的，即闭合面上各点的电场强度是由闭合面内、外所有电 荷共同激发的</p>
</li>
<li><p>高斯定理将静电场与场源电荷联系了起来，揭示了静电场是有源场这一普遍性质(静电场有源无旋)</p>
</li>
</ul>
<h3 id="4-高斯定理的应用"><a href="#4-高斯定理的应用" class="headerlink" title="4. 高斯定理的应用"></a>4. 高斯定理的应用</h3><p>应用条件:</p>
<ol>
<li><p>静电场必须具有一定的对称性</p>
</li>
<li><p>根据对称性选择高斯面</p>
</li>
<li><p>高斯面上的场强处处相等或者分区域相等;</p>
<p>部分高斯面上的通量为零,部分高斯面上的场强相等</p>
</li>
<li><p>先使用高斯定理求出电场强度通量,而后用高斯定理,配合闭合曲面大小求出电场强度</p>
</li>
</ol>
<h2 id="14-4-静电场的环路定理-电势"><a href="#14-4-静电场的环路定理-电势" class="headerlink" title="14-4 静电场的环路定理 电势"></a>14-4 静电场的环路定理 电势</h2><h4 id="1-静电场力所做的功"><a href="#1-静电场力所做的功" class="headerlink" title="1. 静电场力所做的功"></a>1. 静电场力所做的功</h4><p>点电荷的电场</p>
<p>$dA &#x3D; q_0 \vec{E} \cdot \vec{l} &#x3D; q_0E \cdot dl \cdot \cos{\theta} $</p>
<p>​	  $&#x3D;q_0 \frac{q}{4 \pi \epsilon_0 r^2} \cdot dl \cdot \cos{\theta} $</p>
<p>$dl \cos{\theta} &#x3D; dr$</p>
<p>$dA &#x3D; \frac{q_0q}{4 \pi \epsilon_0 r^2} dr$</p>
<p>$A&#x3D; \frac{q_0q}{4 \pi \epsilon_0} \int^{r_B}_{r_A} \frac{dr}{r^2} &#x3D; \frac{q_0q}{4 \pi \epsilon_0}(\frac{1}{r_A} - \frac{1}{r_B})$</p>
<p>所做的功<strong>A</strong> 仅和 $q_0$ 的始末位置有关,与路径无关(积分与路径无关)</p>
<p>即可得:</p>
<p>$ \vec{E} &#x3D; \sum \vec{E_i} $ (点电荷的组合)</p>
<p>$ A &#x3D; \int_l q_0 \vec{E} \cdot d \vec{l} &#x3D; \sum_i q_0 \cdot \int_l \vec{E_i} \cdot d \vec{l} $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011121105020.png" alt="image-20231011121105020" style="zoom: 67%;" />

<h4 id="2-静电场的环路定理"><a href="#2-静电场的环路定理" class="headerlink" title="2. 静电场的环路定理"></a>2. 静电场的环路定理</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20231011123130536.png" alt="image-20231011123130536"></p>
<p>$ q_0 \int_{ABC} \vec{E} \cdot d \vec{l} &#x3D; q_0 \int_{ADC} \cdot d \vec{l} $</p>
<p>$ q_0(\int_{ABC} \vec{E} \cdot d \vec{l} - \int_{ADC} \vec{E} \cdot d \vec{l}) &#x3D; 0 $</p>
<p>静电场是保守场,沿闭合路径一周,电场力做功为零</p>
<h1 id="16章-稳恒磁场"><a href="#16章-稳恒磁场" class="headerlink" title="16章 稳恒磁场"></a>16章 稳恒磁场</h1><h2 id="16-1"><a href="#16-1" class="headerlink" title="16-1"></a>16-1</h2><h3 id="1-电流电流密度"><a href="#1-电流电流密度" class="headerlink" title="1. 电流	电流密度"></a>1. 电流	电流密度</h3><h4 id="1-1形成电流的条件："><a href="#1-1形成电流的条件：" class="headerlink" title="1.1形成电流的条件："></a>1.1形成电流的条件：</h4><ul>
<li><p>在导体内有可以自由移动的电荷（载流子） </p>
</li>
<li><p>在导体内要维持一个电场，或者在导体两端要存在有电势差\</p>
</li>
</ul>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231011192022160.png" alt="image-20231011192022160"></p>
<p>电流强度：通过截面<strong>S</strong>的电荷随时间的变化率</p>
<p>$I &#x3D; \frac{dq}{dt} $		</p>
<p>$dq &#x3D; qnudtS$ 		</p>
<ul>
<li>$q$ 载流子电荷</li>
<li>$n$ 载流子浓度 </li>
<li>$\vec{u}$ 载流子漂移速度 	$u$ 电子漂移速度的大小</li>
</ul>
<p>$dI &#x3D; qnudS_{\perp} &#x3D; qnudS \cos{theta} &#x3D; qn \vec{u} \cdot d \vec{S} &#x3D; \vec{j} \cdot \textbf{d} \vec{S} $  </p>
<p>电流密度矢量大小: $j &#x3D; \frac{dI}{d S_{\perp}} &#x3D; qnu$ 方向为该点正电荷运动方向,单位: $A \cdot m^{-2}$ </p>
<p>通过任意曲面的电流: $I &#x3D; \int_S \vec{j} \cdot d \vec{S}$ </p>
<h4 id="1-2-电流的连续性方程稳恒电流条件"><a href="#1-2-电流的连续性方程稳恒电流条件" class="headerlink" title="1.2 电流的连续性方程	稳恒电流条件"></a>1.2 电流的连续性方程	稳恒电流条件</h4><p>单位时间内通过闭合曲面向外流出的电荷，等于此时间内闭合曲面内电荷的减少量.</p>
<p>电流密度矢量点乘闭合曲面面积矢量微元即是此刻在该处曲面的电流的微元</p>
<p>$ dI &#x3D; \vec{j} \cdot d \vec{S}$ $I &#x3D; \oint_S \vec{j} \cdot d \vec{S} &#x3D; \frac{dq_外}{dt} &#x3D; -\frac{dq_内}{dt} $</p>
<p>某一时刻,单位闭合曲面 <em>S</em> 内,流入的电荷量与流出的电荷量相互抵消——即闭合曲面 <em>S</em> 内部的电荷不随时间的变化而变化，则</p>
<p>$ \frac{d q_内}{dt} &#x3D; 0$ </p>
<p>稳恒电流	$ \oint_S \vec{j} \cdot d \vec{S} &#x3D; 0$ </p>
<p>导体内的电流密度不随时间变化的电流</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011201203610.png" alt="image-20231011201203610" style="zoom:50%;" />

<p>由基尔霍夫第一定律:	$ -I+I_1+I_2&#x3D;0 $ </p>
<ol>
<li>在稳恒电流情况下，导体中电荷分布不随时间变化形成恒定电场</li>
<li>稳恒电场与<mark>静电场具有相似性质</mark>（高斯定理和环路定理），同时稳恒电场引入了电势概念</li>
<li>稳恒电场存在<mark>能量的转换</mark>（很正常，带电体在电场内会做功或者被做功，则必然伴随着$势能 \rightleftharpoons 动能$）</li>
</ol>
<p>$U &#x3D; IR$ 	$R &#x3D; \rho \frac{l}{s}$</p>
<h4 id="1-3-欧姆定律的微分形式"><a href="#1-3-欧姆定律的微分形式" class="headerlink" title="1.3 欧姆定律的微分形式"></a>1.3 欧姆定律的微分形式</h4><img src="E:\DeskTable\博客学习截图传输\image-20231012000103917.png" alt="image-20231012000103917" style="zoom:67%;" />

<p>$dI &#x3D; \frac{dU}{R}$ 	$R &#x3D; \frac{\rho dl}{dS} $ </p>
<p>$dI &#x3D; \frac{1}{\rho} \frac{dU}{dl} dS$ </p>
<p>$\frac{dI}{dS} &#x3D; \frac{1}{\rho} \frac{dU}{dl} &#x3D; \frac{1}{\rho} E &#x3D; \sigma E$ </p>
<p>$\vec{j} &#x3D; \frac{dI}{dS} &#x3D; \frac{1}{\rho} \vec{E} &#x3D; \sigma \vec{E}$ </p>
<p>非静电力：能不断分离正负电荷使正电荷逆静电场力方向运动</p>
<p>电源：提供非静电力的装置</p>
<p>非静电电场强度 $\vec{E_k}$ : 为单位正电荷所受的非静电力.</p>
<p>$A_非 &#x3D; \int^+_- q \vec{E_k} \cdot d \vec{l} $ </p>
<p>电动势的定义：单位正电荷从负极通过电源内部移到正极时非静电力所做的功.</p>
<p>电动势是电路中电荷流动的驱动力</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231012081945376.png" alt="image-20231012081945376" style="zoom:50%;" />

<p>计算电动势的两种不同描述:</p>
<ol>
<li><p>基于电荷在已知电场中的移动</p>
<ul>
<li>这个公式表示了电场 $\vec{E_k}$ 在电荷 $q$ 移动的路径上执行的功，然后将这个功除以电荷的大小 $q$，得到电动势 $\epsilon$。这是电动势的一种定义方式，其中 $\vec{E_k}$ 是电场力，$d\vec{l}$ 是电荷移动路径上的微小位移，而 $\int_{+}^{-}$ 表示要对电荷从一个点移动到另一个点的路径上进行积分。</li>
<li>$ \epsilon &#x3D; \frac{A_非}{q} &#x3D; \int^+_- \vec{E_k} \cdot d \vec{l}$</li>
</ul>
</li>
<li><p>考虑电荷周围存在其他电场情况</p>
<ul>
<li>这个公式表示电场 $\vec{E_k}$ 和一个额外电场 $\vec{E}$ 一起对电荷 $q$ 执行的功的总和。在这里，$\vec{E_k}$ 是由于电荷本身产生的电场，而 $\vec{E}$ 可能是由外部因素产生的电场，如其他电荷或电场源。这个公式采用了环路积分的形式，表示对电荷沿着闭合路径 $l$ 移动时，电场 $\vec{E_k}$ 和 $\vec{E}$ 执行的总功。</li>
<li>$\epsilon &#x3D; \oint_l (\vec{E_k} + \vec{E}) \cdot d \vec{l}$</li>
</ul>
</li>
</ol>
<h2 id="16-2-磁场和磁感应强度"><a href="#16-2-磁场和磁感应强度" class="headerlink" title="16-2 磁场和磁感应强度"></a>16-2 磁场和磁感应强度</h2><h3 id="1-磁感应强度"><a href="#1-磁感应强度" class="headerlink" title="1. 磁感应强度"></a>1. 磁感应强度</h3><h4 id="1-1磁感应强度的定义"><a href="#1-1磁感应强度的定义" class="headerlink" title="1.1磁感应强度的定义:"></a>1.1磁感应强度的定义:</h4><p>当正电荷垂直于特定直线运动时，受力$\vec{F_{max}}$ 将$\vec{F_{max}} \times \vec{v}$ 方向定义为该点的$ \vec{B}$ 的方向.</p>
<p>磁感强度大小: $B&#x3D;\frac{F_{max}}{qv} $</p>
<p>运动电荷在磁场中受力(洛伦兹力),受力大小为:<br>$ \vec{F} &#x3D; q \vec{v} \times \vec{B}$ </p>
<img src="E:\DeskTable\博客学习截图传输\image-20231012083921021.png" alt="image-20231012083921021" style="zoom:50%;" />

<p>单位:特斯拉 $ 1T &#x3D; 1 N \cdot (A \cdot m)^{-1}$</p>
<h4 id="1-2-磁感线-有旋无源"><a href="#1-2-磁感线-有旋无源" class="headerlink" title="1.2 磁感线(有旋无源)"></a>1.2 磁感线(有旋无源)</h4><ol>
<li>理想模型,规定:曲线上每一点的切线方向就是该点的磁感强度<em>B</em>的方向,曲线的疏密程度表示该点的磁感强度<em>B</em>的大小.</li>
</ol>
<img src="E:\DeskTable\博客学习截图传输\image-20231012084013228.png" alt="image-20231012084013228" style="zoom:67%;" />

<ol start="2">
<li>性质:<ul>
<li>与电流套连 </li>
<li>闭合曲线 </li>
<li>方向与电流成右手螺旋关系</li>
</ul>
</li>
</ol>
<h2 id="16-3-毕奥-萨伐尔定律-磁生电"><a href="#16-3-毕奥-萨伐尔定律-磁生电" class="headerlink" title="16-3 毕奥-萨伐尔定律(磁生电)"></a>16-3 毕奥-萨伐尔定律(磁生电)</h2><h3 id="1-电流元在空间产生的磁场"><a href="#1-电流元在空间产生的磁场" class="headerlink" title="1. 电流元在空间产生的磁场"></a>1. 电流元在空间产生的磁场</h3><img src="E:\DeskTable\博客学习截图传输\image-20231012091229844.png" alt="image-20231012091229844" style="zoom:50%;" />

<p>$dB &#x3D; \frac{\mu_0}{4 \pi} \frac{I dl \sin{\theta}}{r^2}$	$\rightarrow$	$d\vec{B} &#x3D; \frac{\mu_0}{4 \pi} \frac{I d\vec{l} \times \vec{r}}{r^3} $</p>
<p>$\mu_0 为真空电导率,\mu_0 &#x3D; 4 \pi \times 10^{-7} N \cdot A^{-2}$</p>
<p>任意载流导线在点 <strong>P</strong> 处的磁感强度</p>
<p>磁感强度叠加:	$\vec{B} &#x3D; \int d \vec{B} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \vec{r}}{r^3} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \hat{r}}{r^2} $ </p>
<ol>
<li><p>$\vec{B}$ 表示磁场矢量，它是一个矢量，表示在某个点上的磁场强度和方向。</p>
</li>
<li><p>$\int d\vec{B}$ 表示对磁场矢量 $\vec{B}$ 进行积分，通常表示对整个区域的磁场进行积分以获得某一点的总磁场。</p>
</li>
<li><p>$\mu_0$ 是真空磁导率。</p>
</li>
<li><p>$I$ 表示电流，它是电流环中的电流。</p>
</li>
<li><p>$d\vec{B}$ 表示磁场小微元，即微小部分的磁场，通常由微小电流元素产生。</p>
</li>
<li><p>$\vec{r}$ 是位置矢量，表示观察点到电流元素的距离。</p>
</li>
<li><p>$d\vec{l}$ 表示电流元素的微小位移，即在电流环上的微小长度元素。</p>
</li>
<li><p>$\times$ 表示矢量叉积，产生一个垂直于 $d\vec{l}$ 和 $\vec{r}$ 的磁场矢量。</p>
</li>
<li><p>$r$ 表示观察点到电流微元的距离大小。</p>
</li>
<li><p>$\hat{r}$ 是单位矢量，指向观察点到电流元素的方向。</p>
<p>一个非零向量 $\vec{r}$的 <strong>正规化向量</strong> $\hat{r}$ 就是平行于$\vec{r}$的单位向量： $\hat{r} &#x3D; \frac{r}{|| \vec{r} ||}$</p>
</li>
</ol>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231016085221183.png" alt="image-20231016085221183"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231016085317033.png" alt="image-20231016085317033" style="zoom:50%;" />  <img src="E:\DeskTable\博客学习截图传输\image-20231016090631799.png" alt="image-20231016090631799" style="zoom: 33%;" /> </p>
<p>载流导线<em>CD</em> 产生磁感强度 $\vec{B}$ ,$I d\vec{l}$ 在P点产生$d\vec{B}$ ,方向垂直于纸面向里(即所有电流元在P点产生的磁感强度小微元方向均相同):</p>
<p>又 $dB &#x3D; \frac{\mu_0 I dl \sin{\alpha}}{4 \pi r^2}$ ,为了后续的计算,需要进行变量的统一,将线变量转换成角变量</p>
<p>$l &#x3D; \frac{\cos{\beta}}{\sin{\beta}} \Rightarrow dl &#x3D; d \sec^2{\beta} d\beta$  			$r &#x3D; d \sec{\beta}$ 		$\sin{\alpha} &#x3D; \cos{\beta} &#x3D; \frac{d}{r} $ </p>
<p>$B &#x3D; \int^{\beta_2}<em>{\beta_1} \frac{\mu_0}{4 \pi} \frac{I d \sec^2{\beta} \cos{\beta} d\beta }{d^2 \sec^2{\beta}} &#x3D; \frac{\mu_0I}{4 \pi d} \int^{\beta_2}</em>{\beta_1} \cos{\beta} d\beta &#x3D; \frac{\mu_0I}{4 \pi d}(\sin{\beta_2}-\sin{\beta_1}) $</p>
<p>​    $&#x3D; \frac{\mu_0I}{4 \pi d}(\cos{\alpha_1}-\cos{\alpha_2})$  </p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092407037.png" alt="image-20231016092407037" style="zoom: 50%;" /> 

<p>电流和磁感强度成 <mark>右手螺旋定则</mark>  </p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092546084.png" alt="image-20231016092546084" style="zoom:40%;" />

<p><img src="E:\DeskTable\博客学习截图传输\image-20231016092604543.png" alt="image-20231016092604543" style="zoom:40%;" />  <img src="E:\DeskTable\博客学习截图传输\image-20231016092705072.png" alt="image-20231016092705072" style="zoom:40%;" /></p>
<h3 id="3-磁偶极矩"><a href="#3-磁偶极矩" class="headerlink" title="3. 磁偶极矩"></a>3. 磁偶极矩</h3><p>$ \vec{m} &#x3D; IS \vec{e_n} $ </p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092744912.png" alt="image-20231016092744912" style="zoom:50%;" /> 



<h1 id="17-带电粒子在电场和磁场中的运动"><a href="#17-带电粒子在电场和磁场中的运动" class="headerlink" title="17 带电粒子在电场和磁场中的运动"></a>17 带电粒子在电场和磁场中的运动</h1><h2 id="17-1-带电粒子在电场和磁场中所受的力"><a href="#17-1-带电粒子在电场和磁场中所受的力" class="headerlink" title="17-1 带电粒子在电场和磁场中所受的力"></a>17-1 带电粒子在电场和磁场中所受的力</h2><p>电场力：$\vec{F_e} &#x3D; q\vec{E}$ </p>
<p>磁场力(洛伦兹力): $\vec{F_m} &#x3D; q \vec{v} \times \vec{B} $ </p>
<p>运动电荷在电场和磁场中受的力: $\vec{F} &#x3D; q\vec{E} + q \vec{v} \times \vec{B}$ </p>
<h3 id="1-带电粒子在均匀磁场中的运动举例"><a href="#1-带电粒子在均匀磁场中的运动举例" class="headerlink" title="1.带电粒子在均匀磁场中的运动举例"></a>1.带电粒子在均匀磁场中的运动举例</h3><h4 id="1-回旋半径和回旋频率"><a href="#1-回旋半径和回旋频率" class="headerlink" title="1. 回旋半径和回旋频率"></a>1. 回旋半径和回旋频率</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20231016100903128.png" alt="image-20231016100903128"></p>
<p>$\vec{v_0} \perp \vec{B} $	$q \vec{v_0} B &#x3D; m \frac{v_0^2}{R} $	$R &#x3D; \frac{mv_0}{qB}$ </p>
<p>$T &#x3D; \frac{2 \pi R}{v_0} &#x3D; \frac{2 \pi m}{qB}$ 		$ f&#x3D;\frac{1}{T} &#x3D; \frac{qB}{2 \pi m} $ </p>
<h4 id="2-速度选择器"><a href="#2-速度选择器" class="headerlink" title="2. 速度选择器"></a>2. 速度选择器</h4><img src="E:\DeskTable\博客学习截图传输\image-20231016101428001.png" alt="image-20231016101428001" style="zoom:50%;" /> 

<h4 id="3-质谱仪"><a href="#3-质谱仪" class="headerlink" title="3. 质谱仪"></a>3. 质谱仪</h4><img src="E:\DeskTable\博客学习截图传输\image-20231016101510210.png" alt="image-20231016101510210" style="zoom:50%;" /> 

<h4 id="4-回旋加速器"><a href="#4-回旋加速器" class="headerlink" title="4. 回旋加速器"></a>4. 回旋加速器</h4><img src="E:\DeskTable\博客学习截图传输\image-20231016101533592.png" alt="image-20231016101533592" style="zoom:50%;" /> 

<h3 id="2-磁聚焦"><a href="#2-磁聚焦" class="headerlink" title="2. 磁聚焦"></a>2. 磁聚焦</h3><p>洛伦兹力不做功</p>
<p>$ \vec{F_m} &#x3D; q \vec{v} \times \vec{B} $ 	$\vec{v} &#x3D; \vec{v_{\parallel}} + \vec{v_{\perp}}$ </p>
<p>$\vec{v_{\perp}} &#x3D; \frac{qBR}{m}$ 	$T &#x3D; \frac{2 \pi R}{\vec{v_{\perp}}} &#x3D; \frac{2 \pi R m}{qBR} &#x3D; \frac{2 \pi m}{qB}$ </p>
<p>螺距: $ d &#x3D; v_{\parallel} T&#x3D; v \cos{\theta} (\frac{2 \pi m }{qB})$  </p>
<h3 id="3-霍尔效应"><a href="#3-霍尔效应" class="headerlink" title="3. 霍尔效应"></a>3. 霍尔效应</h3><img src="E:\DeskTable\博客学习截图传输\image-20231016102845418.png" alt="image-20231016102845418" style="zoom:67%;" />

<img src="E:\DeskTable\博客学习截图传输\image-20231016102813922.png" alt="image-20231016102813922" style="zoom:67%;" />



<h2 id="18-磁介质"><a href="#18-磁介质" class="headerlink" title="18 磁介质"></a>18 磁介质</h2><h3 id="18-1-磁介质及其分类"><a href="#18-1-磁介质及其分类" class="headerlink" title="18.1 磁介质及其分类"></a>18.1 磁介质及其分类</h3><p>磁介质中的磁感应强度：</p>
<p>$\vec{B}&#x3D;\vec{B_0} + \vec{B’}$		$B &#x3D; \mu_r B_0$ <img src="E:\DeskTable\博客学习截图传输\image-20231018104714589.png" alt="image-20231018104714589" style="zoom: 25%;" /></p>
<table>
<thead>
<tr>
<th align="center">磁介质种类</th>
<th align="center">种类</th>
<th align="center">温度</th>
<th align="center">相对磁导率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\mu_r &lt; 1$</td>
<td align="center">铋 汞 铜 氢(气)</td>
<td align="center">293K 293K 293K</td>
<td align="center">1-16.6×10-5 1-2.9×10 -5 1-1.0×10-5 1-3.89×10-5</td>
</tr>
<tr>
<td align="center">$\mu_r &gt; 1$</td>
<td align="center">氧（液） 氧（气） 铝 铂</td>
<td align="center">90K 293K 293K 293K</td>
<td align="center">1+769.9×10 -5 1+334.9×10-5 1+1.65×10-5 1+26.0×10-5</td>
</tr>
<tr>
<td align="center">$\mu_r &gt;&gt;1$</td>
<td align="center">铸钢 铸铁 硅钢 坡莫合金</td>
<td align="center"></td>
<td align="center">2.2×10 3（最大值） 4×10 2（最大值） 7×10 2（最大值） 1×105（最大值）</td>
</tr>
<tr>
<td align="center">$\mu_r &#x3D; 0$</td>
<td align="center">汞 铌</td>
<td align="center">小于4.15K 小于9.26K</td>
<td align="center">0 0</td>
</tr>
</tbody></table>
<h3 id="18-1-2-分子磁矩"><a href="#18-1-2-分子磁矩" class="headerlink" title="18.1.2 分子磁矩"></a>18.1.2 分子磁矩</h3><ol>
<li><p>从经典物理角度进行分析</p>
<p>经典理论：组成分子或原子中的电子，不仅存在绕原子核的轨道运动，还存在自旋运动。这两种运动都能产生磁效应。把分子或原子看作一个整体，分子或原子中各电子对外产生磁效应的总和，可等效于一个圆电流，称为“分子电流” 。分子电流的磁矩称为“分子磁矩” 。</p>
<p>电子具有的两种磁矩:</p>
<ol>
<li><p>电子轨道磁矩: $\vec{p_m} &#x3D; -\frac{e}{2m} \vec{L} $ </p>
</li>
<li><p>电子自旋磁矩: $\vec{p_s} &#x3D; - \frac{e}{m} \vec{S}$</p>
</li>
</ol>
</li>
<li><p>分子附加磁矩:当磁介质处于外磁场中时，每个分子产生与<mark>外磁场方向相反</mark>的附加磁矩</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018110837487.png" alt="image-20231018110837487" style="zoom: 33%;" /></li>
</ol>
<h3 id="18-1-3-顺磁质和抗磁质的磁化"><a href="#18-1-3-顺磁质和抗磁质的磁化" class="headerlink" title="18.1.3 顺磁质和抗磁质的磁化"></a>18.1.3 顺磁质和抗磁质的磁化</h3><ol>
<li><p>顺磁质	存在分子的固有磁矩<br>(严格来说,顺磁质也具有抗磁矩,但是比固有磁矩小得多,因而忽略不计)</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018111601536.png" alt="image-20231018111601536" style="zoom: 33%;" />
</li>
<li><p>抗磁质<br>无外磁场时分子磁矩为零 $\vec{m} &#x3D; 0$<br>加外磁场后分子产生附加磁矩（与外磁场方向相反）<br>抗磁质内磁场 $B &#x3D;  B_0 -B &lt; B_0 $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018112211691.png" alt="image-20231018112211691" style="zoom:33%;" /> 
</li>
<li><p>磁化电流和磁化强度</p>
<p>介质磁化以后，由于分子磁矩的有序排列，其宏观效果是在介质表面出现环形电流，这种电流称为”磁化电流( $I_s$ )”</p>
<p>长直螺线管为例:</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018112509239.png" alt="image-20231018112509239" style="zoom: 50%;" /></li>
</ol>
<h3 id="18-2-磁介质中的安培环路定理"><a href="#18-2-磁介质中的安培环路定理" class="headerlink" title="18-2 磁介质中的安培环路定理"></a>18-2 磁介质中的安培环路定理</h3><p>2.1 有磁介质存在时的高斯定理</p>
<p>$\oint_S \vec{B} \cdot d\vec{S} &#x3D; \oint_S(\vec{B_0}+\vec{B’}) \cdot d\vec{S} &#x3D; 0$ </p>
<p>2.2 有磁介质存在时的安培环路定理</p>
<p>$\oint \vec{B} \cdot d \vec{l} &#x3D; \mu_0(\sum I + \sum I_s) &#x3D; \mu_0(\sum I + \oint_L \vec{M}\cdot d \vec{l})$ </p>
<p>则有: $\oint_L(\frac{\vec{B}}{\mu_0} - \vec{M})\cdot d \vec{l} &#x3D; \sum I $ </p>
<p>定义”磁场强度” $\vec{H} &#x3D; \frac{\vec{B}}{\mu_0} - \vec{M}$		由 $\vec{M} &#x3D; \chi_m \vec{H} $ </p>
<p>则有: $\vec{H} &#x3D; \frac{\vec{B}}{\mu_0} - \vec{M} &#x3D; \frac{\vec{B}}{\mu_0} - \chi_m \vec{H} $ </p>
<p>$ \vec{B} &#x3D; \mu_0(1+\chi_m) \vec{H} &#x3D; \mu_0 \mu_r \vec{H} $ </p>
<p>$\mu_r &#x3D; 1+\chi_m $ 称为磁介质的”相对磁导率”</p>
<p>$\mu &#x3D; \mu_0 \mu_r $ 称为磁导率</p>
<p>$\oint_L \vec{B} \cdot d \vec{l} &#x3D; \mu \sum I$ </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/" data-id="cm7pnj29m003bucv2674e96wd" data-title="大学物理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库/SQL语句练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.243Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/">SQL语句练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL语句练习"><a href="#SQL语句练习" class="headerlink" title="SQL语句练习"></a>SQL语句练习</h1><h2 id="1378"><a href="#1378" class="headerlink" title="1378"></a>1378</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/">使用唯一标识码替换员工ID</a></p>
<p><code>Employees</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，id 是这张表的主键。</span><br><span class="line">这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。</span><br></pre></td></tr></table></figure>

<p><code>EmployeeUNI</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，(id, unique_id) 是这张表的主键。</span><br><span class="line">这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。</span><br></pre></td></tr></table></figure>

<p>展示每位用户的 <strong>唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p>
<p>你可以以 <strong>任意</strong> 顺序返回结果表。</p>
<p>返回结果的格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employees 表:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line">EmployeeUNI 表:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line">输出：</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line">解释：</span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure>



<p><strong>ANSWER：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> en.unique_id , e.name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Employees <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> EmployeeUNI <span class="keyword">as</span> en</span><br><span class="line"><span class="keyword">on</span> e.id <span class="operator">=</span> en.id</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<p>本题为联表查询，个人认为难点在于如何将 <code>unique_id</code> 填充为 <code>null</code>，同时为了保证员工姓名这一行保留，因而可以使用左结合，以id作为结合条件，而如果在EmployeeUNI不存在的也会给unique_id填充null。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/" data-id="cm7pnj291000cucv2aa2q1cxj" data-title="SQL语句练习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库/Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.242Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">redis基础篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis基础篇"><a href="#Redis基础篇" class="headerlink" title="Redis基础篇"></a>Redis基础篇</h1><p>NoSQL(No Structed Query Language)：</p>
<p>非关系形（非结构化的）数据库</p>
<p>redis是一个基于内存的key-value的数据库，key一般为String类型，value类型多样： String,Hash,List,Set,SortedSet,GEO,BitMap,Hyperlog</p>
<p>​	</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ol>
<li>数字类型<code>int</code>,<code>float</code>的字符串存储时转换为二进制码进行存储</li>
<li>真正的字符串则是转换成字节码进行存储</li>
</ol>
<p><strong>常见指令：</strong></p>
<ul>
<li><code>set</code>:</li>
<li><code>get</code>:</li>
<li><code>mset</code>:</li>
<li><code>mget</code>:</li>
<li><code>incr</code>:</li>
<li><code>incrbyfloat</code></li>
<li><code>incrby steps</code>:</li>
<li><code>decr</code>:</li>
<li><code>decrby steps</code>:</li>
<li><code>setnx</code>:</li>
<li><code>setex</code>:</li>
</ul>
<h3 id="key的层级结构"><a href="#key的层级结构" class="headerlink" title="key的层级结构"></a>key的层级结构</h3><blockquote>
<p>使用：项目名：业务名：类型：key</p>
</blockquote>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><ul>
<li><p><code>hset key field value</code></p>
</li>
<li><p><code>hget key field</code>：获取</p>
</li>
<li><p><code>hmset key field value</code>：设置一个hash类型的key和field的value</p>
</li>
<li><p><code>hmget key field</code>：获取key中的多个field及其value</p>
</li>
<li><p><code>hgetall key</code>：获取key中所有的field和value</p>
</li>
<li><p><code>hkeys </code>：获取key中所有的filed</p>
<ul>
<li><pre><code class="language-livescript">127.0.0.1:6379[1]&gt; hkeys heima:user:1
1) &quot;name&quot;
2) &quot;age&quot;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `hvals`：获取key中所有的value</span><br><span class="line"></span><br><span class="line">  - ```livescript</span><br><span class="line">    127.0.0.1:6379[1]&gt; hvals heima:user:1</span><br><span class="line">    1) &quot;heima&quot;</span><br><span class="line">    2) &quot;18&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><code>hincrby steps</code>：让一个hash类型的key的字段自增并指定步长</p>
</li>
<li><p><code>hsetnx</code>：添加一个hash类型的key和field（field需要不存在，否则不执行）</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><ul>
<li><code>sadd key member</code>:向一个set容器中添加元素</li>
<li><code>smembers key </code>：获取set中所有的元素</li>
<li><code>srem key member</code>：移除set中的指定元素</li>
<li><code>sismember key member</code>：判断一个元素是否存在于set中</li>
<li><code>scan key</code>：返回set中元素的个数</li>
</ul>
<h2 id="在Java客户端中使用Redis"><a href="#在Java客户端中使用Redis" class="headerlink" title="在Java客户端中使用Redis"></a>在Java客户端中使用Redis</h2><blockquote>
<p>在java中有三种方式使用redis，分别是：jedis，</p>
</blockquote>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><h4 id="需要导入的依赖："><a href="#需要导入的依赖：" class="headerlink" title="需要导入的依赖："></a>需要导入的依赖：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 单元测试Junit --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 配置Maven的JDK编译级别 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定义一个redis连接对象*/</span></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	使用 JedicConnectionFactory 连接池进行jedis连接的管理</span></span><br><span class="line"><span class="comment">    	通过连接池进行Jedis对象的初始化与连接的创建</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis = JedicConnectionFactory.getJedis();</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入一个 String 类型的键值对数据*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入一个 HashMap 类型的键值对数据*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String,String &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;heima:user:3&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map1 = jedis.hgetAll(<span class="string">&quot;heima:user:3&quot;</span>);</span><br><span class="line">        System.out.println(map1.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试连接池 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String,String &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;heima:user:4&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map1 = jedis.hgetAll(<span class="string">&quot;heima:user:4&quot;</span>);</span><br><span class="line">        System.out.println(map1.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭连接，释放jedis资源*/</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="配置资源"><a href="#配置资源" class="headerlink" title="配置资源"></a>配置资源</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPool&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis集群 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisCluster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisCluster&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7006&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><h4 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis 缓存操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pool 对象池 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用lettuce客户端需要引入commons-pool2依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="application-yml文件的配置"><a href="#application-yml文件的配置" class="headerlink" title="application.yml文件的配置"></a>application.yml文件的配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 地址</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="comment"># 端口，默认为6379</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment"># 密码，没有不填</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="comment"># 几号库</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">sentinel:</span></span><br><span class="line">        <span class="attr">master:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">nodes:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="attr">cluster:</span></span><br><span class="line">        <span class="attr">nodes:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="comment"># 连接池的最大数据库连接数</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">200</span></span><br><span class="line">          <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">          <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">50</span></span><br><span class="line">          <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义RedisTemplate的配置类"><a href="#自定义RedisTemplate的配置类" class="headerlink" title="自定义RedisTemplate的配置类"></a>自定义RedisTemplate的配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*自定义Redis配置类，进行序列化以及RedisTemplate设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.data.redis.mode&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisMode;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisProperties properties;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfig</span><span class="params">(RedisProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceConnectionFactory <span class="title function_">redisConnectionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;LettuceClientConfigurationBuilderCustomizer&gt; builderCustomizers,</span></span><br><span class="line"><span class="params">            ClientResources clientResources)</span> &#123;</span><br><span class="line">        GenericObjectPoolConfig&lt;?&gt; config = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        config.setMaxTotal(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxActive());</span><br><span class="line">        config.setMaxIdle(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxIdle());</span><br><span class="line">        config.setMinIdle(<span class="built_in">this</span>.properties.getLettuce().getPool().getMinIdle());</span><br><span class="line">        config.setMaxWait(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxWait());</span><br><span class="line"> </span><br><span class="line">        <span class="type">LettucePoolingClientConfiguration</span> <span class="variable">clientConfiguration</span> <span class="operator">=</span> LettucePoolingClientConfiguration</span><br><span class="line">                .builder()</span><br><span class="line">                .poolConfig(config)</span><br><span class="line">                .build();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (redisMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;master&quot;</span>:</span><br><span class="line">                <span class="type">RedisStandaloneConfiguration</span> <span class="variable">redisStandaloneConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisStandaloneConfiguration</span>();</span><br><span class="line">                redisStandaloneConfiguration.setDatabase(<span class="built_in">this</span>.properties.getDatabase());</span><br><span class="line">                redisStandaloneConfiguration.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisStandaloneConfiguration.setHostName(<span class="built_in">this</span>.properties.getHost());</span><br><span class="line">                redisStandaloneConfiguration.setPort(<span class="built_in">this</span>.properties.getPort());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisStandaloneConfiguration, clientConfiguration);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;sentinel&quot;</span>:</span><br><span class="line">                <span class="type">RedisSentinelConfiguration</span> <span class="variable">redisSentinelConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSentinelConfiguration</span>();</span><br><span class="line">                redisSentinelConfig.setDatabase(<span class="built_in">this</span>.properties.getDatabase());</span><br><span class="line">                redisSentinelConfig.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisSentinelConfig.setMaster(<span class="built_in">this</span>.properties.getSentinel().getMaster());</span><br><span class="line">                redisSentinelConfig.setSentinels(</span><br><span class="line">                        <span class="built_in">this</span>.properties.getSentinel().getNodes().stream()</span><br><span class="line">                                .map(RedisNode::fromString).collect(Collectors.toList())</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisSentinelConfig, clientConfiguration);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cluster&quot;</span>:</span><br><span class="line">                <span class="type">RedisClusterConfiguration</span> <span class="variable">redisClusterConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisClusterConfiguration</span>();</span><br><span class="line">                redisClusterConfiguration.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisClusterConfiguration.setClusterNodes(</span><br><span class="line">                        <span class="built_in">this</span>.properties.getCluster().getNodes().stream()</span><br><span class="line">                                .map(RedisNode::fromString).collect(Collectors.toList())</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisClusterConfiguration, clientConfiguration);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的redis mode配置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(om, Object.class);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置数据源的连接工厂（默认会传入框架中自带的，也就是读取配置文件装配的LettuceConnectionFactory）        </span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 设置值（value）的序列化采用Jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer序列化和反序列化redis hash类型的key值</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 序列化和反序列化redis hash类型的value值</span></span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h4><p><strong>常用的操作API</strong></p>
<blockquote>
<p>redisTemplate 通常不直接操作键值，而是通过 opsForXxx() 访问</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>hashKey(K key)</td>
<td>Boolean</td>
<td>key是否存在</td>
</tr>
<tr>
<td>countExistingKeys(Collection<K> keys)</td>
<td>Long</td>
<td>redis中keys的数量</td>
</tr>
<tr>
<td>delete(K key)</td>
<td>Boolean</td>
<td>删除key</td>
</tr>
<tr>
<td>delete(Collention<K> keys)</td>
<td>Long</td>
<td>批量删除key</td>
</tr>
<tr>
<td>type(K key)</td>
<td>DataType</td>
<td>获取key的类型</td>
</tr>
<tr>
<td>rename(K oldKey,K newKey)</td>
<td>void</td>
<td>重命名key</td>
</tr>
<tr>
<td>renameIfAbsent(K oldKey,K newKey)</td>
<td>Boolean</td>
<td>如果存在，重命名key</td>
</tr>
<tr>
<td>expire(K key,Long timeout,TimeUnit unit)</td>
<td>Boolean</td>
<td>为key设置过期时间</td>
</tr>
<tr>
<td>expireAt(K key,Date date)</td>
<td>Boolean</td>
<td>为key设置过期时间</td>
</tr>
<tr>
<td>getExpire(K key)</td>
<td>Long</td>
<td>获取key的过期时间</td>
</tr>
<tr>
<td>getExpire(K key,TimeUnit timeUnit)</td>
<td>Long</td>
<td>获取key的过期时间</td>
</tr>
<tr>
<td>persist(K key)</td>
<td>Boolean</td>
<td>移除key的过期时间，使其变为永久</td>
</tr>
<tr>
<td>move(K key,int dbIndex)</td>
<td>Boolean</td>
<td>将key移动到dbIndex中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">返回值类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">redisTemplate.opsForValue()</td>
<td align="left">ValueOperations</td>
<td align="left">操作 String 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.opsForHash()</td>
<td align="left">HashOperations</td>
<td align="left">操作 Hash 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.opsForList()</td>
<td align="left">ListOperations</td>
<td align="left">操作 List 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.opsForSet()</td>
<td align="left">SetOperations</td>
<td align="left">操作 Set 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.opsForZSet()</td>
<td align="left">ZSetOperations</td>
<td align="left">操作 SortedSet 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.boundValueOps(K key)</td>
<td align="left">BoundValueOperations</td>
<td align="left">操作 String 类型 数据</td>
</tr>
<tr>
<td align="left">redisTemplate.boundHashOps(K key)</td>
<td align="left">BoundHashOperations</td>
<td align="left">操作 Hash 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.boundListOps(K key)</td>
<td align="left">BoundListOperations</td>
<td align="left">操作 List 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.boundSetOps(K key)</td>
<td align="left">BoundSetOperations</td>
<td align="left">操作 Set 类型数据</td>
</tr>
<tr>
<td align="left">redisTemplate.boundZSetOps(K key)</td>
<td align="left">BoundZSetOperations</td>
<td align="left">操作 SortedSet 类型数据</td>
</tr>
</tbody></table>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;heima:user:5&quot;</span>,<span class="keyword">new</span> <span class="title class_">Usr</span>(<span class="string">&quot;rose&quot;</span>,<span class="number">19</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;heima:user:5&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(o.toString());</span><br></pre></td></tr></table></figure>



<h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><blockquote>
<p>继承了RedisTemplate，API与RedisTemplate基本一致，只不过在使用时多了一步需要开发者自己进行json序列化和反序列化的过错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(obj);</span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;heima:user:6&quot;</span>,json);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonUsr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;heima:user:6&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*手动序列化*/</span></span><br><span class="line"><span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> mapper.readValue(jsonUsr,Usr.class);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>


















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" data-id="cm7pnj28z0007ucv2gxm8byv5" data-title="redis基础篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库/Mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Mybatis/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.241Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Mybatis/">mybatis学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MyBatis学习"><a href="#MyBatis学习" class="headerlink" title="MyBatis学习"></a>MyBatis学习</h1><h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><p>是一个持久化框架，用于简化JDBC的开发</p>
<h2 id="结合JDBC的使用操作"><a href="#结合JDBC的使用操作" class="headerlink" title="结合JDBC的使用操作"></a>结合JDBC的使用操作</h2><h3 id="五大步骤"><a href="#五大步骤" class="headerlink" title="五大步骤"></a>五大步骤</h3><ol>
<li>建立驱动连接</li>
<li>连接数据库，获取连接对象 Connection</li>
<li>获取执行SQL的对象Statement，执行SQL，取得返回结果</li>
<li>封装返回结果</li>
<li>释放资源</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Mybatis/" data-id="cm7pnj28z0006ucv29nct09ik" data-title="mybatis学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/typora/">typora</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E9%A9%AC-%E5%90%8E%E7%AB%AF/">黑马:后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E5%9F%BA%E7%A1%80/" rel="tag">Vue基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html%E5%9F%BA%E7%A1%80/" rel="tag">html基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%BA%95%E5%B1%82/" rel="tag">java底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80/" rel="tag">js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" rel="tag">单体架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%B3%E6%B3%95/" rel="tag">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" rel="tag">闲杂经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC/" rel="tag">黑马</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDBC/" style="font-size: 11.67px;">JDBC</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Vue%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Vue基础</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/html%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">html基础</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/java%E5%BA%95%E5%B1%82/" style="font-size: 10px;">java底层</a> <a href="/tags/java%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">java框架</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">js基础</a> <a href="/tags/juc/" style="font-size: 10px;">juc</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">关系型</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" style="font-size: 11.67px;">单体架构</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.33px;">后端</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">基础</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 16.67px;">大学专业课</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" style="font-size: 13.33px;">学习规划</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.33px;">数据库</a> <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="font-size: 20px;">期末复习</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" style="font-size: 15px;">计算机四大件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">设计架构</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件架构设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">软件项目管理</a> <a href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">闲杂经验</a> <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">非关系型</a> <a href="/tags/%E9%AB%98%E9%98%B6/" style="font-size: 10px;">高阶</a> <a href="/tags/%E9%BB%91%E9%A9%AC/" style="font-size: 11.67px;">黑马</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/LeetCode/">Leetcode刷题题解</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>