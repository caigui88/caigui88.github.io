<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-常用工具/markdown语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T05:01:35.387Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/">markdown语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="markdwon语法"><a href="#markdwon语法" class="headerlink" title="markdwon语法"></a>markdwon语法</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/" data-id="cm7pquzi6001dr8v29b5bb4u3" data-title="markdown语法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-力扣刷题/经典算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.302Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/">算法思路：OI Wiki</a></p>
<h2 id="高精度计算-大整数计算"><a href="#高精度计算-大整数计算" class="headerlink" title="高精度计算&amp;大整数计算"></a>高精度计算&amp;大整数计算</h2><p>高精度的计算实际上是用<strong>数组存储</strong>和<strong>模拟运算</strong></p>
<p>翻转存储数字，为了保证个位在数组的同一个位置</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p><strong>输入格式</strong></p>
<p>两行输入。$a,b &lt;&#x3D; 10^{500}$ </p>
<p><strong>输出格式</strong></p>
<p>输出一行，$a+b$的值</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>将数字进行翻转存储，让个位位于数组的0号位，方便对数字数组进行处理</p>
<p>在翻转存储之后，根据贴近生活当中正常的加减法的运算方式进行模拟</p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="type">int</span> la,lb,lc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[], <span class="type">int</span> C[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lc;i++)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    la = a.<span class="built_in">size</span>(),lb = b.<span class="built_in">size</span>(),lc = c.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = la - <span class="number">1</span>; ~i ; i--) A[la<span class="number">-1</span>-i] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lb - <span class="number">1</span>; ~i ; i--) B[lb<span class="number">-1</span>-i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">add</span>(A,B,C);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lc - <span class="number">1</span>; ~i; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h2 id="贪心和动态规划算法"><a href="#贪心和动态规划算法" class="headerlink" title="贪心和动态规划算法"></a>贪心和动态规划算法</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法在解决找零钱问题时，为了能够找到最优解，对硬币面额进行了限制：</p>
<p><strong>即任意两个面额之间的比率是整数倍关系。</strong></p>
<p>在上述条件下，贪心算法在每一步选择中都可以选择当前面额最大的硬币，这样可以确保每次选择的硬币面额尽可能大。</p>
<p>假设硬币的面额集合为 $({c_1, c_2, c_3, \ldots, c_n})$，并且满足贪心选择性质，那么在找零钱问题中，当需要找零金额为 $(k)$ 时，贪心算法可以这样工作：</p>
<ol>
<li>从硬币面额集合中选取面额最大的硬币，假设为 $(c_i)$，其中 $(i \leq n)$。</li>
<li>扣除 $(c_i)$ 后剩余的金额为 $(k - c_i)$。</li>
<li>重复以上步骤，直到剩余金额为 $(0)$。</li>
</ol>
<p>由于硬币面额之间的比率是整数倍关系，贪心算法每次都选择当前面额最大的硬币，因此可以确保每次选择的硬币面额尽可能大。这样，贪心算法得到的解是一个局部最优解，而且由于贪心选择性质的特性，这个局部最优解也是全局最优解。</p>
<p>因此，硬币面额满足贪心选择性质时，贪心算法能够得到最优解的原因在于每次选择的硬币面额都是局部最优的，且这些局部最优解的组合也构成了全局最优解。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/" data-id="cm7pquzhu0003r8v25cvc4pfr" data-title="经典算法学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-力扣刷题/LeetCode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/LeetCode/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.301Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/LeetCode/">Leetcode刷题题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode刷题记录"><a href="#LeetCode刷题记录" class="headerlink" title="LeetCode刷题记录"></a>LeetCode刷题记录</h1><h2 id="2549-统计桌面上的不同数字"><a href="#2549-统计桌面上的不同数字" class="headerlink" title="[2549] 统计桌面上的不同数字"></a>[2549] 统计桌面上的不同数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>109</code> 天内，每天都要执行下述步骤：</p>
<ul>
<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>
<li>然后，将这些数字放在桌面上。</li>
</ul>
<p>返回在 <code>109</code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一旦数字放在桌面上，则会一直保留直到结束。</li>
<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：最开始，5 在桌面上。 </span><br><span class="line">第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 </span><br><span class="line">再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3 </span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">因为 3 % 2 == 1 ，2 也出现在桌面上。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 </span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="解法思路一："><a href="#解法思路一：" class="headerlink" title="解法思路一："></a>解法思路一：</h4><p>本题目本质其实相当于找质数;</p>
<p>对于变量$x \in [0,n]$,需要查找在$y \in [0,x]$当中可以满足式子$x<del>mod</del>y&#x3D;&#x3D;1$的y并使用一个HashSet(为了方便去重)进行记录,最后返回HashSet的个数即可;其实最终会发现撤了除了1的所有数字都出现过一次.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		set.add(n);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i%j==<span class="number">1</span>)&#123;</span><br><span class="line">					set.add(j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二?"></a>解题思路二?</h4><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="[322]零钱兑换"></a>[322]零钱兑换</h2><blockquote>
<p>动态规划</p>
</blockquote>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><ol>
<li><p>首先，找零问题无法使用<strong>贪心</strong>解决，因为贪心算法永远需要从最大或最小的硬币面额开始，且无法进行回退，解集的不完整，得到的局部最优解最终并不一定可以组成全局最优解，而在找零问题中，很明显，存在并不从coins最大面额进行凑零的解集，因而不能使用<strong>贪心算法</strong>。</p>
</li>
<li><p>采取<strong>动态规划</strong>进行解决：动态规划算法可以得出在不断加入新面额的硬币的情况下得到的新的最优解，因而可以得到最优解集，进而在最优解集当中得到最优解。</p>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] coins = &#123;<span class="number">186</span>,<span class="number">419</span>,<span class="number">83</span>,<span class="number">408</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">6249</span>;      </span><br><span class="line">        System.out.println(coinChange(coins,amount));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 排序得出数组内最小的零钱面额；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minCoin</span> <span class="operator">=</span> Arrays.stream(coins).min().orElse(Integer.MIN_VALUE);</span><br><span class="line">			  <span class="comment">// 得出伪最差解（因为存在amount/minCoin为小数的情况，因而是伪最差解）</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">maxResult</span> <span class="operator">=</span> amount/minCoin;</span><br><span class="line">        <span class="comment">//建立dp数组进行动态规划；</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//先对第一行初始情况进行初始化，全部定为最差情况，进而在动态递推的过程中使用较优解			 //进行替换</span></span><br><span class="line">        Arrays.fill(dp, maxResult+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当零钱为0时，解为0，确定一个确定的优解，进而递推出剩余的优解</span></span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp过程：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin:coins)&#123;</span><br><span class="line">          	<span class="comment">//此处从得到的硬币面额开始递推，因为小于硬币面额的显然不会出现比原来更优的解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coin;j&lt;=amount;j++)&#123;</span><br><span class="line">              	<span class="comment">//在当前零钱面额下，每当引入一种新的硬币面额，减去这种硬币面额，并在前面已经存在的解当中查找是否已存在优解，如果存在即说明可以在优解的前提下加一得到当前零钱面额的优解；如果不存在则为最差解。（建议状态转移过程需要画个图进行理解）</span></span><br><span class="line">                dp[j] =Math.min(dp[j],dp[j-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;maxResult ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="[26]删除有序数组中的重复项"></a>[26]删除有序数组中的重复项</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><code>题目</code></h3><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<h3 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h3><p>本题需要采用原地算法</p>
<h4 id="原地算法-in-place-algorithm-："><a href="#原地算法-in-place-algorithm-：" class="headerlink" title="原地算法(in-place algorithm)："></a>原地算法(in-place algorithm)：</h4><ol>
<li>常见的案例就是如本题，在不使用超过O(1)的额外空间的基础上，完成对数组重复元素的删除。</li>
</ol>
<p>本题原地删除采用快慢指针的方式，其中一个指针pre一直沿着数组往下走，另一个指针last负责将pre所经过的元素中的第一次出现的元素提取出来并形同栈一样压入数组前面pre已经遍历过的空间。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] != nums[i])&#123;</span><br><span class="line">                nums[++p] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ++p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="[27]移除元素"></a>[27]移除元素</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h3 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h3><blockquote>
<p>本体与[26]题相似，同样用到了原地删除的方法，但是略有细节上的不同，本体要求的是指定删除的所有元素，而[26]题则是删除重复元素，因此在[26]我们使用的是++p，因为当前元素不需要删除，但是在本体则是使用p++，因为当前元素如果是符合val的话，则需要进行删除。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; nums.length; p++)</span><br><span class="line">            <span class="keyword">if</span>(nums[p] != val) &#123;</span><br><span class="line">                nums[cur++] = nums[p];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="[704] 二分查找"></a>[704] 二分查找</h2><blockquote>
<p>本题目的目的是为了初步了解、熟悉和掌握二分查找，并未进行高级的应用</p>
</blockquote>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h3 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h3><p>二分查找核心即为通过不断比较有序数组的中间下标对应的值与target的大小关系，不断缩小target在数组中的可能存在的区间范围，因而可以达到$O(logn)$的复杂度</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[len-<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid +<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="[35]搜索插入位置"></a>[35]搜索插入位置</h2><blockquote>
<p>本题应用到了[704]所学的二分查找算法，通过二分寻找到待插入元素的可以被插入的位置，假如当最后的nums[mid]小于val，则说明val需要插入到mid+1的位置，假如nums[mid]的值大于val，则需要将val插入到mdi这个位置，并将mid之后的元素右移一个单元。</p>
</blockquote>
<h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid-<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="[1]两数相加"></a>[1]两数相加</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>本题为模拟题，但并不意味着没有什么可学习的地方，为了使得代码简洁且清晰明了，我们需要结合计算机组成原理当中的行波进位加法器的原理来进行加法的模拟，一个进位(即前一位进过来的位)，与输入1和输入2，共同构成本位的值，同时根据本位的值再重新为进位赋值，将其作为下一个位的进位传递下去。</p>
<h3 id="解题代码如下"><a href="#解题代码如下" class="headerlink" title="解题代码如下"></a>解题代码如下</h3><h4 id="屎山版本"><a href="#屎山版本" class="headerlink" title="屎山版本"></a>屎山版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">answer</span> <span class="operator">=</span> l3;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="keyword">while</span>(tmp1!=<span class="literal">null</span>)&#123;</span><br><span class="line">        num1++;</span><br><span class="line">        tmp1 = tmp1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tmp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        num2++;</span><br><span class="line">        tmp2 = tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Integer.min(num1,num2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minNum-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> l1.val+l2.val;</span><br><span class="line">        </span><br><span class="line">        l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            l3.val += sum;</span><br><span class="line">            l3.val = l3.val % <span class="number">10</span>;</span><br><span class="line">            l3.next.val++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l3.val += sum;</span><br><span class="line">            <span class="keyword">if</span>(l3.val&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                l3.next.val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l3 = l3.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l3.val += l1.val+l2.val;</span><br><span class="line">    <span class="keyword">if</span>(l3.val&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">        l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1&lt;num2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1; i &lt; num2; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l3.next == <span class="literal">null</span>)</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                l3 = l3.next;</span><br><span class="line">                l3.val+= l2.next.val;</span><br><span class="line">                <span class="keyword">if</span>(l3.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                    l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num2; i &lt; num1; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l3.next == <span class="literal">null</span>)</span><br><span class="line">                   l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                l3 = l3.next;</span><br><span class="line">                l3.val+= l1.next.val;</span><br><span class="line">                <span class="keyword">if</span>(l3.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                    l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp3</span> <span class="operator">=</span> answer;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="行波进位加法器思想修改版本"><a href="#行波进位加法器思想修改版本" class="headerlink" title="行波进位加法器思想修改版本"></a>行波进位加法器思想修改版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">null</span> || l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显可以看出，带有正确的思想和原理去进行模拟，可以得到一个更为优良的解法和代码。</p>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="[7]整数反转"></a>[7]整数反转</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>&#96;&#96;-2^31 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1&#96;</li>
</ul>
<h3 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h3><p>本题为纯数学问题，而后将一个个截取出来的每一位都加载到一个新的数字当中。</p>
<h3 id="代码解答"><a href="#代码解答" class="headerlink" title="代码解答"></a>代码解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(x);</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            reversed = reversed * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reversed &gt; Integer.MAX_VALUE || reversed &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果超出范围，返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>) (-<span class="number">1</span> * reversed);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="type">int</span>) reversed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="[8]字符串转换整数(atoi)"></a>[8]字符串转换整数(atoi)</h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231,  231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="[239] 滑动窗口最大值"></a>[239] <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></h2><p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    if (nums == null || k &lt;= 0) &#123;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    int[] ans = new int[n - k + 1];</span><br><span class="line">    int count = 0;</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + 1) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">    </span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            ans[count++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><h3 id="题目思路-5"><a href="#题目思路-5" class="headerlink" title="题目思路"></a>题目思路</h3><p>本题核心是，通过 sort 方法先将每一个区间的左边界进行排序，这样就将问题简化成只需要对比<strong>上一个区间的右边界与下一个区间的左边界</strong>的大小即可知道需要合并与否了</p>
<h3 id="代码解答-1"><a href="#代码解答-1" class="headerlink" title="代码解答"></a>代码解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="comment">// 如果数组大小为 0，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据区间的左边界继续排序</span></span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> [] interval1,<span class="type">int</span> [] interval2)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ans.size() == <span class="number">0</span> || ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>],R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




























      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/LeetCode/" data-id="cm7pquzhw0006r8v2899x4k6i" data-title="Leetcode刷题题解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机重要基础/计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.296Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h2><blockquote>
<p>——本章<strong>task</strong>：</p>
<ol>
<li>介绍基本术语和概念<ul>
<li>构成网络的基本硬件和软件组成：<ul>
<li>从网络边缘——网络中运行的端系统和网络应用；</li>
<li>再到网络核心——传输数据的链路和交换机以及将端系统与网络核心相连接的接入网和物理媒体。</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络中数据的时延、丢包和吞吐量</li>
<li>端到端吞吐量和时延的定量模型：<ul>
<li>模型兼顾了传输、传播和排队时延等因素</li>
</ul>
</li>
<li>体系结构原则：<ul>
<li>协议分层和服务模型</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="计网概念简述"><a href="#计网概念简述" class="headerlink" title="计网概念简述"></a>计网概念简述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<ol>
<li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过<strong>通信设备和线路</strong>连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li>
<li>本质即是由若干个节点和连接这些节点的链路组成的一张网</li>
</ol>
</blockquote>
<h3 id="计网的结构组成"><a href="#计网的结构组成" class="headerlink" title="计网的结构组成"></a>计网的结构组成</h3><blockquote>
<p>——由三大要素组成：<strong>硬件</strong>、<strong>软件</strong> 、<strong>协议</strong>&lt;一系列规则和约定的集合&gt;</p>
</blockquote>
<h4 id="物理硬件进度来看结构："><a href="#物理硬件进度来看结构：" class="headerlink" title="物理硬件进度来看结构："></a>物理硬件进度来看结构：</h4><ul>
<li><p>节点分为两类节点</p>
<ol>
<li><strong>主机节点</strong></li>
<li><strong>数据交换节点</strong>（数据传输过程中间过渡连接两个端的节点）：<ol>
<li>例如：路由器（工作在网络层）Router；交换机（工作在链路层）Switch</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>端系统&#x2F;端系统</strong>：与因特网相连的计算机或其他联网的设备</p>
<ul>
<li>端系统通过**通信链路(communication link)<strong>和</strong>分组交换机(packet switch)**进行链接；</li>
<li>host &#x3D;&#x3D; end system</li>
</ul>
</li>
<li><p><strong>分组交换机 packet switches：</strong> 转发数据报</p>
<ul>
<li><strong>分组</strong>：当一台端系统向另一条端系统发送数据时，发送端会将数据分段，并未每一段加上首部字节，由此形成的<strong>信息包</strong>称之为<strong>分组</strong>；</li>
<li>路由器 router 作用于网络 通常用于网络核心中进行数据的转发</li>
<li>交换机 switch 作用于链路层 通常用于接入网将主机的数据转发到路由器</li>
<li><strong>路径 route&amp;path</strong>：从发送端到接收端，一个分组所走过的一系列通信链路和分组交换机</li>
</ul>
</li>
<li><p><strong>通信链路 links：</strong></p>
<ul>
<li>光纤 fiber，铜缆 copper，无线电 radio，卫星 satellite</li>
<li>trabsmission rate bandwidth 传输速率：带宽</li>
</ul>
</li>
<li><p><strong>网络 network</strong></p>
<ul>
<li>以上设备相互组合的集合</li>
</ul>
</li>
</ul>
<h4 id="功能角度来看结构："><a href="#功能角度来看结构：" class="headerlink" title="功能角度来看结构："></a>功能角度来看结构：</h4><ul>
<li><p><strong>网络边缘 Network Edge：</strong></p>
<ul>
<li>主机和主机当中的应用</li>
<li>端系统与网络间的接口</li>
</ul>
</li>
<li><p><strong>接入网 Access Network：</strong></p>
<blockquote>
<p>将端系统物理连接到 <strong>边缘路由器 edge router</strong>的网络</p>
</blockquote>
<ul>
<li><strong>因特网服务提供商 Internet Service Provider,ISP</strong>：端系统通过ISP接入因特网<ul>
<li>ISP包括：本地电缆、电话公司提供的住宅区ISP、公司ISP、大学ISP……</li>
</ul>
</li>
<li><strong>Residential access nets(家庭接入网)</strong> 基于电缆接入</li>
<li><strong>mobile access networks (WiFi, 4G&#x2F;5G)(移动接入网络)</strong> <ul>
<li>无线局域网</li>
<li>广域蜂窝接入网</li>
</ul>
</li>
<li><strong>institutional access networks(机构介入网络)</strong><ul>
<li>混合使用有线、无线链路技术，连接混合的交换机和路由器</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络核心 NetWork Core：</strong></p>
<ul>
<li>由高速路由器和交换机组成。</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><blockquote>
<p>——掌握计算机网络领域知识的过程就是理解网络协议的构成 、原理和工 作方式的过程 。</p>
</blockquote>
<ul>
<li><p><strong>网络协议</strong>：端系统、分组交换机和其他可接入因特网的部件都遵循一系列预先<strong>规定好的规则</strong>，这些规则被称之为协议。协议控制因特网当中信息的接收和发送。</p>
<ul>
<li>**TCP(Transmission Control Protocol，传输控制协议)<strong>和</strong>IP(Internel Protocol，网络协议)**是因特网中最为重要的两个协议。<ul>
<li><strong>IP协议</strong>定义了在路由器和端系统之间发送和接收的<strong>分组格式</strong>。</li>
</ul>
</li>
<li><strong>功能</strong>：<ul>
<li>定义了在两个或多个通信实体间交换的报文的格式和顺序，以及报文发送&amp;接收一条报文或其他事件所采取的动作。</li>
</ul>
</li>
</ul>
</li>
<li><p>应用TCP的app： </p>
<ul>
<li>HTTP Web 网页数据报文传输</li>
<li>FTP file transfer 文件传输 </li>
<li>Telnet——remote login 远程登录, </li>
<li>SMTP—— email</li>
</ul>
</li>
<li><p>应用UDP的app：流媒体 streaming media，teleconferencing 电话会议，DNS，Internet telephony 网络电话。</p>
</li>
</ul>
<h4 id="网络实体"><a href="#网络实体" class="headerlink" title="网络实体"></a>网络实体</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><ul>
<li>参与网络通信的任何设备或程序。这可以包括服务器、客户端、路由器、交换机、防火墙等硬件设备，也可以包括浏览器、邮件客户端、FTP客户端等软件程序。每个网络实体都有一个或多个网络接口，用于发送和接收数据。</li>
</ul>
<h5 id="对等层次的实体"><a href="#对等层次的实体" class="headerlink" title="对等层次的实体"></a>对等层次的实体</h5><ul>
<li>在网络模型的同一层次中，执行相同功能的两个网络实体。这些实体可以在不同的计算机上，通过网络进行通信。</li>
<li>“对等”只是指这两个实体在网络模型中处于同一层次，并执行相同的功能。</li>
</ul>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><blockquote>
<p>更深入了解计算机网络的部件</p>
</blockquote>
<p>通过ISP接入互联网，</p>
<h4 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h4><blockquote>
<p>主机host和端系统————一个概念<br>边缘部分包括：端系统和接入网<br>在C&#x2F;S体系中，主机进一步划分为<strong>client</strong>和<strong>server</strong>。</p>
</blockquote>
<ul>
<li><p><strong>边缘部分</strong>：用户直接使用</p>
<blockquote>
<p>端系统之间的通信强调的是两个端系统当着正在执行的进程之间的通信</p>
</blockquote>
<ul>
<li><strong>C&#x2F;S方式（Client&#x2F;Server）&amp; B&#x2F;S方式（Browser&#x2F;Server）</strong></li>
<li>**P2P方式（peer To peer）**主机数量越多，下载速度越快（一份资源拥有的人越多，则下载速度越快，因为可以同时从多个主机处下载同一份资源，多线程下载？）</li>
</ul>
</li>
<li><p><strong>接入网</strong>：将端系统物理连接到<strong>边缘路由器 edge router</strong>的网络</p>
<ul>
<li><p>Residential accsee 家庭接入：点对点接入</p>
<p>家庭利用分配器将数据信号和电话信号分开</p>
<p>电话公司利用DSLAM把数据和电话信号分开，并将数据送往因特网</p>
<ul>
<li>DSL 数字用户线 常用：</li>
<li>Dialup via modem 通过调解器进行拨号</li>
<li>电缆 常用</li>
<li>HFC hybrid Fiber coax 混合光纤同轴</li>
<li>FTTH</li>
<li>拨号和卫星</li>
</ul>
</li>
<li><p>企业&amp;家庭接入：以太网&amp;WIFI</p>
</li>
<li><p>广域无线接入：3G和LTE</p>
</li>
</ul>
</li>
<li><p><strong>物理媒体</strong>：</p>
<blockquote>
<p>所有无线网的根基都是有线网</p>
</blockquote>
<ul>
<li>导引型：光缆&#x2F;光纤、双绞铜线、同轴电缆</li>
<li>非导引型：电波、陆地无线电信道、卫星无线电信道</li>
</ul>
</li>
</ul>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>核心部分为边缘部分服务</p>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul>
<li><p><strong>分组 packet</strong>：源主机将长报文划分为小的数据块</p>
</li>
<li><p>端系统彼此交换<strong>报文 message</strong>，分组 packet在源和目的地之间通过<strong>通信链路</strong>和<strong>分组交换机 packet-switch</strong>传输和转发报文。</p>
<ul>
<li>解释：在应用层，端和端之间交流的信息单位是报文message，但是具体进入到下面层次时，需要将报文（太长了，无法一次传输完）依照预先设定好的格式划分若干的小报文，这种小报文的名称就是分组，将这种分组向下层结构传递再经过一系列链路和交换机传输到目的主机，以达成信息交互的目的。</li>
</ul>
</li>
<li><p><strong>存储转发传输 store-and-forward transmission</strong>：多数分组交换机在链路输入端使用。指的是在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p>
<p>假设有一个简单网络：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241804.png" alt="image-20240605162345495"> </p>
<p>源主机通过链路传输分组到路由器，假设发送方发送一个大小我 L bits 的分组，链路传输速率为 R bits&#x2F;s，则传输该分组的时间为：传输时延 L&#x2F;R s</p>
<ul>
<li>假设分组1的前沿先到达路由器，路由器采用存储转发机制</li>
<li>此时路由器会先缓存分组1的前沿比特</li>
<li>等待分组1的所有比特都达到路由器时，才会开始向出链路传输分组1</li>
</ul>
</li>
</ul>
<h4 id="功能组成："><a href="#功能组成：" class="headerlink" title="功能组成："></a>功能组成：</h4><ul>
<li><p>通信子网：实现<strong>数据通信</strong>。</p>
</li>
<li><p>资源子网：实现<strong>资源共享</strong>&#x2F;数据处理。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	subgraph 子网</span><br><span class="line">	direction TB</span><br><span class="line">	str1[&quot;资源子网\n(实现资源共享功能的设备和软件的集合)&quot;]</span><br><span class="line">	str6[&quot;通信子网\n(各种传输介质,通信设备,相应的网络协议组成)&quot;]</span><br><span class="line">	end</span><br><span class="line">	subgraph OSI七层结构</span><br><span class="line">	str2[&quot;应用层&quot;]</span><br><span class="line">	str3[&quot;表示层&quot;]</span><br><span class="line">	str4[&quot;会话层&quot;]</span><br><span class="line">	str5[&quot;传输层&quot;]</span><br><span class="line">	str7[&quot;网络层\n如:路由器&quot;]</span><br><span class="line">	str8[&quot;数据链路层\n(如:交换机,网桥)&quot;]</span><br><span class="line">	str9[&quot;物理层\n(如:集线器,中继器)&quot;]</span><br><span class="line">	end</span><br><span class="line">	str1 --&gt; str2 &amp; str3 &amp; str4 </span><br><span class="line">	str6 --&gt; str7 &amp; str8 &amp; str9</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>数据通信</strong></li>
<li><strong>资源共享</strong></li>
<li><strong>分布式处理</strong>：<ul>
<li>多台设备各自承担同一任务的不同部分</li>
<li>使用备用机来顶替出故障的设备，提高安全性和可靠性</li>
</ul>
</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p><strong>分布范围</strong>：是按照使用技术进行区分而不是按照实际物理距离进行区分</p>
<ul>
<li><strong>广域网(WAN)</strong>;</li>
<li>城域网(MAN);</li>
<li><strong>局域网(LAN)</strong>;</li>
<li>个人区域网(PAN)</li>
</ul>
</li>
<li><p><strong>使用者</strong>：</p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li><p><strong>交换技术</strong>：</p>
<ul>
<li>电路交换，如：打电话</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li><p>拓扑结构：</p>
<ul>
<li><p>总线型</p>
</li>
<li><p>星型</p>
</li>
<li><p>环形</p>
</li>
<li><p>网状型</p>
</li>
</ul>
</li>
<li><p><strong>传输技术</strong>：</p>
<ul>
<li>广播式网络：共享公共通信通道</li>
<li>点对点网络：使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li>
</ul>
</li>
</ul>
<h4 id="标准化工作"><a href="#标准化工作" class="headerlink" title="标准化工作"></a>标准化工作</h4><ul>
<li><strong>法定标准</strong>：OSI</li>
<li><strong>事实标准</strong>：TCP&#x2F;IP</li>
</ul>
<h3 id="分组交换网络中的时延、丢包和吞吐量"><a href="#分组交换网络中的时延、丢包和吞吐量" class="headerlink" title="分组交换网络中的时延、丢包和吞吐量"></a>分组交换网络中的时延、丢包和吞吐量</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul>
<li><p><strong>速率</strong>：数据率&amp;数据传输率&amp;比特率</p>
<ul>
<li>数据在传输单位是bit 0&#x2F;1 位</li>
<li>单位：$b&#x2F;s$  $1Gb&#x2F;s &#x3D; 10^{3}Mb&#x2F;s &#x3D; 10^{6}Kb&#x2F;s &#x3D; 10^{9}b&#x2F;s$<blockquote>
<p>存储容量： $1TB &#x3D; 2^{10}GB &#x3D; 2^{20}MB &#x3D; 2^{30}KB &#x3D; 2^{40}B &#x3D; 2^{43}bite$ $1Byte(字节) &#x3D; 2^{3}bit(比特)$</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>带宽</strong>：网络通信线路传输数据的能力，通常指单位时间内从网络中的某一节点到另一节点所能通过的“最高数据率” ，单位“$bite&#x2F;s$” </p>
</li>
<li><p><strong>吞吐量</strong>：单位时间内通过某个网络（或信道、接口）的数据量，单位：$b&#x2F;s、kb&#x2F;s、Mb&#x2F;s$</p>
</li>
</ul>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241713.png" alt="image-20240605170015617"> </p>
<ul>
<li><p><strong>nodal processing 节点处理时延</strong>：</p>
<ul>
<li><p>检查：检查分组首部所需要的时间；检查比特级别的错误；</p>
</li>
<li><p>找出口：决定将该分组导向何处所需要的时间；</p>
</li>
<li><p>高速路由器的处理时延通常是微秒或更低的数量级</p>
</li>
</ul>
</li>
<li><p><strong>queueing 排队时延（最复杂）</strong>：</p>
<p>分组到达路由的速率超过了出路由的能力，因而存入一个缓存队列中，等待发出</p>
<p>等待输出&#x2F;入链路可用</p>
<ul>
<li><p>取决于拥塞程度</p>
</li>
<li><p>取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<ul>
<li>该队列是空的，则排队时延为0</li>
<li>如果许多其他分组等待传输，排在等待缓存队列当中，则等待时延很长</li>
</ul>
</li>
<li><p>实际的排队时延可以是毫秒到微秒量级。</p>
</li>
<li><p>R 为链路带宽 bps</p>
</li>
<li><p>L 为分组长度 bits</p>
</li>
<li><p>a &#x3D; 平均分组到达速率</p>
</li>
<li><p>交通强度 traffic intersity &#x3D; L*a &#x2F; R</p>
</li>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241232.png" alt="image-20240605201914573" style="zoom:50%;" /> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241233.png" alt="image-20240605202000063" style="zoom: 80%;" /></p>
</li>
<li><p><strong>transmission传输时延</strong>：将分组的所有比特推向链路(即传输,或者说发送)所需要的时间</p>
<ul>
<li>L 比特表示该分组的长度，</li>
<li>用 R bps(即 b&#x2F;s) 表示从路由器 A 到路由器 B 的链路传输速率。</li>
<li>$传输时延 &#x3D; \frac{L}{R}$</li>
</ul>
</li>
<li><p><strong>propagation 传播时延</strong>：信道路上消耗的时间，取决于<strong>电磁波传播速度</strong>和<strong>链路长度</strong></p>
<ul>
<li>d 为物理链路长度</li>
<li>s 为在物理介质中的传播速率</li>
<li>$传播时延&#x3D;\frac{d}{s}$​</li>
</ul>
</li>
<li><p><strong>节点时延：</strong> </p>
<ul>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242712.png" alt="image-20240605201719133" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>时延带宽积</strong>：$时延带宽积 &#x3D; 传播时延\times带宽$ ，又称为 <strong>以比特为单位的链路长度</strong></p>
</li>
<li><p><strong>往返时延RTT</strong>：从<strong>发送方</strong>发送数据开始；到<strong>发送方</strong>收到<strong>接收方</strong>的确认结束。</p>
<p> RTT越大，在收到确认之前，可以发送的数据越多</p>
<p> $RTT包括\begin{cases}往返传播时延 &#x3D; 传播时延\times2 \ 末端处理时间 \end{cases}$</p>
</li>
</ul>
</li>
<li><p><strong>利用率</strong>：</p>
<ul>
<li>信道利用率： $\frac{有数据通过时间}{(有+无)数据通过时间}$</li>
<li>网络利用率：信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h4 id="丢包-loss"><a href="#丢包-loss" class="headerlink" title="丢包 loss"></a>丢包 loss</h4><p><strong>丢包</strong>：</p>
<ul>
<li>因为排队容量有限，当新到达的分组没有地方存放时，路由器将<strong>丢弃 drop</strong>该分组，则该分组<strong>丢失 lost</strong>。</li>
<li>丢弃的分组需要进行重传</li>
</ul>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><strong>throughput 吞吐量：</strong> 单位时间内成功传输的数据量。</p>
<ul>
<li>瞬时吞吐量 instantaneous throughput：在特定时刻网络传输的数据速率。</li>
<li>平均吞吐量 average throughput：在较长时间内网络传输的数据的平均速率。平均吞吐量可以反映网络在一段时间内的整体传输能力。</li>
<li></li>
</ul>
<h3 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h3><h4 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h4><h5 id="协议分层-层次结构"><a href="#协议分层-层次结构" class="headerlink" title="协议分层&amp;层次结构"></a>协议分层&amp;层次结构</h5><blockquote>
<p>为什么分层？</p>
<p>因为计算机网络的数据传输是一个较大且复杂的问题。因而将一个大问题拆分为无数个小问题进行解决，而每一个小问题就对应着一个层次。</p>
<p>怎样分层？</p>
<p>$实体 \rightarrow 协议(对等的实体间才有协议) \rightarrow 接口 \rightarrow 服务(下级为上级提供服务)$</p>
</blockquote>
<blockquote>
<p>计算机网络体系结构，简称“网络体系结构”：是计算机网络的各层及其协议的集合。</p>
<p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</p>
</blockquote>
<ul>
<li><strong>分层基本原则</strong><ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li>
<li>结构上可分割。每层采用最合适技术实现</li>
<li>保持下层对上层的独立性，上层单向使用下次提供的服务</li>
</ol>
</li>
<li><strong>实体</strong>：第n层中的活动元素称为<strong>n层实体</strong>。同一层实体叫<strong>对等实体</strong>。</li>
<li><strong>协议</strong>：为进行网络中的<strong>对等实体</strong>数据交换建立的规则、标准或约定。称为网络协议。<ul>
<li>协议只在对等层次间进行使用。【协议是水平的】</li>
<li>语法：规定了传输数据的格式。</li>
<li>语义：规定所要完成的功能。</li>
<li>同步：规定各种操作的顺序。</li>
</ul>
</li>
<li><strong>接口（访问服务点SAP）</strong>：上层使用下层服务的入口。</li>
<li><strong>服务</strong>：下层为相邻上层提供的功能调用。【服务是垂直的】</li>
<li><strong>SDU服务数据单元</strong>：为完成用户所要求的功能而传送的数据。</li>
<li><strong>PCI协议控制信息</strong>：控制协议操作的信息</li>
<li><strong>PDU协议数据单元</strong>：对等层次之间传递的数据单元</li>
</ul>
<h4 id="TCP-IP模型-实例-事实标准-5层"><a href="#TCP-IP模型-实例-事实标准-5层" class="headerlink" title="TCP&#x2F;IP模型(实例)事实标准 5层"></a>TCP&#x2F;IP模型(实例)事实标准 5层</h4><ul>
<li><strong>应用层</strong>：网络应用程序及它们的应用层协议存留的地方。<ul>
<li>位于应用层的信息分组称为<strong>报文</strong>。</li>
</ul>
</li>
<li><strong>运输层</strong>：因特网的传输层在应用程序端点间传送应用层报文。<ul>
<li>位于运输层的信息分组称为<strong>报文段 segment</strong></li>
<li>有两种运输协议：<strong>TCP和UDP</strong>，利用其中任一个 都可以运输应用层报文。</li>
<li><strong>TCP</strong>向应用程序提供面向连接服务————包括：<ul>
<li>应用层报文向目的地的确保传递和流量控制(即发送方&#x2F;接收方速率匹配）</li>
<li>将长报文划分为短报文,并提供拥塞控制机制,因此当网络拥塞时,源抑制其传输速率。</li>
</ul>
</li>
<li><strong>UDP</strong>向应用程序提供无连接服务，这种服务不提供不必要服务，没有可靠性、流量控制、拥塞控制。</li>
</ul>
</li>
<li><strong>网络层</strong>：<ul>
<li>位于网络层的信息分组称为<strong>数据报 datagram</strong></li>
<li>负责将数据报从一台主机移动到另一台主机。</li>
<li>源端中的运输层协议向网络层递交运输层报文段 segment和目的地址</li>
</ul>
</li>
<li><strong>链路层</strong>：端之间的网络层通过一系列路由器、路由数据报。<ul>
<li>位于链路层的信息分组称为<strong>帧 frame</strong></li>
<li>链路层接收由网络层传递来的数据报，沿着路径 path将数据报传递给下一个节点。</li>
<li>链路层提供的服务取决于应用于该链路的特定链路层协议。</li>
</ul>
</li>
<li><strong>物理层</strong>：<ul>
<li>物理层的任务是将链路层的帧的一个个比特从一个节点传输到下一个节点。</li>
<li>这一层的协议仍旧和链路相关，且进一步与链路的实际及输出媒体有关。</li>
</ul>
</li>
</ul>
<h4 id="ISO-OSI模型-实例-法定标准-7层"><a href="#ISO-OSI模型-实例-法定标准-7层" class="headerlink" title="ISO&#x2F;OSI模型(实例)法定标准 7层"></a>ISO&#x2F;OSI模型(实例)法定标准 7层</h4><p>$应用层 \rightarrow 表示层\rightarrow会话层\rightarrow传输层\rightarrow网络层\rightarrow数据链路层\rightarrow物理层$ </p>
<ul>
<li><p>其他六个层次都只加一个头部$H<del>n$ 只有在数据链路层会加上头部和尾部 $H</del>2<del>and</del>T~2$  </p>
</li>
<li><p>数据传输是端对端&#x2F;点对点的，需要考虑下一个端，且需要知道终点。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242324.png" alt="image-20240311100615910" /> 


</li>
<li><p><strong>应用层</strong>：网络应用程序和它们的应用层协议存留的地方。所有能和用户交互产生网络流量的程序。</p>
<ul>
<li>把位于应用层的信息分组称为<strong>报文(message)</strong>。</li>
</ul>
</li>
<li><p><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<ul>
<li>数据格式的交换</li>
<li>数据加密解密</li>
<li>数据压缩和恢复</li>
</ul>
</li>
<li><p><strong>会话层</strong>：向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据</p>
<ul>
<li>会话的同时<strong>建立同步(SYN)</strong>。</li>
<li>和不同实体建立的会话是相对独立的，不会相互影响</li>
<li>建立、管理、终止会话</li>
<li>使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步。例如：大文件的传输。</li>
</ul>
</li>
<li><p><strong>传输层</strong>：负责不同的主机中两个相同进程的通信，即端到端的通信。传输单位时报文段or用户数据报。</p>
<ul>
<li>可靠传输：基于确认机制的一种传输方式</li>
<li>不可靠传输：基于</li>
<li>差错控制：</li>
<li>流量控制：</li>
<li>复用分用：</li>
</ul>
</li>
<li><p><strong>网络层</strong>：</p>
</li>
<li><p><strong>数据链路层</strong>：</p>
</li>
</ul>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol>
<li><p>端与端之间的通信过程：数据经由发送端的协议栈向下、沿着中间链路层分组交换机的协议栈上上下下，而后向上到达接收端的协议栈。</p>
</li>
<li><p>一个应用层报文message传输到运输层，会为其增加一个首部信息，该首部信息将被接收端的运输层使用，应用层的message和添加的首部信息构成了运输层的segment，则运输层封装了应用层传递过来的报文信息；</p>
<ol>
<li>其他层次都只加一个头部$H~n$ </li>
<li>只有在数据链路层会加上头部和尾部 $H<del>2</del>and<del>T</del>2$</li>
</ol>
</li>
<li><p>同理，在经过源端的协议栈的过程中，数据形成的信息分组会不断添加附加信息以供目的端使用。</p>
<ol>
<li>应用层向运输层传递message，运输层添加运输层首部信息构成了运输层的segment;</li>
<li>运输层向网络层传递segment，网络层增加源和目的端系统地址等网络层首部信息、构成网络层datagram</li>
<li>网络层向链路层传递datagram，链路层增加其首部信息并生成链路层frame</li>
</ol>
</li>
<li><p>图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242940.png" alt="image-20240316230731784" style="zoom:50%;" /></li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><blockquote>
<p>研发网络应用程序核心是写出能够运行在不同端系统和通过网络彼此通信的程序。</p>
</blockquote>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="应用层协议是什么"><a href="#应用层协议是什么" class="headerlink" title="应用层协议是什么"></a>应用层协议是什么</h4><ul>
<li>定义了运行在不同端系统上的应用进程如何进行进行报文的交换<ul>
<li><p>交换的类型</p>
</li>
<li><p>报文的语法</p>
</li>
<li><p>根据语法建立的字段的语义</p>
</li>
<li><p>进程进行报文发送的时序和次序——何时发、如何发、响应规则</p>
</li>
</ul>
</li>
</ul>
<h4 id="公开协议"><a href="#公开协议" class="headerlink" title="公开协议"></a>公开协议</h4><ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>E.g：HTTP，SMTP</li>
</ul>
<h4 id="专用协议"><a href="#专用协议" class="headerlink" title="专用协议"></a>专用协议</h4><ul>
<li>不公开</li>
<li>E.g：Skype</li>
</ul>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><h4 id="两种主流的应用程序体系结构"><a href="#两种主流的应用程序体系结构" class="headerlink" title="两种主流的应用程序体系结构"></a>两种主流的应用程序体系结构</h4><ol>
<li><p><strong>客户-服务器体系（C&#x2F;S——client-server）</strong></p>
<ul>
<li><p>有一个总是打开的主机称为<strong>服务器</strong>，服务来自其他的被称为<strong>客户</strong>的主机的请求。</p>
</li>
<li><p>以Web应用程序为例：其中总是打开的Web服务器服务于来自浏览器（运行在client主机上）的请求。当Web服务器接受到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。（相当于多了一个卖家和买家之间的中间商，其中每个client即可以是卖家、也可以是买家。</p>
</li>
<li><p>主要应用：Web、FTP、Telnet和电子邮件</p>
</li>
<li><p>该模型中客户的服务与服务器有高度的依赖</p>
</li>
</ul>
</li>
<li><p><strong>对等服务体系（P2P——Peer-to-Peer）</strong></p>
<ul>
<li><p>该模型中对服务器的依赖最小（或没有）</p>
</li>
<li><p>应用程序在间断连接的主机对之间直接通信，这些主机称为<strong>Peer</strong>，</p>
</li>
<li><p>P2P具有<strong>自扩展性</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><blockquote>
<p>进行通信的实际上是两个端系统当中创建出的同一种<strong>进程 process</strong>而非程序。</p>
<p>关注点在于——运行在不同端系统（可能具有不同的操作系统）上的进程间的通信</p>
</blockquote>
<p>在两个不同端系统当中创建的同一种进程，通过计算机网络交换**报文(message)**从而相互通信。发送进程生成并向网络发送message，接收进程接收这些message并可能通过回送message进行响应。</p>
<h5 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h5><ul>
<li><strong>客户&amp;客户端</strong>：在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程标识为客户；</li>
<li><strong>服务器&amp;服务器端</strong>：在会话开始时等待联系的进程是服务器；</li>
</ul>
<h5 id="进程和计算机网络之间的接口"><a href="#进程和计算机网络之间的接口" class="headerlink" title="进程和计算机网络之间的接口"></a>进程和计算机网络之间的接口</h5><ul>
<li><p>进程通过一个称为**套接字(socket)**的软件接口向网络发送&#x2F;接受报文。</p>
<p>host–socket–server工作图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242898.png" alt="image-20240317085036165" style="zoom:50%;" /> 
</li>
<li><p><strong>socket</strong>称为应用程序和网络之间的<strong>应用程序编程接口(Application Programming Interface API)</strong>。开发者可以控制socket在应用层端的一切。</p>
</li>
<li><p>开发者在socket的运输层只有有限的控制权：</p>
<ul>
<li>选择运输层协议；</li>
<li>可能可以设定几个运输层参数</li>
</ul>
</li>
</ul>
<h5 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h5><blockquote>
<p>就像发邮件需要有一个收件人地址，发送message数据也需要一个目的端接收进程的地址。</p>
</blockquote>
<ul>
<li><p>标识一个进程需要两种信息：</p>
<ul>
<li><p>主机地址：主机由其<strong>IP address</strong>唯一标识。</p>
<p>IP address是一个32bite的量且能够唯一标识某一台主机。</p>
</li>
<li><p>在目的主机中指定接收进程的标识符：<strong>目的地&#x2F;客户端</strong>-端口号 <strong>port number</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ul>
<li><strong>可靠数据传输</strong>：一个运输层协议实现了<strong>确保数据交付服务</strong>，则认为是可靠数据传输 reliable-data-transfer。</li>
<li><strong>吞吐量</strong>：<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。<ul>
<li>可用吞吐量可能存在波动————因为存在其他共享当前网络path的还会，随着这些会话的进入和离开导致可用吞吐量的波动。</li>
<li>需求：运输层协议能够以某种特定的速率提供确保的可用吞吐量————<strong>确保吞吐量</strong>。</li>
<li><strong>带宽敏感的应用(bandwidth-sensitive application)</strong>：具有吞吐量要求的应用程序，在吞吐量达不到协议要求时————如只有规定所需吞吐量的一半————会放弃发送给，因为对于这类应用程序，接收一半的吞吐量没有意义。</li>
<li><strong>弹性应用</strong>：课根据当前带宽或多或少利用可供使用的吞吐量。如电子邮件、文件传输以及web传送。</li>
</ul>
</li>
<li><strong>定时</strong>：</li>
<li><strong>安全性</strong>：对发送的报文信息进行加密。</li>
</ul>
<h4 id="常见的运输服务"><a href="#常见的运输服务" class="headerlink" title="常见的运输服务"></a>常见的运输服务</h4><h5 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h5><ul>
<li><strong>面向连接服务</strong>：<ul>
<li><strong>handshaking</strong>：在应用层数据message开始流动前，TCP让客户和服务器互相交换运输层控制信息。提醒客户和服务器做好准备应对接下来大量的信息分组。</li>
<li>握手阶段后：一个TCP connection在两个进程的socket间建立。该connection是全双工的————即连接双方的进程可以在此连接上同时进行message的收发；在message发送结束后必须拆除该连接。</li>
</ul>
</li>
<li><strong>可靠数据传输服务</strong>：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进socket时，它能够依靠TCP将相同的字节流交付给接收方的socket，而没有字节的丢失和冗余。</li>
<li>TCP还也有<strong>拥塞控制机制</strong>，该服务不一定可以为通信进程带来好处，但能为因特网整体带来好处————当发生端和接收端之间的网络出现拥塞，TCP拥塞控制机制会抑制发送端。</li>
</ul>
<h5 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h5><ul>
<li>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连<br>接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</li>
</ul>
<h3 id="Web-HTTP"><a href="#Web-HTTP" class="headerlink" title="Web &amp; HTTP"></a>Web &amp; HTTP</h3><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><ul>
<li><p>Web的应用层协议是<strong>超文本传输协议 HyperText Transfer Protocol,HTTP</strong>————是Web的核心。</p>
</li>
<li><p>HTTP由两个程序实现：客户程序喝服务器程序运行在不同的端系统中，通过HTTP报文进行会话。</p>
<blockquote>
<p>HTTP定义了message的结构、客户和服务器进行报文交换的方式</p>
</blockquote>
<ul>
<li>一个客户端程序</li>
<li>一个服务器程序</li>
</ul>
</li>
</ul>
<h5 id="Web页面-Web-page是由对象组成的"><a href="#Web页面-Web-page是由对象组成的" class="headerlink" title="Web页面 Web page是由对象组成的"></a><strong>Web页面 Web page</strong>是由对象组成的</h5><ul>
<li><p>一个<strong>object</strong>只是一个文件，如一个HTML文件、一个JPEG图像…且它们可以通过一个URL地址寻址。</p>
</li>
<li><p>多数page包含有一个HTML基本文件(base HTML file)以及几个引用对象。</p>
</li>
<li><p>HTML基本文件通过对象的URL地址引用页面中的其他对象。</p>
</li>
<li><p>URL由两部分组成：存放对象的服务器主机名和对象的路径名。</p>
<p>如：URL 地址 http: &#x2F;&#x2F; <a target="_blank" rel="noopener" href="http://www.someschool/">www.someSchool</a>. edu&#x2F;someDepartment&#x2F;picture.gif,其中的www. someSchool.edu就是主机名, &#x2F;someDepartment&#x2F;picture.gif就是路径名。 </p>
</li>
<li><p>Web browser实现HTTP的客户端，Web服务器实现HTTP的服务器端，用于存储Web对象，每个对象由URL进行寻址。</p>
</li>
</ul>
<h5 id="HTTP的工作方式："><a href="#HTTP的工作方式：" class="headerlink" title="HTTP的工作方式："></a>HTTP的工作方式：</h5><ul>
<li><strong>基本思想为</strong>：用户请求一个Web页面，浏览器向服务器发送该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。</li>
<li>HTTP以TCP作为支持运输的协议</li>
<li>分层体系结构最大的优点,即HTTP协议不用担心数据丢失,也不关注 TCP从网络的数据丢失和乱序故障中恢复的细节。</li>
<li><strong>HTTP是一个无状态协议 stateless protocol</strong>：HTTP并不保存任何客户状态信息，假如短时间内客户发送了两次<strong>请求同一个对象</strong>，服务器并不会因为刚刚为客户提供了该对象而不再响应，而是<strong>重新发送该对象</strong>。</li>
</ul>
<h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><p><strong>非持续连接 non-persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求&#x2F;响应对是经过单独的一个TCP进行</p>
<p><strong>持续连接 persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求&#x2F;响应对是经相同的TCP连续发送</p>
<h5 id="非持续连接的HTTP"><a href="#非持续连接的HTTP" class="headerlink" title="非持续连接的HTTP"></a>非持续连接的HTTP</h5><p>每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他对象而持续下来。每个TCP连接只传输一个请求报文&amp;一个响应报文。</p>
<p><strong>往返时间 Round-Trip Time RTT</strong>：是指一个短分组从客户到服务器然后再返回客户所花费的时间 。 </p>
<ul>
<li><p><em>RTT</em>包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
</li>
<li><p>非持续连接中一次超链接点击：设计一次“三次握手”过程。</p>
<p>客户向服务器发送一个小 TCP 报文段；</p>
<p>服务器用一个小 TCP 报文段做出确认和响应；</p>
<p>客户向服务器返回确认</p>
<p>前两个部分占用一个RTT，客户结合握手的第三部分向TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。</p>
</li>
<li><p>HTTP请求&#x2F;响应也需要用去一个RTT，因此粗略计算：$总的响应时间&#x3D;两个RTT+服务器传输HTML文件的时间$。</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>必须为每一个请求的对象建立和维护一个全新的连接，加重了服务器负担。</p>
</li>
<li><p>每个对象经受双倍<em>RTT</em>的交付时延————一个<em>RTT</em>创建TCP，另一个用于请求和接收对象</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242436.png" alt="image-20240318101113130" style="zoom:50%;" /> 
</li>
<li></li>
</ol>
<p><strong>工作全流程</strong>：</p>
<ul>
<li>HTTP客户进程在端口号xx发起一个到服务器<a target="_blank" rel="noopener" href="http://www.xxx的tcp连接,在客户端和服务器上分别有一个socket与该连接相关联./">www.xxx的TCP连接，在客户端和服务器上分别有一个socket与该连接相关联。</a></li>
<li>HTTP客户经过它的socket向该服务发送一个HTTP请求报文。请求报文中包含有路径名</li>
<li>HTTP服务器进程经它的socket接收请求报文，从其存储器中检索出对象<a target="_blank" rel="noopener" href="http://www.xxx/xxx%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AA">www.xxx/xxx，在一个</a> HTTP响应报文中封装对象，并通过其socket向客户端发送响应报文。</li>
<li>HTTP服务器进程通知断开该TCP连接。（但是直到 TCP 确认客户已经完整地收到响应报文为止,它才会实际中断连接。）</li>
<li>HTTP客户接收响应报文，TCP连接关闭。</li>
<li>重复前四个步骤；</li>
</ul>
<h5 id="采用持续连接的HTTP"><a href="#采用持续连接的HTTP" class="headerlink" title="采用持续连接的HTTP"></a>采用持续连接的HTTP</h5><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h3><p>运输层为两个主机当中的两个应用进程提供<strong>逻辑通信</strong>。</p>
<p>运输层协议在端系统中实现</p>
<ul>
<li>将发送进程接收到的报文封装成运输层分组——报文段 segment。<ul>
<li>将应用报文分为较小的块，为每个块分别加上首部就可以生成运输层的报文段 segment</li>
<li>网络层再将segment封装成网络分组——数据报 datagram</li>
</ul>
</li>
</ul>
<h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><blockquote>
<p>网络层提供了主机间的逻辑通信</p>
</blockquote>
<p>运输层只工作在端系统上，通过运输层协议将报文段通过接入网载入网络层。</p>
<p>每一层的向上都可以使用下层提供的服务，同时进行服务的拓展，再提供给上层。</p>
<p>由于网络协议的不可靠——可能造成分组丢失、篡改和冗余；运输层解决这些问题，为进程提供可靠的数据传输服务。同时运输协议还可以通过加密手段来增强网络传输的安全性。</p>
<h4 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h4><ul>
<li><p>IP 网际协议（网络层协议）</p>
<ul>
<li>服务模型为：尽力而为交付服务，best-effort delivery service。IP不确保报文段的交付、不保证报文段的有序交付，不保证报文段数据的完整性。</li>
<li>综上可知，IP是不可靠服务，ubreliable service</li>
<li>每台主机至少有一个网络层地址，即为俗称的IP地址。</li>
</ul>
</li>
<li><p>两种可用的运输层协议：</p>
<ul>
<li>UDP 无连接、不可靠的服务</li>
<li>TCP 面向连接的、可靠的服务</li>
<li>两种模型的基本职责是：将端系统间IP的交付服务拓展为端系统上正在运行的进程间的交付服务。这种将主机间交付拓展为进程间交付的行为称之为：<strong>运输层的多路复用 transport-layer multiplexing</strong>和<strong>多路分解 demultiplexing</strong>。</li>
<li>同时，协议还可以根据报文段首部当中的字段进行包括检错等服务的拓展</li>
</ul>
</li>
<li><p>TCP提供的附加服务：</p>
<ul>
<li>可靠数据传输 reliable data transfer：通过流量控制、序号、确认和定时器，TCP可以正确地、按序地将数据从发送进程交付给接收进程。</li>
<li>拥塞机制 congestion control：</li>
</ul>
</li>
</ul>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>一个进程有一个或多个<strong>套接字socket</strong>——网络和进程相互传递数据的门户。</p>
<h4 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h4><p>在接收端，运输层检查字段，标识接收socket，将segment定向到特定的socket。将运输层segment交付到正确的socket的这个过程称之为多路分解。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在源host从不同socket收集数据，并将每个数据块加上首部信息封装成报文段，然后将报文段传递到网络层，该过程称之为多路复用。</p>
<p>多路复用的实现需要什么要求：</p>
<ul>
<li>socket有唯一标识</li>
<li>每个报文段有特殊的字符用于定位到对应的socket<ul>
<li>即源端口字段 source port number field和目的端口字段 destination port number field</li>
<li>端口号：16bit的数，0~1023为周知端口号 well-known port number，是被保留的</li>
</ul>
</li>
</ul>
<blockquote>
<p>将数据分发给每一个socket是分解</p>
<p>将从不同socket收集到一起，再将其统一传递是复用</p>
</blockquote>
<h4 id="UDP的多路复用"><a href="#UDP的多路复用" class="headerlink" title="UDP的多路复用"></a>UDP的多路复用</h4><p>主机为每一个socket分配一个port，当segment到达主机时，检查segment当中的destination port，用这个d port定位到对应的socket，而后将data通过socket进入到相应的进程当中。</p>
<p>一个udp socket是由一个二元组进行标识</p>
<ul>
<li>二元组：一个目的IP地址和一个目的端口号</li>
<li>如果两个 UDP 报文段有不同的源 IP 地址和源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</li>
<li>源端口号和源IP地址的用途：<ul>
<li>用于数据的返回发送，当A到B的数据传输完，B需要给A传时，则使用到A传输过来的数据当中的源port和IP地址。当B传A时，源和目的发生了改变。</li>
</ul>
</li>
</ul>
<h4 id="TCP的多路复用与多路分解"><a href="#TCP的多路复用与多路分解" class="headerlink" title="TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h4><p>TCP socket是一个四元组（源IP地址，源port，目的IP地址，目的port）来标识。</p>
<p>TCP建立连接示例：</p>
<ul>
<li>client创建一个socket，并发送连接建立请求</li>
<li>当运行 server 进程的主机收到报文段，定位到进程，在该服务器进程创建一个新的socket</li>
<li>根据连接请求报文段当中的四个值：1.源port，2.源IP地址，3.目的port，4.目的IP地址，进行socket的创建，之后再有与这四个值匹配的首部则会将报文段传给创建好的socket。</li>
<li>当TCP报文段达到主机，根据四个字段将报文段定向（分解）到对应socket。</li>
</ul>
<h4 id="Web服务器和TCP"><a href="#Web服务器和TCP" class="headerlink" title="Web服务器和TCP"></a>Web服务器和TCP</h4><p>当今的高性能 Web 服务器边常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程（单个进程里可以同时有多个线程）。 </p>
<h3 id="UDP：无连接传输"><a href="#UDP：无连接传输" class="headerlink" title="UDP：无连接传输"></a>UDP：无连接传输</h3><p>运输层需要最低限度地提供一种复用&#x2F;分解服务，以便在网络层和正确的应用层进程间进行数据的传递。</p>
<h4 id="UDP功能"><a href="#UDP功能" class="headerlink" title="UDP功能"></a>UDP功能</h4><ol>
<li>复用&#x2F;解复用</li>
<li>少量的差错检测</li>
</ol>
<blockquote>
<p>因为基本没有在IP基础上进行更多功能的拓展，仅是完成了传输层的本职工作，因此采用UDP的应用程序，相当于直接应用IP协议。</p>
</blockquote>
<h4 id="使用UDP的过程解析："><a href="#使用UDP的过程解析：" class="headerlink" title="使用UDP的过程解析："></a>使用UDP的过程解析：</h4><ol>
<li>UDP 从应用进程得到数据，附加上用于多路复用&#x2F;分解服务的<strong>源和目的port</strong>字段以及两个其他的小字段，然后将形成的报文段segment交给网络层。 </li>
<li>网络层将该运输层报文段封装到一个IP数据报datagram中,然后尽力而为地尝试将此报文段交付给接收主机。</li>
<li>如果该报文段到达接收主机，UDP使用<strong>目的port</strong>将报文段中的数据交付给port对应的应用进程。</li>
</ol>
<blockquote>
<p>在发送报文段之前，sender和receiver的运输层实体间未建立连接，因而称之为无连接</p>
</blockquote>
<p>DNS是使用UDP的典例：</p>
<p>进行一次DNS查询，将查询报文交给UDP，无需建立连接，主机的UDP为查询报文添加首部字段，而后交给网络层，网络层将报文段封装成数据报，发送给dns服务器进行查询，查询主机中的DNS应用这等待响应；若未收到响应，这试图向其他的dns服务器发送查询请求or报错未得到响应。</p>
<h5 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h5><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242311.png" alt="image-20240523175429387" style="zoom:50%;" /> 

<ol>
<li><p>首部四个字段，每个字段有2两个字节组成</p>
</li>
<li><p>源端口号：用于后续可能的数据回传</p>
</li>
<li><p>目的端口号：初始化socket</p>
</li>
<li><p>长度：指示UDP报文段的字节数（head（花销）+data（载荷））</p>
</li>
<li><p>检验和：用于校验数据是否出现错误 EDC 差错检测编码</p>
</li>
</ol>
<p>检验和</p>
<ul>
<li><p>作用</p>
<p>用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变</p>
</li>
<li><p>发送方校验和的计算方法</p>
<p>对发送方的 UDP 报文段的所有 16 比特字的和进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E7%A0%81&spm=1001.2101.3001.7020">反码</a>运算，当求和遇见溢出的时候，进行回卷（回卷的补充在下面），得到的结果放在 UDP 报文段中的检验和字段</p>
</li>
<li><p>什么是回卷</p>
<p>所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第 17 位和后 16 位进行加法和运算。</p>
</li>
</ul>
<h3 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h3><h4 id="可靠传输服务的概念："><a href="#可靠传输服务的概念：" class="headerlink" title="可靠传输服务的概念："></a>可靠传输服务的概念：</h4><p>就可靠传输这一服务而言，位于较低的层次为上层实体提供的服务可以抽象为一种抽象服务：数据可以通过一条可靠的信道进行传输。借助该信道，数据比特可以无损、无丢失地按照发送顺序进行交付，恰好就是TCP提供的服务模型</p>
<p>实现这种抽象服务即为可靠数据传输协议 reliable data transfer protocol RDT的任务。</p>
<h4 id="传输过程："><a href="#传输过程：" class="headerlink" title="传输过程："></a>传输过程：</h4><p>rdt_send()被最上层调用，将data交付给下层的发送实体</p>
<p>-&gt;udt_send()被rdt调用，用于将分组放在不可靠的信道上传输给接收方</p>
<p>-&gt;rdt_rev()当分组到达接收方时调用</p>
<p>-&gt;deliver_data()被rdt调用，将pkt当中的data传输给应用层</p>
<h4 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h4><blockquote>
<p>假设数据在信道中不丢失、不出错</p>
</blockquote>
<p>使用有限状态机 FSM 进行状态的表示，使用带箭头的edge表示状态的变迁，edge上带有便标注：</p>
<ul>
<li>分子表示变迁条件——即A状态做出了什么动作导致了跳转到B状态</li>
<li>分母表示：状态变迁状态过程中A状态做出的动作。</li>
</ul>
<h4 id="rdt2-0-StopAndWait"><a href="#rdt2-0-StopAndWait" class="headerlink" title="rdt2.0(StopAndWait)"></a>rdt2.0(StopAndWait)</h4><blockquote>
<p>假设数据会出错但不会丢失</p>
</blockquote>
<p>使用肯定确认 positive ackonwledgment ACK和否定确认negative ackonwledgment NCK——自动重传请求（Automatic Repeat reQuest,ARQ）协议</p>
<ul>
<li>差错检测</li>
<li>接收方反馈：通过接收方发送回来的回馈信息为：ACK or NCK来了解接收方的接收情况</li>
<li>重传：接收方接收到有差错的分组时，发送方重新发送数据给接收方</li>
</ul>
<p>rdt3.0：经具有比特差错的丢包信道的可靠数据传输</p>
<h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>接收方处理出错的ACK&#x2F;NCK</p>
<p>假设接收方接受了P0，当接收方发送的返回的ACK_0&#x2F;NCK_0发生错误，导致发送方重复发送了P0，则接收方不接收这个重复的P0但重新发送ACK_0以处理ACK出错的情况，使得发送方和接收方重新回到同步状态</p>
<p>发送方：</p>
<ul>
<li>在每一个pkt里加入序列号：两个序列号（0,1）</li>
<li>一次只发送一个未经确认的分组</li>
<li>需要检测ACK&#x2F;NCK是否出错</li>
</ul>
<p>接收方：</p>
<ul>
<li>需要检测出收到的分组是否重复<ul>
<li>状态会指示出希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="rdt2-2-NAK-free"><a href="#rdt2-2-NAK-free" class="headerlink" title="rdt2.2 NAK-free"></a>rdt2.2 NAK-free</h4><p>对ACK进行编号，通过对前一个分组的ACK来代替这一个NAK，即期待得到NAK_0，当得到ACK_1时相当于实现了同样的效果</p>
<h4 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h4><blockquote>
<p>数据会丢失、会出错</p>
</blockquote>
<p>超时重传机制：</p>
<p>启动一个计时器，比一个RTT多一点的时间，当超时则重新发送pkt</p>
<p>不担心重复，因为分组有序，重复问题在rdt2.2解决了</p>
<p>动态设置计时器</p>
<p>迭代到rdt3.0，则停等协议已经满足了抗丢失、可检错的需求，较为完备，但该协议在信道容量较大时，效率较低。因为信道的利用率很低</p>
<h4 id="流水线可靠数据传输协议-Pipeline-："><a href="#流水线可靠数据传输协议-Pipeline-：" class="headerlink" title="流水线可靠数据传输协议(Pipeline)："></a>流水线可靠数据传输协议(Pipeline)：</h4><blockquote>
<p>在rdt3.0的基础上，由一次发一个未经确认的分组改成一次发多个未经确认的分组</p>
</blockquote>
<h5 id="滑动窗口-SlideWindow-协议："><a href="#滑动窗口-SlideWindow-协议：" class="headerlink" title="滑动窗口(SlideWindow)协议："></a>滑动窗口(SlideWindow)协议：</h5><p>缓冲区：暂时存放已发送的分组，以备检错重发和超时重发；但是存放在发送缓冲区的分组不一定都是已发送的。缓冲区的大小决定了一次可以发送多少个未经确认的分组。</p>
<table>
<thead>
<tr>
<th>发送方窗口大小</th>
<th>接收方窗口大小</th>
<th>协议</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>stop-wait</td>
<td></td>
</tr>
<tr>
<td>&gt;1</td>
<td>1</td>
<td>GBN</td>
<td>累计确认</td>
</tr>
<tr>
<td>&gt;1</td>
<td>&gt;1</td>
<td>SR select_repeat</td>
<td>非累计确认</td>
</tr>
</tbody></table>
<p>发送窗口：发送缓冲区的一个范围，发送缓冲区的一个子集；发送窗口内的分组都是已发送待确认的，每确认一个分组则窗口向前滑动一个分组；窗口的大小小于或等于缓冲区大小。</p>
<p>回退N步 GBN (Go_Back_N_Steps)</p>
<ul>
<li>基序号：将基序号定义为最早未确认分组的序号</li>
<li>下一个序号：定义为最小的未使用序号</li>
<li>则可将序号范围分成了四个部分：<ul>
<li>已发送已确认的分组</li>
<li>已发送未确认的分组</li>
<li>即将被发送的分组</li>
<li>尚未能使用</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242093.png" alt="image-20240527162540507"> </p>
<p>在发送方有一个N大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为1的接收窗口，</p>
<p>假设当前接收窗口指向为pkt_1，但到来的是pkt_2，首先抛弃掉pkt_2，在迟迟等不到pkt_1，接收方无法发送ACK_1，则发送方计时器超时，发送窗口和发送缓冲区不会向前移动，需要重新发送整个发送窗口内的分组，因为可能有一些分组比pkt_1先到达（例如pkt_2）当被舍弃了，则需要重新发送。</p>
<h5 id="Select-repeat-选择重传"><a href="#Select-repeat-选择重传" class="headerlink" title="Select repeat 选择重传"></a>Select repeat 选择重传</h5><p>在发送方有一个SN大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为RN的接收窗口</p>
<p>在发送方每发送一个pkt就会开启一个timepiece 计时器记录该分组是否超时，每收到一个对应分组的ACK则会关闭对应的tp，哪个分组的计时器超时则重新发送哪个分组，从而达到选择重传的效果</p>
<p>假设当前RW内包含分组：pkt_1、2、3、4；则每来一个RW内的分组都可以被接收并发送一个ACK信号给发送方，但是当且仅当到达的是，RW最前面的那个分组，到达，才可以将接收窗口前移：</p>
<p>假设先来的是pkt_2、和3，则接收方返回ACK_2、3，但是窗口不移动，当接收到pkt_1时，将pkt_1、2、3解码读取出data上传给应用层并将窗口前移3格，更新RW为：pkt_4、5、6、7</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>点对点</li>
<li>可靠、按顺序</li>
<li>管道化</li>
<li>发送和接收缓存</li>
<li>全双工</li>
<li>面向连接：数据交换之前需要建立连接</li>
<li>有流量控制</li>
</ul>
<p><strong>报文段结构：</strong> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242029.png" alt="img"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242460.png" alt="img"> </p>
<blockquote>
<p>MSS：每个TCP报文段中数据字段的最大长度，仅为数据部分的字段，不包括TCP的head</p>
</blockquote>
<ul>
<li><p>HEAD：</p>
<ul>
<li><p>头部长度为：长20字节：</p>
</li>
<li><p>序号seq：报文段的第一个字节+N个偏移量（MSS*N）</p>
<p>第一个字节，假设seq &#x3D; m，则传过去的数据序号就是m</p>
</li>
<li><p>确认号ack:第二个字节，假设ack &#x3D; n，相当于告诉对方n-1号以前的序号已经确认完毕，需要从第n号开始传</p>
</li>
<li><p>标志位：</p>
<ul>
<li><p>URG：紧急指针，为1时表示紧急指针有效</p>
</li>
<li><p>SYN：同步序号，用于建立连接，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。</p>
</li>
<li><p>FIN：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li><p>RST：重置连接标志，</p>
</li>
<li><p>ACK：确认序号标志，为1时表示确认号ack有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
</ul>
</li>
<li><p>receive window：窗口大小，可以用于流量控制</p>
</li>
</ul>
</li>
<li><p>DATA：</p>
</li>
</ul>
<p>cumulative ack 累计确认</p>
<p>一条TCP连接的双方均可随机地选择初始序号。</p>
<h4 id="TCP的RTT估计和超时"><a href="#TCP的RTT估计和超时" class="headerlink" title="TCP的RTT估计和超时"></a>TCP的RTT估计和超时</h4><p>样本RTT：从某报文段被发出到对该报文段的确认被收到之间的时间量。</p>
<p>获得新的一段时间内的某一时刻的样本RTT时，需要重新计算 预估的RTT</p>
<p>$RTT_s &#x3D; (1-\alpha)*RTT_s +  \alpha * RTT$</p>
<p>一般$\alpha$取0.125，则上面的式子改写成：$RTT_s &#x3D; (0.875)*RTT_s +  0.125 * RTT$</p>
<p>DevRTT &#x3D; (1-β) · DevRTT + β·|RTT - RTT_s| β一般取0.25</p>
<p>重传RTT设置为：RTT_s + 4*DevRTT</p>
<p>初始 Timeoutlnterval 值为 1 秒，出现超时后将 timeoutinterval的值加倍，以免即将确认的后继报文过早超时。</p>
<h4 id="TCP-超时重传时间设置"><a href="#TCP-超时重传时间设置" class="headerlink" title="TCP 超时重传时间设置"></a>TCP 超时重传时间设置</h4><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ul>
<li><p>一直顺序到达：</p>
<p>暂缓发送ack，设置一个定时器，在定时器超时之前如果又来了一个新的顺序分组，则重启定时器，再次暂缓发送ack，直到超时；因为累计确认，则在超时发送的那个ack之前的那些分组都是确认过的了</p>
</li>
<li><p>乱序到达：</p>
<p>赶紧将需要的顺序最小的期待收到的发一个ack通知发送方重新发送</p>
</li>
<li><p>前面顺序，中间有一个乱序：</p>
<p>有一部分gap未到达：缺那部分发哪部分的ack通知重传</p>
</li>
<li><p>快速重传：三个冗余ack触发的重传，无须等待发送方的计时器超时</p>
<p>例如：[30,39] [40,44] [45,50] [51,60] [60,70]</p>
<p>其中除了[40,44]其他几个都已到达</p>
<p>[30,39] 发送第一个正常的ack_40；后面三个分组则会发送三个冗余的ack_40给发送方，从而触发快速重传机制</p>
</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>接收方使用捎带技术(Piggybacking)，将本地空闲缓冲区的大小反馈发送方，告知其接下来可以发送数据的大小规模，则不会因为发送方发送过多，接收方处理能力无法跟上导致的数据被大量舍弃。</p>
<h4 id="连接控制"><a href="#连接控制" class="headerlink" title="连接控制"></a>连接控制</h4><blockquote>
<ol>
<li>双方知道要建立通信</li>
<li>为从此通信准备好缓冲区</li>
<li>为要发送的数据和控制变量做一些制位操作，告诉彼此初始序号、窗口大小等一些必要信息</li>
</ol>
</blockquote>
<p>需要三次握手</p>
<ol>
<li>申请连接</li>
<li>同意申请连接</li>
<li>告知已知道对方同意</li>
</ol>
<ul>
<li><h2 id="SYN位："><a href="#SYN位：" class="headerlink" title="SYN位："></a>SYN位：</h2></li>
<li>FIN位</li>
<li>RST位</li>
</ul>
<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><h5 id="释放连接"><a href="#释放连接" class="headerlink" title="释放连接"></a>释放连接</h5><p>一个完整的TCP连接可以视为两个 半连接 ，即 C-&gt;S 和 S-&gt;C ，因此如果要进行释放则是释放两个 半连接。首先 C 向 S 发送释放请求，S 同意后C不再向S发送数据，但是此时S仍然可以向C发送数据——一种对称式的拆除。在第二个 半连接释放多一步细节，在发送ACK后，启动一个定时器，在超时之前没有数据再传过来，则彻底关闭连接</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络有太多数据，超过了网络的处理能力</p>
<p>两种控制方法：</p>
<ol>
<li>端到端拥塞控制：<ol>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件判断是否有拥塞</li>
<li>TCP采用的方式</li>
</ol>
</li>
<li>网络辅助的拥塞控制<ol>
<li></li>
</ol>
</li>
</ol>
<p>ATM ABR拥塞控制</p>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>采用端对端的拥塞控制</p>
<p>自我感知：</p>
<p>将复杂的放在边缘部分，core部分提供简单服务与功能</p>
<h4 id="是否发生拥塞"><a href="#是否发生拥塞" class="headerlink" title="是否发生拥塞"></a>是否发生拥塞</h4><ol>
<li><p><strong>超时</strong>：</p>
</li>
<li><p><strong>三个冗余ACK</strong>：</p>
</li>
</ol>
<h4 id="如何控制发送方发送速率"><a href="#如何控制发送方发送速率" class="headerlink" title="如何控制发送方发送速率"></a>如何控制发送方发送速率</h4><ul>
<li><p>维持一个拥塞窗口：CongWin</p>
</li>
<li><p>发送方限制已发送但未确认的数据量（的上限）</p>
</li>
<li><p>从而粗略控制发送方往网络中注入的速率 $rate &#x3D; \frac{CongWin}{RTT}$ </p>
</li>
<li><p>SS阶段：加倍增加（每个RTT）</p>
</li>
<li><p>CA阶段：线性增加（每个RTT）</p>
</li>
<li><p>CongWin是动态的，可以感知到网络拥塞程度的函数</p>
<ul>
<li>超时：CongWin降为 1 MSS，进入SS阶段然后再倍增到 CongWin&#x2F;2(每个RTT)，从而进入CA阶段</li>
<li>冗余ACK：CongWin降为CongWin&#x2F;2，CA阶段</li>
<li>否则（即正常收到ACK）：CongWin跃跃欲试</li>
</ul>
</li>
</ul>
<h4 id="联合控制："><a href="#联合控制：" class="headerlink" title="联合控制："></a>联合控制：</h4><ul>
<li><p>发送方已发送但未确认的数据量不超过接收窗口的空闲尺寸、也不超过拥塞窗口</p>
</li>
<li><p>可以同时满足拥塞控制和流量控制</p>
</li>
<li><p>$SendWin &#x3D; min { CongWin,RecvWin } $</p>
</li>
</ul>
<h4 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h4><ul>
<li>慢启动<ul>
<li>连接刚建立：CongWin &#x3D; 1 MSS</li>
<li>每收到一个确认，CongWin加倍增长，指数级增长——必然导致拥塞</li>
<li>超时后：重置为 1 MSS，而后加倍达到标记处(CongWin&#x2F;2)，而后进行线性增长(一个个MSS增加)</li>
<li>冗余ACK后：重置为 CongWin&#x2F;2</li>
</ul>
</li>
<li>AIMD：线性增长、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242079.png" alt="image-20240529221931664"> </p>
<h4 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h4><p>$ (\frac{CongWin}{2},CongWin)$ </p>
<p>$吞吐量为：\frac{ \frac{CongWin}{2} + CongWin}{2 \times RTT} &#x3D; \frac{3}{4}\frac{CongWin}{RTT}$​ </p>
<h2 id="网络层：概述"><a href="#网络层：概述" class="headerlink" title="网络层：概述"></a>网络层：概述</h2><blockquote>
<p>网络层重要的两个功能：转发和路由</p>
<p>转发：数据平面</p>
<p>路由：控制平面——是全局的，在整个网络层面寻找源和目标post</p>
</blockquote>
<p>网络层的功能：</p>
<ol>
<li>在post之间传送 segment&#x2F;datagram</li>
<li>在发送段将段封装到数据报中</li>
<li>在接收端将段上报给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ol>
<h3 id="转发功能"><a href="#转发功能" class="headerlink" title="转发功能"></a>转发功能</h3><ul>
<li>传统方式：基于目标地址和转发表</li>
<li>SDN方式：基于多个字段+流表</li>
</ul>
<h3 id="控制平面方法："><a href="#控制平面方法：" class="headerlink" title="控制平面方法："></a>控制平面方法：</h3><ul>
<li>传统的路由器算法：在路由器中实现<ul>
<li>每一个路由器中的单独路由器算法元件，在控制平面进行交互</li>
<li>一个路由器实现了数据和控制平面的功能</li>
<li>路由实体和其他路由器实体交互路由器信息，分布式地计算流表</li>
<li>算出的流表交给IP协议实体，IP实体根据到来的分组的目标IP地址进行匹配，进而完成分组的转发动作</li>
<li>数据和控制平面紧耦合</li>
</ul>
</li>
<li>software-defined networking（SDN）：在远程的服务器中实现<ul>
<li>一个不同的（通常是远程的）控制器（网络操作系统）和本地控制代理（CAs）交互</li>
<li>CAs上报当前本地状况</li>
<li>控制器根据CAs给出的状态数据算出相对应的流表</li>
<li>而后通过南向接口将流表交给每一个分组交换设备</li>
<li>分组交互设备将流表装载好，而后对每一个到来的分组进行多个字段的匹配，同时流表内已经设置好了分组动作，当一个分组匹配到哪个流表，则会相对应的执行该流表内的分组动作（转发、阻塞、）</li>
<li>由分布式修改为了集中式</li>
</ul>
</li>
</ul>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><h4 id="指标："><a href="#指标：" class="headerlink" title="指标："></a>指标：</h4><ul>
<li>对于单个数据报而言：<ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
</li>
<li>对于数据报流：<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组间的延迟差 jitter</li>
</ul>
</li>
<li>建立连接<ul>
<li>某些架构内是重要的功能</li>
<li>网络层的连接和传输层不一样（在传输层的TCP指的是面向连接，即源post的某个进程和目标post的某个进程之间的连接，与中间的交换设备无关，体现在端系统之间的逻辑连接）而网络层是两个主机之间的连接，涉及到路径上的路由器</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242143.png" alt="image-20240530120240222"> </p>
<p>一类指标组成的服务称之为服务模型，而基于这种服务模型建立起来的协议的模型可以用这类服务模型来代指</p>
<h3 id="路由器的组成"><a href="#路由器的组成" class="headerlink" title="路由器的组成"></a>路由器的组成</h3><p>路由：运行路由选择算法&#x2F;协议(RIP,OSPF,BGP)——生成流表</p>
<p>转发：从输入到输出链路交互数据报——根据流表进行分组<strong>转发</strong></p>
<p>具有输入输出端口，输入到输出端口存在queue，输出端口到链路层也有queue，因为传输延迟做不到百分之百为0，因而需要把一些frame暂时放在缓存queue当中，而后这些frame的发送也需要一定的调度schedule方法。</p>
<h4 id="调度规则："><a href="#调度规则：" class="headerlink" title="调度规则："></a>调度规则：</h4><ul>
<li>FIFO 先到先服务<ul>
<li>按照分组到来次序</li>
<li>丢弃策略也是FIFO</li>
</ul>
</li>
<li>优先级 <ul>
<li>多类，不同分类有不同级别</li>
</ul>
</li>
<li>RoundRobin RR 调度<ul>
<li>轮换法</li>
</ul>
</li>
<li>Weighted Fair Queuing WFQ 加权公平队列<ul>
<li>服务时间可以根据权重计算得出</li>
</ul>
</li>
</ul>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><p>20 byte的TCP 20 byte的IP &#x3D; 40 bytes + app layer overhead</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242655.png" alt="image-20240530144524045"> </p>
<p>TTL(time to live)生存时间：每经过一个三层设备TTL-1，当TTL&#x3D;&#x3D;0时，数据包丢弃（向源主机发一个ICMP的错误信息报文通知源post）</p>
<p>option，一般没有，可以有</p>
<h4 id="IP的分片和重组"><a href="#IP的分片和重组" class="headerlink" title="IP的分片和重组"></a>IP的分片和重组</h4><p>FDDI</p>
<p>对于每个frame：head+body 组成，body的最大长度即为MTU</p>
<p>对于一个较大的segment，将其进行分片，分片原理：</p>
<ul>
<li>首先复制首部，因此分片出来的每一个frame具有相同的源id，因而可以标识为同一个分组分片出来的片段，其次使用offset进行每个分组的序号依据，最后在目标主机根据offset进行重组。</li>
</ul>
<h4 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h4><p><strong>IP地址</strong>：32位标示，对主机或路由器的接口编址</p>
<ul>
<li>使用IP地址用来标识设备</li>
</ul>
<p><strong>接口</strong>：主机&#x2F;路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也可能拥有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
<p>一个IP地址和一个接口相关联</p>
<h4 id="子网-Subnets"><a href="#子网-Subnets" class="headerlink" title="子网 Subnets"></a>子网 Subnets</h4><p>IP地址：</p>
<ul>
<li>子网部分（高位）</li>
<li>主机部分（低位）</li>
</ul>
<p>一个子网内的节点，它们的IP地址高位部分相同，这些节点构成的网络称之为子网</p>
<p>无需路由器介入，子网内各个主机可以在物理上相互直接到达，可以借助于交换机</p>
<p>纯子网两个特点：</p>
<ul>
<li>前缀相同（高位相同）</li>
<li>他们之间的分组转发在ip层面一跳可达，无须借助路由器</li>
</ul>
<p>互联网：点到点</p>
<p>局域网：多点连接——通过交换机相连，</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242162.png" alt="img"> </p>
<p>每个ip地址包含两个标识码ID：网络ID和主机ID</p>
<ul>
<li><p>A类地址：网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0， 共126个网络地址，全零和全1的地址不使用，$2^{7}-2$ </p>
</li>
<li><p>B类地址：网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255，$2^{14}-2$ </p>
</li>
<li><p>C类地址：网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。$2^{30}-2$​ </p>
</li>
<li><p>D类地址：IP地址第一个字节以“1110”开始，它是一个专门保留的地址。224.0.0.0到239.255.255.255用于多点广播。</p>
<ul>
<li>每个网络地址容纳254个主机</li>
<li>多点广播（Multicast）中</li>
</ul>
</li>
</ul>
<p>A、B、C类称为单播地址</p>
<p>D类称之为主播地址——发送给属于主播组的成员</p>
<p>广播一般是局域网内部的广播，一般不会是全球范围的广播</p>
<p>互联网的路由以网络为单位，做路由信息的发布和路由信息的计算：每一个网络是一个流表</p>
<p>特殊IP地址：</p>
<ul>
<li>子网部分：全为0——本网络</li>
<li>主机部分：全为0——本主机</li>
<li>主机部分：全为1——广播地址，这个网络的舍友主机</li>
</ul>
<p>回路地址：127.x.x.x，该地址为目标ip，则tcp\udp将分组传输到ip层时会回传，又称为测试地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242150.png" alt="image-20240602222253233"> </p>
<p>IP编制：CIDR Classless InterDomaiin Routing</p>
<p>无类域间路由</p>
<ul>
<li>子网部分可以在任意位置</li>
<li>地址格式为：a.b.c.d&#x2F;x，x是地址中子网号的长度</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243270.png" alt="image-20240602222546094"></li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>使用32位bit标识网络id和主机id</p>
<p>两种标书方法：</p>
<ul>
<li>直接32位 1标识网络号，0标识主机号</li>
<li>&#x2F;xx，标识前xx位为网络号</li>
</ul>
<h3 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h3><h4 id="动态分配的过程："><a href="#动态分配的过程：" class="headerlink" title="动态分配的过程："></a>动态分配的过程：</h4><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243726.png" alt="image-20240602224024681"> </p>
<h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>集中化网络控制器</p>
<p>匹配目标ip、源IP、目标端口、源端口</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243300.png" alt="image-20240603092539337"> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243987.png" alt="image-20240603092754178"> </p>
<h2 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h2><blockquote>
<p>决定数据如何走，传输过程</p>
</blockquote>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><blockquote>
<p>选择一条合适的路径从源主机到目标主机</p>
<p>网络层的路由是由子网到子网的路由，而非主机到主机</p>
<p>子网聚集下，可以先当作子网到子网，减少工作量，到了子网后再在子网内找主机，提高效率，分治思想，一步步解决一个复杂的大问题，分成一个个子问题</p>
<p>一个路由器代表着一个子网，则由子网到子网的路由相当于从路由器到路由器的路由</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243422.png" alt="image-20240603093907802"> </p>
<h4 id="最优化原则-optimality-principle"><a href="#最优化原则-optimality-principle" class="headerlink" title="最优化原则 optimality principle"></a>最优化原则 optimality principle</h4><ul>
<li>汇集树 sink tree<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243521.png" alt="image-20240603101328110"> </li>
<li>找到的最优路径是一棵树而不是一个图，因为不可能存在环</li>
</ul>
</li>
</ul>
<h4 id="Link-State-LS"><a href="#Link-State-LS" class="headerlink" title="Link State LS"></a>Link State LS</h4><ul>
<li>迪杰斯特拉算法——核心<ul>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243409.png" alt="image-20240603112241395"></li>
</ul>
</li>
<li>LS应用情况：<ul>
<li>OSPF协议是一种LS协议，用于Internet上</li>
<li>IS-IS(intermediate system-intermediate system)：用于Internet主干上，NetWare</li>
</ul>
</li>
</ul>
<h4 id="Distance-Vectos-DV"><a href="#Distance-Vectos-DV" class="headerlink" title="Distance Vectos DV"></a>Distance Vectos DV</h4><h3 id="自治系统内部的路由选择"><a href="#自治系统内部的路由选择" class="headerlink" title="自治系统内部的路由选择"></a>自治系统内部的路由选择</h3><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>RIP算法，相邻路由器之间互相传递路由表信息，信息包括：目标主机和到相邻的节点的距离。通过每一次交互进行路由表的迭代，最终可以完成收敛，进而得出每个节点到其他所有节点的最短路径。</p>
<p>好消息传递快，坏消息传递慢</p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>SPF，最短路径优先</p>
<p>洪泛法——广播</p>
<p>发送信息：本路由器相邻的室友路由器的链路状态</p>
<p>当链路状态发生变化时，进行一次洪泛发送</p>
<ul>
<li><p>重要的分组：</p>
<ul>
<li><p>HELLO分组，问候分组</p>
</li>
<li><p>DD分组，数据库描述分组</p>
</li>
<li><p>LSR分组，链路状态请求分组</p>
</li>
<li><p>LSU分组，链路状态更新分组</p>
</li>
<li><p>LSAck分组，链路状态确认分组</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243391.png" alt="image-20240603210211955"> </p>
<p>网络较大，将网络分成多个区域——自治系统AS，本区域的洪泛不会影响到其他区域area，而后是区域间进行分组传递交由area0去路由到目标主机的area，再到与目标相邻的路由器。</p>
<h3 id="ISP之间路由选择：BGP"><a href="#ISP之间路由选择：BGP" class="headerlink" title="ISP之间路由选择：BGP"></a>ISP之间路由选择：BGP</h3><p>自治区AS之间的选择协议</p>
<p>每个AS有一个BGP发言人，相邻的AS通过BGP发言人交换信息</p>
<p>BGP发言人交换的信息：到达某个网络所需要经过的一系列AS，根据收到的信息选择较好的路由。</p>
<p>BGP路由器既需要管理外部AS间路由的选择，同时也需要执行自治系统内部的路由的选择</p>
<p>BGP路由表包括：网络前缀，下一跳，到达目的网络所要经过的各个自治系统系列（路径）</p>
<blockquote>
<p>三种路由协议：</p>
<ul>
<li>RIP，用于自治系统，内部网关。采用UDP报文来交互路由信息</li>
<li>OSPF，用于自治系统，内部网关。采用IP报文</li>
<li>BGP，用于自治系统之间，外部网关，因网络环境复杂，需要可靠传输，采用TCP报文</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243667.png" alt="image-20240603222249253"> </p>
</blockquote>
<h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><h3 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243042.png" alt="image-20240603222345159"> </p>
<p>支持主机或路由器：</p>
<ul>
<li>差错&#x2F;异常报告</li>
<li>网络探询</li>
</ul>
<p>报文结构：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243232.png" alt="image-20240603222515556"> </p>
<ul>
<li><p>差错报文：</p>
<ul>
<li><p>终点不可达：无法交付，向源主机发送终点不可大报文</p>
</li>
<li><p>（取消了）源点抑制：当由于拥塞而丢弃数据报时，向源主机发送抑制报文，让源主机放慢数据报发送速率（一种反馈）</p>
</li>
<li><p>时间超过：当TTL&#x3D;0时，丢弃报文，同时向源主机发送时间超过报文。当终点在预定时间内未收到一个数据报的完整数据片，就把已收到的数据片丢弃并发送时间超过报文</p>
</li>
<li><p>参数问题：首部字段出问题</p>
</li>
<li><p>改变路由（重定向）：修改发送数据报去往的路由器到更好的路由器。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243582.png" alt="image-20240603223206089"> </p>
</li>
<li><p>不发生ICMP差错报文的情况：</p>
<ul>
<li>对ICMP差错报文不发送</li>
<li>只对第一个数据片发送ICMP差错</li>
<li>对具有组播地址的数据报都不发送</li>
<li>对具有特殊地址的数据报不发送</li>
</ul>
</li>
</ul>
</li>
<li><p>ICMP询问报文</p>
<ul>
<li>回送请求和回答报文：</li>
</ul>
</li>
</ul>
<p>ICMP应用：</p>
<ul>
<li>PING</li>
<li>Traceroute</li>
</ul>
<h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><p>网卡实现了链路层和物理层的功能</p>
<ul>
<li><p>数据链路层的原理：</p>
<ul>
<li>检错和纠错</li>
<li>共享广播信道：多点接入</li>
<li>链路层寻址</li>
<li>LAN：以太网、VLANS</li>
<li>可靠数据传输，流控制：donel</li>
</ul>
</li>
<li><p>点到点的链路</p>
</li>
<li><p>多点连接的链路</p>
<ul>
<li>同轴电缆</li>
<li>网络通信设备都接入交换机，通过交换机进行信息的传递</li>
</ul>
</li>
<li><p>节点：</p>
<ul>
<li>主机和路由器都是节点 nodes，网桥和交换机也是节点</li>
</ul>
</li>
<li><p>链路：</p>
<ul>
<li>将节点连接在一起的边</li>
</ul>
</li>
<li><p>帧 frame：</p>
<ul>
<li>链路层的pdu protocol data unit，</li>
</ul>
</li>
</ul>
<h3 id="检错和纠错"><a href="#检错和纠错" class="headerlink" title="检错和纠错"></a>检错和纠错</h3><p>EDC &#x3D; 差错检测和纠正位（冗余位）</p>
<p>D &#x3D; 数据由差错检测保护，可以包含头部字段</p>
<ul>
<li>奇偶校验<ul>
<li>单bit奇偶校验</li>
<li>2维奇偶校验</li>
</ul>
</li>
</ul>
<h4 id="CRC-循环冗余检错"><a href="#CRC-循环冗余检错" class="headerlink" title="CRC 循环冗余检错"></a>CRC 循环冗余检错</h4><ol>
<li>模2运算（每一位进行异或）</li>
</ol>
<blockquote>
<p>加法不进位</p>
<p>减法不借位</p>
</blockquote>
<ol start="2">
<li><p>比特序列的两种表示：</p>
<ul>
<li><p>位串：1011</p>
</li>
<li><p>多项式：$x^3+x+1$</p>
</li>
</ul>
</li>
<li><p>生成多项式 </p>
<ul>
<li><p>r次方 有r+1位</p>
</li>
<li><p>$G &#x3D; x^3+1$ 3次方，有3+1&#x3D;&#x3D;4位</p>
</li>
</ul>
</li>
<li><h2 id="冗余位："><a href="#冗余位：" class="headerlink" title="冗余位："></a>冗余位：</h2></li>
<li><p>性能：</p>
<ul>
<li>可检测出所有1bit错误、2bits错误</li>
<li>检查出所有长度为r或小于r的错误</li>
<li>出现长度为r+1的突发错误，，检查不出的概率为：$\frac{1}{2^{r-1}}$ </li>
<li>出现长度大于r+1的突发错误，，检查不出的概率为：$\frac{1}{2^r-1}$</li>
</ul>
</li>
</ol>
<h3 id="多点访问协议-MAP"><a href="#多点访问协议-MAP" class="headerlink" title="多点访问协议 MAP"></a>多点访问协议 MAP</h3><blockquote>
<p>有两种类型的网络链路：</p>
<ul>
<li>点对点链路 <ul>
<li>链路协议：PPP，point2point link和high-level data link control HDLC</li>
</ul>
</li>
<li>广播链路 broadcast link<ul>
<li>让多个发送节点和接收节点都连接到相同、单一、共享的广播信道上。</li>
<li>每有一个节点传输一个frame，其他所有的节点都可以通过信道收到这个frame的副本，以太网和无线局域网</li>
</ul>
</li>
</ul>
<p>局域网使用</p>
</blockquote>
<h4 id="多路访问协议-multiple-access-protocol"><a href="#多路访问协议-multiple-access-protocol" class="headerlink" title="多路访问协议 multiple access protocol"></a>多路访问协议 multiple access protocol</h4><p><strong>为什么要有多路访问协议：</strong></p>
<p>在广播链路当中，每个节点都可以传输frame，则会导致，多个节点同时发送frame，所有的节点同时接收到多个frame，传输的frame在所有接收方发生了<strong>碰撞  collide</strong>。</p>
<p>以上情况可以通过使用一个多路访问协议来进行协调，协调活跃节点的对frame的传输。</p>
<p><strong>多路访问协议希望做到的特性：</strong></p>
<blockquote>
<p>理想情况下，对于速率为 R bps的广播信道</p>
</blockquote>
<ol>
<li>当仅有一个节点发送数据，该节点具有 R bps 的吞吐量</li>
<li>当有M个节点发送数据，，每个节点具有 R&#x2F;M bps的吞吐量——在一段时间内的平均速率达到即可</li>
<li>协议是分散的，不会因为某个主节点故障而全局奔溃</li>
<li>协议简单、便宜</li>
</ol>
<h4 id="信道划分协议："><a href="#信道划分协议：" class="headerlink" title="信道划分协议："></a>信道划分协议：</h4><p>时分多路复用TDM和频分多路复用FDM两种用于划分广播信道带宽的技术</p>
<ul>
<li>TDM：将时间划分为时间帧time frame，进一步将每个时间帧划分为N个时隙slot<ul>
<li>将N个slot不重复的平均分配给N个节点，每个节点只在每个时间帧的指定的第N个slot出书分组，一个slot可以传输单个分组。</li>
<li>缺点：<ul>
<li>节点限制在R&#x2F;N bps的平均速率，上限设死了</li>
<li>节点必须等待到他的轮次，即当出现情况：xx节点是唯一需要发送的节点，也必须被迫等待到第N个slot才能进行发送。</li>
</ul>
</li>
</ul>
</li>
<li>FDM：<ul>
<li>将R bps的信道划分为不同的频段，将每个判断分配给N个节点中的一个。</li>
</ul>
</li>
<li>码分多址 CDMA Code Division Multiple Access：<ul>
<li>对每个节点分配一种不同编码，每个节点用其唯一编码来对发送的数据进行编码</li>
<li>不同的节点可以同时传输，且接收方可以正确接收，不受干扰</li>
</ul>
</li>
</ul>
<h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><p>一个传输节点总是以信道的全部速率（即 R bps）进行发送。</p>
<p>有碰撞时，涉及的每个节点反复重发分组，知道分组无碰撞通过为止。</p>
<p>但不是立即重发，而是在等待一个随机时延后进行重发。则每一个参与碰撞的节点都会独立地选择一个随机时延，则可能有出现一种情况：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>
<ul>
<li>最常见的几个：ALOHA协议，Abramson 和 载波侦听多路访问 CSMA 协议——以太网使用的及时CSMA</li>
</ul>
<ol>
<li><strong>时隙 ALOHA：</strong> <ul>
<li>所有frame由L比特组成</li>
<li>时间被划分位长度为 L&#x2F;R 的时隙，一个时隙对于传输一帧的时间</li>
<li>节点在时隙起点开始传输帧</li>
<li>节点同步，每个节点都知道时隙何时开始</li>
<li>如果一个时隙内发生碰撞，所有节点在该时隙结束之前检测到碰撞时间</li>
</ul>
</li>
</ol>
<p>取一个概率 <em>p</em> ，每个节点的操作为：</p>
<ul>
<li>当节点有一个待发送的帧，等到下一个时隙开始时传输整个帧</li>
<li>如果没有碰撞，该节点成功传输，无需重发</li>
<li>如果发生碰撞，在时隙结束前检测到，并以 <em>p</em> 的概率在后续的时隙中重发这一帧，知道无碰撞无须重发为止</li>
</ul>
<ol start="2">
<li><h2 id="ALOHA："><a href="#ALOHA：" class="headerlink" title="ALOHA："></a><strong>ALOHA</strong>：</h2></li>
<li><strong>载波侦听多路访问 CSMA：</strong><ul>
<li>设定规则：<ul>
<li>传输节点之前先听信道是否有人在传输，载波侦听过程：一直到检测到一段时间无人传输，才开始传输</li>
<li>传输时，一直侦听信道，如果与其他节点正在传输干扰帧，停止吃成熟，在重复上一个过程“侦听 —— 当信道空闲时传输”之前需要等待一段随机时间。</li>
<li>等待时间随机的必要性：加入两个节点同时传输，然后碰撞后又等待相同的时间，则会一直碰撞下去。</li>
<li>当碰撞节点数量较少，时间间隔较短；数量较大，时间间隔较长</li>
</ul>
</li>
<li>二进制指数回退算法：<ul>
<li>当传输一个给定帧时，该帧发生n次碰撞，节点随机在 [0,1,2,… $2^n-1$] 中选择一个K值，碰撞越多，K选择的间隔越大。一个节点实际等待时间为：K*512bit时间，n小于10</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><ol>
<li>轮询协议 taking-turns protocol：N个节点之中要有一个指定为主节点。主节点以循环方式轮询poll每一个节点。<ol>
<li>主节点首先向节点1发送一个报文，告诉它能够传输的帧的最多数量；在节点1传输了某些帧后,主节点告诉节点2它能够传输的帧的最大数量</li>
<li>主节点可以观察到信道上是否缺乏信号来决定一个节点何时完成帧的发送。 </li>
<li>缺点：<ol>
<li>轮询时延，即每个活跃节点必须等待主节点轮询非活跃节点的时间</li>
<li>主节点故障，全局系统瘫痪</li>
</ol>
</li>
</ol>
</li>
<li>令牌传递协议 token-passing protocol：<ol>
<li>无主节点，有一个令牌token的小的特殊帧在节点间以设定好的固定次序进行交互</li>
<li>当一个节点拿到token时，仅当其需要发送帧时才继续持有，否则立刻将token发送给下一个节点。</li>
</ol>
</li>
</ol>
<h4 id="DOCSIS：用于电缆因特网接入的链路层协议"><a href="#DOCSIS：用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h4><ol>
<li>使用FDM将上下行信道进行分离</li>
<li>使用TDM将上行信道划分为时间间隔，每个时间间隔包含一个微时隙序列，每个电缆调制解调器分配到序列为N的时隙向CMTS传输数据，CMTS在下行信道发送控制报文——MAP报文——指定哪个电缆调制解调器能够在时间间隔中的哪个微时隙中传输数据。</li>
<li>电缆调制解调器在一组特殊的微时隙间隔内向CMTS发送请求帧来告诉CMTS有数据要发送。请求帧以随机接入方式传输，可能发生碰撞，当电缆没有在下一个下行控制报文收到响应，则推断请求帧发生了碰撞，采取二进制指数回退将其微时隙请求帧延缓到以后的时隙重新发送。</li>
</ol>
<h3 id="LANS"><a href="#LANS" class="headerlink" title="LANS"></a>LANS</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址具有扁平化结构，不像IP地址一样需要划分出网络部分和主机部分，且MAC地址不会因为地点的改变而改变，不像IP地址一样，随着主机设备的移动，IP地址也需要动态做出改变</p>
<p>适配器向其他适配器发送一个frame，发送适配器将目的适配器的MAC地址插入到帧中，并将帧发送到局域网，交换机广播这一个帧，一个适配器可以接收到一个并非向它寻址的帧，当接收到一个帧时会去匹配MAC地址，若匹配得上，则提取出封装的数据，否则丢弃该数据。</p>
<h4 id="ARP协议-地址解析协议"><a href="#ARP协议-地址解析协议" class="headerlink" title="ARP协议 地址解析协议"></a>ARP协议 地址解析协议</h4><p>ARP：输入进来一个子网IP，将其转换成对应的MAC地址并返回。</p>
<p>ARP只作用于同一个子网上的主机和路由器接口解析IP地址</p>
<p>每台主机或路由器存有一张ARP表，该表包含IP地址到MAC地址的映射关系，表项中含有一个TTL，指示从表中删除某对映射关系的时间</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243579.png" alt="image-20240604164237575"> </p>
<p>该表不必为子网中每台主机和路由器都包含一个表项，某些可能从未进入，某些可能过期了。</p>
<p>一个通讯过程中：</p>
<ul>
<li><p>发送方构造一个称为ARP分组 ARP pkt 的特殊分组，分组含有字段：</p>
<ul>
<li>发送和接收IP地址及MAC地址</li>
</ul>
<p>ARP查询分组和响应分组具有相同格式，查询分组目的是查询子网上所有其他主机和路由器以缺点对应于要解析的IP地址的那个MAC地址</p>
</li>
<li><p>发送查询分组，使用MAC广播地址来发送这个分组，每一个接收到广播而来的分组的适配器去匹配IP地址，如果匹配成功，则发送一个带有IP和MAC地址映射关系的响应ARP分组，而后查询主机更新ARP表，并发送IP数据报，该数据报封装在一个链路层帧中，并且该帧目的MAC与之前发送响应报文的主机或路由器的MAC地址相同。</p>
</li>
</ul>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ol>
<li><strong>帧结构：</strong><ul>
<li>前同步码+目的地址+源地址+类型+数据部分+…+CRC检验和</li>
<li>数据字段：承载IP数据报，MTU位1500字节。</li>
<li>目的地址（6字节）：包含目的适配器的MAC地址</li>
<li>源地址（6字节）：包含发送适配器的MAC地址</li>
<li>类型字段（2字节）：允许以太网复用多种网络层协议</li>
<li>CRC（4字节）：校验和</li>
<li>前同步码（8字节）：前七个字节值都为10101010，最后一个为10101011。前七个用于唤醒接收适配器，且将它们的时钟和发送方的时钟同步。</li>
</ul>
</li>
</ol>
<h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><p>交换机本身对于子网中的主机和路由器是透明的，即不需要理会的。</p>
<ol>
<li><p><strong>过滤：</strong></p>
<ul>
<li>决定进行转发or丢弃的功能</li>
</ul>
</li>
<li><p><strong>转发：</strong></p>
<ul>
<li>决定一个帧应该被导向哪个接口，并把帧移动到接口的功能</li>
</ul>
</li>
<li><p><strong>交换机表 switch table：</strong></p>
<ul>
<li>过滤和转发功能借助于交换机表实现。</li>
<li>包含某局域网上某些主机和路由器的表项，不必时是全部的</li>
<li>表项包含：<ul>
<li>一个MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项放置在表中的时间</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243777.png" alt="image-20240604195935508"> </li>
<li>查表的三种情况：</li>
<li>假设有一个包含目的地址为dd-dd-dd-dd-dd-dd的帧，从接口x到达交换机：<ul>
<li>表中无记录dd-dd-dd-dd-dd-dd的表项。这种情况下，对除了接口x以外的所有接口进行洪泛。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="链路虚拟化"><a href="#链路虚拟化" class="headerlink" title="链路虚拟化"></a>链路虚拟化</h3><h3 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="cm7pquzid002er8v2ek5de4uy" data-title="计算机网络学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机重要基础/计算机组成原理学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.295Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 align =center > 计算机组成原理 </h1>

<h2 id="CH1-计算机基本知识"><a href="#CH1-计算机基本知识" class="headerlink" title="CH1 计算机基本知识"></a>CH1 计算机基本知识</h2><h3 id="计算机类型："><a href="#计算机类型：" class="headerlink" title="计算机类型："></a>计算机类型：</h3><ol>
<li>嵌入式计算机</li>
<li>个人计算机</li>
<li>服务器和企业系统</li>
<li>超级计算机和网络计算机</li>
</ol>
<h3 id="计算机五大部件："><a href="#计算机五大部件：" class="headerlink" title="计算机五大部件："></a>计算机五大部件：</h3><ol>
<li>输入单元——Input Unit</li>
<li>输出单元——Output Unit</li>
<li>存储设——Memory</li>
<li>运算逻辑单元——ALU Arithmetic and Logic Unit</li>
<li>控制单元——Control Unit</li>
</ol>
<h3 id="3、程序运行"><a href="#3、程序运行" class="headerlink" title="3、程序运行"></a>3、程序运行</h3><h3 id="4、计算机发展"><a href="#4、计算机发展" class="headerlink" title="4、计算机发展"></a>4、计算机发展</h3><h2 id="CH9-Arithmetic"><a href="#CH9-Arithmetic" class="headerlink" title="CH9 Arithmetic"></a>CH9 Arithmetic</h2><h3 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h3><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li><p>数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。</p>
</li>
<li><p>硬件实现的数据类型——数据表示</p>
</li>
<li><p>软件实现的数据类型——数据结构</p>
</li>
</ul>
<h3 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h3><ol>
<li>有符号整数，符号位为0表示为正；符号位为1表示为负</li>
</ol>
<p>出于各种原因，针对二进制数，设计出了以下几种二进制编码</p>
<ul>
<li><p>原码</p>
</li>
<li><p>反码</p>
</li>
<li><p>补码</p>
</li>
<li><p>移码</p>
</li>
</ul>
<h4 id="原码："><a href="#原码：" class="headerlink" title="原码："></a>原码：</h4><ol>
<li><p>一个数的绝对值的二进制表示</p>
</li>
<li><p>特点：</p>
</li>
</ol>
<ul>
<li>含有+0（0000 0000）和-0（1111 1111）</li>
<li>计算乘除法比较方便，加减法较麻烦</li>
</ul>
<p>为了简便加减法运算，因而设计出了<strong>补码</strong> </p>
<h4 id="反码："><a href="#反码：" class="headerlink" title="反码："></a>反码：</h4><p>也叫一位补数</p>
<ol>
<li>正数的反码是其本身，如： $0000<del>0001 \xrightarrow{\text{反码}} 0000</del>0001$</li>
<li>负数的反码，则符号位不变，其余各位取反，如：$1000<del>0001 \xrightarrow{\text{反码}} 1111</del>1110$</li>
</ol>
<h4 id="补码："><a href="#补码：" class="headerlink" title="补码："></a>补码：</h4><p>也叫二位补数</p>
<ol>
<li><p>将一个数的反码末位 $+1$ 即可得到补码；也可以将原码从右向左，第一个1的下一位开始进行取反，符号位除外。</p>
</li>
<li><p>具体应用</p>
</li>
</ol>
<ul>
<li>无模运算：实数范围内进行运算</li>
<li>有模运算：<ol>
<li>概念：给定一个正整数p，任意一个整数n，一定存在等式 n &#x3D; k*p + r<br>其中k 、r 是整数，且 0 ≤ r &lt; p 称呼k 为n 除以p 的商，r 为n 除以p的余数。</li>
<li>有模运算体系当中，减去一个数等于加上这个数对模的补数。如a+b&#x3D;M a和b互为补数</li>
</ol>
</li>
<li>（二进制）正数的补码是其本身，负数（无论整数还是小数 ）的补码，将负数变成补码——每一位取反末位加一</li>
</ul>
<p>在计算机当中，加减法均采用补码进行</p>
<ul>
<li><p>在纯小数二进制编码当中 补码为1.0000000 —&gt;真值：-1.0000000 最高位表示为数值位也是符号位；原码：超出范围</p>
</li>
<li><p>补码符号位拓展：</p>
<p>将n位定点整数补码拓展到2n位：</p>
<ul>
<li>当补码表示正数时，则直接在前面补上n个0即可</li>
<li>当补码表示负数时，则在前面补上n个1即可</li>
</ul>
<p>即与符号位保持一致进行拓展</p>
</li>
<li><p>算术右移（除2运算）</p>
</li>
</ul>
<p>一个数算术右移1位后，其最低有效位被移出。低位舍去，高位补符号位</p>
<p>小数 正数情况：低位舍去，高位补0</p>
<p>​		负数情况：低位舍去，高位补1</p>
<ul>
<li>算术左移（乘2运算）</li>
</ul>
<h4 id="移码："><a href="#移码：" class="headerlink" title="移码："></a>移码：</h4><ol>
<li>移码的表示范围：此处只讨论纯整数</li>
</ol>
<table>
<thead>
<tr>
<th align="center">移码&#x3D;偏移量+真值</th>
<th align="center">真值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1111 1111</td>
<td align="center">$2^{n}-1$</td>
</tr>
<tr>
<td align="center">1111 1110</td>
<td align="center">$2{n}-2$</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">1000 0000 (偏移量)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">0000 0001</td>
<td align="center">$-2^{n}+1$</td>
</tr>
<tr>
<td align="center">0000 0000</td>
<td align="center">$-2^{n}$</td>
</tr>
</tbody></table>
<p>由上图可看出看，移码的设计初衷即是为了使得移码值和真值成线性正比关系</p>
<ol start="2">
<li>无论正负数：补码求移码——符号位取反即可</li>
<li>移码主要应用于浮点数的阶码。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KP411X71M/?p=2&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.02.29 补码的性质2；反码、移码_哔哩哔哩 bilibili</a> </p>
<ol>
<li>正数的原码，补码，反码<strong>相同</strong>；</li>
<li>负数的反码：原码的数值（符号位除外）取反；</li>
<li>负数的补码：原码转换成反码，反码末位加1；除符号位，将原码从右到左第一个1之后的位取反即可。</li>
<li>一个数的移码：与补码的符号位取反。</li>
</ol>
<p>除了以上四种常见的编码外，还有以下编码，可供了解：</p>
<p>**BCD码（Binary-Coded Decimal） ** </p>
<p><strong>8421码（有权码）最常见：</strong> </p>
<p>采取 4个二进制位对应一个十进制位</p>
<p>每一位的权重分别为：8、4、2、1</p>
<p>计算方法：</p>
<p>E.p ：5（0101）+ 8（1000） &#x3D; 13（1101）不在映射内（1010~1 0010）则加上6进行修正</p>
<p>则13（1101）+ 6（0110） &#x3D; 19（1 0011）&#x3D;&#x3D; 1（00001）&amp;&amp; 3（0011）</p>
<p>**2421码： ** </p>
<p>重定义的权值</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243623.png" alt="image-20230919163128770" style="zoom:50%;" />

<p><strong>其他的4位有权BCD码：</strong> </p>
<p>5421码、5211码、4311码 —— 这三种对9互补，逢十进一</p>
<p>84-2-1（八四负二负一）码</p>
<p><strong>余3码（无权码）：</strong> </p>
<p>$8421码 + (0011)_2$</p>
<p><strong>其他的4位无权BCD码：</strong> </p>
<p>格雷码（1）、格雷码（2）、格雷码（3）</p>
<h4 id="一位全加器的表达式："><a href="#一位全加器的表达式：" class="headerlink" title="一位全加器的表达式："></a>一位全加器的表达式：</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243607.png" alt="image-20231218090128576" style="zoom:67%;" /></h4><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KP411X71M?p=3&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.03.04 浮点数的一般格式1</a></p>
<p>科学计数法：</p>
<ul>
<li>动态移动十进制小数点到约定位置，并使用10的指数来记录此小数点的位置</li>
<li>可表示整数也可表示小数</li>
<li>可表示范围很大</li>
<li>规格化数字</li>
</ul>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244008.png" alt="image-20230919092538911" style="zoom:50%;" />

<p>数符：表示浮点数的符号</p>
<p>阶符：</p>
<p>阶码：（数值部分）从高位开始进行比较 阶码位数表示表示范围</p>
<p>尾数：（数值部分） 尾数位数越多，精度越高</p>
<p>所谓的浮点数表示其实可以简单粗暴的理解成，把一个数按照以2为模的科学计数法，将符号（+ -）放在首位——数符，将2^n以二进制形式放在前面——阶码，把数的部分以二进制码形式放在后面——尾数</p>
<p>但是二进制的尾数是纯小数形式，不需要小数点前有有效数字。</p>
<p>规格化的浮点数：</p>
<p>在计算机当中尾数的表示一般采取的是原码，但是补码也得了解了解</p>
<ul>
<li><p>如果阶码的底为2，则尾数应该满足 1&#x2F;2 &lt;&#x3D; |M| &lt; 1 —— 原码 小数点右侧第一位为1（0.1xxxxxxx……） </p>
</li>
<li><p>当尾数用补码表示：</p>
<ul>
<li><p>尾数M&gt;&#x3D;0时，尾数应当具有的格式：M &#x3D; 0.1xxxxx…x，$当M \geq 0 时，[\frac{1}{2}]_补 \leq [M]_补 &lt; [1]_补$</p>
</li>
<li><p>尾数M&lt;0时，不将$[-1&#x2F;2]_补$列入规格化的数，而把$[1]_补$列入规格化的数当中。</p>
</li>
<li><p>即: $[1&#x2F;2]_补 \geq [M]_补 \leq [1]_补 $</p>
</li>
</ul>
</li>
<li><p>左规：</p>
<p>采用变形补码表示尾数，则当结果的尾数出现11.11xxxx或00.0xxxx时，将尾数左移1位，阶码-1，直到尾数变为<strong>规格化</strong>形式为止</p>
</li>
<li><p>右规：  </p>
<p>当结果尾数出现01.xxxx……x或者10.xxx……x时，并不一定溢出，应当先把尾数右移一位，阶码+1，在判断阶码是否溢出</p>
</li>
</ul>
<p>奇偶校验码：</p>
<p>对于一个n位的信息，在最前面增加一个奇偶校验位，即通过这个增加的校验位来使得整个有效信息串当中的1的个数达到“奇数”——对应奇校验 或者“偶数”——对应偶校验</p>
<p>方法局限性：</p>
<p>当出现偶数个位数的错误时，则无法进行校验。</p>
<p>奇校验：</p>
<p>整个校验码（有效信息位和校验位）当中“1”的个数位奇数</p>
<p>偶校验：</p>
<p>整个校验码（有效信息位和校验位）当中“1”的个数位偶数</p>
<p>校验：</p>
<p>使用<strong>异或运算</strong>操作进行偶校验，结果为0则未出错，结果为1则出错</p>
<p>算数逻辑单元</p>
<p>（Arithmetic and Logic Unit，ALU）</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244281.png" alt="image-20230919213319875" style="zoom: 67%;" />



<p>IEEE745标准：</p>
<p>尾数的格式：</p>
<p>规格化的原码表示—— S.1xxxxxx</p>
<p>规格化补码表示—— 正数：0.1xxxxxx	负数：1.0xxxxxx</p>
<h3 id="二进制的运算"><a href="#二进制的运算" class="headerlink" title="二进制的运算"></a>二进制的运算</h3><h4 id="二进制的乘法："><a href="#二进制的乘法：" class="headerlink" title="二进制的乘法："></a>二进制的乘法：</h4><p>补码的乘法运算规则：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244727.png" alt="image-20230921184009102" style="zoom:50%;" />

<p>补码的编码值按位展开得到真值，正数符号位权值为<strong>1</strong>，负数符号位权值为**-1**</p>
<h4 id="原码一位乘法："><a href="#原码一位乘法：" class="headerlink" title="原码一位乘法："></a>原码一位乘法：</h4><p>和手算一样</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244121.png" alt="image-20230923105803490" style="zoom:27%;" />

<p>加法次数和相乘的两个原码的位数相同</p>
<h4 id="Booth法"><a href="#Booth法" class="headerlink" title="Booth法"></a>Booth法</h4><p>时序逻辑电路图</p>
<p>无符号：Booth法的电路是时序逻辑电路，具有时钟信号控制</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244402.png" alt="image-20230922162220296" style="zoom:50%;" />

<h4 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h4><p>1）手算及单元电路</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244587.png" alt="image-20230923101554580" style="zoom: 30%;" />

<p>2）、定点无符号数阵列乘法器</p>
<p>组合逻辑电路因为不需要根据时钟周期进行移位累加，所使用的时间会少于移位累加的方法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244655.png" alt="image-20230922170428659"></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244576.png" alt="image-20230923101344400" style="zoom:30%;" />



<p>3）、有符号数的阵列乘法</p>
<p>下图中的电路可以完美实现一个二进制数的求补操作，即——从右往左找到第一个<strong>1</strong>，之后的所有位按位取反</p>
<p>可通过图中电路图可以做到</p>
<ol>
<li>已知一个数的补码，求该数的绝对值</li>
<li>已知一个数的绝对值，求该数的补码</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244232.png" alt="image-20230923102304075" style="zoom:25%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244590.png" alt="image-20230923102750917" style="zoom:26.5%;" />

<h4 id="二进制的除法"><a href="#二进制的除法" class="headerlink" title="二进制的除法"></a>二进制的除法</h4><h4 id="1）、原码除法"><a href="#1）、原码除法" class="headerlink" title="1）、原码除法"></a>1）、原码除法</h4><p>规则：</p>
<ol>
<li>前提条件<ol>
<li>除数 !&#x3D; 0 </li>
<li>定点纯小数时，被除数绝对值小于除数，商的结果位数与除数保持一致，则认为精度足够了 </li>
<li>定点纯整数时，被除数绝对值大于或等于除数</li>
</ol>
</li>
<li>商的符号&#x3D;&#x3D;被除数符号<strong>异或</strong>除数符号</li>
<li>商的绝对值&#x3D;&#x3D;被除数绝对值&#x2F;除数绝对值</li>
<li>将符号和绝对值拼接</li>
</ol>
<p>由手算引入逻辑实现</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244797.png" alt="image-20230923103943081" style="zoom:30%;" />



<h4 id="2）、恢复余数法"><a href="#2）、恢复余数法" class="headerlink" title="2）、恢复余数法"></a>2）、恢复余数法</h4><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245398.png" alt="image-20230923105332402" style="zoom:29.5%;" />

<h4 id="3）、不恢复余数法"><a href="#3）、不恢复余数法" class="headerlink" title="3）、不恢复余数法"></a>3）、不恢复余数法</h4><h1 align=center> 存储体系结构 </h1>

<h2 id="CH8-计算机存储体系结构"><a href="#CH8-计算机存储体系结构" class="headerlink" title="CH8 计算机存储体系结构"></a>CH8 计算机存储体系结构</h2><h3 id="8-1基本概念"><a href="#8-1基本概念" class="headerlink" title="8.1基本概念"></a>8.1基本概念</h3><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245083.png" alt="image-20231010221402861" style="zoom: 33%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245730.png" alt="image-20231010222309462" style="zoom: 50%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245153.png" alt="image-20231010222624421" style="zoom:50%;" />

<p>存储器的不同特性</p>
<ul>
<li>存储信息的介质，物质类型<ul>
<li>Semiconductor，半导体</li>
<li>Magnetic Surface，磁盘，磁带</li>
<li>Optical，光盘</li>
</ul>
</li>
<li>用途</li>
<li>信息的易失性&#x2F;非易失性</li>
<li>转移单位</li>
<li>存取方式<ul>
<li>随机——存取时间和物理地址无光，任一单元的读写所需时间相同</li>
<li>顺序</li>
</ul>
</li>
<li>读写功能</li>
</ul>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li><p>内存(Primary Storage)：计算机中直接被处理器(Processor)访问的存储器，也称为主存（Main Memory）或内部存储器（Internal Memory）。</p>
<ul>
<li>内存可以存储当前运行的程序和数据，以供处理器使用。</li>
</ul>
</li>
<li><p>内存比起外部存储器：读写速度更快，容量小，价格高</p>
</li>
<li><p>内存的类型有很多，常见的有随机存取存储器（RAM）、只读存储器（ROM）、高速缓冲存储器（Cache）。</p>
<ul>
<li><p>随机存取存储器（Random Access Memory,RAM）是一种可读写的内存，也叫做主存。它可以随机地访问任何一个地址的数据，而不需要按照顺序。RAM是易失性的，也就是说，当断电时，它会丢失所有的数据。</p>
<ul>
<li>RAM有两种主要的子类：<ul>
<li>静态RAM（Staic Random Access Memory,SRAM）：不掉电，则内容不丢失</li>
<li>动态RAM（Dynamic Ranodm Access Memory,DRAM）<ul>
<li>同步DRAM（Synchronous DRAM,SDRAM）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>只读存储器（Read Only Memory,ROM）是一种只能读取的内存，也叫做固件。它通常用来保存一些不会改变的数据或程序，例如计算机启动时的基本输入输出系统（BIOS）。ROM是非易失性的，也就是说，当断电时，它不会丢失数据。</p>
<ul>
<li>ROM有三种主要的子类：<ul>
<li>可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）</li>
<li>电子可擦除可编程只读存储器（EEPROM）</li>
<li>闪速（Flash） ：<ul>
<li>NOR</li>
<li>NAND</li>
</ul>
</li>
</ul>
</li>
<li>ROM当中存储有一段代码指令<strong>BIOS</strong>，作用：<ul>
<li>硬件自检</li>
<li>输入输出接口初始化</li>
<li>最后跳转到MM当中的引导扇区，以及操作系统的启动</li>
</ul>
</li>
</ul>
</li>
<li><p>高速缓冲存储器（Cache）是一种位于处理器和主存之间的高速内存，它可以缓存一些经常使用的数据或指令，以减少处理器访问主存的时间。</p>
<p>Cache是静态RAM（SRAM）制造的，它比动态RAM（DRAM）更快，但也更贵。</p>
<ul>
<li>Cache有多个级别，通常分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。</li>
</ul>
</li>
</ul>
</li>
<li><p>主存的运作（作用）：</p>
<ul>
<li><p>Connection of the Memory to the Processor——连接存储器和处理器</p>
</li>
<li><p>Processor-Memory Interface</p>
<ul>
<li>[处理器-内存接口的主要目的是让处理器能够读取或写入内存中的数据，以执行指令或存储结果。](<a target="_blank" rel="noopener" href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture</a> 13 - memory interface.pdf)</li>
<li>基本原理：当处理器需要访问内存时，它会将内存地址发送到地址总线上，然后通过一个解码电路来选择相应的内存芯片或设备。</li>
</ul>
</li>
<li><p>Read(Load) Operation</p>
<ul>
<li>将一个特定内存位置的数据副本读到处理器（Processor）</li>
<li>Processor： Load the address of the required memory location  into the MAR register and set the R&#x2F;W line to 1</li>
<li>Memory：Place the data from the addressed location onto the  data lines and confirm this action by asserting the MFC signal</li>
<li>Processor: Upon receipt of the MFC signal, the processor loads  the data on the data lines into the MDR register.</li>
</ul>
</li>
<li><p>Write(Store) Operation</p>
<ul>
<li>将一项信息从处理器传输到特定位置，销毁该位置先前的内容。</li>
<li>Processor： Load the address of the specific location into MAR and  load the data into MDR register. It also set the R&#x2F;W line to 0.</li>
<li>Memory：When the data have been written, it responses processor  with MFC signal.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h4><ul>
<li><p>外存(Secondary Storage)：计算机中不能直接被处理器访问的存储器，也称为辅助存储器（Auxiliary Storage）或外部存储器（External Memory）。</p>
<ul>
<li><p>外存可以长期保存大量的数据或程序，以供计算机使用。</p>
</li>
<li><p>外存的速度比内存：读写速度慢，容量更大，价格更低。</p>
</li>
</ul>
</li>
<li><p>外存的类型有很多，常见的有硬盘（Hard Disk）、固态硬盘（Solid State Drive）、U盘（Thumb Drive）、SD卡（SD Card）、光盘（Optical Disc）等。</p>
<ul>
<li><p>硬盘（<strong>Hard Disk</strong>）是一种利用磁性材料记录数据的外存，也叫做磁盘。它由一个或多个金属盘片组成，每个盘片都覆盖了磁性材料。硬盘通过一个机械臂上的磁头来读写数据，磁头可以在盘片上移动到不同的位置。硬盘的容量很大，但是速度较慢，而且易受物理损坏。</p>
</li>
<li><p>固态硬盘（<strong>Solid State Drive</strong>）是一种利用闪存芯片记录数据的外存，也叫做闪存盘。它没有任何机械部件，因此速度很快，而且抗震性强。固态硬盘的容量较小，但是价格较高，而且有写入次数的限制。</p>
</li>
<li><p>U盘（<strong>Thumb Drive</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做USB驱动器。它可以通过USB接口连接到计算机上，实现数据的传输和存储。U盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。U盘的优点是方便携带和使用，缺点是易丢失和损坏。</p>
</li>
<li><p>SD卡（<strong>SD Card</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做安全数字卡。它可以通过SD卡插槽连接到计算机或其他设备上，实现数据的传输和存储。SD卡的容量和速度各有不同，但是都比U盘小得多。SD卡的优点是体积小巧和兼容性强，缺点是易损坏和丢失。</p>
</li>
<li><p>光盘（<strong>Optical Disc</strong>）是一种利用光学原理记录数据的外存，也叫做光学数字媒体。它由一个或多个塑料圆盘组成，每个圆盘都覆盖了一层反射材料。光盘通过一个激光头来读写数据，激光头可以在圆盘上移动到不同的位置。光盘的类型有很多，常见的有CD（Compact Disc）、DVD（Digital Versatile Disc）、BD（Blu-ray Disc）等。光盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。光盘的优点是成本低廉和寿命长久，缺点是易刮花和损坏。</p>
</li>
</ul>
</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul>
<li>MAR(Memory Address Register) 存储器地址寄存器</li>
<li>MDR(Memory Data Register) 存储器数据寄存器</li>
</ul>
<h4 id="存储单元和地址"><a href="#存储单元和地址" class="headerlink" title="存储单元和地址"></a>存储单元和地址</h4><ul>
<li><p>Word（字）：每一组固定大小的<strong>bit</strong>称为一个字。</p>
</li>
<li><p>Word Length（字长）：每个字的位数称为字长。它通常在16位到64位之间</p>
</li>
<li><p>Byte(字节)：$1 byte &#x3D; 8 bit$ byte是KB，MB，GB中的B。</p>
<ul>
<li>K: $2^{10},1024$  </li>
<li>M：$2^{20},1046576$ </li>
<li>G：$2^{30},1073741824$</li>
</ul>
</li>
</ul>
<p>计算机存储器图表表示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245430.png" alt="image-20231010165617847" style="zoom:50%;" /> 

<h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>1、大端赋值</p>
<p>字节排序</p>
<p>多字节数据类型（如整数、浮点数等）在内存中的字节排列顺序。它决定了在内存中的哪个字节存储数据的最低有效位（低位）和最高有效位（高位）。字节排序有两种常见的方式：大端序（Big-endian）和小端序（Little-endian）。</p>
<p>大端赋值（Big-Endian）</p>
<ul>
<li>在大端字节顺序中，最高有效字节（Most Significant Byte，MSB）位于内存地址的最低端（低地址端）</li>
<li>最低有效字节（Least Significant Byte，LSB）位于内存地址的最高端（高地址端）。</li>
<li>这意味着在大端字节顺序下，数据的各个字节按照从高位到低位的顺序存储，与日常习惯从左到右读数的顺序相同。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">大端赋值（从左到右）是一种在内存中存储数据的方式，其中最高有效字节（MSB）放在最低的内存地址，而最低有效字节（LSB）放在最高的内存地址。这意味着字节的存储顺序与我们从左到右读取它们的顺序相同。</a> </p>
<p>例如，如果我们想要将十六进制数 0x12345678 存储在一个 4 字节的内存位置，我们将按照以下方式分配字节：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">字节值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x1000</td>
<td align="left">0x12</td>
</tr>
<tr>
<td align="left">0x1001</td>
<td align="left">0x34</td>
</tr>
<tr>
<td align="left">0x1002</td>
<td align="left">0x56</td>
</tr>
<tr>
<td align="left">0x1003</td>
<td align="left">0x78</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/">这也被称为大端字节序或网络字节序，因为它通常用于网络协议，如 TCP&#x2F;IP。</a> </p>
<p>大端赋值的一些优点是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">它更容易阅读和调试，因为数据的存储顺序与我们写它的顺序相同。</a></li>
<li><a target="_blank" rel="noopener" href="https://teaching.idallen.com/cst8281/10w/notes/110_byte_order_endian.html">它与我们在数学中表示数字的方式一致，其中最高有效位在左边。</a></li>
<li><a target="_blank" rel="noopener" href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它简化了算术运算，如加法和减法，因为进位或借位从右到左传播。</a></li>
</ul>
<p>大端赋值的一些缺点是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26204333/little-endian-and-big-endian">它与一些使用小端赋值的处理器不兼容，其中 LSB 在最低的内存地址，而 MSB 在最高的内存地址。这在不同系统之间交换数据时可能会导致问题。</a></li>
<li><a target="_blank" rel="noopener" href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它在处理数组或矩阵时可能会引起混淆，因为索引顺序可能与字节顺序不匹配。例如，在 Verilog 中，一个声明为 <code>reg [3:0] array1 [0:7]</code> 的数组具有大端位顺序，但小端索引顺序。</a></li>
</ul>
<p>2、小端赋值</p>
<ul>
<li>在小端序中，最低有效字节（低位字节）存储在内存的最低地址。</li>
<li>最高有效字节（高位字节）存储在内存的最高地址。</li>
<li>这种字节排序方式类似于我们书写数字的方式，从右到左。</li>
<li>小端序在一些体系结构（如x86、ARM、网络通信协议中的小端序）中使用。</li>
</ul>
<h4 id="访问方式："><a href="#访问方式：" class="headerlink" title="访问方式："></a>访问方式：</h4><p>1、Sequential Access	顺序访问</p>
<ol>
<li>如果当前记录为1，那么为了读取记录N，需要读取记录1到N-1。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245993.png" alt="image-20231207191223478" style="zoom: 50%;" /></li>
</ol>
<p>2、Direct Access			直接访问</p>
<ol>
<li>访问是通过直接访问到达大致附近加上顺序搜索、计数或等待到达最终位置来完成的。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245784.png" alt="image-20231207192656562" style="zoom:50%;" /></li>
</ol>
<p>3、Random Access		随机访问</p>
<ol>
<li>任何存储位置都可以随机选择并直接寻址和访问。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245629.png" alt="image-20231207192628560" style="zoom:50%;" /></li>
</ol>
<p>内存访问时间：</p>
<ol>
<li><p>Memory Access Time</p>
<ul>
<li>得到地址和获取有效数据（内存或其他存储）之间的时间</li>
</ul>
<ol>
<li><p>Random-Access Memory</p>
<ul>
<li>执行读或写操作所需的时间</li>
</ul>
</li>
<li><p>Non-Random-Access Memory</p>
<ul>
<li>将读写机制定位到所需位置所需的时间。</li>
</ul>
</li>
</ol>
</li>
<li><p>Memory Cycle Time</p>
<ol>
<li>仅用于随机存储</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="易失性与非易失性："><a href="#易失性与非易失性：" class="headerlink" title="易失性与非易失性："></a>易失性与非易失性：</h4><p>volatile和nonvolatile</p>
<ol>
<li>volatile<ul>
<li>当电源关闭时，信息会自然衰减或丢失</li>
</ul>
</li>
<li>nonvolatile<ul>
<li>信息一旦记录，就不会变质，直到被故意更改为止。 无需电力即可保留信息</li>
</ul>
</li>
</ol>
<h4 id="可擦除和不可擦除性"><a href="#可擦除和不可擦除性" class="headerlink" title="可擦除和不可擦除性"></a>可擦除和不可擦除性</h4><p>erasable和nonerasable</p>
<ol>
<li><p>erasable</p>
<ul>
<li>保存在内存中的信息可以被替换修改</li>
</ul>
</li>
<li><p>nonerasable</p>
<ul>
<li>保存在内存中的信息不可被替换修改，除非损毁对应的存储单元</li>
</ul>
</li>
</ol>
<h3 id="8-2-存储器及其部分概念"><a href="#8-2-存储器及其部分概念" class="headerlink" title="8.2 存储器及其部分概念"></a>8.2 存储器及其部分概念</h3><h4 id="1、SRAM"><a href="#1、SRAM" class="headerlink" title="1、SRAM"></a>1、SRAM</h4><p><strong>Static Random Access Memory</strong> 	<strong>静态随机存储器</strong> </p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245502.png" alt="image-20231020151241416" style="zoom:50%;" /> 

<p>只要不断电,信息一直保持——静态</p>
<p>初始加电后状态随机</p>
<p>n个存储器构成n位存储单元</p>
<p>熟练掌握以下SRAM的画法</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245107.png" alt="image-20231207173618008" style="zoom: 67%;" /> 

<p>对于一个SRAM需要的引脚数：</p>
<p>以 $1K \times 1$ 为例：$1K \times 1 \rightarrow 2^{10} \times 1$ </p>
<ol>
<li>地址线Address Lines（input）：10根地址线——$A_0<del>-</del>A_{9}$ </li>
<li>数据线Data Lines（Input&#x2F;Output）：1根数据线——$b_0$ </li>
<li>控制线Control Lines（Input）：R&#x2F;W，CS</li>
<li>以及其他两根常规的电源线Power Supply Line和地线Ground Line</li>
</ol>
<p>总计&#x3D;10+1+2+2 &#x3D; 15</p>
<h4 id="2、DRAM"><a href="#2、DRAM" class="headerlink" title="2、DRAM"></a>2、DRAM</h4><p><strong>Dynamic Random Access Memory</strong>	<strong>动态随机存储器</strong> </p>
<p>优点：</p>
<ol>
<li>高密度</li>
<li>低成本</li>
</ol>
<p>缺点：</p>
<ol>
<li>更长的访问时间</li>
<li>易失的，需要不断刷新</li>
<li>不易被CMOS集成</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245772.png" alt="image-20231208095542511" style="zoom:50%;" /> 

<p>需要掌握以下图中一个DRAM的画法</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245615.png" alt="image-20231207174152063" style="zoom:67%;" /> 

<p>对于一个DRAM需要的引脚数量位：</p>
<p>以$64K \times 1$为例：</p>
<ol>
<li>地址线：8   $64K &#x3D; 2^{16}$ 为了节省线路，因而将行地址线和列地址线进行复用，$\frac{16}{2} &#x3D; 8$ </li>
<li>数据线：1根</li>
<li>控制线：1   只有R&#x2F;W线</li>
<li>还有常规的电源线、地线以及刷新线</li>
</ol>
<p><strong>Burst操作</strong> </p>
<h4 id="3、Latency-and-Bandwidth"><a href="#3、Latency-and-Bandwidth" class="headerlink" title="3、Latency and Bandwidth"></a>3、Latency and Bandwidth</h4><p>延迟和带宽是指示内存系统性能的两个参数。</p>
<ol>
<li>Latency：指将一个字的数据传入或传出内存所花费的时间<ol>
<li>注意：在块传输中，延迟用于表示传输第一个数据字之前所需的时间。</li>
</ol>
</li>
<li>Bandwidth：<ol>
<li>一秒内可以传输的位数或字节数称为带宽。</li>
<li>单位：比特每秒或字节每秒。</li>
<li>存储单元的带宽取决于存储数据的访问速度以及可并行访问的位数。</li>
<li>有效带宽还取决于连接存储器和处理器的链路的传输能力。</li>
<li>有效带宽 &#x3D; 总线速度 × 总线宽度</li>
</ol>
</li>
</ol>
<h3 id="8-3-Cache-Memories"><a href="#8-3-Cache-Memories" class="headerlink" title="8.3 Cache Memories"></a>8.3 Cache Memories</h3><p>Main Memory的一个块只能映射到Cache固定的一行当中，</p>
<h4 id="主存和cache的三种地址映射方式"><a href="#主存和cache的三种地址映射方式" class="headerlink" title="主存和cache的三种地址映射方式"></a>主存和cache的三种地址映射方式</h4><h4 id="1、直接映射"><a href="#1、直接映射" class="headerlink" title="1、直接映射"></a>1、直接映射</h4><p><strong>Direct Mapping</strong> </p>
<p>主存每个块可以放在cache同一个槽当中</p>
<p>假设cache槽数为8，</p>
<p>将Main Memory每八个块切割为一组进行分组，在同一组内的相同位置，放在cache的同一个槽位内。</p>
<p>即：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245507.png" alt="image-20231207213537311" style="zoom:67%;" /> 

<p>如图中，在Main Memory当中块号为2——$2<del>mod</del>8 &#x3D;&#x3D; 2$ ,同样的，块号为10——$10<del>mod</del>8&#x3D;&#x3D;2$ 则第2块和第10块放在cache的2号槽当中。 </p>
<h4 id="2、全相联映射"><a href="#2、全相联映射" class="headerlink" title="2、全相联映射"></a>2、全相联映射</h4><p><strong>Fully Associative Mapping</strong> </p>
<p>主存任意块可以映射到cache任意槽内。</p>
<h4 id="3、组相连映射"><a href="#3、组相连映射" class="headerlink" title="3、组相连映射"></a>3、组相连映射</h4><p><strong>Set Associative Mapping</strong> </p>
<p>主存多个块放在Cache同一个组内的任一槽当中</p>
<ol>
<li>先将Cache进行分组，假设Cache内有8个槽，每2个槽为一组，可分为4组，如下图所示：</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245317.png" alt="image-20231207214021904" style="zoom: 50%;" /> 

<ol start="2">
<li>将Main Memory 按照Cache的组数进行分组，即Cache分为4组，则Main Memory的每四块为一组。组内号对应着Cache的组号，假设Main Memory内有20个块，可分为5组，$块_0 $ 对应的组内号为0 ，则映射到Cache$组_0$ 的任意一个槽当中。</li>
</ol>
<p>分区——分组——分块</p>
<p>目录表：</p>
 <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245862.png" alt="image-20231023100630364" style="zoom:33%;" />

<p>主存区号——主存组内块号——Cache组内块号——有效位</p>
<p>主存地址：</p>
<p>区号—组号—主存组内块号—块内地址</p>
<p>Cache地址：</p>
<p>  tag——set——word</p>
<h3 id="8-4-虚存"><a href="#8-4-虚存" class="headerlink" title="8.4 虚存"></a>8.4 虚存</h3><p><strong>virtual Memory</strong> </p>
<ol>
<li>无物理设备但是有抽象概念</li>
<li></li>
</ol>
<h4 id="1、页式虚存（Paging）"><a href="#1、页式虚存（Paging）" class="headerlink" title="1、页式虚存（Paging）"></a>1、页式虚存（Paging）</h4><ol>
<li><p>以页为单位</p>
</li>
<li><p>虚拟空间和主存空间划分为相同大小的页，主存内的页——实页；虚存内的页——虚页</p>
</li>
<li><p>虚拟地址——虚页号+页内地址</p>
<p>虚拟地址到物理地址的转换由页表是实现</p>
<ol>
<li>页表：存放在主存内的虚页号和实页号的对照表，用以记录虚页存入主存时安排再主存的哪个位置。</li>
</ol>
</li>
<li><p>Write Policy</p>
<ol>
<li>Write Back</li>
<li>write through is not suitable for virtual memory</li>
</ol>
</li>
<li><p>TLB（快表）</p>
</li>
<li><p>页表内容：</p>
<ul>
<li>页号：</li>
<li>有效位：标记该页是否被加载到主存当中</li>
<li>修改位&#x2F;脏位：标记该页是否被修改</li>
<li>引用位&#x2F;使用位：标记改页是否被使用</li>
<li>访问控制位</li>
</ul>
</li>
<li><p>选择较大页面尺寸的优点</p>
<ul>
<li>页表的大小与页面大小成反比：因此可以通过增大页面来节省内存。</li>
<li>可能通过网络将较大的页面传输到辅助存储或从辅助存储传输较大的页面比传输较小的页面更有效。</li>
</ul>
</li>
<li><p>选择较大页面尺寸的缺点</p>
<ul>
<li>当虚拟内存的连续区域的大小不等于页面大小的倍数时，较大的页面大小将导致更多的存储浪费（内部碎片）。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411E7D6/?spm_id_from=333.337.search-card.all.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">Cache与虚拟存储器_哔哩哔哩_bilibili</a> </p>
<h4 id="2、段式虚存"><a href="#2、段式虚存" class="headerlink" title="2、段式虚存"></a>2、段式虚存</h4><ol>
<li>虚拟地址组成：Virtual Segment Number+Offset <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245442.png" alt="image-20231210135304188" style="zoom: 67%;" /> </li>
<li>段表内容：<ul>
<li>段的起始位置</li>
<li>段的大小</li>
<li>控制位</li>
</ul>
</li>
<li></li>
</ol>
<h4 id="3、段页式虚存"><a href="#3、段页式虚存" class="headerlink" title="3、段页式虚存"></a>3、段页式虚存</h4><h2 id="CH2-机器指令"><a href="#CH2-机器指令" class="headerlink" title="CH2 机器指令"></a>CH2 机器指令</h2><h3 id="2-1指令和指令序列"><a href="#2-1指令和指令序列" class="headerlink" title="2.1指令和指令序列"></a>2.1指令和指令序列</h3><h4 id="1、四种指令："><a href="#1、四种指令：" class="headerlink" title="1、四种指令："></a>1、四种指令：</h4><ol>
<li>存储器和处理器寄存器之间的数据传输、</li>
<li>数据的算术和逻辑运算</li>
<li>程序序列和控制</li>
<li>I&#x2F;O传输</li>
</ol>
<h4 id="2、Register-transfer-notation（RTN"><a href="#2、Register-transfer-notation（RTN" class="headerlink" title="2、Register transfer notation（RTN)"></a>2、Register transfer notation（RTN)</h4><ol>
<li><p>一种用于描述硬件级别的关于数据传输与操作的表示方法（就像是markdown一样的一种标记型语言，</p>
<p>E.P:</p>
<ul>
<li>处理器寄存器：R0、R5</li>
<li>I&#x2F;O 寄存器：DATAIN、OUTSTATUS</li>
<li>内存位置：LOC、PLACE、A、VAR2</li>
</ul>
<p>$R2 \leftarrow [LOC]$ ——意指将LOC内的数据传输到R2寄存器当中</p>
<p>右操作数通常提供数据，左操作数通常表示一种地址</p>
</li>
<li><p>两种RTN的符号</p>
<ol>
<li>“[  ]”表示地址内存储的内容，相当于c++语言当中的解引用*</li>
<li>“$\leftarrow$” 表示数据的传输</li>
</ol>
</li>
</ol>
<h4 id="3、Assembly-Language-Notation（ALN）"><a href="#3、Assembly-Language-Notation（ALN）" class="headerlink" title="3、Assembly-Language Notation（ALN）"></a>3、Assembly-Language Notation（ALN）</h4><ol>
<li>与RTN一样的一种语言，但是比RTN高级一些。</li>
<li>在有了RTN表示数据的传输和计算之后，需要有语言来表示机器指令或程序并使用它们。</li>
<li>可将$R2 \leftarrow [LOC] $ 转换为汇编语言：$Load<del>R2</del>LOC$ </li>
<li>指令中包含有操作和操作数</li>
</ol>
<h4 id="4、RISC-Instruction-Sets"><a href="#4、RISC-Instruction-Sets" class="headerlink" title="4、RISC Instruction Sets"></a>4、RISC Instruction Sets</h4><ol>
<li><p>缩减计算机指令集合</p>
</li>
<li><p>两个关键字：load和store</p>
<ol>
<li>只有这两个操作是用于访问主存的操作数的</li>
<li>用于算数或逻辑指令的操作数必须在处理器的寄存器中或在指令字中显式给出</li>
</ol>
</li>
<li><p>指令的执行需要先存储在内存当中</p>
<p>在进行数据的计算之前，需要先进行数据的传输——RISC需要操作数</p>
</li>
<li><p>Load操作指令：Load procr_register, mem_location</p>
</li>
</ol>
<h4 id="5、Branching"><a href="#5、Branching" class="headerlink" title="5、Branching"></a>5、Branching</h4><ol>
<li>即分支语句，联想高级程序语言中的 if语句</li>
</ol>
<h3 id="2-2-指令格式"><a href="#2-2-指令格式" class="headerlink" title="2.2 指令格式"></a>2.2 指令格式</h3><ol>
<li>指令集即是可被CPU执行的多种机器指令的集合</li>
<li>微程序指令和机器指令的关系：<ul>
<li>一条机器指令通常是由多条微程序控制指令组合而成的，因为机器指令控制的是CPU的一系列功能；而微程序指令控制的是一系列电路功能，而机器指令的完成需要这些电路功能的完成来实现</li>
</ul>
</li>
</ol>
<p>微命令、微指令、微程序、控制信号概念区分：</p>
<p>总结：</p>
<ul>
<li><p>微命令-&gt;微指令-&gt;微程序	A-&gt;B 表示 A组成B</p>
</li>
<li><p>控制部件通过控制线向执行部件发出控制命令，这种控制命令称为&#x3D;&#x3D;微命令&#x3D;&#x3D;、也称为控制信号。微命令序列即控制信号序列，微命令是最小的单元；</p>
</li>
<li><p>在一个CPU的时钟周期内，会产生一系列的微命令，这些微命令的组合形成了&#x3D;&#x3D;微指令&#x3D;&#x3D;；</p>
</li>
<li><p>一条机器指令通常由一系列微指令组成，这些微指令序列称为&#x3D;&#x3D;微程序&#x3D;&#x3D;；</p>
</li>
</ul>
<p>微操作和微指令的联系：</p>
<ul>
<li><p>一个&#x3D;&#x3D;微操作&#x3D;&#x3D;对应一条&#x3D;&#x3D;微指令&#x3D;&#x3D;，一条微指令可能有多个微命令。</p>
</li>
<li><p>微指令是一串&#x3D;&#x3D;编码&#x3D;&#x3D;，那么微操作就是这段编码所代表的操作。</p>
</li>
<li><p>&#x3D;&#x3D;微操作&#x3D;&#x3D;是&#x3D;&#x3D;微命令&#x3D;&#x3D;作用在硬件上的一个当作，</p>
</li>
</ul>
<h4 id="1、指令的元素："><a href="#1、指令的元素：" class="headerlink" title="1、指令的元素："></a>1、指令的元素：</h4><ol>
<li><p>操作码 opcode</p>
</li>
<li><p>源操作数地址</p>
</li>
<li><p>结果操作数地址</p>
<p>结果操作数地址有三个去向：</p>
<ol>
<li>主存或虚存</li>
<li>处理器寄存器</li>
<li>I&#x2F;O设备</li>
</ol>
</li>
</ol>
<h4 id="2、指令的表示"><a href="#2、指令的表示" class="headerlink" title="2、指令的表示"></a>2、指令的表示</h4><p>指令的组成：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245222.png" alt="image-20231214213936303" style="zoom: 67%;" /> 操作码字段和地址字段</p>
<h4 id="3、指令地址字段的格式"><a href="#3、指令地址字段的格式" class="headerlink" title="3、指令地址字段的格式"></a>3、指令地址字段的格式</h4><ol>
<li><p>零地址</p>
</li>
<li><p>一地址</p>
<ol>
<li>存在隐式调用<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245651.png" alt="image-20231214214238803" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>二地址</p>
</li>
<li><p>三地址</p>
</li>
</ol>
<h4 id="4、指令的长度："><a href="#4、指令的长度：" class="headerlink" title="4、指令的长度："></a>4、指令的长度：</h4><ol>
<li><p>固定长度：所有指令有相同的长度<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245707.png" alt="image-20231215083957842"> </p>
</li>
<li><p>可变长度：指令可能会有不同的长度</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246842.png" alt="image-20231215084034340" style="zoom: 67%;" /> 
</li>
<li><p>缩减指令长度方法</p>
<ol>
<li>当操作数被<strong>多次使用</strong>时，可移入寄存器当中</li>
<li>隐式指定一个或多个操作数</li>
</ol>
</li>
</ol>
<h4 id="5、操作码格式"><a href="#5、操作码格式" class="headerlink" title="5、操作码格式"></a>5、操作码格式</h4><ol>
<li><p>固定长度操作码</p>
<ol>
<li>操作码长度固定，但指令长度可变</li>
</ol>
</li>
<li><p>可变长度操作码（拓展操作码）</p>
<p>通常指令长度固定，但操作码和操作数地址的长度此消彼长</p>
<p>E.P..</p>
<p>Suppose the designers need </p>
<ul>
<li><p>15 three-address instructions</p>
</li>
<li><p>14 two-address instructions </p>
</li>
<li><p>31 one-address instructions </p>
</li>
<li><p>16 zero-address instructions</p>
</li>
</ul>
<p>How should we design the instruction format?</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246141.jpg" alt="02c3d0bfa744674125de773e1d082e8" style="zoom: 25%;" /></li>
</ol>
<h4 id="6、寻址模式"><a href="#6、寻址模式" class="headerlink" title="6、寻址模式"></a>6、寻址模式</h4><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246871.png" alt="image-20231215102613798" style="zoom: 67%;" />

<ol>
<li><p>立即寻址方式：操作数在指令中明确给出。</p>
<ol>
<li><p><strong>把我们实际要操作的数，直接存放在形式地址中</strong> </p>
</li>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246126.webp" alt="img"></p>
</li>
<li><p>寻址特征为#，代表立即寻址的意思。</p>
</li>
<li><p>A为立即数，假设A操作数为3，则形式地址<strong>写的是操作数3的补码（011）。</strong> </p>
</li>
<li><p>立即寻址主要执行取指令访存1次，不需要执行指令访存，一共访存1次。</p>
</li>
</ol>
</li>
<li><p>直接寻址：</p>
<ol>
<li><p>直接寻址指令中的地址码字段给的是<strong>操作数的有效位置</strong>，我们可以根据这个有效位置直接去内存中寻找操作数。</p>
</li>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246410.webp" alt="img"> </p>
</li>
<li><p>与立即寻址相比：直接寻址主要执行取指令访存1次，还有执行指令访存1次，一共访存2次。</p>
</li>
<li><p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246400.webp" alt="img"></p>
</li>
</ol>
</li>
<li><p>绝对寻址方式：<strong>操作数位于内存位置； 该位置的地址在指令中明确给出。</strong> </p>
<ol>
<li>直接寻址的一种，指令包含数据在内存中的确切地址，CPU通过这个地址获取或存储数据。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246209.png" alt="image-20231215161204849"></li>
</ol>
</li>
<li><p>寄存器寻址方式：操作数是处理器寄存器的内容； 寄存器的地址在指令中给出。</p>
<p>和直接寻址原理一样，只是把访问主存改为访问寄存器。</p>
<ol>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246954.webp" alt="img"></p>
</li>
<li><p>寄存器寻址主要执行取指令访存1次，由于访问的是寄存器因此<strong>不需要执行指令访存</strong>，一共访存1次。</p>
</li>
<li><p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246675.webp" alt="img"></p>
</li>
<li><p>**访问寄存器会比访问主存快得多。**但是寄存器数量也较少，可以看出地址码长度也是比访问主存的短的。</p>
</li>
</ol>
</li>
<li><p>寄存器间接寻址方式：操作数的有效地址是：出现在指令中的寄存器存储的内容。</p>
<ol>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246827.webp" alt="img"></p>
</li>
<li><p>寄存器间接寻址的指令中的地址码字段给的是<strong>操作数所在的寄存器位置</strong>，我们可以根据这个地址去寄存器中找到操作数的有效地址，再去内存中寻找操作数。</p>
</li>
<li><p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246748.webp" alt="img"></p>
</li>
</ol>
</li>
<li><p>变址寻址方式：操作数的有效地址是通过将常数值与寄存器（变址寄存器）的内容相加而生成的。</p>
<ol>
<li><p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246460.png" alt="image-20231215161451624"></p>
</li>
<li><p>$EA &#x3D; X + [Ri]$ </p>
<p><strong>X (offset)</strong>：指令中包含的常数值</p>
</li>
<li><p>变址寻址的两种方式：</p>
<ol>
<li>偏移量是一个常量</li>
<li>偏移量是在变址寄存器当中，而变址寄存器当中的值是可以进行修改的</li>
</ol>
</li>
</ol>
</li>
<li><p>base with index</p>
</li>
</ol>
<h2 id="CH5-基础处理器单元"><a href="#CH5-基础处理器单元" class="headerlink" title="CH5 基础处理器单元"></a>CH5 基础处理器单元</h2><p>CPU内存中的寄存器</p>
<ol>
<li>通用寄存器——存放操作数；某种寻址方式所需的专用寄存器</li>
<li>数据寄存器——</li>
<li>地址寄存器——存放地址数</li>
<li>条件码寄存器——存放条件码</li>
<li>控制寄存器：<ol>
<li>$PC \rightarrow MAR \rightarrow M \rightarrow MDR \rightarrow IR$  </li>
<li>只有PC可见</li>
</ol>
</li>
<li>状态寄存器<ol>
<li>在中断产生时，由于断点之前的程序使用的硬件状态会被修改，需要提前保存，在断点恢复之后可以恢复中断前的程序场景。</li>
<li>CU：产生全部指令的微操作命令序列</li>
</ol>
</li>
</ol>
<h3 id="5-1-Some-Fundamental-Concepts"><a href="#5-1-Some-Fundamental-Concepts" class="headerlink" title="5.1 Some Fundamental Concepts"></a>5.1 Some Fundamental Concepts</h3><ol>
<li><p>Processing Unit</p>
<ul>
<li>Instruction Set Processor or Central Processing Unit  (CPU)</li>
<li>处理器负责从计算机内存中读取程序指令并执行它们。<ul>
<li>它一次获取一条指令。</li>
<li>它解码（解释）指令。</li>
<li>然后，它执行指定的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>指令执行：</p>
<p>（1）获取PC指向的内存位置的内容。 该位置的内容被加载到 IR 中。$IR ← [[PC]]$ </p>
<p>（2）PC自增</p>
<p>（3）执行IR中指令指定的操作。</p>
<p>（1）（2）：取指阶段，（3）：执行阶段</p>
</li>
<li><p>执行指令的操作：</p>
<p>1）加载数据到处理器当中：读取给定的内存位置的内容并将其加载到<strong>处理器寄存器</strong>中。<br>2）读取数据：从一个或多个<strong>处理器寄存器</strong>读取数据。<br>3）执行操作指令：执行算术或逻辑运算并将结果放入处理器寄存器中。<br>4）写回数据：将处理器寄存器中的数据存储到给定的内存位置。</p>
</li>
<li><p>指令执行的五大步骤：</p>
<ul>
<li>Fetch <strong>取指阶段</strong>: 从内存中读取下一条指令。</li>
<li>Decode <strong>解码阶段</strong>: 解析指令，确定其类型和所需操作。</li>
<li><strong>执行阶段</strong>: 执行指令规定的操作。</li>
<li><strong>访存阶段</strong>: 如果需要访问内存，进行读取或写入。</li>
<li><strong>写回阶段</strong>: 将执行结果写回寄存器或内存。</li>
</ul>
</li>
<li><p>处理器主要硬件组成：</p>
<ol>
<li>PC</li>
<li>IR</li>
<li>Instruction address generator</li>
<li>Control circuitry</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246557.png" alt="image-20231215210130431" style="zoom:50%;" />
</li>
<li></li>
</ol>
<h3 id="5-2-Instruction-Execution-5-steps"><a href="#5-2-Instruction-Execution-5-steps" class="headerlink" title="5.2 Instruction Execution (5 steps)"></a>5.2 Instruction Execution (5 steps)</h3><ol>
<li>Load指令：$Load<del>R5</del>X(R7)$ <ol>
<li>从主存取指令，wait for MFC，并且PC自增</li>
<li>译码decode得到操作，读取寄存器R7中的内容</li>
<li>将X和R7的内容相加</li>
<li>将相加结果作为源操作数的有效地址，并读取存储器中该地址内的内容</li>
<li>将存储器读取数据存入R5</li>
</ol>
</li>
<li>算数逻辑运算指令<ol>
<li>两个源寄存器or一个直接操作数和一个源寄存器</li>
<li>无需访问存储器操作数</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="5-3-Hardware-Components-5-stages"><a href="#5-3-Hardware-Components-5-stages" class="headerlink" title="5.3 Hardware Components (5 stages)"></a>5.3 Hardware Components (5 stages)</h3><h3 id="5-4-Instruction-Fetch-and-Execution-Steps"><a href="#5-4-Instruction-Fetch-and-Execution-Steps" class="headerlink" title="5.4 Instruction Fetch and Execution Steps"></a>5.4 Instruction Fetch and Execution Steps</h3><h3 id="5-5-Control-Signals"><a href="#5-5-Control-Signals" class="headerlink" title="5.5 Control Signals"></a>5.5 Control Signals</h3><h3 id="5-6-Hardwired-Control"><a href="#5-6-Hardwired-Control" class="headerlink" title="5.6 Hardwired Control"></a>5.6 Hardwired Control</h3><h3 id="5-7-CISC-Style-Processors"><a href="#5-7-CISC-Style-Processors" class="headerlink" title="5.7 CISC-Style Processors"></a>5.7 CISC-Style Processors</h3><h2 id="CH6-流水线"><a href="#CH6-流水线" class="headerlink" title="CH6 流水线"></a>CH6 流水线</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><h4 id="1、什么是流水线"><a href="#1、什么是流水线" class="headerlink" title="1、什么是流水线"></a>1、什么是流水线</h4><p>流水线是用于构建快速处理器的关键实现技术。 它允许多条指令的执行在时间上重叠。</p>
<ol>
<li>核心：将多条指令执行时间进行重叠</li>
<li>本质：在完成前一条指令之前执行下一条指令</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246243.png" alt="image-20231216111436816"></li>
</ol>
<h4 id="2、回顾指令执行的五大步骤"><a href="#2、回顾指令执行的五大步骤" class="headerlink" title="2、回顾指令执行的五大步骤"></a>2、回顾指令执行的五大步骤</h4><ol>
<li><p>Instruction Fetch  </p>
</li>
<li><p>Instruction Decode and Register Read  </p>
</li>
<li><p>Execution operation or calculate address </p>
</li>
<li><p>Memory access  </p>
</li>
<li><p>Write result into register</p>
</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246014.png" alt="image-20231216111805502" style="zoom: 80%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246802.png" alt="image-20231216111829396" style="zoom:80%;" />

<p>将原先的：上一条指令第五步结束后才进行下一指令的第一步的模式</p>
<p>切换为：在上一条指令移码阶段的同时进行下一指令的取指令</p>
<h4 id="3、术语"><a href="#3、术语" class="headerlink" title="3、术语"></a>3、术语</h4><ol>
<li><p>吞吐量&#x2F;Throught：每秒完成指令的数量。The number of instructions completed per second</p>
</li>
<li><p>延迟&#x2F;Latency： 在管道中执行一条指令需要多长时间。How long does it take to execute a single instruction</p>
</li>
<li><p>流水线片段&#x2F;Pipe Stage或Pipe Segment：完成指令的流水线中的一个步骤</p>
</li>
<li><p>流水线深度&#x2F;Pipeline Depth：流水线中的步骤的个数。</p>
</li>
</ol>
<h4 id="4、流水线的组成"><a href="#4、流水线的组成" class="headerlink" title="4、流水线的组成"></a>4、流水线的组成</h4><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246952.png" alt="image-20231216112503816" style="zoom: 67%;" />

<ol>
<li>流水线不改变原来的每个指令执行的时间延迟，完成每个指令所需的时间不变</li>
<li>但是减少的是多个指令总的运行的平均时间</li>
<li>提高了总体的吞吐量</li>
</ol>
<h3 id="6-2-数据依赖"><a href="#6-2-数据依赖" class="headerlink" title="6.2 数据依赖"></a>6.2 数据依赖</h3><ol>
<li>程序或指令序列中，一个操作对另一个操作的数据需求或依赖关系。这种依赖关系决定了指令执行的顺序以及可能存在的并行性。</li>
<li>三种主要依赖：<ol>
<li>读后写（Read-after-Write，RAW）依赖：</li>
<li>写后读（Write-after-Read，WAR）依赖：</li>
<li>写后写（Write-after-Write，WAW）依赖：</li>
</ol>
</li>
</ol>
<h4 id="1、三种冲突："><a href="#1、三种冲突：" class="headerlink" title="1、三种冲突："></a>1、三种冲突：</h4><ol>
<li>数据冲突——可进行规避<ol>
<li>指令的源操作数或目标操作数在流水线中预期的时间不可用的任何情况。 </li>
<li>因此某些操作必须延迟，流水线就会停顿。</li>
<li>可能可以采用&#x3D;&#x3D;操作数转发&#x3D;&#x3D;的形式解决此种冲突，但并非都可以。</li>
</ol>
</li>
<li>指令（控制）冲突——可进行规避<ol>
<li>指令可用性的延迟会导致流水线停顿。</li>
</ol>
</li>
<li>结构冲突——无法规避<ol>
<li>两条指令同时需要使用给定硬件资源的情况</li>
</ol>
</li>
</ol>
<p>$E.P.~~~~~~~~ Add<del>R2</del>R3~~井100$</p>
<p>$~~~~~~~~~~~~~~~~~Subtract<del>R9</del>R2~~~井30$ </p>
<ol>
<li><p>Add指令中的R2 和 Subtract 中的R2 存在数据依赖</p>
</li>
<li><p>在非流水线的数据路径上，当Add指令结束后R2的新值可应用于Subtract</p>
</li>
<li><p>但是在流水线上，Subtract必须等待Add指令中R2 被操作结束后才可以进行第一步骤取指操作。</p>
</li>
<li><p>因而<mark>流水线停顿</mark> </p>
</li>
<li><p>流水线停顿的详细信息</p>
<ul>
<li><p>在周期 3 中解码 Subtract 时，控制电路必须识别相关性</p>
</li>
<li><p>级间缓冲区携带指令源和目标的寄存器标识符</p>
</li>
<li><p>在周期 3 中，将计算阶段的目标标识符与解码阶段的源标识符进行比较</p>
</li>
<li><p>R2 匹配，因此 Subtract 保留在 Decode 中，而 Add 允许正常继续</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-5-存储器延迟"><a href="#6-5-存储器延迟" class="headerlink" title="6.5 存储器延迟"></a>6.5 存储器延迟</h3><p>由于访问存储器产生的延迟导致流水线的停顿。如Load指令，当发生cache miss时会导致流水线停顿。</p>
<h2 id="CH3-基本输入输出"><a href="#CH3-基本输入输出" class="headerlink" title="CH3 基本输入输出"></a>CH3 基本输入输出</h2><h3 id="3-1-访问I-O设备"><a href="#3-1-访问I-O设备" class="headerlink" title="3.1 访问I&#x2F;O设备"></a>3.1 访问I&#x2F;O设备</h3><h4 id="1、内存映射I-O"><a href="#1、内存映射I-O" class="headerlink" title="1、内存映射I&#x2F;O"></a>1、内存映射I&#x2F;O</h4><ol>
<li><p>特点：</p>
<ul>
<li><p>I&#x2F;O设备和内存共享相同的地址空间</p>
</li>
<li><p>没有针对I&#x2F;O的特殊指令</p>
</li>
<li><p>I&#x2F;O设备的访问和内存的读写很像</p>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>任何可以访问内存的机器指令都可以用于向 I&#x2F;O 设备传输数据或从 I&#x2F;O 设备传输数据</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>占用了宝贵的内存地址空间</li>
</ul>
</li>
</ol>
<h4 id="2、独立I-O"><a href="#2、独立I-O" class="headerlink" title="2、独立I&#x2F;O"></a>2、独立I&#x2F;O</h4><ol>
<li><p>特点：</p>
<ul>
<li><p>独立的地址空间</p>
</li>
<li><p>具有用于执行I&#x2F;O传输的特殊指令</p>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>I&#x2F;O 设备处理的地址线很少。</li>
</ul>
</li>
<li><p>注：独立的 I&#x2F;O 地址空间并不一定意味着 I&#x2F;O 地址线与内存地址线在物理上是分开的。</p>
</li>
</ol>
<h3 id="3-2-I-O设备接口"><a href="#3-2-I-O设备接口" class="headerlink" title="3.2 I&#x2F;O设备接口"></a>3.2 I&#x2F;O设备接口</h3><h4 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h4><ul>
<li>I&#x2F;O 设备接口是设备和互连网络之间的电路。</li>
<li>提供数据传输以及状态和控制信息交换的方式。</li>
<li>包括可通过加载和存储指令访问的数据、状态和控制寄存器。</li>
<li>内存映射 I&#x2F;O 使软件能够将这些寄存器视为内存中的位置。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" data-id="cm7pquzie002kr8v22dys2wod" data-title="计算机组成原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机重要基础/编译原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.294Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="CH1-编译器介绍"><a href="#CH1-编译器介绍" class="headerlink" title="CH1: 编译器介绍"></a>CH1: 编译器介绍</h2><h3 id="编译器概述"><a href="#编译器概述" class="headerlink" title="编译器概述"></a>编译器概述</h3><blockquote>
<p>为什么需要编译器？</p>
<p>因为计算机只能执行机器语言，而为了便于项目开发，人们需要使用高级程序语言提高效率。此时需要编译器将人能看懂但机器看不懂的高级程序语言转换为机器可以看得懂的机器码(machine code)</p>
<p>什么是编译器？</p>
<ol>
<li><p>编译器也是一种程序或软件</p>
</li>
<li><p>其核心功能是将<strong>输入</strong>的<strong>源代码</strong>翻译为<strong>目标代码</strong>进行<strong>输出</strong>。</p>
<p>即将代码由一种语言转换为另一种语言的翻译软件</p>
</li>
</ol>
</blockquote>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><ol>
<li>一种常见的语言处理器。</li>
<li>它并不通过翻译的方式生成目标程序；解释器直接利用用户提供的输入执行源程序中指定对的操作。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240735.png" alt="image-20240311182629128"> </p>
<h3 id="编译器和解释器对比"><a href="#编译器和解释器对比" class="headerlink" title="编译器和解释器对比"></a>编译器和解释器对比</h3><h4 id="相同点：都是一种语言实现系统"><a href="#相同点：都是一种语言实现系统" class="headerlink" title="相同点：都是一种语言实现系统"></a>相同点：都是一种语言实现系统</h4><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ol>
<li><p>解释器边解释边执行。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240650.png" alt="image-20240311194928864"> </p>
</li>
<li><p>编译器对源代码总的进行编译并产生可直接使用的对象代码。</p>
</li>
<li><p>解释器运行程序基本没有预处理。</p>
</li>
<li><p>编译器做了许多拓展性的预处理，大部分都是靠编译器实现。</p>
</li>
<li><p>编译器和解释器配合使用，法力无边（参考JAVA）</p>
</li>
</ol>
<h3 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h3><ol>
<li><p><strong>Lexical analysis(Scanning)词法分析</strong>：识别description逻辑块。</p>
</li>
<li><p><strong>Syntax analysis(Parsing) 语法分析</strong>：识别逻辑块间的相互关系。</p>
</li>
<li><p><strong>Semantic analysis 语义分析</strong>：识别整个结构的意义。</p>
</li>
<li><p><strong>IR Generation 中间代码生成</strong>：设计一个可能符合的结构</p>
</li>
<li><p><strong>IR Optimization 中间代码优化</strong>：简化生成的目的结构</p>
</li>
<li><p><strong>Generation (最终)代码生成</strong>：产生目的结构</p>
</li>
<li><p><strong>Optimization 机器相关代码优化</strong>：优化最终结构</p>
</li>
</ol>
<h4 id="编译器的高层结构"><a href="#编译器的高层结构" class="headerlink" title="编译器的高层结构"></a>编译器的高层结构</h4><ol>
<li>编译器具有非常<strong>模块化</strong>的高层结构<ol>
<li>前端 <strong>Front End</strong> </li>
<li>后端 <strong>Back End</strong></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">	str1[&quot;源代码&quot;]</span><br><span class="line">	str2[&quot;词法分析&quot;]</span><br><span class="line">	str3[&quot;语法分析&quot;]</span><br><span class="line">	str4[&quot;语义分析&quot;]</span><br><span class="line">	str5[&quot;代码生成&quot;]</span><br><span class="line"></span><br><span class="line">	str1 --字符序列--&gt; str2 --token序列--&gt; str3 --抽象语法树--&gt; str4 --中间代码--&gt; str5</span><br></pre></td></tr></table></figure>



<h2 id="CH2-词法分析"><a href="#CH2-词法分析" class="headerlink" title="CH2: 词法分析"></a>CH2: 词法分析</h2><blockquote>
<p>编译器的第一个步骤称为<strong>词法分析(lexical analysis)</strong>&amp;<strong>扫描(Scanning)</strong>。</p>
</blockquote>
<h3 id="词法分析的工作："><a href="#词法分析的工作：" class="headerlink" title="词法分析的工作："></a>词法分析的工作：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">字符流--&gt;|词法分析器|记号流</span><br></pre></td></tr></table></figure>

<ol>
<li><p>词法分析器读入组成源程序的<strong>字符流</strong>，并且将它们组成有意义的词素(lexeme)的序列，生成并输出一个词法单元序列，每个词法单元对应一个词素lexeme。</p>
</li>
<li><p>对于每个词素，词法分析器产生词法单元，该单元会传入下一步骤——<strong>语法分析</strong>当中。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240118.png" alt="image-20240312170757833" style="zoom:50%;" /> 
</li>
<li><p>词法分析器通常需要和符号表进行交互，当发现一个<strong>标识符</strong>的词素时，将该词素添加到符号表当中。<br>符号表条目的信息会在<strong>语义分析</strong>和<strong>代码生成</strong>步骤使用</p>
</li>
<li><p>词法分析器在编译器中的其他任务：</p>
<ol>
<li>过滤源程序中的注释和空白(空格、换行符、制表符以及在输入中用于分隔词法单元的其他字符)。</li>
<li>将编译器生成的错误信息和源程序的位置联系起来。</li>
<li>如果源程序使用了宏预处理器，则宏的拓展也可以由词法分析器完成。</li>
</ol>
</li>
<li><p>词法分析可分为两个阶段：</p>
<ol>
<li><p><strong>扫描阶段</strong>：完成一些不需要生成词法单元<strong>token</strong>的简单处理，如删除注释和将多个连续空白符压缩为一个。</p>
</li>
<li><p><strong>词法分析阶段</strong>：处理扫描阶段的输出并生成<strong>token</strong>。</p>
</li>
</ol>
</li>
<li><p>词法分析步骤将源代码的字符流转换为记号流，以待后续使用。</p>
</li>
</ol>
<h3 id="词法单元、模式和词素"><a href="#词法单元、模式和词素" class="headerlink" title="词法单元、模式和词素"></a>词法单元、模式和词素</h3><h4 id="词法单元-Token"><a href="#词法单元-Token" class="headerlink" title="词法单元 Token"></a>词法单元 Token</h4><p><strong>token的组成</strong>：一个词法单元名和一个可选的属性值（不一定有）组成。</p>
<p>（<strong>token-name</strong>，<strong>attribute-value</strong>）</p>
<pre><code>  1. *token-name*：是一个表示某种词法单位的抽象符号，如：特定的关键字，或代表标识符的输入字符序列。
  2. *attribute-value*：多个词素和一个模式匹配，则词法分析器需要向编译器的后续阶段提供被匹配词素的附加信息。因而词法分析器和语法分析器的交互中，词法分析器需要向语法分析器不仅返回**token-name**，还要返回一个描述该词法单元的词素的**attribut-value**。（词法单元名字影响语法分析过程中的决定；属性值影响语法分析之后对这个词法单元的翻译，语义）
  3. 以标识符举例：**id**，和一个标识符相关的信息——词素、类型、首次出现位置（报错时使用）存放在符号表中。一个标识符的属性值是一个指向符号表中该标识符对应条目的指针。
</code></pre>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p><strong>模式的定义</strong>：描述了一个词法单元的词素可能具有的形式。</p>
<h4 id="词素"><a href="#词素" class="headerlink" title="词素"></a>词素</h4><p><strong>词素的定义</strong>：源程序中的一个的字符序列，与某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。</p>
<h4 id="常见的词法单元类别："><a href="#常见的词法单元类别：" class="headerlink" title="常见的词法单元类别："></a>常见的词法单元类别：</h4><ol>
<li>每个关键字有一个词法单元。一个关键字的模式就是其本身；</li>
<li>表示运算符的词法单元。可以表示单个运算符；也快有表示一类运算符；</li>
<li>一个表示所有标识符的词法单元；</li>
<li>一个或多个表示常量的词法单元，如数字和字面值字符串；</li>
<li>每一个标点符号有一个词法单元，比如左右括号、逗号和分号。</li>
</ol>
<h4 id="词法错误"><a href="#词法错误" class="headerlink" title="词法错误"></a>词法错误</h4><p>解决词法错误的策略：<strong>“恐慌模式”恢复</strong>。</p>
<p>其他可能的错误恢复动作：</p>
<ol>
<li>从剩余的输入中删除一个字符。</li>
<li>向剩余的输入中插入一个遗漏的字符。</li>
<li>用一个字符来替换另一个字符。</li>
<li>交换两个相邻字符。</li>
</ol>
<h3 id="输入缓冲"><a href="#输入缓冲" class="headerlink" title="输入缓冲"></a>输入缓冲</h3><h4 id="缓冲区对"><a href="#缓冲区对" class="headerlink" title="缓冲区对"></a>缓冲区对</h4><p>两个交替读入的缓冲区，每个缓冲区的容量为N（通常为磁盘大小）。当输入文件中的剩余字符不足<strong>N</strong>时，使用<strong>eof</strong>标记末尾。</p>
<p><strong>两个指针</strong>：</p>
<ol>
<li><strong>lexemeBegin</strong> Pointer：该指针指向当前词素的开始处。</li>
<li><strong>forward</strong> Pointer：向前扫描，直到发现匹配某个模式为止。</li>
</ol>
<h4 id="哨兵标记"><a href="#哨兵标记" class="headerlink" title="哨兵标记"></a>哨兵标记</h4><p>在缓冲区对的基础上，</p>
<h3 id="扫描和token"><a href="#扫描和token" class="headerlink" title="扫描和token"></a>扫描和token</h3><ol>
<li>扫描得到一个<strong>lexeme</strong>，将词素加上记号构成一个<strong>token</strong>。有些<strong>token</strong>只有<strong>token-name</strong>而没有<strong>token-attribute</strong>，例如保留关键字<strong>while</strong>：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240860.png" alt="image-20240312170715066" style="zoom: 50%;" /> </li>
<li>扫描过程中，空格虽然算作一个词素，但并不将之存储，因为没有意义</li>
<li>某些<strong>token</strong>含有属性<strong>attribute</strong>，用于存储关于这个<strong>token</strong>额外的信息，例如一个数123，则会存储为：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240675.png" alt="image-20240312170546745" style="zoom:33%;" /></li>
</ol>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>正则表达式可以由较小的正则表达式按照规则递归构建：</p>
<ul>
<li>每个正则表达式$r$标识一个语言$L(r)$ ，这个语言也是根据$r$的子表达式所表示的语言递归定义的。</li>
</ul>
</blockquote>
<h4 id="归纳基础"><a href="#归纳基础" class="headerlink" title="归纳基础"></a>归纳基础</h4><p>给定字符集 $\Sigma &#x3D; {c_1,c_2,…c_n}$；</p>
<ol>
<li>空串$\varepsilon$是正则表达式；若$L(\epsilon) &#x3D; {\epsilon}$，则该语言只包含空串；</li>
<li>对于任意 $c \in \Sigma$ $c$​是正则表达式</li>
</ol>
<h4 id="归纳步骤"><a href="#归纳步骤" class="headerlink" title="归纳步骤"></a>归纳步骤</h4><p>由小的正则表达式构造大的正则表达式有四种方式，假设$r$和$s$都是正则表达式，分别表示语言$L(r)$和$L(S)$，则有：</p>
<ol>
<li><p>$(r)|(s)$是一个正则表达式，表示语言$L(r) \cup L(s)$；</p>
</li>
<li><p>$(r)(s)$是一个正则表达式，表示语言$L(r)L(s)$；</p>
</li>
<li><p>$(r)^<em>$是一个正则表达式，表示语言$(L(r))^</em>$；</p>
</li>
<li><p>$(r)$是一个正则表达式，表示语言$L(r)$。</p>
</li>
</ol>
<p>如果$M$和$N$是正则表达式，则具有以下归纳关系：</p>
<ol>
<li>选择 $M|N &#x3D; {M \cup N}$ </li>
<li>连接 $MN &#x3D; {mn|m \in M,n \in N}$ </li>
<li>闭包 $M^{*} &#x3D; {\varepsilon,M,MM,MMM,…}$</li>
</ol>
<h4 id="规定正则表达式优先级"><a href="#规定正则表达式优先级" class="headerlink" title="规定正则表达式优先级"></a>规定正则表达式优先级</h4><ol>
<li>一元运算符$*$具有最高的优先级，并且是左结合；</li>
<li>连接具有次高的优先级，是左结合；</li>
<li>$|$​ 的优先级最低，是左结合;</li>
<li>例如,我们可以根据这个约定将$(a)|(<del>(b*(c)</del>)$改写为$a|b^*c$。</li>
</ol>
<h4 id="正则表达式代数定律"><a href="#正则表达式代数定律" class="headerlink" title="正则表达式代数定律"></a>正则表达式代数定律</h4><table>
<thead>
<tr>
<th align="left">定律</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$r</td>
<td align="left">s&#x3D;s</td>
</tr>
<tr>
<td align="left">$r</td>
<td align="left">(s</td>
</tr>
<tr>
<td align="left">$r(st)&#x3D;(rs)t$</td>
<td align="left">连接是可结合的</td>
</tr>
<tr>
<td align="left">$r(s</td>
<td align="left">t)&#x3D;rs</td>
</tr>
<tr>
<td align="left">$\epsilon r&#x3D;r\epsilon&#x3D;r$</td>
<td align="left">$\epsilon$是连接的单位元</td>
</tr>
<tr>
<td align="left">$r^*&#x3D;(r</td>
<td align="left">\epsilon)^*$</td>
</tr>
<tr>
<td align="left">$r**&#x3D;r*$</td>
<td align="left">$*$具有幂等性</td>
</tr>
</tbody></table>
<h4 id="正则表达式拓展"><a href="#正则表达式拓展" class="headerlink" title="正则表达式拓展"></a>正则表达式拓展</h4><ol>
<li><p>至少一个实例：单目运算符$+$表示以一个正则表达式的正闭包。</p>
</li>
<li><p>0个或1个实例：单目运算符$?$表示“0个或一个实例</p>
</li>
<li><p>字符类：$[a_1 a_2 … a_n]$ $[a_1 a_2 … a_n]$形成一个逻辑上连续的序列，如连续的大写字母、小写字母或数位时：表示为$a_1 -a_n$，只写出序列的首尾符号，中间连词符隔开。如：[a-z]表示26个小写字母。</p>
</li>
<li><p>Lex的正则表达式</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240451.png" alt="image-20240317200417333"></p>
</li>
</ol>
<h3 id="词法单元的识别"><a href="#词法单元的识别" class="headerlink" title="词法单元的识别"></a>词法单元的识别</h3><blockquote>
<p>用正则表达式来表示一个模式，用模式来匹配词素</p>
</blockquote>
<ul>
<li>让词法分析器消除空白符<ul>
<li>方法：让词法分析器去识别：$ws \rightarrow (blank|tab|newline)^*$ </li>
<li>blank、tab及newline是用于表示具有同样名字的ASCII字符的抽象符号。</li>
<li>当我们识别到$ws$时,我们并不将它返回给语法分析器,而是从这个空白之后的字符开始继续进行词法分析。返回给语法分析器的是下一个词法单元。</li>
</ul>
</li>
</ul>
<h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><blockquote>
<p>将模式转换成具有特定风格的流图</p>
</blockquote>
<p><strong>重要约定</strong>：</p>
<ul>
<li>某些状态定义为接受状态或最终状态。双圈表示接受状态<ul>
<li>接受状态可执行的动作：向语法分析器返回一个词法单元和相关属性值</li>
</ul>
</li>
<li>如果需要forward回退一个位置（即相应词素并不包括那个在最后一部使我们到达接受状态的符号）则将在该接受状态的附近加上$*$​。</li>
<li>有一个状态指定为开始状态&amp;初始状态，该状态由一条没有出发结点的、标号为“start”的边指明。在读入任何输入符号之前，状态转换图总是位于它的开始状态。</li>
</ul>
<h4 id="保留字和标识符的识别"><a href="#保留字和标识符的识别" class="headerlink" title="保留字和标识符的识别"></a>保留字和标识符的识别</h4><h5 id="两种处理看起来很像标识符的保留字："><a href="#两种处理看起来很像标识符的保留字：" class="headerlink" title="两种处理看起来很像标识符的保留字："></a>两种处理看起来很像标识符的保留字：</h5><ul>
<li><p>初始化时就将各个保留字填入符号表中。</p>
<ul>
<li>任何词法分析时不在符号表中的标识符都不可能是一个保留字</li>
<li></li>
</ul>
</li>
<li><p>为每个关键字建立单独的状态转换图。</p>
<ul>
<li><p>以then为例：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240322.png" alt="image-20240317215751827" style="zoom:67%;" />
</li>
<li><p>这样的状态转换图包含的状态表示看到该关键字的各个后续字母后的情况,最后是一个“非字母或数字”的测试,也就是检查后面是否为某个不可能成为标识符一部分的字符。</p>
</li>
<li><p>如果采用这个方法,我们必须设定词法单元之间的优先级,使得当一个词素同时匹配id的模式和关键字的模式时,优先识别保留字词法单元,而不是id词法单元。</p>
</li>
</ul>
</li>
</ul>
<p>词法规则是一个Patamer集合，会有许许多多种正则表达式，许许多多种模式去匹配。</p>
<h4 id="冲突解决两种经典方案"><a href="#冲突解决两种经典方案" class="headerlink" title="冲突解决两种经典方案"></a>冲突解决两种经典方案</h4><ul>
<li><p>最长子串原则：</p>
<ul>
<li>自动机：用新的匹配得到的token去替换已经匹配到的token，进入<code>last-match</code>，当所有模式都卡住时返回<code>last-match</code>。</li>
</ul>
</li>
<li><p>优先级规则：如果最长的可能前缀与多个模式匹配，选择优先级高的进行匹配。</p>
</li>
</ul>
<h3 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h3><blockquote>
<p>字符流转换为token的核心是有穷自动机。</p>
</blockquote>
<ul>
<li>有穷自动机是识别器 recognizer，只能对每个可能输入串简单地回答“是&amp;否”。</li>
<li>分类：<ul>
<li>不确定的有穷自动机 NFA</li>
<li>确定的有穷自动机 DFA</li>
</ul>
</li>
<li>两种自动机能识别的语言集合是一样的，这些语言的集合正好是正则表达式描述的语言的集合————正则语言(RE，regular language)</li>
</ul>
<h4 id="NFA-不确定的自动机"><a href="#NFA-不确定的自动机" class="headerlink" title="NFA 不确定的自动机"></a>NFA 不确定的自动机</h4><blockquote>
<p>$(Σ,S,T,S_0,{S_n})$ </p>
<p>符号集，有穷的状态集合，变迁函数，开始状态，接受状态集</p>
</blockquote>
<p>一个不确定的有穷自动机(NFA)由以下几个部分组成:</p>
<ul>
<li>一个有穷的状态集合S。</li>
<li>一个输入符号集合$Σ$,即输入字母表(input alphabet)。我们假设代表空串的$\epsilon$不是$Σ$中的元素。</li>
<li>一个转换函数(transition function),它为每个状态和$Σ∪{\epsilon}$​中的每个符号都给出了相应的后继状态(next state)的集合。</li>
<li>S中的一个状态$s_0$被指定为开始状态,或者说初始状态。</li>
<li>S的一个子集F被指定为接受状态(或者说终止状态的)集合。</li>
</ul>
<p>将自动机表示为一张转换图：</p>
<blockquote>
<p>图中的结点是状态，带有标号的边表示自动机的转换函数</p>
</blockquote>
<ol>
<li>同一个符号可以标记从同一状态出发到达多个目标状态的多条边</li>
<li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串$\varepsilon$。</li>
</ol>
<h4 id="自动机中输入字符串的接受"><a href="#自动机中输入字符串的接受" class="headerlink" title="自动机中输入字符串的接受"></a>自动机中输入字符串的接受</h4><ul>
<li>一个NFA accpet输入字符串xx，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径，使该路径中各条边上的标号组成符号串x。</li>
<li>路径中的$\varepsilon$标号将被忽略，因为<strong>空串不影响根据路径得到的字符串</strong></li>
</ul>
<p>由一个NFA定义(或接受)的语言是从开始状态到某个接受状态的所有路径上的标号串的集合。</p>
<h3 id="DFA-确定的有穷自动机"><a href="#DFA-确定的有穷自动机" class="headerlink" title="DFA 确定的有穷自动机"></a>DFA 确定的有穷自动机</h3><ol>
<li>没有输入$\varepsilon$变迁</li>
<li>一个不会变迁到多个状态：每个状态s和每个输入符号a，有且只有一条标号为a的边离开s。</li>
</ol>
<h3 id="RE转换成NFA：Thompson算法"><a href="#RE转换成NFA：Thompson算法" class="headerlink" title="RE转换成NFA：Thompson算法"></a>RE转换成NFA：Thompson算法</h3><blockquote>
<p>只有一个开始状态&amp;接受状态；</p>
</blockquote>
<p><strong>算法转换步骤</strong>：</p>
<ol>
<li>增加开始状态</li>
<li>增加接受状态</li>
<li>将原来的开始和接受状态转换为中间状态</li>
<li>用空变迁来连接开始状态和接受状态到中间状态的变迁</li>
</ol>
<h3 id="NFA转换成DFA：子集构造算法"><a href="#NFA转换成DFA：子集构造算法" class="headerlink" title="NFA转换成DFA：子集构造算法"></a>NFA转换成DFA：子集构造算法</h3><h4 id="NFA和DFA的区别"><a href="#NFA和DFA的区别" class="headerlink" title="NFA和DFA的区别"></a>NFA和DFA的区别</h4><ol>
<li>空变迁</li>
<li>多重变迁</li>
</ol>
<h4 id="子集构造算法"><a href="#子集构造算法" class="headerlink" title="子集构造算法"></a>子集构造算法</h4><blockquote>
<p>思想核心是——讲构造得到的DFA的每个状态去对应原来NFA的一个状态集合。</p>
<p>NFA和DFA的状态数量大致相同</p>
</blockquote>
<h4 id="在NFA状态集上的操作"><a href="#在NFA状态集上的操作" class="headerlink" title="在NFA状态集上的操作"></a>在NFA状态集上的操作</h4><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$\varepsilon-closure(s)$</td>
<td align="left">能够从NFA的状态s开始只通过$\varepsilon$转换到达的NFA状态集合</td>
</tr>
<tr>
<td align="left">$\varepsilon-closure(T)$</td>
<td align="left">能够从T中某个NFA状态s开始，只通过$\varepsilon$转换到达的NFA状态集合，即$\cup _{s\in T}\varepsilon-closure(s)$</td>
</tr>
<tr>
<td align="left">$move(T,a)$</td>
<td align="left">能够从T中某个状态s出发通过标号为a的转换到达的NFA状态集合</td>
</tr>
</tbody></table>
<ol>
<li><p>是为了消除以上NFA和DFA的区别</p>
</li>
<li><p>子集构造法将多重变迁的多种状态构成一个集合，然后让同一个输入由原来的<strong>变迁到多种状态</strong>变成现在的<strong>变迁到同一个状态集合</strong>。</p>
<p>在得到等价状态集合的时候需要消除空变迁，即所有由空变迁可达的状态都是等价状态集合的元素。</p>
<p>将开始状态可达的状态包含入一个状态集合中，然后用其中一个集合符号进行代表。</p>
</li>
<li><p>构造结束：当DFA的状态表不在产生新的元素的改变，即集合不在因为输入而改变，</p>
<ol>
<li>需要求一个$\varepsilon$闭包 $\varepsilon-closure(I) &#x3D; I \cup \Sigma S$ </li>
<li>则会停止NFA到DFA的转换，得到了最简子集。</li>
</ol>
</li>
</ol>
<h3 id="DFA的最小化：Hopcroft算法"><a href="#DFA的最小化：Hopcroft算法" class="headerlink" title="DFA的最小化：Hopcroft算法"></a>DFA的最小化：Hopcroft算法</h3><p>简化DFA，将构建出的DFA最小化</p>
<ol>
<li>将同类型的n个会转化到等价状态的状态进行等价合并（若A是中间状态，但B是接受状态，则A和B不可以合并）</li>
</ol>
<h4 id="等价状态"><a href="#等价状态" class="headerlink" title="等价状态"></a>等价状态</h4><p>等价标准：</p>
<ul>
<li>s和t都是接受状态或都是非接受状态</li>
</ul>
<p>树的数据结构可以用来表达嵌套结构。</p>
<h3 id="从DFA生成分析算法"><a href="#从DFA生成分析算法" class="headerlink" title="从DFA生成分析算法"></a>从DFA生成分析算法</h3><h2 id="CH3-语法分析-Part-I"><a href="#CH3-语法分析-Part-I" class="headerlink" title="CH3: 语法分析(Part I)"></a>CH3: 语法分析(Part I)</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/501849448">学生角度————编译原理-语法分析详解</a> </p>
<blockquote>
<p>语法分析器从词法分析器得到一个由token组成的token序列，并验证这个token串可以由源语言的文法生成。</p>
<p><img src="D:\DeskTable\博客学习截图传输\image-20240319141414360.png" alt="image-20240319141414360"> </p>
<p>词法分析阶段处理了多个字符组成的构造，如标识符；</p>
<p>语法分析阶段因为词法分析已经完成了字符的token化，所以可以把原本由多个字符组成的标识符当作<strong>单元</strong>进行处理。</p>
</blockquote>
<h3 id="语法分析的任务"><a href="#语法分析的任务" class="headerlink" title="语法分析的任务"></a>语法分析的任务</h3><ol>
<li><p>还原token序列所描述的语法结构；</p>
<p>Recover the structure described by that series of tokens.</p>
</li>
<li><p>对token序列构成的不符合文法要求的结构进行报错</p>
<p>Report errors if those tokens do not properly encode a structure.</p>
</li>
</ol>
<h4 id="语法分析器分为三类："><a href="#语法分析器分为三类：" class="headerlink" title="语法分析器分为三类："></a>语法分析器分为三类：</h4><ol>
<li>通用的</li>
<li>自顶向下的</li>
<li>自底向上的</li>
</ol>
<h3 id="上下文无关文法和推导"><a href="#上下文无关文法和推导" class="headerlink" title="上下文无关文法和推导"></a>上下文无关文法和推导</h3><blockquote>
<p>上下文无关文法——简称“文法”。</p>
</blockquote>
<p>Derivation————得到上下文无关法</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li><p>一个终结符号集合(也称“词法单元”)：终结符号是该文法所定义的语言的基本符号的集合。</p>
</li>
<li><p>一个非终结符号集合(也称“语法变量”)：每个非终结符号表示一个终结符号串的集合。</p>
</li>
<li><p>一个产生式集合：主要用来表示某个构造的某种书写形式，其中每个产生式包括：</p>
<ul>
<li>一个称为产生式头或左部的非终结符号；</li>
<li>一个箭头；</li>
<li>一个称为产生式体或右部的由终结符号及非终结符号组成的序列。</li>
</ul>
<p>如果产生式头非终结符号代表一个构造，那么该产生式体就代表该构造的一种书写方式。</p>
</li>
<li><p>指定一个非终结符号为开始符号。</p>
</li>
</ul>
<h3 id="分析树和二义性文法"><a href="#分析树和二义性文法" class="headerlink" title="分析树和二义性文法"></a>分析树和二义性文法</h3><h3 id="自顶向下分析"><a href="#自顶向下分析" class="headerlink" title="自顶向下分析"></a>自顶向下分析</h3><p>LR(0)</p>
<p>LR(1)</p>
<p>SLR(1)</p>
<p>LALR(1)</p>
<h3 id="递归下降分析算法"><a href="#递归下降分析算法" class="headerlink" title="递归下降分析算法"></a>递归下降分析算法</h3><h2 id="CH5-语法分析-Part-II"><a href="#CH5-语法分析-Part-II" class="headerlink" title="CH5: 语法分析(Part II)"></a>CH5: 语法分析(Part II)</h2><h3 id="LL-1-分析算法"><a href="#LL-1-分析算法" class="headerlink" title="LL(1)分析算法"></a>LL(1)分析算法</h3><h3 id="LL-1-分析的冲突处理"><a href="#LL-1-分析的冲突处理" class="headerlink" title="LL(1)分析的冲突处理"></a>LL(1)分析的冲突处理</h3><h3 id="LR-0-分析算法"><a href="#LR-0-分析算法" class="headerlink" title="LR(0)分析算法"></a>LR(0)分析算法</h3><h3 id="SLR分析算法"><a href="#SLR分析算法" class="headerlink" title="SLR分析算法"></a>SLR分析算法</h3><h3 id="LR-1-分析算法"><a href="#LR-1-分析算法" class="headerlink" title="LR(1)分析算法"></a>LR(1)分析算法</h3><h3 id="LR-1-分析工具"><a href="#LR-1-分析工具" class="headerlink" title="LR(1)分析工具"></a>LR(1)分析工具</h3><p>采取管道过滤器的架构</p>
<p>源代码input – 词法分析器lexical Analysis – output token序列（存储于符号表）input – 语法分析器 syntax Analysis – output 语法树 input – 语义分析器（理解语句的意思）— 带注解的语法树</p>
<p>语义分析：</p>
<ol>
<li>从类型检测开始。</li>
<li></li>
</ol>
<p>语法指导的翻译SDD<br>符号表是一个使用hash table的表 便于查询和搜索 核心是search<br>语法和词法分析是 类型检查</p>
<p>TAC three address code 三地址码拓展<br>中间代码：为了方便优化代码，方便计算上的优化。采取优化方法。<br>中间代码的翻译称为与机器无关的翻译<br>生成代码称为与机器有关的翻译</p>
<p>语法分析的目的：<br>分词，token抽取<br>基于词法规则来进行分词<br>词法规则的描述：正则表达式 Regular expression</p>
<ol>
<li>检查词法错误，使用的token是否正确；</li>
<li></li>
</ol>
<p>原子正则表达式<br>a和空串<br>递归的方式</p>
<p>复合复杂的正则表达式<br>4种操作</p>
<ol>
<li>R1 R2 的串</li>
<li>R1 union R2 并集</li>
<li>R*</li>
<li>括号()区分union集使用</li>
</ol>
<p>patern————使用正则表达式 RE表示&amp;自动机 FA</p>
<p>自动机，FA：过于复杂，难以理解，机器易于阅读，刻画算法过程。对算法动态转移的直观展示，转移的过程也是翻译的问题。<br>正则表达式 RE：易于理解，人易于阅读，对规则的静态描述。</p>
<p>正则表达式+自动tb机，融合优点。<br>正则表达式容易地转换为自动机</p>
<p>如何将RE转换问DFA</p>
<p>Scanner program generator<br>输入正则表达式集合<br>输出Scanner code<br>flex 词法生成器<br>bis语法生成器</p>
<p>tb</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" data-id="cm7pquzic0028r8v26kog8xej" data-title="编译原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机重要基础/数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.293Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素:"></a>数据结构三要素:</h3><ol>
<li><p>逻辑结构</p>
</li>
<li><p>存储结构（物理结构）</p>
</li>
<li><p>具体的运算，即包含基础操作：数据的访问、添加、删除、更新</p>
</li>
</ol>
<h3 id="为什么要有数据结构"><a href="#为什么要有数据结构" class="headerlink" title="为什么要有数据结构:"></a>为什么要有数据结构:</h3><p>数据结构的提出是为了满足实际生产需求当作遇到的数据存储空间的分配问题,良好的空间分配方式可以提高程序的效率,降低成本,提高产能,因而数据结构并不高深,取之于生活再用之于生活。</p>
<h2 id="二、线性数据结构"><a href="#二、线性数据结构" class="headerlink" title="二、线性数据结构"></a>二、线性数据结构</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数组内元素具有相同的类型</li>
<li>每个元素对应一个唯一的索引，可以通过索引对数组内元素进行操作</li>
<li>数组大小在创建时固定，因而数组长度和元素个数可知</li>
<li>在内存中连续存储，可以进行高效的随机访问——通过索引直接访问</li>
<li></li>
</ul>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h3><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><p>用顺序表进行模拟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] elem;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">usedSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.elem = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">this</span>.usedSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usedSize == <span class="built_in">this</span>.elem.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//栈满则扩容</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="built_in">this</span>.elem = Arrays.copyOf(elem,<span class="number">2</span>*<span class="built_in">this</span>.elem.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.elem[<span class="built_in">this</span>.usedSize] = val;</span><br><span class="line">        usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.usedSize==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="built_in">this</span>.elem[usedSize-<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.usedSize--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>((<span class="string">&quot;栈为空！&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elem[usedSize-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><h3 id="线性-哈希表-Hash"><a href="#线性-哈希表-Hash" class="headerlink" title="(线性)哈希表(Hash)"></a>(线性)哈希表(Hash)</h3><h4 id="Hash概念引入"><a href="#Hash概念引入" class="headerlink" title="Hash概念引入"></a>Hash概念引入</h4><p>本质很简单，即通过一个函数，实现 键<strong>key</strong>和值<strong>value</strong>的映射,实现高效的元素查询.即向哈希表输入<strong>key</strong>,即可在$O(1)$ 时间内获取对应的<strong>value</strong>.</p>
<p>可联想: $学号 \xrightarrow[\text{Hash Function}]{\text{哈希函数}} 姓名$ </p>
<p>哈希表的增删查改四大基础操作时间复杂度均为$O(1)$ </p>
<h4 id="Hash的简单实现"><a href="#Hash的简单实现" class="headerlink" title="Hash的简单实现"></a>Hash的简单实现</h4><p>先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为「桶Bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。</p>
<p>是通过 $「哈希函数 Hash Function」$ 实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <strong>key</strong> ，输出空间是所有桶（<em>index</em>）。换句话说，输入一个<strong>key</strong>，我们可以通过哈希函数得到该 <strong>key</strong> 对应的键值对在数组中的存储位置。</p>
<p>输入一个<strong>key</strong> ，哈希函数计算过程:</p>
<ol>
<li>通过某种哈希算法 hash() 计算得到哈希值。</li>
<li>将哈希值对桶数量（数组长度）<strong>capacity</strong> 取模，从而获取该 <strong>key</strong> 对应的数组索引 <strong>index</strong>。</li>
<li>$index &#x3D; hash(key) % capacity$</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246595.png" alt="image-20231013000021119" style="zoom: 80%;" />

<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在<strong>多个输入对应相同输出</strong>的情况。而这种<strong>多对一</strong>的情况即被称为哈希冲突。</p>
<h4 id="链式地址法"><a href="#链式地址法" class="headerlink" title="链式地址法"></a>链式地址法</h4><p>为解决哈希冲突的第一种方法——「链式地址 Separate Chaining」，原理即是：单元格转换为链表，将生成的键值对当作链表节点，将所有发生冲突的键值对都存储在同一链表中。</p>
<ul>
<li>局限性:</li>
<li>空间开销较大</li>
<li>查询效果随着数据量的增大以及哈希冲突现象的出现频率的增多而逐渐降低,设想当有N个值对应同一个键时,此时在该节点上哈希表退化为了链表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key 则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key 则返回 nullptr</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="三、非线性结构"><a href="#三、非线性结构" class="headerlink" title="三、非线性结构"></a>三、非线性结构</h2><h1 align = center > 树 </h1>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>（Tree）</p>
<p>树（Tree）是一种常见的数据结构，它具有分层结构，类似于自然界中的树，由节点（Node）和边（Edge）组成。<code>每个树结构都包括一个根节点</code>，该节点没有父节点，而其他节点通过边与根节点和其他节点相连。</p>
<p>树可以被称为递归数据结构</p>
<p>树结构有许多不同的应用，包括计算机科学中的数据存储、搜索、排序以及层次性组织等。</p>
<h4 id="树结构中的常见的术语和特性"><a href="#树结构中的常见的术语和特性" class="headerlink" title="树结构中的常见的术语和特性"></a>树结构中的常见的术语和特性</h4><ol>
<li><strong>根节点（Root）</strong>：树结构的顶部节点，<strong>没有父节点</strong>，它是树的起始点。</li>
<li><strong>子节点（Child）</strong>：树中的每个节点可以有<strong>零个或多个</strong>子节点，子节点是其父节点的直接下级节点。</li>
<li><strong>父节点（Parent）</strong>：每个节点<strong>除了根节点</strong>外，都有一个父节点，它是其子节点的直接上级节点。</li>
<li><strong>叶子节点（Leaf）</strong>：<strong>没有子节点</strong>的节点称为叶子节点，它们位于树结构的末端 。</li>
<li><strong>兄弟节点（Sibling）</strong>：<strong>具有相同父节点</strong>的节点称为兄弟节点。</li>
<li><strong>节点的度</strong>：一个节点包含的子树的个数即为该节点的度</li>
<li><strong>树的度</strong>：所有节点的度当中的最大值</li>
<li><strong>节点的层次</strong>：根节点层次为1，以此递增</li>
<li><strong>深度（Depth）</strong>：从根节点到某个节点的路径上的边数称为该节点的深度。根节点的深度为0。</li>
<li><strong>高度（Height）</strong>：树结构中任意节点的最长路径（边数）称为树的高度。树的高度通常以根节点为参考。</li>
<li><strong>子树（Subtree）</strong>：树中的任何节点和其所有后代节点（包括该节点本身）构成的子树。</li>
<li><strong>有向边（Directed Edge）</strong>：连接两个节点的边<strong>具有方向</strong>，从一个节点指向另一个节点。</li>
</ol>
<h4 id="常见的树类型"><a href="#常见的树类型" class="headerlink" title="常见的树类型"></a>常见的树类型</h4><ol>
<li><p><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，左子节点和右子节点。</p>
</li>
<li><p><strong>二叉搜索树（Binary Search Tree）</strong>：二叉树的一种，具有特定的排序规则，左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</p>
</li>
<li><p><strong>平衡二叉树（Balanced Binary Tree）</strong>：一种二叉搜索树，具有平衡性质，确保树的高度较低，提高了搜索等操作的效率。</p>
</li>
<li><p><strong>B树和B+树</strong>：用于在磁盘上高效存储和检索数据的树状数据结构，常见于数据库管理系统中。</p>
</li>
<li><p><strong>树堆（Heap）</strong>：一种特殊的树结构，用于高效查找和删除最大或最小值的元素，通常用于堆排序和优先队列。</p>
</li>
<li><p><strong>树结构的图形表示</strong>：树结构通常可以以树状图的方式进行可视化表示，根节点在顶部，子节点向下延伸。</p>
</li>
</ol>
<p>树结构是计算机科学中的重要数据结构之一，它们用于解决各种问题，包括数据存储、搜索、排序、编译器中的语法分析、操作系统中的文件系统等等。了解树结构的基本概念和特性对于编写高效的算法和解决问题非常重要。</p>
<h4 id="树的遍历操作："><a href="#树的遍历操作：" class="headerlink" title="树的遍历操作："></a>树的遍历操作：</h4><h5 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">visit</span>(R);</span><br><span class="line">		<span class="keyword">while</span>(!R-&gt;next)&#123;</span><br><span class="line">			<span class="built_in">preOrder</span>(R-&gt;next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!R)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!R-&gt;next)&#123;</span><br><span class="line">			<span class="built_in">postOrder</span>(R-&gt;next);</span><br><span class="line">			<span class="built_in">visit</span>(R);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>当前根节点R入队，R出队时将R所有的子节点入队，而后每出队一个一个节点，就入队该节点的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void </span><br></pre></td></tr></table></figure>



<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树中的许多操作的时间开销取决于树的高度，因此总希望二叉树的高度尽可能的小</p>
<h5 id="二叉树的三种遍历："><a href="#二叉树的三种遍历：" class="headerlink" title="二叉树的三种遍历："></a>二叉树的三种遍历：</h5><ul>
<li>前序遍历——先后访问根节点、左子树、右子树</li>
<li>中序遍历——先后访问左子树、根节点、右子树</li>
<li>后序遍历——先后访问左子树、右子树、根节点</li>
</ul>
<p>三序的遍历有更加直观易记的方法 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ub4y147Zv/?spm_id_from=333.337.search-card.all.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">无脑画点连线法，一学就会</a> 作者：<a target="_blank" rel="noopener" href="https://space.bilibili.com/446171901">阿琛w</a></p>
<p>具体思路：</p>
<p>对于任意一颗树而言，前序遍历的形式总是<br>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p>
<p>而中序遍历的形式总是<br>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
<p>已知其中xx和xx序，推测第三种yy序：</p>
<p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。</p>
<p>由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>细节</p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p>
<hr>
<p>版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43762191/article/details/107280503">种树：二叉树、二叉搜索树、AVL树、红黑树、哈夫曼树、B树、树与森林</a></p>
<hr>
<p>作者：LeetCode-Solution<br>原文链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树</a></p>
<h4 id="完整二叉树"><a href="#完整二叉树" class="headerlink" title="完整二叉树"></a>完整二叉树</h4><p>（Complete Binary Tree）</p>
<p>完整二叉树（Complete Binary Tree）是一种二叉树，其中每一层都被完全填充，<strong>除了最后一层</strong>可能不是满的，但是最后一层的所有节点都<strong>集中在该层的左侧</strong>。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li>所有叶子节点都出现在最后一层或倒数第二层。</li>
<li>如果有子节点，每个节点都有两个子节点。</li>
<li>最后一层的节点都尽可能地靠左排列。</li>
</ol>
<h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line">/   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>



<h4 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h4><p>（Perfect Binary Tree）</p>
<p>完美二叉树（Perfect Binary Tree），也被称为满二叉树（Full Binary Tree），是一种特殊类型的二叉树</p>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ol>
<li>每个非叶子节点都有两个子节点。</li>
<li>所有叶子节点都在同一层级上，也就是说，树的<strong>所有层级都被完全填充</strong>。</li>
</ol>
<p>这意味着在完美二叉树中，每一层都包含最大数量的节点，即每一层的节点数都是2的幂次方。完美二叉树的高度（深度）通常由叶子节点的层级决定，如果有h层，则叶子节点位于第h层，树的高度为h。</p>
<h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>（Binary Search Tree，BST）</p>
<p>二叉搜索树（Binary Search Tree，BST）是一种二叉树的特殊形式。</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol>
<li>每个节点都包含一个值（通常是一个可比较的值），并且这些值按照特定的顺序排列。</li>
<li>对于每个节点：<ul>
<li>所有左子树中的节点的值都小于该节点的值。</li>
<li>所有右子树中的节点的值都大于该节点的值。</li>
<li>左右子树都是二叉搜索树。</li>
<li>每个节点的左右子树也是BST</li>
</ul>
</li>
<li>左子树的每一个节点的键值一定小于右子树每一个节点的键值（即右子树最小的键值）</li>
</ol>
<p>这个特性使得二叉搜索树非常适合进行快速的搜索、插入和删除操作，因为它充分利用了值的相对大小来构建树结构。如果树的结构是平衡的，搜索、插入和删除操作的时间复杂度通常为O(log n)，其中n是树中节点的数量。</p>
<h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \ / \</span><br><span class="line">1  4 7  9</span><br></pre></td></tr></table></figure>

<h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>需要注意的是，如果二叉搜索树的<strong>结构不平衡</strong>，即左子树和右子树的高度差异很大，搜索操作的性能可能会退化到O(n)，其中n是树中节点的数量。在极限情况下可能退化成链表（重新变成线性结构）</p>
<h5 id="BST常见操作："><a href="#BST常见操作：" class="headerlink" title="BST常见操作："></a>BST常见操作：</h5><h6 id="1、查找（搜索）："><a href="#1、查找（搜索）：" class="headerlink" title="1、查找（搜索）："></a>1、查找（搜索）：</h6><p>采取递归式搜索：</p>
<ol>
<li>value &lt; root，则向根节点左侧向下搜索</li>
<li>value &gt; root，则向根节点右侧向下搜索</li>
<li>当root为空或&#x3D;&#x3D;value时，直接返回为空或者返回根节点的值</li>
</ol>
<h6 id="2、插入："><a href="#2、插入：" class="headerlink" title="2、插入："></a>2、插入：</h6><p>新元素进入后，遇到大于的键值val的向左走，小于键值val的向右走，一直到尾端</p>
<h6 id="3、删除："><a href="#3、删除：" class="headerlink" title="3、删除："></a>3、删除：</h6><p>假设删除A节点</p>
<ol>
<li>A的度为0（叶节点）：直接移除A</li>
<li>A的度为1：A节点的节点直接补上</li>
<li>A的度为2：将A节点右子树键值最小的节点补上</li>
</ol>
<h5 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建每一个树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//节点存储的数据</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每个节点带有一个左孩子节点和一个右孩子节点</span></span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数初始化</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//创建二叉搜索树的根节点</span></span><br><span class="line">	TreeNode* root;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//递归插入新节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">insertRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//节点的初始化</span></span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">insertRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">insertRecursive</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归查询节点</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">findRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val == current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursive</span>(current-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归删除节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">removeRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">removeRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursive</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (current-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* tmp = current-&gt;right;</span><br><span class="line">				<span class="keyword">delete</span> current;</span><br><span class="line">				<span class="keyword">return</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* tmp = current-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> current;</span><br><span class="line">				<span class="keyword">return</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			TreeNode* tmp = <span class="built_in">findMin</span>(current-&gt;right);</span><br><span class="line">			current-&gt;value = tmp-&gt;value;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursive</span>(current-&gt;right, tmp-&gt;value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找子树的最小节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			current = current-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;right);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数进行成员变量初始化</span></span><br><span class="line">	<span class="built_in">BinarySearchTree</span>():<span class="built_in">root</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数释放内存空间</span></span><br><span class="line">	~<span class="built_in">BinarySearchTree</span>() &#123;</span><br><span class="line">		<span class="built_in">clearTree</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">insertRecursive</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">removeRecursive</span>(root, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursive</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//树空间释放函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearTree</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;right);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="线索二叉搜索树"><a href="#线索二叉搜索树" class="headerlink" title="线索二叉搜索树"></a>线索二叉搜索树</h4><p>在原来二叉树的基础上引入前驱和后继的概念，使得原来以树状逻辑排放的元素重新以线性逻辑排放。</p>
<p>存在一定问题，即某些节点的右节点即是其后继，或者其左节点即是其前驱</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>（Balanced Binary Tree）</p>
<p>平衡二叉树（Balanced Binary Tree），也称为平衡二叉搜索树（Balanced Binary Search Tree），是一种特殊类型的二叉搜索树（BST），因二叉搜索树的查找效率取决于树的高度，因而进一步提出而平衡二叉搜索树来保持树的高度达到最小。</p>
<h5 id="E-p："><a href="#E-p：" class="headerlink" title="E.p："></a>E.p：</h5><p>当输入序列 {1，2，3，4，5，6}，仍使用普通的二叉搜索树会退化成单链表：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247991.png" alt="img"></p>
<p>但使用平衡二叉搜索树则是：当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。这种左右子树的高度相差不超过1的树为平衡二叉树。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247843.png" alt="在这里插入图片描述"></p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ol>
<li>每个节点都包含一个值（通常是可比较的值）。</li>
<li>对于每个节点：<ul>
<li>左子树和右子树的高度之差（平衡因子）最多为1。</li>
<li>左右子树都是平衡二叉树。</li>
</ul>
</li>
</ol>
<p>平衡二叉树的关键特性是它的高度相对较低，因此搜索、插入和删除操作的时间复杂度通常是O(log n)，其中n是树中节点的数量。</p>
<h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \ / \</span><br><span class="line">1  3 5  7</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="平衡二叉搜索树-AVL树"><a href="#平衡二叉搜索树-AVL树" class="headerlink" title="平衡二叉搜索树(AVL树)"></a>平衡二叉搜索树(AVL树)</h4><h5 id="1-AVL树的构造："><a href="#1-AVL树的构造：" class="headerlink" title="1. AVL树的构造："></a>1. AVL树的构造：</h5><p>由上图可知：插入62节点之后，先进行普通的BST的插入，此时左子树高度为1，右子树高度为3，平衡因子的绝对值 &#x3D;&#x3D; 2，树失衡则需进行旋转操作：</p>
<h5 id="2-单旋转"><a href="#2-单旋转" class="headerlink" title="2. 单旋转"></a>2. 单旋转</h5><h5 id="2-1-左旋（LL平衡旋转）操作的步骤："><a href="#2-1-左旋（LL平衡旋转）操作的步骤：" class="headerlink" title="2.1 左旋（LL平衡旋转）操作的步骤："></a>2.1 左旋（LL平衡旋转）操作的步骤：</h5><ol>
<li>设定一个不平衡的节点为X，其右子树的高度比左子树高度高。</li>
<li>将X的右子节点Y取出，并将Y的左子节点B连接到X的右子节点。</li>
<li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点，以保持树的连接。</li>
<li>最后，将X连接到Y的左子节点B上。</li>
</ol>
<p>左旋操作后，X会变成Y的左子节点，而Y会成为X的父节点，从而保持了树的平衡性。</p>
<p>一直遍历，直到找到平衡因子的绝对值不为1的节点进行旋转操作。</p>
<p><strong>40</strong>的右节点<strong>51</strong>的左节点<strong>46</strong>接到<strong>40</strong>的右节点，而后将<strong>40</strong>这一节点接到<strong>51</strong>的左节点，如下图所示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247501.png" alt="在这里插入图片描述" style="zoom:80%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247494.png" alt="img" style="zoom:86%;" />

<h5 id="2-2-右旋（RR平衡旋转）操作的步骤如下："><a href="#2-2-右旋（RR平衡旋转）操作的步骤如下：" class="headerlink" title="2.2 右旋（RR平衡旋转）操作的步骤如下："></a>2.2 右旋（RR平衡旋转）操作的步骤如下：</h5><ol>
<li>设定一个不平衡的节点为X，其左子树的高度比右子树高度高。</li>
<li>将X的左子节点Y取出，并将Y的右子节点B连接到X的左子节点。</li>
<li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点。</li>
<li>最后，将X连接到Y的右子节点B上。</li>
</ol>
<p>右旋操作后，X会变成Y的右子节点，而Y会成为X的父节点，也能够保持树的平衡性。</p>
<p>A处的节点左右失衡，找到失衡节点的左节点B，将B的右节点E和B断开，接入A的左节点，而后将A接入到B的右节点。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247038.png" alt="在这里插入图片描述"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247169.png" alt="img"></p>
<h5 id="2-3-双旋转（不平衡节点在内侧）"><a href="#2-3-双旋转（不平衡节点在内侧）" class="headerlink" title="2.3 双旋转（不平衡节点在内侧）"></a>2.3 双旋转（不平衡节点在内侧）</h5><p>先左后右双旋转（LR平衡旋转）</p>
<p>左孩子右子树上插入新的节点，导致的不平衡</p>
<h5 id="2-4-代码模拟"><a href="#2-4-代码模拟" class="headerlink" title="2.4 代码模拟"></a>2.4 代码模拟</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> val) :<span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右子树高度差绝对值小于1</span></span><br><span class="line"><span class="comment">左右子树也都是平衡二叉搜索树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每个节点具有其自身的高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//根节点</span></span><br><span class="line">	TreeNode* root;</span><br><span class="line">	<span class="comment">//计算节点高度</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node-&gt;height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//平衡因子计算</span></span><br><span class="line">	<span class="comment">//平衡因子的计算是（当前节点的左子树高度减去右子树）</span></span><br><span class="line">	<span class="comment">//平衡因子大于1，说明左子树偏重</span></span><br><span class="line">	<span class="comment">//平衡因子小于-1，说明右子树偏重</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//更新节点高度</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			node-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//左旋</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">rotateLeft</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		TreeNode* newRoot = node-&gt;right;</span><br><span class="line">		node-&gt;right = newRoot-&gt;left;</span><br><span class="line">		newRoot-&gt;left = node;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(node);</span><br><span class="line">		<span class="built_in">updateHeight</span>(newRoot);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newRoot;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//右旋</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">rotateRight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		TreeNode* newRoot = node-&gt;left;</span><br><span class="line">		node-&gt;left = newRoot-&gt;right;</span><br><span class="line">		newRoot-&gt;right = node;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(node);</span><br><span class="line">		<span class="built_in">updateHeight</span>(newRoot);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newRoot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入新节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">insertRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">insertRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">insertRecursion</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> balance = <span class="built_in">balanceFactor</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &lt; current-&gt;left-&gt;value) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				current-&gt;left = <span class="built_in">rotateLeft</span>(current-&gt;left);</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (balance &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &gt; current-&gt;right-&gt;value) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				current-&gt;right = <span class="built_in">rotateRight</span>(current-&gt;right);</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找节点</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">findRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val == current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursion</span>(current-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">removeRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">removeRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursion</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;left == <span class="literal">nullptr</span> || current-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* temp = (current-&gt;left) ? current-&gt;left : current-&gt;right;</span><br><span class="line">				<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					temp = current;</span><br><span class="line">					current = <span class="literal">nullptr</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					*current = *temp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">delete</span> temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				TreeNode* temp = <span class="built_in">findMin</span>(current-&gt;right);</span><br><span class="line">				current-&gt;value = temp-&gt;value;</span><br><span class="line">				current-&gt;right = <span class="built_in">removeRecursion</span>(current-&gt;right, temp-&gt;value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> balance = <span class="built_in">balanceFactor</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &gt; current-&gt;left-&gt;value) &#123;</span><br><span class="line">				current-&gt;left = <span class="built_in">rotateLeft</span>(current-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (balance &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &lt; current-&gt;right-&gt;value) &#123;</span><br><span class="line">				current-&gt;right = <span class="built_in">rotateRight</span>(current-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找子树的最小节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			current = current-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;right);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数进行成员变量初始化</span></span><br><span class="line">	<span class="built_in">AVLTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构函数释放内存空间</span></span><br><span class="line">	~<span class="built_in">AVLTree</span>() &#123;</span><br><span class="line">		<span class="built_in">clearTree</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">insertRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">removeRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放树空间</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearTree</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;right);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348797577">深入理解伸展树(splay tree) - 知乎 (zhihu.com)</a></p>
<p>本质也是一颗二叉搜索树，但引入假设——当一个节点被访问时，该节点下一次被访问的可能性很大。基于该假设做出操作：每次一个节点被访问时，将该节点推到根节点的位置。</p>
<p>统计意义上的平衡树</p>
<p>这种结构可以不考虑进行树的平衡调整。</p>
<h5 id="单R-L型"><a href="#单R-L型" class="headerlink" title="单R&#x2F;L型"></a>单R&#x2F;L型</h5><p>根节点是查找节点的父节点。相当于直接将该节点提起，其他节点相对位置保持不变</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247990.png" alt="img" style="zoom: 67%;" />

<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247091.png" alt="img" style="zoom:73%;" />

<h5 id="RR-LL型："><a href="#RR-LL型：" class="headerlink" title="RR&#x2F;LL型："></a>RR&#x2F;LL型：</h5><h5 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h5><p>单旋转</p>
<p>之字型</p>
<p>一字型</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它是由Rudolf Bayer于1972年首次提出，后来由Leo J. Guibas和Robert Sedgewick进行改进。红黑树之所以重要，是因为它保持了二叉搜索树的基本性质，并在其上加入了一些额外的规则来确保树的高度保持在较小的范围内，从而保证了搜索、插入和删除操作的高效性。</p>
<h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ol>
<li>每个节点都有一个颜色，可以是红色或黑色。</li>
<li>根节点是黑色的。</li>
<li>所有叶子节点（NIL节点）都是黑色的。</li>
<li>叶节点是不存储数据的黑色空节点</li>
<li>如果一个节点是红色的，则其两个子节点必须是黑色的（不能有两个相连的红色节点）。</li>
<li>从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点，这被称为黑色高度。</li>
</ol>
<p>这些性质确保了红黑树在插入和删除操作后能够自动调整自身，以保持平衡，从而避免出现最坏情况的性能。</p>
<p>红黑树广泛用于各种编程语言和数据结构中，包括C++的STL中的<code>std::map</code>和<code>std::set</code>，以及Java的<code>java.util.TreeMap</code>和<code>java.util.TreeSet</code>等。它们支持高效的搜索、插入和删除操作，并且在保持数据有序的同时，具有可预测的性能。</p>
<p>红黑树的操作复杂度为O(log n)，其中n是树中节点的数量。这使得它成为许多算法和数据结构的重要组成部分，特别是需要高效插入和删除操作的情况下。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>（多&#x2F;M路搜索树）</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247382.png" alt="image-20230922101648057"></p>
<p>（课本把终端节点当作叶子节点，所以“数据放在叶子节点”）</p>
<h5 id="B树提出的主要目的："><a href="#B树提出的主要目的：" class="headerlink" title="B树提出的主要目的："></a>B树提出的主要目的：</h5><p>减少磁盘I&#x2F;O操作。</p>
<p><strong>一颗m阶B树即是一颗平衡的m路搜索树</strong></p>
<p><strong>一颗B树的阶由叶子节点最多的分叉决定</strong></p>
<h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><p>B树可以视为将原本的二叉搜索树引入区间的概念，即将要每一个子节点根据键值进行区间的划分，从而通过比较待搜索的数和区间的关系进行查找。</p>
<ul>
<li><p>绝对平衡，因所有子树都在同一层</p>
</li>
<li><p>数据项存储在叶子节点上（即之前所有的节点均为索引或者说关键字&#x2F;键）</p>
</li>
<li><p>叶子节点的下一层（均为空节点）均为失败节点，出现在同一层，代表搜索失败的节点</p>
</li>
<li><p>非叶子节点存储直到</p>
</li>
<li><p>非根节点点至少有：$[m&#x2F;2]$(向上取整) 个子树，至多有$m$个子树</p>
</li>
<li><p>非根节点的关键字：</p>
<ul>
<li>有序（升序或者降序</li>
<li>最少有：$[M&#x2F;2]-1$(向上取整)；最多有：$M-1$(子节点数-1)</li>
</ul>
</li>
<li><p>根节点最少 1个关键字（二叉），最多M-1个关键字（M叉），即根节点儿子个数取值范围$[2,m]$</p>
</li>
</ul>
<h5 id="基础操作："><a href="#基础操作：" class="headerlink" title="基础操作："></a>基础操作：</h5><h5 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h5><p>与<strong>BST</strong>类似，由根节点出发，递归向下查找。</p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>（M阶）：</p>
<p>基于B树提出，不同之处：</p>
<ol>
<li><p>非叶子节点子树指针个数与关键字个数相同</p>
</li>
<li><p>非叶子节点的子树指针P[i]-&gt;[K[i],K[i+1]]</p>
</li>
<li><p>所有叶子节点增加一个链指针，所有关键字都在叶子节点出现</p>
</li>
<li><p>B+树内部有两种节点，一种索引节点，一种叶子节点。</p>
</li>
<li><p>B+树索引——只用于索引，所有的数据保存</p>
</li>
</ol>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><h4 id="Disjoint-Set"><a href="#Disjoint-Set" class="headerlink" title="Disjoint Set:"></a>Disjoint Set:</h4><p>Operations:</p>
<ol>
<li><strong>Find</strong> the equivalence class(set) of a given element </li>
<li><strong>Union</strong> of two sets</li>
</ol>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p>
<p>并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。</p>
<h1 align = center> 哈希表 </h1>

<h3 id="非线性-哈希表"><a href="#非线性-哈希表" class="headerlink" title="(非线性)哈希表"></a>(非线性)哈希表</h3><p>哈希表，也叫散列表，一种由关键字到值并使用数组存储的数据结构</p>
<p>有一个hash function，关键字——hash function —— 值，将每个关键字映射到一个表当中。</p>
<p>理想当中，每一个关键字在经过hash function 后会有各自的值，但实际操作中，很可能不同的关键字得出相同的值，则会造成 <strong>hash冲突</strong>，因而会有以下几种解决冲突的方法。</p>
<p>1、分离链表法（separate chaining）：</p>
<p>将具有相同<strong>值</strong>的关键字存储到同一个 值链表 当中</p>
<p>2、开放地址法（Closed Hash Tbales&#x2F;Open Adderssing）</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>1、二叉堆，简称堆：</p>
<p>堆是一颗完全填满的二叉树(叶子节点可以不填满，但是需要从左到右填充)，即一颗完全二叉树</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248001.png" alt="image-20231008101022069"></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>在前面所学的线性数据结构中，每个元素都只有一个直接前驱和一个直接后驱。而在树结构当作，元素划分为层，每一层与上一层形成明确的层次关系，数据有着一个唯一的前驱，可能有着多个后继，但各元素间的直接关系仍旧限制在相邻层次间。在图结构当中，各节点之间的关系是任意的，可以随意进行节点间的相连，任意两个在限定集合内的两个节点都都可以形成直接关系。</p>
<h4 id="9-1-概念与定义"><a href="#9-1-概念与定义" class="headerlink" title="9.1 概念与定义"></a>9.1 概念与定义</h4><ol>
<li><p>定义：</p>
<ul>
<li>图(Graph)是由顶点的有穷非空集合$V(G)$和定点之间边的集合$E(G)$组成,通常表示为:$G&#x3D;(V,E)$,其中,G表示个图,</li>
<li>线性表和树可以为空,但图不可以为空,即图的顶点集不可为空集，但边集可以为空集。</li>
</ul>
</li>
<li><p>有向图：</p>
<ul>
<li>有向图的有向边也称为&#x3D;&#x3D;弧&#x3D;&#x3D; 弧尾—&gt;弧头</li>
<li>边集 <em>E</em> 是有向边集合。</li>
<li>边连接的两个顶点是有序对：$&lt;v，w&gt;$ </li>
<li>如图，表示的是有序对：$E&#x3D;{&lt;1,2&gt;,&lt;2,1&gt;,&lt;2,3&gt;}$ <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248416.png" alt="在这里插入图片描述" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>无向图</p>
</li>
</ol>
<h4 id="9-2-图的存储"><a href="#9-2-图的存储" class="headerlink" title="9.2 图的存储"></a>9.2 图的存储</h4><ol>
<li>邻接矩阵<ul>
<li>无向图的邻接矩阵是一个对称矩阵</li>
</ul>
</li>
</ol>
<h4 id="9-3-有向图"><a href="#9-3-有向图" class="headerlink" title="9.3 有向图"></a>9.3 有向图</h4><p>给出一个顶点集</p>
<h2 id="四、搜索算法"><a href="#四、搜索算法" class="headerlink" title="四、搜索算法"></a>四、搜索算法</h2><h3 id="搜索的概念："><a href="#搜索的概念：" class="headerlink" title="搜索的概念："></a>搜索的概念：</h3><ol>
<li>状态</li>
<li>状态转移</li>
</ol>
<p>根据路线画出一个搜索树</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><p>尽可能深的搜索树的分支。递归向下，设置一个“不符合条件”的底，触及时返回开始进行搜索的节点重新走另一条路径开始搜索</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//触底回弹</span></span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//成功达到迷宫出口</span></span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">5</span> &amp;&amp; y==<span class="number">5</span>)&#123;</span><br><span class="line">		flag = <span class="literal">true</span>; <span class="comment">//成功达到目的地，即找到路径，搜索成功，停止递归</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nxt_x = x+dx[i],nxt_y = y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(nxt_x &lt; <span class="number">1</span>||nxt_y&lt;<span class="number">1</span> || nxt_x &gt; <span class="number">5</span> || nxt_y &gt; <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(gh[nxt_x][nxt_y] == <span class="number">0</span> &amp;&amp; vis[nxt_x][nxt_y] == <span class="literal">false</span>)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt_x,nxt_y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、-排序算法"><a href="#五、-排序算法" class="headerlink" title="五、 排序算法"></a>五、 排序算法</h2><p>算法可视化网站:</p>
<p><a target="_blank" rel="noopener" href="https://visualgo.net/en">通过动画可视化数据结构和算法 - VisuAlgo</a></p>
<p><a target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting">排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo</a> </p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248819.png" alt="img"></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言:"></a>引言:</h3><ol>
<li><p>「排序算法 Sorting Algorithm」用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有 序数据通常能够被更有效地查找、分析和处理。</p>
</li>
<li><p>在排序算法中，数据类型可以是整数、浮点数、字符或字符串等；顺序的判断规则可根据需求设定，如数字 大小、字符 ASCII 码顺序或自定义规则。</p>
</li>
</ol>
<h3 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度:"></a>评价维度:</h3><ol>
<li><p>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（即时间复杂度中的常数项降低）。 对于大数据量情况，运行效率显得尤为重要。</p>
</li>
<li><p>就地性：顾名思义，「原地排序」通过在原数组上直接操作实现排序，无需借助额外的辅助数组，从而节省内 存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
</li>
<li><p>稳定性：「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。稳定排序是优良特性，也是 多级排序场景的必要条件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">(&#x27;A&#x27;, 19)</span><br><span class="line">(&#x27;B&#x27;, 18)</span><br><span class="line">(&#x27;C&#x27;, 21)</span><br><span class="line">(&#x27;D&#x27;, 19)</span><br><span class="line">(&#x27;E&#x27;, 23)</span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">(&#x27;B&#x27;, 18)</span><br><span class="line">(&#x27;D&#x27;, 19)</span><br><span class="line">(&#x27;A&#x27;, 19)</span><br><span class="line">(&#x27;C&#x27;, 21)</span><br><span class="line">(&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自适应性：「自适应排序」的时间复杂度会受输入数据的影响，即最佳、最差、平均时间复杂度并不完全相等。</p>
</li>
<li><p>是否基于比较：「基于比较的排序」依赖于比较运算符（&lt; , &#x3D; , &gt;）来判断元素的相对顺序，从而排序整个 数组，理论最优时间复杂度为 𝑂(𝑛 log 𝑛) 。而「非比较排序」不使用比较运算符，时间复杂度可达 𝑂(𝑛) ， 但其通用性相对较差。</p>
</li>
</ol>
<h3 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h3><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。 接下来，罗列出各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。</p>
<h3 id="Theta-N-2-排序算法"><a href="#Theta-N-2-排序算法" class="headerlink" title="$\Theta(N^2)$ 排序算法"></a>$\Theta(N^2)$ 排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>「冒泡排序 Bubble Sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样， 因此得名冒泡排序。</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>首先，对 𝑛 个元素执行“冒泡”，将数组的最大元素交换至正确位置， </li>
<li>接下来，对剩余 𝑛 − 1 个元素执行“冒泡”，将第二大元素交换至正确位置。 </li>
<li>以此类推，经过 𝑛 − 1 轮“冒泡”后，前 𝑛 − 1 大的元素都被交换至正确位置。</li>
<li>仅剩的一个元素必定是最小元素，无需排序，因此数组排序完成。</li>
</ol>
<h5 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li><strong>时间复杂度</strong>为 $O(n^2)$,<strong>自适应排序</strong>:各轮“冒泡”遍历的数组长度依次为$ 𝑛−1,𝑛−2, ⋯,2,1$,总和为 $\frac{n(n-1)}{2}$。在引入 flag 优化后，最佳时间复杂度可达到 $O(n)$ 。flag记录序列是否已经是有序；若存在部分无序，则可加入pos，记录上一次最后交换的位置，在pos之后的序列必然是有序的。</li>
<li>空间复杂度为 $O(1)$、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。 </li>
<li>稳定排序：由于在“冒泡”中遇到相等元素<strong>不交换</strong>。</li>
</ul>
<h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  swapped = false</span><br><span class="line">  for i = 1 to indexOfLastUnsortedElement-1:</span><br><span class="line">    if leftElement &gt; rightElement:</span><br><span class="line">      swap(leftElement, rightElement)</span><br><span class="line">      swapped = true; ++swapCounter</span><br><span class="line">while swapped</span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现"><a href="#c-代码实现" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-4-2-选择排序"><a href="#10-4-2-选择排序" class="headerlink" title="10.4.2 选择排序"></a>10.4.2 选择排序</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h5><p> 「选择排序 Selection Sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其 放到已排序区间的末尾。</p>
<h5 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h5 id="3-算法特性"><a href="#3-算法特性" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul>
<li>时间复杂度为 $𝑂(𝑛^2)$ 、非自适应排序：外循环共 $𝑛 − 1$ 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮 的未排序区间长度为 $2$ ，即各轮外循环分别包含 $𝑛 , 𝑛 − 1 , ⋯ , 2$ 轮内循环，求和为 $\frac{(𝑛−1)(𝑛+2)}{2}$ 。</li>
<li>空间复杂度 $𝑂(1)$ 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li>
<li>非稳定排序：在交换元素时，有可能将 $nums[i]$ 交换至其相等元素的右边，导致两者的相对顺序发生改变。</li>
</ul>
<h5 id="4-伪代码"><a href="#4-伪代码" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">重复（元素个数-1）次</span><br><span class="line">  把第一个没有排序过的元素设置为最小值</span><br><span class="line">  遍历每个没有排序过的元素</span><br><span class="line">    如果元素 &lt; 现在的最小值</span><br><span class="line">      将此元素设置成为新的最小值</span><br><span class="line">  将最小值和第一个没有排序过的位置交换</span><br></pre></td></tr></table></figure>

<h5 id="5-c-代码实现"><a href="#5-c-代码实现" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//整數或浮點數皆可使用，若要使用物件（class）時必須重载运算符(&gt;)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-4-3-插入排序"><a href="#10-4-3-插入排序" class="headerlink" title="10.4.3 插入排序"></a>10.4.3 插入排序</h4><h5 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>「插入排序 Insertion Sort」是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p>
<h5 id="2-算法步骤-1"><a href="#2-算法步骤-1" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol>
<li>初始状态下，数组的第 1 个元素已完成排序。</li>
<li>选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。</li>
<li>选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。</li>
<li>以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。</li>
</ol>
<h5 id="3-算法特性-1"><a href="#3-算法特性-1" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul>
<li>时间复杂度 $𝑂(𝑛^2 )$ 、自适应排序：最差情况下，每次插入操作分别需要循环 $𝑛 − 1 , 𝑛 − 2 , ⋯ , 2 , 1$ 次，求和得到 $\frac{(𝑛−1)𝑛}{2}$ ，因此时间复杂度为 $𝑂(𝑛^2 )$ 。在遇到有序数据时，插入操作会提前终止。当输入 数组完全有序时，插入排序达到最佳时间复杂度 $𝑂(𝑛)$ 。</li>
<li>空间复杂度 $𝑂(1)$ 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li>
<li>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li>
</ul>
<h5 id="4-伪代码-1"><a href="#4-伪代码-1" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将第一个元素标记为已排序</span><br><span class="line">对于每一个未排序的元素 X</span><br><span class="line">  “提取” 元素 X</span><br><span class="line">  i = 最后排序过元素的索引 到 0 的遍历</span><br><span class="line">    如果当前元素 j &gt; X</span><br><span class="line">      将排序过的元素向右移一格</span><br><span class="line">    跳出循环并在此插入 X</span><br></pre></td></tr></table></figure>

<h5 id="5-c-代码实现-1"><a href="#5-c-代码实现-1" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="type">int</span> key = arr[i];</span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; arr[j])) &#123;</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-5-Theta-N-logN-排序算法"><a href="#10-5-Theta-N-logN-排序算法" class="headerlink" title="10.5 $\Theta(N logN)$ 排序算法"></a>10.5 $\Theta(N logN)$ 排序算法</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本(插入排序plus版)<br>基于插入排序两种性质提出的改进:</p>
<ul>
<li>插入排序在对<strong>近似良序</strong>的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>先将整个待排序的记录序列分割成为<strong>若干子序列</strong>分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h5 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>时间复杂度为: $O(NLogN)$ </li>
<li>空间复杂度为: $O(1)$ </li>
<li>采取分治思想,将数组通过增量序列分解后得出各部分的局部最优解,再进行归整得到全局最优解。</li>
</ul>
<h5 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现-1"><a href="#c-代码实现-1" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">		h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">				std::<span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h = h / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>该算法原理是是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ul>
<li>“划分阶段”从顶至底递归地将数组从中点切为两个子数组：<ol>
<li>计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。 </li>
<li>递归执行步骤 1. ，直至子数组区间长度为 1 时，终止递归划分。</li>
</ol>
</li>
<li>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开 始合并，合并阶段中的每个子数组都是有序的。</li>
</ul>
<p>图示参见连接:</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/merge-sort.html">1.5 归并排序 | 菜鸟教程 (runoob.com)</a> </p>
<h5 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、非自适应排序：划分产生高度为 $log 𝑛 $的递归树，每层合并的总操作数量为$ 𝑛$ ，因此总体时间复杂度为 $𝑂(𝑛 log 𝑛)$ 。</li>
<li>空间复杂度 $ 𝑂(𝑛)$ 、非原地排序：递归深度为 $ log 𝑛$ ，使用 $𝑂(log 𝑛) $大小的栈帧空间。合并操作需要 借助辅助数组实现，使用 $𝑂(𝑛)$ 大小的额外空间。</li>
<li>稳定排序：在合并过程中，相等元素的次序保持不变。</li>
</ul>
<h5 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将每个元素拆分成大小为1的分区</span><br><span class="line"></span><br><span class="line">递归地合并相邻的分区</span><br><span class="line"></span><br><span class="line">  遍历 i = 左侧首项位置 到 右侧末项位置</span><br><span class="line"></span><br><span class="line">    如果左侧首项的值 &lt;= 右侧首项的值</span><br><span class="line"></span><br><span class="line">      拷贝左侧首项的值</span><br><span class="line"></span><br><span class="line">    否则： 拷贝右侧首项的值; 增加逆序数</span><br><span class="line"></span><br><span class="line">将元素拷贝进原来的数组中</span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现-2"><a href="#c-代码实现-2" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><ol>
<li>迭代版</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	T* a = arr;</span><br><span class="line">	T* b = <span class="keyword">new</span> T[len];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">			<span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">			<span class="type">int</span> k = low;</span><br><span class="line">			<span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">			<span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">				b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1) &#123;</span><br><span class="line">				b[k++] = a[start1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (start2 &lt; end2) &#123;</span><br><span class="line">				b[k++] = a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		T* temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			b[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		b = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>递归版</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; Array, <span class="type">int</span> front, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preconditions:</span></span><br><span class="line">	<span class="comment">// Array[front...mid] is sorted</span></span><br><span class="line">	<span class="comment">// Array[mid+1 ... end] is sorted</span></span><br><span class="line">	<span class="comment">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class="line">	<span class="comment">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LeftSubArray</span><span class="params">(Array.begin() + front, Array.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">RightSubArray</span><span class="params">(Array.begin() + mid + <span class="number">1</span>, Array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> idxLeft = <span class="number">0</span>, idxRight = <span class="number">0</span>;</span><br><span class="line">	LeftSubArray.<span class="built_in">insert</span>(LeftSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">	RightSubArray.<span class="built_in">insert</span>(RightSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">	<span class="comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class="line">			Array[i] = LeftSubArray[idxLeft];</span><br><span class="line">			idxLeft++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Array[i] = RightSubArray[idxRight];</span><br><span class="line">			idxRight++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; Array, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (front &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (front + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(Array, front, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(Array, mid + <span class="number">1</span>, end);</span><br><span class="line">	<span class="built_in">Merge</span>(Array, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>你好，我是必应。 我可以帮助你排序算法。 😊</p>
<p>快速排序是一种流行且高效的排序算法，它通过划分和征服输入数组来工作。 它选择一个主元元素并将数组划分为两个子数组，一个子数组的元素小于主元，另一个子数组的元素大于主元。 然后对子数组进行递归排序，直到数组排序完毕。</p>
<p>三中位数划分是一种通过取数组第一个、中间和最后一个元素的中位数来选择一个好的主元元素的策略。 这可以提高某些输入（例如已排序或接近排序的数组）的快速排序性能。</p>
<p>截止是一个阈值，低于该阈值，快速排序将切换到更简单的排序算法（例如插入排序），以避免递归的开销。 这也可以提高小型数组上快速排序的性能。</p>
<p>要使用具有三中位数分区和截断值 3 的快速排序对 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 进行排序，我们可以按照以下步骤操作：</p>
<ul>
<li>首先，我们对数组的第一个、中间和最后一个元素进行排序，并以中位数为基准。 该数组变为 3, 1, <strong>4</strong>, 1, <strong>5</strong>, <strong>5</strong>, 2, 6, <strong>9</strong>, 3, <strong>5</strong>。 枢轴是 <strong>5</strong>。</li>
<li>接下来，我们围绕主元将数组划分为两个子数组。 左子数组包含小于或等于 5 的元素，右子数组包含大于或等于 5 的元素。数组变为 <strong>3</strong>、<strong>1</strong>、<strong>4</strong>、<strong>1</strong> 、<strong>2</strong>、<strong>3</strong>、<strong>5</strong>、<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong>。</li>
<li>由于两个子数组都有超过 3 个元素，因此我们递归地对它们应用具有三中位数分区和 3 截止值的快速排序。</li>
<li>对于左子数组 [3, 1, 4, 1, 2, 3]，我们对第一个、中间和最后一个元素进行排序，并以中位数为基准。 子数组变为<strong>1</strong>、<strong>3</strong>、<strong>4</strong>、<strong>1</strong>、<strong>2</strong>、<strong>3</strong>。 枢轴是<strong>3</strong>。</li>
<li>我们将子数组划分为围绕枢轴的两个子数组。 左子数组包含小于或等于3的元素，右子数组包含大于或等于3的元素。子数组变为<strong>1</strong>、<strong>1</strong>、<strong>2</strong>、<strong>3</strong> ，<strong>3</strong>，<strong>4</strong>。</li>
<li>由于两个子数组的元素都小于或等于 3，因此我们对它们应用插入排序。 左子数组 [1, 1, 2] 已经排序。 右子数组 [3, 3, 4] 也已排序。</li>
<li>对于右子数组 [5, 5, 6, 9]，我们对第一个、中间和最后一个元素进行排序，并以中位数为基准。 子数组变为<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong>。 枢轴是 <strong>6</strong>。</li>
<li>我们将子数组划分为围绕枢轴的两个子数组。 左子数组包含小于或等于6的元素，右子数组包含大于或等于6的元素。子数组变为<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong> 。</li>
<li>由于两个子数组的元素都小于或等于 3，因此我们对它们应用插入排序。 左子数组 [5, 5] 已经排序。 右子数组 [6, 9] 也已排序。</li>
</ul>
<p>最终排序后的数组为 [1, 1, 2, 3, 3, 4, 5, 5, 5, 6 ,9]。</p>
<p>如果您想了解有关 Python 中采用中位数三分区和截断值为 3 的快速排序的更多信息，您可以在 Stack Overflow² 上查看此<a href="%5E1%5E">答案</a>。 您还可以在此 <a href="%5E3%5E">PDF</a> 中找到一些使用此算法进行排序的示例。</p>
<p>我希望这可以帮助您了解具有三中位数分区和 3 截止值的快速排序是如何工作的。 祝你今天过得愉快！ 😊</p>
<p>来源：与必应的对话， 2023&#x2F;10&#x2F;19<br>（1）排序 - Python：中位数为三的快速排序 - 堆栈内存溢出 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of-">https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of-</a> Three。<br>（2）排序 - Python：中位数为三的快速排序 - 堆栈内存溢出 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of-">https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of-</a> Three。<br>（3）算法 - 三值中值策略 - 堆栈内存溢出 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7559608/median-of-">https://stackoverflow.com/questions/7559608/median-of-</a> Three-values-strategy。<br>(4) CS 152h：数据结构作业#3 - Youmu。 <a target="_blank" rel="noopener" href="https://blog.youmu.moe/comp2012h-backup/p/assign/hw3.pdf%E3%80%82">https://blog.youmu.moe/comp2012h-backup/p/assign/hw3.pdf。</a></p>
<h5 id="1-原理-2"><a href="#1-原理-2" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol>
<li><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
</li>
<li><p>体现出的核心操作「哨兵划分」：选取序列当中的某一个元素作为”基准数“，将所有小于该基准数的元素移到左侧，反之移到右侧。</p>
<ul>
<li>选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ul>
</li>
<li><p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组；</p>
</li>
</ol>
<p>  并且满足“$左子数组任意元素≤基准数≤右子数组任意元素$”。</p>
<p>  因此，接下来只需对这两个子数组进行排序。</p>
<ol start="4">
<li>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</li>
</ol>
<h5 id="2-算法步骤-2"><a href="#2-算法步骤-2" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ul>
<li><p>首先，对原数组执行一次「哨兵划分」，得到未排序的左子数组和右子数组。</p>
</li>
<li><p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p>
</li>
<li><p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p>
</li>
</ul>
<h5 id="3-算法特性-2"><a href="#3-算法特性-2" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul>
<li><p>顾名思义，简单粗暴，就是快，效率高，处理大量数据最快的排序算法之一。</p>
</li>
<li><p>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、自适应排序：在平均情况下，哨兵划分的递归层数为 $log 𝑛$ ，每层中的总循环数为 𝑛 ，总体使用 $𝑂(𝑛 log 𝑛)$ 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为 长度为 0 和 $𝑛 − 1$ 的两个子数组，此时递归层数达到 𝑛 层，每层中的循环数为 𝑛 ，总体使用 $ 𝑂(𝑛2 )$ 时间。</p>
</li>
<li><p>空间复杂度 $𝑂(𝑛)$ 、原地排序：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 $𝑂(𝑛)$ 栈 帧空间。排序操作是在原数组上进行的，未借助额外数组。 </p>
</li>
<li><p>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">快排为什么快:</span><br><span class="line">1、出现最差情况的概率很低：虽然快速排序的最差时间复杂度为 𝑂(𝑛2) ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛 log 𝑛) 的时间复杂度下运行。</span><br><span class="line">2、缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像「堆排序」这类算法需要跳跃式访问元素，从而缺乏这一特性。</span><br><span class="line">3、复杂度的常数系数低：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与「插入排序」比「冒泡排序」更快的原因类似。</span><br><span class="line"></span><br><span class="line">快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平均期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序					  ——《算法艺术与信息学竞赛》</span><br></pre></td></tr></table></figure>
<h5 id="4-伪代码-2"><a href="#4-伪代码-2" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">每个（未排序）的部分</span><br><span class="line"></span><br><span class="line">将第一个元素设为 pivot</span><br><span class="line"></span><br><span class="line">  存储索引 = pivot索引 +1</span><br><span class="line"></span><br><span class="line">  从 i=pivot指数 +1 到 最右索引 的遍历</span><br><span class="line"></span><br><span class="line">    如果 a[i] &lt; a[pivot]</span><br><span class="line"></span><br><span class="line">      交换 (i, 存储索引); 存储索引++;</span><br><span class="line"></span><br><span class="line">  交换(pivot, 存储索引 - 1)</span><br></pre></td></tr></table></figure>

<h5 id="5-c-代码实现："><a href="#5-c-代码实现：" class="headerlink" title="5. c++代码实现："></a>5. c++代码实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序的优化算法：三数中值法："><a href="#快速排序的优化算法：三数中值法：" class="headerlink" title="快速排序的优化算法：三数中值法："></a>快速排序的优化算法：三数中值法：</h4><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>先取待排序序列的首位、中位和末尾数进行排序，而后取三个值当中的中值作为枢纽元。</p>
<h5 id="cpp代码实现"><a href="#cpp代码实现" class="headerlink" title="cpp代码实现"></a>cpp代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">median3</span><span class="params">(<span class="type">int</span> arr[].<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据量超过3时采取该算法</span></span><br><span class="line">    <span class="keyword">if</span>(right - left<span class="number">+1</span> &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="type">int</span> center = (left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[center] &lt; arr[left])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,center,left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[center] &gt; arr[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,center,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据量极小时(3个数据时)：</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,left,right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><ol>
<li><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
</li>
<li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</li>
</ul>
</li>
</ol>
<h5 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>创建一个堆 H[0……n-1]，建立大顶堆。完成后，最大元素位于堆顶；</li>
<li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元 素数量加 1 ；</li>
<li>从堆顶元素开始，从顶到底执行堆化操作（Sift Down），完成堆化后，堆的性质得到修复；</li>
<li>循环执行第 2. 和 3. 步。循环 𝑛 − 1 轮后，即可完成数组排序。</li>
</ol>
<h5 id="算法特性-3"><a href="#算法特性-3" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、非自适应排序：建堆操作使用 $𝑂(𝑛)$ 时间。从堆中提取最大元素的时间复杂 度为 $𝑂(log 𝑛)$ ，共循环 𝑛 − 1 轮。</li>
<li>空间复杂度 $𝑂(1)$ 、原地排序：几个指针变量使用 $𝑂(1)$ 空间。元素交换和堆化操作都是在原数组上进 行的。</li>
<li>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li>
</ul>
<h5 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现-3"><a href="#c-代码实现-3" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立父節點指標和子節點指標</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子節點指標在範圍內才做比較</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Theta-N-K-排序算法"><a href="#Theta-N-K-排序算法" class="headerlink" title="$\Theta(N+K)$ 排序算法"></a>$\Theta(N+K)$ 排序算法</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><ol>
<li>个人理解就是一个哈希表</li>
<li>「计数排序 Counting Sort」通过统计元素数量来实现排序，通常应用于整数数组。</li>
<li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
</ol>
<h5 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>遍历数组，找出数组中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚 + 1 的辅助数组 counter 。</li>
<li>借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法 很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加 1 即可。</li>
<li>由于 counter 的各个索引天然有序，因此相当于所有数字已经被排序好了。接下来，我们遍历 counter ，根据各数字的出现次数，将它们按从小到大的顺序填入 nums 即可。</li>
</ol>
<h5 id="算法特性-4"><a href="#算法特性-4" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>当输入的元素是n个0到k之间的整数时，它的运行时间是 $Θ(n + k)$计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
<li>时间复杂度 𝑂(𝑛 + 𝑚) ：涉及遍历 $nums$ 和遍历 $counter$ ，都使用线性时间。一般情况下 $𝑛 ≫ 𝑚$ ，时 间复杂度趋于 $𝑂(𝑛)$ 。</li>
<li>空间复杂度 $𝑂(𝑛 + 𝑚)$ 、非原地排序：借助了长度分别为 𝑛 和 𝑚 的数组 $res$ 和 $counter$ 。</li>
<li>稳定排序：由于向 $res$ 中填充元素的顺序是“从右向左”的，因此倒序遍历 $nums$ 可以避免改变相等元 素之间的相对位置，从而实现稳定排序。实际上，正序遍历 $nums$ 也可以得到正确的排序结果，但结果 是非稳定的。</li>
</ul>
<h5 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建关键值（计数）数组</span><br><span class="line">遍历数列中的每个元素</span><br><span class="line">相应的计数器增加 1</span><br><span class="line">每轮计数，都从最小的值开始</span><br><span class="line">当计数为非零数时</span><br><span class="line">重新将元素存储于列表</span><br><span class="line">将计数减1</span><br></pre></td></tr></table></figure>

<h5 id="c代码实现"><a href="#c代码实现" class="headerlink" title="c代码实现"></a>c代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(arr, n);</span><br><span class="line">        <span class="built_in">counting_sort</span>(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><ol>
<li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
</li>
<li>「桶排序 Bucket Sort」是分治思想的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</li>
</ol>
<h5 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>考虑一个长度为 𝑛 的数组，元素是范围 [0, 1) 的浮点数。桶排序的流程如下： </p>
<ol>
<li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。 </li>
<li>对每个桶分别执行排序（本文采用编程语言的内置排序函数）。 </li>
<li>按照桶的从小到大的顺序，合并结果。</li>
</ol>
<h5 id="算法特性-5"><a href="#算法特性-5" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>时间复杂度 $𝑂(𝑛 + 𝑘)$ ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\frac{𝑛}{𝑘}$ 。假设排序单 个桶使用 $𝑂( \frac{𝑛}{𝑘} log(\frac{𝑛}{𝑘}))$ 时间，则排序所有桶使用 $𝑂(𝑛log(\frac{𝑛}{𝑘}))$ 时间。当<strong>桶数量 𝑘 比较大时，时间复杂度则趋向于</strong> $𝑂(𝑛) $。合并结果时需要遍历所有桶和元素，花费 $𝑂(𝑛 + 𝑘) $时间。</li>
<li>自适应排序：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 $𝑂(𝑛^2 ) $时间。</li>
<li>空间复杂度 $𝑂(𝑛 + 𝑘)$ 、非原地排序：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ul>
<h5 id="伪代码-5"><a href="#伪代码-5" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现-4"><a href="#c-代码实现-4" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">        ListNode* mNext;</span><br><span class="line">        <span class="type">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *pre,*curr;</span><br><span class="line">        dummyNode.mNext = head;</span><br><span class="line">        pre = &amp;dummyNode;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;mNext = curr;</span><br><span class="line">        pre-&gt;mNext = newNode;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *dummy = &amp;dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">                        dummy-&gt;mNext = head1;</span><br><span class="line">                        head1 = head1-&gt;mNext;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dummy-&gt;mNext = head2;</span><br><span class="line">                        head2 = head2-&gt;mNext;</span><br><span class="line">                &#125;</span><br><span class="line">                dummy = dummy-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="type">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">                ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">                buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">                head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                arr[i] = head-&gt;mData;</span><br><span class="line">                head = head-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Theta-N-times-K-排序算法"><a href="#Theta-N-times-K-排序算法" class="headerlink" title="$\Theta(N \times K)$ 排序算法"></a>$\Theta(N \times K)$ 排序算法</h3><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h5><ol>
<li>两次哈希表的应用，将一个数拆分成基数形式表示，通过基数进行分配比较</li>
<li>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
<li>「基数排序 Radix Sort」的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</li>
</ol>
<h5 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的步骤如下： </p>
<ol>
<li>初始化位数 𝑘 &#x3D; 1 。 </li>
<li>对学号的第 𝑘 位执行「计数排序」。完成后，数据会根据第 𝑘 位从小到大排序。 </li>
<li>将 𝑘 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<h5 id="算法特性-6"><a href="#算法特性-6" class="headerlink" title="算法特性"></a>算法特性</h5><p>相较于计数排序，基数排序适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位 数不能过大。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 $𝑂(𝑛𝑘) ≫ 𝑂(𝑛2 )$ 。 </p>
<ul>
<li>时间复杂度 𝑂(𝑛𝑘) ：设数据量为 𝑛 、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 $𝑂(𝑛 + 𝑑)$ 时间，排序所有 𝑘 位使用 $𝑂((𝑛 + 𝑑)𝑘)$ 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 $𝑂(𝑛)$ 。 </li>
<li>空间复杂度 $𝑂(𝑛 + 𝑑)$ 、非原地排序：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 $res$ 和 $counter$ 。</li>
<li>稳定排序：与计数排序相同。</li>
</ul>
<h5 id="伪代码-6"><a href="#伪代码-6" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分别给每个数位（0到9）创造1个桶（数列），共计10个</span><br><span class="line">遍历每个数位</span><br><span class="line">遍历数列中的每个元素</span><br><span class="line">将元素移至相应的桶中</span><br><span class="line">在每个桶中，从最小的数位开始</span><br><span class="line">当桶不是空的</span><br><span class="line">将元素恢复至数列中</span><br></pre></td></tr></table></figure>

<h5 id="c-代码实现-5"><a href="#c-代码实现-5" class="headerlink" title="c++代码实现"></a>c++代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>&#123; <span class="comment">//辅助函数，求数据的最大位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];              <span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*    int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm7pquzic002br8v23jrz5u8a" data-title="数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机重要基础/操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.291Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="CH1—基本概念概述"><a href="#CH1—基本概念概述" class="headerlink" title="CH1—基本概念概述"></a>CH1—基本概念概述</h2><p>操作系统：</p>
<ol>
<li>是一台将复杂的执行细节隐藏， 向用户提供虚拟的易于使用的功能的一种机器。</li>
<li>一种资源管理机器</li>
</ol>
<h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><blockquote>
<p>正在执行的一个程序就是一个进程</p>
<p>为了描述和控制进程的运行</p>
</blockquote>
<ol>
<li><p>一个称为command interpret或shell的进程从终端读取命令。</p>
</li>
<li><p>一个进程可以创建一个或多个子进程，从而构成进程树。</p>
</li>
<li><p>UNIX有一个共同的父进程：<strong>root</strong></p>
</li>
</ol>
<h3 id="进程块-PCB"><a href="#进程块-PCB" class="headerlink" title="进程块 PCB"></a>进程块 PCB</h3><p>为了便于描述和控制进程的运行，OS为进程定义了一种数据结构“进程块 PCB（Process Control Block）”，每创建一个进程，即是为某个程序设置了一个PCB，用于对该进程进行控制和管理。进程任务完成则收回PCB，代表进程消亡。</p>
<p>至此，PCB是进程存在的唯一标志。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul>
<li><p><strong>running</strong></p>
</li>
<li><p><strong>blocked</strong>(阻塞，不可抢占CPU资源)</p>
</li>
<li><p><strong>ready</strong>(可抢占CPU资源状态)</p>
</li>
</ul>
<h3 id="不同种类的ID"><a href="#不同种类的ID" class="headerlink" title="不同种类的ID"></a>不同种类的ID</h3><ul>
<li><p><strong>UID</strong>：Each person authorized to use a system is assigned a User IDentification</p>
</li>
<li><p><strong>PID</strong>：A process is assigned a Process IDentification</p>
</li>
<li><p><strong>GID</strong>：在一个Group内的用户具有在该组内的Group identification</p>
</li>
</ul>
<p>**进程间通信：**协作和同步进程的通信称为进程间通信</p>
<p>**信道：**一种伪文件，用于连接两个进程</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用提供了运行程序和操作系统之间的接口</p>
<p>系统调用的目的：</p>
<ul>
<li><p>应用程序用来向操作系统请求服务的机制。</p>
</li>
<li><p>主要由程序通过高级应用程序编程接口(API)访问，而不是直接使用系统调用</p>
<p>应用通过申请 预先设定好的用来调用系统的程序 来完成调用系统某项操作的目的</p>
</li>
</ul>
<p>有以下两种考虑：</p>
<ol>
<li><p>使用接口，可以不用事先考虑以后添加新的应用和程序时需要对操作系统进行修改，而只需要提供一套统一的接口调用标准，厂商开发时按照这一套标准进行，而后将开发好的应用安装到操作系统即可</p>
</li>
<li><p><strong>独立</strong>了系统和用户应用程序之间，降低了耦合度。</p>
</li>
</ol>
<h4 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h4><ol>
<li>操作系统是比库函数更加底层的一种接口。因为应用程序在调用部分库函数以后，部分库函数也需要去调用系统调用。</li>
<li>部分库函数各种功能的实现是通过调用了系统调用，进而请求操作系统的内核服务从而完成一系列功能。</li>
<li>部分库函数对系统调用进行了封装。</li>
</ol>
<p><strong>按功能分类，常见的系统调用</strong>·</p>
<blockquote>
<p>凡是与共享资源有关的操作（存储分配、I&#x2F;O操作、文件管理等）都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核来完成。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">功能名称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">设备管理</td>
<td align="left">完成设备的 请求、释放、启动 等功能</td>
</tr>
<tr>
<td align="center">文件管理</td>
<td align="left">完成文件的 读、写、创建、删除 等功能</td>
</tr>
<tr>
<td align="center">进程控制</td>
<td align="left">完成进程的 创建、撤销、阻塞、唤醒 等功能</td>
</tr>
<tr>
<td align="center">进程通信</td>
<td align="left">完成进程之间的 信息传递、信号传递 等功能</td>
</tr>
<tr>
<td align="center">内存管理</td>
<td align="left">完成内存的 分配、回收 等功能</td>
</tr>
</tbody></table>
<h4 id="POSIX："><a href="#POSIX：" class="headerlink" title="POSIX："></a>POSIX：</h4><p>调用操作系统接口：用于调用系统调用的一种<strong>procedure</strong>，通常是一个<strong>procedure</strong>对应一个系统调用<strong>system call</strong>，但并不是绝对的。</p>
<p>完成一个系统调用的步骤</p>
<blockquote>
<p>以read系统调用为例，进行简单的学习</p>
<p>read调用有三个参数： <code>read(fd,buffer,nbytes)</code></p>
</blockquote>
<ul>
<li><p>1、2、3：调用程序首先将三个参数压入堆栈;</p>
</li>
<li><p>4：接着对库过程的实际调用，该指令是用来调用所有过程的正常过程调用指令;</p>
</li>
<li><p>5：将<code>read</code>函数代码放入寄存器当中;</p>
</li>
<li><p>6：陷入内核：而后执行一个<code>TRAP</code>指令，将用户态切换到内核态，并在内核一个固定地址开始执行；(<code>TRAP</code>不能跳转到任意地址上);</p>
</li>
<li><p>7：分派：内核代码检查系统调用编号，分派给正确的系统调用处理器。通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表完成;</p>
</li>
<li><p>8：系统调用处理器运行;</p>
</li>
<li><p>9：系统调用处理器完成工作，控制可能会在跟随<code>TRAP</code>指令后面的指令中返回给用户空间库过程;</p>
</li>
<li><p>10：这个过程接着以通常的过程调用返回的方式，返回到用户程序;</p>
</li>
<li><p>11：完成整个工作后，用户程序清除堆栈，还原回进行任何过程调用之前一样，SP自增。</p>
</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241434.png" alt="image-20240610133629462" style="zoom:80%;" /></li>
</ul>
<h3 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h3><blockquote>
<p>大内核、微内核、分层结构、模块化、外核</p>
</blockquote>
<h4 id="单体架构（Monolithic-Architecture）"><a href="#单体架构（Monolithic-Architecture）" class="headerlink" title="单体架构（Monolithic Architecture）"></a>单体架构（Monolithic Architecture）</h4><ul>
<li><strong>宏内核</strong>：将操作系统的主要功能模块都作为系统内核，运行在和心态<ul>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
<li>例如：早期的Linux，UNIX</li>
</ul>
</li>
</ul>
<h4 id="微内核（Microkernel-Architecture）"><a href="#微内核（Microkernel-Architecture）" class="headerlink" title="微内核（Microkernel Architecture）"></a>微内核（Microkernel Architecture）</h4><ul>
<li><strong>微内核</strong>：只把核心功能（如进程间通信、基本的内存管理、CPU调度等）保留在内核中，而其他服务（如文件系统、设备驱动等）移到用户空间运行。<ul>
<li>优点：缩小内核，只保留核心功能，结构清晰，方便维护</li>
<li>缺点：需要频繁在核心态和用户态之间切换、性能低</li>
<li>例如：Windows NT</li>
</ul>
</li>
</ul>
<h4 id="层次结构（Layered-Architecture）"><a href="#层次结构（Layered-Architecture）" class="headerlink" title="层次结构（Layered Architecture）"></a>层次结构（Layered Architecture）</h4><ul>
<li><strong>分层次结构</strong>：内核分多层，每一层都只使用其下层提供的功能，并为其上层提供服务。<ul>
<li><p>优点：模块化设计，易于理解和调试</p>
</li>
<li><p>缺点：严格的层次划分可能导致效率低下，跨层通信复杂。</p>
</li>
</ul>
</li>
</ul>
<h4 id="模块化结构（Modular-Architecture）"><a href="#模块化结构（Modular-Architecture）" class="headerlink" title="模块化结构（Modular Architecture）"></a>模块化结构（Modular Architecture）</h4><ul>
<li><p><strong>模块化</strong>：将操作系统按功能划分为若干具有一定独立性的模块，可以独立编译和加载。</p>
<ul>
<li>灵活性高，易于扩展和维护</li>
<li>模块间接口设计复杂，安全性和稳定性需要严格管理。</li>
</ul>
</li>
<li><p><strong>外核(exokernel)</strong>：内核负责进程调度、进程通信等功能；外核负责用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>
</li>
<li><p><strong>虚拟机(Hypervisor)</strong>：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机都可以独立运行一个操作系统。</p>
</li>
</ul>
<h2 id="CH2—进程-Process-————"><a href="#CH2—进程-Process-————" class="headerlink" title="CH2—进程&amp;Process ————"></a>CH2—进程&amp;Process ————</h2><blockquote>
<p>25~30分</p>
<p>两个大题；</p>
<p>两个选择题；</p>
<p>可能一个简答题</p>
</blockquote>
<blockquote>
<ol>
<li>Process  进程</li>
<li>Threads 线程</li>
</ol>
<hr>
<ol start="3">
<li><p><strong>Interprocess communication</strong>进程间通信</p>
</li>
<li><p><strong>Classical IPC problems</strong>进程间通信的经典问题</p>
</li>
</ol>
<hr>
<ol start="5">
<li>Scheduling  进程调度问题</li>
</ol>
<p>在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每一个进程个运行几十或几百毫秒。严格来说，在CPU运行的某一个瞬间，CPU只能运行一个进程，但在1秒内可能运行多个进程，则对人来说就会产生类似于看电影一样的效果，感觉同一时间运行了多个进程，也就是<strong>伪并行</strong>。</p>
</blockquote>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="PCB存储的信息"><a href="#PCB存储的信息" class="headerlink" title="PCB存储的信息"></a>PCB存储的信息</h4><table>
<thead>
<tr>
<th align="left">信息种类</th>
<th align="left">具体描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">进程描述信息</td>
<td align="left">进程标识符<strong>PID</strong>&amp;用户标识符<strong>UID</strong></td>
</tr>
<tr>
<td align="left">进程控制和管理信息</td>
<td align="left"><strong>CPU</strong>、磁盘、网络流量使用情况统计…&amp;进程当前状态：就绪态、阻塞态、运行态</td>
</tr>
<tr>
<td align="left">资源分配清单</td>
<td align="left">正在使用哪些文件&amp;正在使用哪些内存区域&amp;正在使用哪些<strong>I&#x2F;O</strong>设备</td>
</tr>
<tr>
<td align="left">处理机相关信息</td>
<td align="left">如<strong>PSW</strong>、<strong>PC</strong>等各种寄存器的值（用于实现进程切换）</td>
</tr>
</tbody></table>
<p>当一个程序开始运行前，创建了相对应的<strong>PCB</strong>，同时将程序中一系列的指令存放到内存当中——构成程序段，包括程序指令——而一个程序执行的过程即是<strong>CPU</strong>从内存中读取一条条指令并依次执行的过程</p>
<p>一个进程实例（进程映像）是由PCB、程序段、数据段组成。</p>
<p>进程是<strong>动态</strong>的，进程实例是<strong>静态</strong>的。</p>
<p>操作系统<strong>以进程为单位进行资源的分配和调度</strong>。</p>
<h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>软件可以视为一组进程的集合</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241488.png" alt="image-20240610140621701" style="zoom:50%;" /> 

 

<p>Multiprogramming of four programs 四个程序的多路编程<br>Conceptual model of 4 independent, sequential processes 4个独立的顺序过程的概念模型<br>Only one program active at any instant 任何时刻只有一个程序处于活动状态</p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p><strong>进程的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次活动</strong></p>
<p>当进程被创建时，会给予进程一个不重复的独一无二的PID。</p>
<p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h4 id="Process-Vs-Program"><a href="#Process-Vs-Program" class="headerlink" title="Process Vs Program"></a>Process Vs Program</h4><p>程序：</p>
<ul>
<li>集合指令，静态概念；</li>
<li>永久</li>
<li>一个程序可以是多个进程的执行程序;</li>
</ul>
<p>进程：</p>
<ul>
<li>描述并发、动态的概念；</li>
<li>进程包括程序、数据和PCB</li>
<li>暂时的</li>
<li>进程可以在其中创建其他进程。</li>
<li>另外，一个进程可以调用多个程序。</li>
</ul>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><ol>
<li>系统初始化时</li>
<li>执行进程创建系统调用时（fork()函数）：请求创建进程的是父进程<ol>
<li>从当前进程创建新的进程，新进程是当前进程的子进程，也是父进程的副本</li>
</ol>
</li>
<li>创建新进程的用户请求：请求创建进程的是用户<ol>
<li>请求是用户或应用程序向操作系统提出的请求，目的是启动一个新的进程。</li>
</ol>
</li>
<li>启动批处理作业</li>
</ol>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ol>
<li>Normal exit 正常退出（自愿）<ol>
<li>程序正常执行完毕</li>
</ol>
</li>
<li>Error exit 错误退出（自愿）<ol>
<li>编译出错</li>
</ol>
</li>
<li>Fatal error 致命错误（非自愿）<ol>
<li>除以0，执行非法指令，引用不存在的内存</li>
</ol>
</li>
<li>Killed by another process 被其他进程杀死（非自愿）</li>
</ol>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul>
<li>基本状态：<ul>
<li>运行 running state</li>
<li>就绪 ready state</li>
<li>阻塞 blocked state</li>
</ul>
</li>
<li>其他状态<ul>
<li>New state</li>
<li>Exit state</li>
</ul>
</li>
<li>挂起<ul>
<li>阻塞挂起状态</li>
<li>就绪挂起状态</li>
</ul>
</li>
</ul>
 <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241084.png" alt="image-20240610172240806" style="zoom:50%;" /> 

<h3 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程 Thread"></a>线程 Thread</h3><h4 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h4><p>在进程当中划分出线程，是对一个进程中已得到CPU资源的一种利用的方式</p>
<ul>
<li><p>**什么是进程：**进程内的顺序执行流。</p>
<ul>
<li>线程将执行的概念与流程抽象分离开来。</li>
<li>每个线程<strong>共享进程的资源</strong>（如地址空间、全局变量、文件描述符等），<strong>但有自己的栈、程序计数器和寄存器</strong>。线程是CPU调度和执行的基本单位。</li>
</ul>
</li>
<li><p><strong>线程控制块ThreadControlBlock TCB：</strong></p>
</li>
</ul>
<h4 id="线程优点："><a href="#线程优点：" class="headerlink" title="线程优点："></a>线程优点：</h4><ol>
<li>创建、销毁、切换用时短</li>
</ol>
<h4 id="进程的作用："><a href="#进程的作用：" class="headerlink" title="进程的作用："></a>进程的作用：</h4><ul>
<li>响应性:多个活动可以同时完成。他们可以加快申请速度。</li>
<li>资源共享:线程共享它们所属进程的内存和资源。</li>
<li>经济:它们很容易被创造和摧毁。</li>
<li>MP(多处理器)体系结构的利用:它们在多CPU系统上很有用。</li>
</ul>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ul>
<li><strong>三种实现方式：</strong><ul>
<li>用户级：<ul>
<li>线程完全处于用户空间中，内核不知道有该线程存在</li>
<li>线程管理由用户级线程库完成</li>
<li>线程切换不需要内核权限，用户级线程创建和管理速度快。</li>
<li>问题:如果内核是单线程的，那么任何执行阻塞系统调用的用户级线程都将导致整个进程阻塞。</li>
</ul>
</li>
<li>内核级<ul>
<li>内核支持:内核在内核空间中执行线程创建、调度和管理。</li>
<li>没有线程库，内核提供API</li>
<li>内核维护进程和线程的上下文</li>
<li>线程切换需要内核</li>
<li>线程是Scheduler的基本单位。</li>
<li>缺点是：资源花销太大</li>
</ul>
</li>
<li>混合实现</li>
</ul>
</li>
</ul>
<h4 id="线程和进程的对比："><a href="#线程和进程的对比：" class="headerlink" title="线程和进程的对比："></a>线程和进程的对比：</h4><ol>
<li><p><strong>资源分配</strong>：进程是资源分配的基本单位，拥有独立的资源记录，而线程与资源分配无关，属于进程的一部分。</p>
</li>
<li><p><strong>地址空间</strong>：不同进程拥有独立的虚拟地址空间，同一进程中的多个线程共享同一地址空间。</p>
</li>
<li><p><strong>切换开销</strong>：进程切换涉及资源指针保存和地址空间转换，开销较大，而线程切换不涉及这些问题，开销较小。</p>
</li>
<li><p><strong>调度机制</strong>：进程调度由操作系统内核完成，线程调度可以由操作系统内核或用户程序完成。</p>
</li>
<li><p><strong>创建能力</strong>：进程可以动态创建进程，线程也可以由进程创建其他线程。</p>
</li>
<li><p><strong>生命周期</strong>：进程和线程都有创建、执行和消亡的生命周期。</p>
</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><blockquote>
<p>三个问题作为引言：</p>
<ol>
<li>一个进程如何传递消息给另一个进程</li>
<li>资源共享<ol>
<li>如何确保两个或多个进程在进行关键活动时不会相互妨碍。(互斥)</li>
</ol>
</li>
<li>进程间协作<ol>
<li>当存在依赖关系时，进行适当的排序(同步)。</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h4><p>对多个相关进程在执行次序上的协调,用于保证这种关系的相应机制称为进程同步。</p>
<p>相互合作的一组并发进程在一些关键点上可能需要互相等待与互通消息,相互制约的等待与互通消息称为进程同步。</p>
<ul>
<li><p>进程间竞争 race：</p>
<ul>
<li>防止竞争的出现关键在于禁止多个进程同时读写共享数据。</li>
</ul>
</li>
<li><p>互斥 Mutual exclusion</p>
</li>
</ul>
<p>确保一个进程使用某共享资源时，其他进程无法访问这个变量</p>
<ul>
<li>临界区<ul>
<li>临界资源：一次仅允许一个进程访问的资源称之为临界资源</li>
<li>程序中访问临界资源的部分称为临界区域或临界段</li>
</ul>
</li>
</ul>
<h4 id="临界区四个性质要求："><a href="#临界区四个性质要求：" class="headerlink" title="临界区四个性质要求："></a>临界区四个性质要求：</h4><ul>
<li>没有两个进程同时处于临界区域</li>
<li>没有对cpu的速度或数量做任何假设</li>
<li>任何在临界区域外运行的进程都不能阻塞另一个进程</li>
<li>没有进程必须永远等待才能进入其临界区域</li>
</ul>
<h4 id="实现互斥"><a href="#实现互斥" class="headerlink" title="实现互斥"></a>实现互斥</h4><ol>
<li><p><strong>禁用中断</strong></p>
<ul>
<li>在进入临界区后禁用所有中断，并在离开临界区之前重新启用它们。</li>
<li>禁用中断后，不会发生时钟中断，因为CPU只有在时钟中断时才可以进行进程的切换，禁用后就不会发生切换了。</li>
</ul>
</li>
<li><p><strong>锁变量</strong>：使用一个简单的锁变量来表示临界区是否被占用。</p>
<ul>
<li>进程在进入临界区之前检查该变量：</li>
<li>如果它没有被锁定，则设置它为锁定状态并进入临界区；</li>
<li>如果被锁定，则等待。该方法存在忙等待问题，并且容易出现竞争条件。</li>
</ul>
</li>
<li><p><strong>严格的轮换法</strong>：用于两个进程之间的互斥。进程交替进入临界区。一个进程完成后设置一个标志，允许另一个进程进入临界区。</p>
<ul>
<li>缺点是会导致不必要的等待，即使一个进程不需要进入临界区，另一个进程也必须等待。</li>
<li>这个方法可能违反性质3——任何在<strong>临界区域外的进程不能</strong>阻塞另一个进程<ul>
<li>由于进程必须严格交替进入它们的临界区，因此想要连续两次进入其临界区的进程将被阻塞，直到另一个进程决定进入(和离开)其临界区。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Peterson算法</strong>：使用两个标志和一个“turn”变量来确保互斥。</p>
<ul>
<li><pre><code class="language-c">// 伪代码
boolean flag[2] = &#123;false, false&#125;;
int turn = 0;

process 0:
while (true) &#123;
    flag[0] = true;
    turn = 1;
    while (flag[1] &amp;&amp; turn == 1);
    critical_section();
    flag[0] = false;
&#125;

process 1:
while (true) &#123;
    flag[1] = true;
    turn = 0;
    while (flag[0] &amp;&amp; turn == 0);
    critical_section();
    flag[1] = false;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **Test-and-Set Lock (TSL)**：</span><br><span class="line"></span><br><span class="line">   - 硬件必须支持一个特殊的指令，tsl，它在一个原子动作中做两件事:</span><br><span class="line">     TSL register，flag</span><br><span class="line">     - copy a value in memory (flag) to a CPU register</span><br><span class="line">     - set flag to 1.</span><br><span class="line"></span><br><span class="line">   - ```c</span><br><span class="line">     // 伪代码</span><br><span class="line">     boolean lock = false;</span><br><span class="line">     </span><br><span class="line">     boolean TestAndSet(boolean *target) &#123;</span><br><span class="line">         boolean rv = *target;</span><br><span class="line">         *target = true;</span><br><span class="line">         return rv;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     while (true) &#123;</span><br><span class="line">         while (TestAndSet(&amp;lock));</span><br><span class="line">         critical_section();</span><br><span class="line">         lock = false;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Sleep and Wakeup</strong>：当一个进程不能进入临界区时，它会进入sleep状态（其实就是blocked），直到另一个进程唤醒wake up它。该方法避免了忙等待问题。</p>
</li>
<li><p><strong>互斥导致的忙等待</strong></p>
<ol>
<li>Peterson算法 和 TSL方法 会造成忙等待，即执行入口代码的进程会一直处于一个紧循环的状态，消耗CPU周期，一般般测试某些条件是否成立，直到为真</li>
<li>如果使用简单的优先级调度来调度进程，着忙等待会导致优先级反转的问题</li>
</ol>
</li>
</ol>
<h2 id="CH3—"><a href="#CH3—" class="headerlink" title="CH3—"></a>CH3—</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>操作系统的文件资源管理MainMemmroy</p>
<p>主存空间的分配问题</p>
<p>操作系统管理虚存：Address Space：地址空间</p>
<h2 id="CH4—"><a href="#CH4—" class="headerlink" title="CH4—"></a>CH4—</h2><p>文件系统 File System</p>
<p>directory 目录</p>
<p>目录树</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241444.png" alt="image-20240313110501430" style="zoom:50%;" /> 

<p>UNIX中目录树唯一</p>
<p>两种查找方式：</p>
<p>绝对路径：从根目录开始</p>
<p>相对路径：从当前目录开始</p>
<h2 id="CH5—Input-Output"><a href="#CH5—Input-Output" class="headerlink" title="CH5—Input&#x2F;Output"></a>CH5—Input&#x2F;Output</h2><p>I&#x2F;O sub-system 子系统去管理I&#x2F;O设备</p>
<p>设备驱动程序 device driver</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cm7pquzia0020r8v28wic7cjk" data-title="操作系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机专业课/软件项目管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.267Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">软件项目管理期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="软件项目管理期末复习"><a href="#软件项目管理期末复习" class="headerlink" title="软件项目管理期末复习"></a>软件项目管理期末复习</h1><blockquote>
<p>IT 项目管理，项目题量是以前的 1.5 倍，但是平均难度下降的<br>以前 IT 项目管理没有选择判断题，今年第一次出现<br>小题（30 分）<br>选择题：单选题，多选题<br>判断题：判断正确或者错误<br>这两块一共占了 30 分，往年是没有小题的</p>
<p>第三部分是概念题<br>概念题就是要解释我们项目管理的一些核心概念（20 分）<br>有一些章节和图片的核心概念，特别重点的内容大家要关注</p>
<p>简答题（20 分）<br>分析一下这里面某一个计划是干什么用的，某一个管理方法可以用来解决什么问题，或者说在处理人力和成本问题中的挑战是什么啊，用什么技术来处理啊</p>
<p>计算题（30 分）<br>计算题考点相对固定<br>时间管理</p>
<p>成本管理<br>课堂上反复跟大家强调的净值处理</p>
<p>重点要放在前面的七章<br>尤其是范围管理、时间管理、成本管理<br>这三大要素里面的主干知识点，占比很高<br>前面的一些综合管理考小题可能性大<br>概念题和其他的分析题只要言之有理，基本都会酌情给分<br>让我们继续复习一下主干内容(◕_◕)&#x2F;✏️，考完机器学习就可以复习软件项目管理了</p>
</blockquote>
<h2 id="CH1-项目管理概述"><a href="#CH1-项目管理概述" class="headerlink" title="CH1 项目管理概述"></a>CH1 项目管理概述</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul>
<li>体会到对更好的项目管理(尤其是 IT 项目管理)不断增长的需求。</li>
<li>解释什么是项目,列举 IT 项目的例子,列出项目的各种特征,并千描述项目管理的约束。</li>
<li>定义项目管理,并论述项目管理框架中的关键因素,包括牙项目干系人、项目管理的知识领域、常用工具和技术,以及项目成功的要素。</li>
<li>讨论项目管理、项目集管理和项目组合管理之间的关系,以及它们中的每一个对企业成功的重要性。</li>
<li>通过描述项目经理做些什么、需要什么技能、理想的技能给组合(能力三角形)和 IT 项目经理的就业机会来了解项目经理的角色。</li>
</ul>
<h3 id="项目管理的四个层次"><a href="#项目管理的四个层次" class="headerlink" title="项目管理的四个层次"></a>项目管理的四个层次</h3><ul>
<li>将复杂的简单化：分解，通过分治的思想，将大问题拆分为小问题进而解决</li>
<li>将简单的量化：临界值，设定好解决问题的值域，谋求在有限空间中寻求解</li>
<li>将量化的专业化：规律，通过量化的指标寻找出解决问题的共通的规律，在其他场景应用</li>
<li>将专业的模板化：框架与模板，将共通的规律抽象成一套解决问题的方法，使上一个解决方案在新的场景里可以简易修改好进行复现与应用</li>
</ul>
<h3 id="为什么要进行项目管理"><a href="#为什么要进行项目管理" class="headerlink" title="为什么要进行项目管理"></a>为什么要进行项目管理</h3><ul>
<li>对财务、物质和人力资源的严格控制</li>
<li>改善客户关系</li>
<li>更短的开发时间</li>
<li>降低成本</li>
<li>更高的质量和可靠性</li>
<li>提高利润率</li>
<li>提高生产力</li>
<li>更好的内部协调</li>
</ul>
<h3 id="什么是项目"><a href="#什么是项目" class="headerlink" title="什么是项目"></a>什么是项目</h3><ul>
<li><strong>项目 project</strong>是为创造独特产品、服务或结果的临时努力</li>
</ul>
<h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><ul>
<li>项目有一个独特的目的</li>
<li>项目是临时性的</li>
<li>项目推动变革并创造价值</li>
<li>项目是通过不断完善细节而逐步开展的</li>
<li>项目需要来自不同领域的资源</li>
<li>项目具有不确定性</li>
</ul>
<h4 id="项目约束"><a href="#项目约束" class="headerlink" title="项目约束"></a>项目约束</h4><p>范围目标、时间目标和成本目标被称为项目管理的&#96;三项约束(triple constraint)&#96;&#96;</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113150457588.png" alt="image-20241113150457588"> </p>
<h4 id="项目管理和程序管理"><a href="#项目管理和程序管理" class="headerlink" title="项目管理和程序管理"></a>项目管理和程序管理</h4><p><strong>项目经理</strong>：项目经理与项目发起人、项目团队和其他参与项目工作的人员一起工作，以实现项目目标</p>
<p><strong>项目</strong>：以协调的方式管理的一组相关项目，以获得单独管理它们无法获得的利益和控制</p>
<h3 id="什么是项目管理"><a href="#什么是项目管理" class="headerlink" title="什么是项目管理"></a>什么是项目管理</h3><p><code>项目管理(project management)</code>是”将知识、技能、工具和技术应用于项目活动,以满<br>足项目要求。”项目经理不应该局限于试图满足项目具体的范围目标、时间目标、成本目<br>标和质量目标,同时也必须协调整个过程,以满足项目活动相关者或干系人的需求或期望。</p>
<ul>
<li>一个项目开发的过程总是不断努力去满足三重约束（项目范围、时间和成本目标），并促进整个过程，以满足项目利益相关者的需求和期望</li>
</ul>
<h4 id="项目利益相关者"><a href="#项目利益相关者" class="headerlink" title="项目利益相关者"></a>项目利益相关者</h4><p>项目利益相关者<code>(stakeholder)</code>是指参与项目活动或受项目活动影响的个人、群体或组织,包括项目发起人、项目团队、支持人员、客户、用户、供应商,甚至项目的反对者。这些干系人通常有完全不同的需求和期望。房屋建设项目是常见的功项目例子,其中可能包含以下干系人</p>
<ul>
<li>项目发起人为潜在的新业主</li>
<li>银行、融资机构</li>
<li>项目经理是承包商</li>
<li>项目团队包括建筑工人、电工、木匠等</li>
<li>支持人员包括买方的雇主</li>
<li>消费者</li>
<li>使用者</li>
<li>材料供应商</li>
<li>反对者：附近的邻居，因为噪音干扰</li>
</ul>
<h4 id="项目管理知识领域"><a href="#项目管理知识领域" class="headerlink" title="项目管理知识领域"></a>项目管理知识领域</h4><p><code>项目管理知识领域(projectmanagementknowledgeareas)</code>描述了项领目经理必须具备的关键<br>能力。图 1-2 的中间部分展示了项目管理的 10 大知识领域。这 10 大知识领域的简要描述如下:</p>
<ol>
<li><p><strong>项目整合管理</strong>：包括定义和管理成功完成项目所需的全部工作。</p>
<ol>
<li>制定项目章程</li>
<li>制定项目管理计划</li>
<li>指导和管理项目工作</li>
<li>实施整体变更控制</li>
<li>结束项目或阶段</li>
<li>监控项目工作</li>
</ol>
</li>
<li><p><strong>项目范围管理</strong>：包括定义和管理成功完成项目所需的全部工作。</p>
<ol>
<li>规划范围管理</li>
<li>收集需求</li>
<li>定义范围</li>
<li>创建工作分解结构</li>
<li>确认范围</li>
<li>控制范围</li>
</ol>
</li>
<li><p><strong>项目进度管理(也称项目时间管理)</strong>：包括估计完成工作所需的时间,制定可接受的项目进度,并确保项目按时完成。</p>
<ol>
<li>规划进度管理</li>
<li>定义活动</li>
<li>排列活动顺序</li>
<li>估算活动资源</li>
<li>估算活动持续时间</li>
<li>制定进度计划</li>
<li>控制进度</li>
</ol>
</li>
<li><p><strong>项目成本管理</strong>：包括项目预算的制定和管理。</p>
<ol>
<li>规划成本管理</li>
<li>估算成本</li>
<li>制定预算</li>
</ol>
</li>
<li><p><strong>项目质量管</strong>：确保项目满足各方明确表述的或隐含的需求。</p>
<ol>
<li>规划质量管理</li>
<li>质量保证</li>
<li>控制质量</li>
</ol>
</li>
<li><p><strong>项目人力资源管理</strong>：有效利用与项目有关的人员和物质资源。</p>
<ol>
<li>规划人力资源管理</li>
<li>组建项目团队</li>
<li>建设项目团队</li>
<li>管理项目团队</li>
</ol>
</li>
<li><p><strong>项目沟通管理</strong>：包括生成、收集、传播和存储项目信息。</p>
<ol>
<li>规划沟通管理</li>
<li>管理沟通</li>
<li>控制沟通</li>
</ol>
</li>
<li><p><strong>项目风险管理</strong>：包括识别、分析和应对与项目相关的风险。</p>
<ol>
<li>规划风险管理</li>
<li>识别风险</li>
<li>定性风险分析</li>
<li>定量风险分析</li>
<li>规划风险应对</li>
<li>控制风险</li>
</ol>
</li>
<li><p><strong>项目采购管理</strong>：包括从实施项目的组织外部获取或采购产品和服务。</p>
<ol>
<li>规划采购</li>
<li>实施采购</li>
<li>结束采购</li>
<li>控制采购</li>
</ol>
</li>
<li><p><strong>项目利益相关者管理</strong>：包括识别和分析干系人的需求,同时在项目的整个生命周期中管理和<br>控制干系人参与项目决策和执行。</p>
<ol>
<li>识别利益相关者</li>
<li>规划利益相关者管理</li>
<li>管理利益相关者参与</li>
<li>控制利益相关者参与</li>
</ol>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113163112719.png" alt="image-20241113163112719"> </p>
<p>项目整合管理是一个影响所有其他知识领域并受其影响的总体功能</p>
<h4 id="项目管理工具和技术"><a href="#项目管理工具和技术" class="headerlink" title="项目管理工具和技术"></a>项目管理工具和技术</h4><p><code>项目管理工具和技术(Project management tools and techniques)</code>帮助项目经理及其团队在所有 10 个知识领域开展工作。例如,一些流行的时间管理工具和技术包括:甘特图(Gantt charts)、项目网络图(project network diagrams)和关键路径分析(critical path analysis)。下表列出了一些知识领域常用的工具和技术。</p>
<p>一些具体的内容包括</p>
<ul>
<li><p>cs项目章程、范围语句和WBS（范围）。</p>
<ul>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113162710748.png" alt="image-20241113162710748"></li>
</ul>
</li>
<li><p>甘特图、网络图、关键路径分析、关键链调度（时间）。</p>
<ul>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113162727435.png" alt="image-20241113162727435"></li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113162754583.png" alt="image-20241113162754583"></li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113162807742.png" alt="image-20241113162807742"></li>
</ul>
</li>
<li><p>成本估算和收益价值管理（成本）。</p>
</li>
</ul>
<h4 id="项目成功"><a href="#项目成功" class="headerlink" title="项目成功"></a>项目成功</h4><ul>
<li>项目达到了范围目标、时间目标和成本目标。</li>
<li>项目使客户&#x2F;发起人满意。</li>
<li>项目的结果达到了主要目标,比如赚取或节省了一定数目目的钱,带来了较好的投资回报率,或者仅仅是让项目发起人感到满意。</li>
</ul>
<h3 id="项目集和项目组合管理"><a href="#项目集和项目组合管理" class="headerlink" title="项目集和项目组合管理"></a>项目集和项目组合管理</h3><h4 id="项目集"><a href="#项目集" class="headerlink" title="项目集"></a>项目集</h4><ul>
<li><code>项目集(program)</code>是指”以协调的方式管理一组相互关联的项目、子项目集和项目集<br>活动,以便获得分别管理所无法获得的利益。”，例如基础设施项目集包括体的项目,例如提供更多的无线网络连接、升级硬件和软件、增强计算机安全、开发或维护公司的 IT 标准等</li>
<li>项目集≠超大项目，</li>
<li><code>项目集经理(program manager)</code>对领导项目集内项目的项目经理进行领导并指明方向。</li>
<li>作为<strong>项目组合管理</strong>的一部分，组织将项目和项目作为一个投资组合，进行分组和管理</li>
</ul>
<h4 id="项目组合管理"><a href="#项目组合管理" class="headerlink" title="项目组合管理"></a>项目组合管理</h4><p>在许多组织中,项目经理还会实行一种新兴的业务战略,即本书所称的<code>项目组合管理(project portfolio management)</code>或<code>组合管理(portfolio management)</code>。在这种战略中,组织将项目以及项目集组合并进行管理,使其作为一个投资组合,从而促足成整个企业的成功。</p>
<p><strong>项目管理与项目投资组合管理的比较</strong></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113163643684.png" alt="image-20241113163643684"> </p>
<h3 id="组织项目管理"><a href="#组织项目管理" class="headerlink" title="组织项目管理"></a>组织项目管理</h3><p>通过将项目分组到项目组合中,组织可以更好地将它们的项目与战略目标联系起来。项目组合管理还可以通过聘用、培训和留住员工来支持投资组合中的项目,进而帮助组织更好地管理其人力资源。简单来说有三种基本的 IT 项目组合种类：</p>
<ul>
<li>冒险类项目:该类项目有助于改变目前的业务经营。例如,在”开篇案例”描述的大型零售连锁示例中,或许存在着一个 IT 项目–在商店里提供 kiosks,同样也在网上提供,这样顾客和供应商就能够迅速提供有关产品和服务的反馈。这个项目能通过与顾客和供应商发展更亲密的关系来转变业务经营。</li>
<li>成长类项目:这类项目能帮助公司提高收入。例如,一家公司或许有一个新的 IT 项目–在其公司网站上用一种新的语言(中文或者日文)提供信息。这种项目能够促进他们在使用该语言的国家增加收入。</li>
<li>核心类项目:它是指为了商业活动的正常运营而必须要完成的那些项目。例如,为新员工提供计算机的 IT 项目就属于此类。</li>
</ul>
<h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><p>最佳实践(best practice)<br>魅力型(charismatic)<br>DevOps (DevOps)<br>企业项目管理软件(enterprise project management software)<br>道德(ethics)<br>甘特图(Gantt chart)<br>交互型(interactional)<br>放任型(laissez-faire)<br>领导者(leader)<br>经理(manager)<br>超大型项目(megaproject)<br>组织项目管理(organizational project management)<br>项目组合(portfolio)<br>项目集(program)<br>项目集经理(programmanager)<br>项目(project)<br>项目和项目组合管理软件(projectand portfolio management software)<br>项目管理(projectmanagement)<br>项目管理协会(ProjectManagement Institute(PMI))<br>项目管理知识领域(projectmanagementknowledge areas)<br>项目管理办公室(ProjectManagementOffice,PMO)<br>项目管理专业人士(ProjectManagement Professional, PMP)<br>项目管理工具和技术(projectmanagement tools and techniques)<br>项目经理(projectmanager)<br>项目组合管理或组合管理(project portfolio management or portfolio management)<br>项目发起人(projectsponsor)<br>干系人(servant leader stakeholders)<br>交易型(transactional)<br>变革型(transformational)<br>三项约束(tripleconstraint)</p>
<h2 id="CH2-项目管理和IT-Information-Technology-环境"><a href="#CH2-项目管理和IT-Information-Technology-环境" class="headerlink" title="CH2 项目管理和IT(Information Technology)环境"></a>CH2 项目管理和IT(Information Technology)环境</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><ul>
<li>定义项目管理的系统观以及如何将项目管理应用于 IT 项目中。</li>
<li>总结组织的相关要点,包括组织的 4 个框架、组织结构和组织文化。</li>
<li>解释为什么项目干系人管理和企业高层的承诺对项目成功至关重要。</li>
<li>区分项目生命周期和产品生命周期之间的异同。</li>
<li>讨论 IT 项目的独特性和多样性。</li>
<li>总结影响 IT 项目管理的最新趋势,包括全球化、外包、虚拟团队和敏捷项目管理。</li>
</ul>
<h3 id="项目管理的系统馆"><a href="#项目管理的系统馆" class="headerlink" title="项目管理的系统馆"></a>项目管理的系统馆</h3><p>为了高效处理复杂的情况，项目经理必须以整体的观点认识项目，并且处理该项目是如何与更大组织进行联系的，<code>系统思考 system thinking</code>描述了这种整体的观点。</p>
<h4 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h4><ul>
<li><code>系统方法systems approach</code>：用于描述一种在解决复杂问题时所需的整体性的和分析性的方法。</li>
<li><code>系统哲学systems philosophy</code>：是将事情作为系统考虑的整体模型</li>
<li><code>系统分析systems analysis</code>：是一种解决问题的方法，该方法需要定义系统的范围，将其分解为各个组成部分，然后识别和估计其问题、机会、约束和需求。</li>
<li><code>系统管理systems management</code>：解决与系统开发、维护和变更相关的业务、技术和组织问题。</li>
</ul>
<h4 id="系统管理的三球模型"><a href="#系统管理的三球模型" class="headerlink" title="系统管理的三球模型"></a>系统管理的三球模型</h4><p><img src="https://chiichen.github.io/assets/image-nf2FXbka.png" alt="Alt text"></p>
<h3 id="了解组织"><a href="#了解组织" class="headerlink" title="了解组织"></a>了解组织</h3><h4 id="组织的四个框架"><a href="#组织的四个框架" class="headerlink" title="组织的四个框架"></a>组织的四个框架</h4><ul>
<li><code>结构框架 structural frame</code>：用来解决组织结构的问题（通常由组织结构图表示），它关注不同部门的角色和职责，以满足高层管理者设定的目标和政策。</li>
<li><code>人力资源框架 human resources frame</code>：达到组织需求和个人需求之间的平衡</li>
<li><code>政治框架 political frame</code>：处理组织和个人的政治问题。组织中的<strong>组织politics</strong>表现为团队或个人对权力、资源和领导地位的竞争。</li>
<li><code>符号框架 symbolic frame</code>：关注符号和含义。在符号框架中，可以对应在一个组织中所发生的任何事件，重要的不是表面发生了什么，而是意味着什么。</li>
</ul>
<h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><ul>
<li>职能型组织结构：职能部门经理向首席执行官汇报工作</li>
<li>项目型组织结构：项目经理向首席执行官汇报工作</li>
<li>矩阵型组织结构：功能结构和项目结构之间的中间地带；人员经常向两个或两个以上的老板报告；结构可以是弱、平衡或强矩阵</li>
</ul>
<p><img src="https://chiichen.github.io/assets/image-2-B9OYFMHS.png" alt="Alt text"></p>
<h4 id="组织文化"><a href="#组织文化" class="headerlink" title="组织文化"></a>组织文化</h4><ul>
<li><code>组织文化(organizational culture)</code>是一系列共享的假设、价值观和行为,它们刻画了组织的职能。</li>
</ul>
<h3 id="项目生命周期和产品生命周期"><a href="#项目生命周期和产品生命周期" class="headerlink" title="项目生命周期和产品生命周期"></a>项目生命周期和产品生命周期</h3><h4 id="项目生命周期"><a href="#项目生命周期" class="headerlink" title="项目生命周期"></a>项目生命周期</h4><p><code>项目生命周期(project life cycle)</code>是一系列项目阶段的集合,项目从人开始到完成需要经历所有这些阶段。</p>
<p>可交付物是作为项目的一部分而生产或提供的产品或服务</p>
<p>通用的项目生命周期,包括以下 4 个阶段:</p>
<ol>
<li>开始项目</li>
<li>组织与准备</li>
<li>执行项目工作</li>
<li>结束项目</li>
</ol>
<blockquote>
<p>这些阶段不应与第 3 章描述的项目管理过程组的<strong>启动、规划、执行、监控和收尾</strong>相混淆。</p>
</blockquote>
<p>一般情况下,项目生命周期定义了每个阶段需要开展的工作、可交付成果、各个阶段在什么时间需要什么样的人员,以及管理层将如何控制和核准每个阶段中的工作。<code>可交付成果(deliverable)</code>是作为项目的一部分生产或提供的产品或服务,例如技术报告、培训课程、硬件或软件代码段。(有关可交付成果的详细内容,请参见第 5 章。)</p>
<h4 id="产品生命周期"><a href="#产品生命周期" class="headerlink" title="产品生命周期"></a>产品生命周期</h4><p><code>产品生命周期(product life cycle)</code>是<strong>定义、开发和交付产品</strong>的过程。通常,开发一个产品(例如一个新的信息系统、一辆汽车、一栋建筑物等)涉及许多项目。</p>
<blockquote>
<p>相关信息</p>
<p>软件开发项目是 IT 项目的一个子项目。许多 IT 项目涉及研究与分析,然后后采购和安装新的硬件和软件,附带少量必要的软件开发,或者完全不需要软件开发。但是,一些项目包括少量的软件更改,以增强现有软件的性能或将一个应用程序与另一个应用程序进行整合。其他的一些项目则涉及大量的软件开发工作。因此 IT 项目 ≠ 软件开发项目</p>
</blockquote>
<p><code>系统开发生命周期(Systems Development Life Cycle, SDLC)</code>是一个用来描述开发信息系统不同阶段的框架。《项目管理知识体系指南(第 6 版)》简要介绍了 5 种产品或开发生命周期。在确定使用哪种生命周期时,有两个因素很重要–需求的变化程度我和有用成果的交付频率。例如,对于需求变化程度低且交付频率低的产品,预测型生命周期更适适用。</p>
<h4 id="五种产品-开发生命周期"><a href="#五种产品-开发生命周期" class="headerlink" title="五种产品&#x2F;开发生命周期"></a>五种产品&#x2F;开发生命周期</h4><ul>
<li><code>预测型生命周期 predictive-life cycle</code>:在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。PMI 将预测型生命周期也称为瀑布型生命周期</li>
<li><code>选代型生命周期 Iterative life cycle</code>:通常在项目生命周期的早期确定项目范围,但时间及成本估算将随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品,以增加产品的功能。当需求变化程度高而交付频率低 I 时,迭代型生命周期最适用。</li>
<li><code>增量型生命周期 incremental build model-life cycle</code>:通过在预定的时间区间内渐进增加产品功能的一系列迭代来产出可交付成果。最后一次迭代完成后,可交付成果才是完整的。当需求变化程度低而交付频率高时,增量型生命周期最适用。</li>
<li><code>适应型生命周期 adaptive software development(ASD)-life cycle</code>:干系人在迭代开始之前定义并批准详细范围,并在每次迭代结束时产生可用的产品。PMI 将适应型生命周期也称为敏捷型或不变更驱动型生命周期。当需求变化程度高且交付频率高时,适应型生命周期最适用。</li>
<li><code>混合型生命周期</code>:根据工作的特性混合使用多种生命周期。例如,像每周进度报告这样的可交付成果具有低需求变化和低交付频率,而像软件马功能这样的可交付成果,就具有高需求变化和高交付频率。</li>
</ul>
<p>目前,许多组织在产品开发中使用混合型生命周期。其中,将预测型生命周期的步骤用作总体方法,以协调适应型生命周期的详细步骤。预测型生命周期和适应型生命周期不是互斥的选择。</p>
<p>预测型生命周期也不仅仅是 SDLC 的瀑布模型一种，还有螺旋模型、原型模型和快速应用开发(RapidApplication Development,RAD)模型。</p>
<h4 id="项目阶段和管理评审"><a href="#项目阶段和管理评审" class="headerlink" title="项目阶段和管理评审"></a>项目阶段和管理评审</h4><p>管理评审又称为<code>阶段出口(phaseexit)</code>、<code>阶段关口评审(phasegatereview)</code>或<code>终止点(kill point)</code>。这一活动对于保持项目在正确的轨道上和确定项目是否应该继续、重新定位或终止非常重要。</p>
<h3 id="关键术语-1"><a href="#关键术语-1" class="headerlink" title="关键术语"></a>关键术语</h3><p>敏捷(agile)<br>倡导者(champion)<br>可交付成果(deliverable)<br>执行指导委员会(executivesteering committee)<br>职能型组织结构(functionalorganizational structure)<br>人力资源(HR)框架(humanresources,HRframe)<br>IT 治理(IT governance)<br>看板(Kanban)<br>终止点(kill point)<br>矩阵型组织结构(matrix organizational structure)<br>项目组织结构(Projectorganizational structure)<br>Scrum (Scrum)<br>结构框架(structural frame)<br>符号框架(symbolic frame)<br>系统分析(systemsanalysis)<br>系统方法(systems approach)<br>离岸外包(offshoring)<br>组织文化(organizational culture)<br>外包(outsourcing)<br>阶段关口评审&#x2F;阶段出口(phasegatereview phase exit)<br>政治框架(political frame)<br>政治(politics)<br>预测型生命周期(predictivelifecycle)<br>产品生命周期(product lifecycle)<br>项目生命周期(projectlifecycle)<br>系统开发生命周期(SDLC)(systemsdevelopment life cycle, SDLC)<br>系统管理(systemsmanagement)<br>系统哲学(systemsphilosophy)<br>系统思考(systems thinking)<br>虚拟团队(virtual team)</p>
<h2 id="CH3-项目管理过程组"><a href="#CH3-项目管理过程组" class="headerlink" title="CH3 项目管理过程组"></a>CH3 项目管理过程组</h2><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><ul>
<li>描述 5 大项目管理过程组及其各自典型的活动水平,以及它们之间的相互关系。</li>
<li>了解项目管理过程组与项目管理知识领域之间的相互关系。</li>
<li>讨论组织如何开发 IT 项目管理方法论来满足自身的需要。</li>
<li>回顾一个组织应用项目管理过程组管理 IT 项目的案例研究,描述每个过程组的输出,了解有效的项目启动、项目计划、项目执行、项目监控和项目收尾是如何促进项目成功的。</li>
<li>回顾应用敏捷方法管理的同一个 IT 项目的案例研究,并比比较敏捷方法和预测方法之间的关键区别。</li>
<li>描述为每个过程组创建文档的几个模板</li>
</ul>
<h3 id="项目管理过程组"><a href="#项目管理过程组" class="headerlink" title="项目管理过程组"></a>项目管理过程组</h3><p><code>过程(process)</code>是指朝向特定结果的一系列行动。<code>项目管理过程组(project management process groups)</code>包括启动活动、执行活动、执行活动、监控活动和以收尾活动。</p>
<ul>
<li>启动过程(initiating processes)</li>
<li>计划过程(planning processes)</li>
<li>执行过程(executing processes)</li>
<li>监控过程(monitoring and controlling processes)</li>
<li>收尾过程(closing processes)</li>
</ul>
<blockquote>
<p>过程组不是独立的</p>
<p>这些过程组并非是相互独立的。例如,项目经理必须确保!监控过程贯穿整个项目。也就是说,在项目中监控过程可能与启动、计划、执行和收尾过程同时发生,启动和计划过程可以与执行过程等其他任何过程组同时发生。</p>
</blockquote>
<h4 id="将流程组映射到知识领域"><a href="#将流程组映射到知识领域" class="headerlink" title="将流程组映射到知识领域"></a>将流程组映射到知识领域</h4><p>您可以使用PMBOKR指南，第五版，将每个PM流程组的主要活动映射到10个知识领域。请注意，在规划流程组下都有来自每个知识领域的活动</p>
<p><img src="D:\Blog\source_posts\校内课程学习笔记\计算机专业课\软件项目管理.assets\image-20241118153749769.png" alt="image-20241118153749769"> </p>
<h3 id="开发IT项目管理方法论"><a href="#开发IT项目管理方法论" class="headerlink" title="开发IT项目管理方法论"></a>开发IT项目管理方法论</h3><ul>
<li><p>《项目管理知识体系指南》作为项目管理方法论的基础</p>
</li>
<li><p>受控环境下的项目管理(PRINCE2):最初是为 IT 项目开发的。1996 年,英国政府商务办公室(OCG)为 IT 项目开发出这一项目管理的通用方法论。它是英国约定俗成的标准,被 50 多个国家采用(</p>
<p>详情请登录<a target="_blank" rel="noopener" href="http://www.prince2.comopen/">www.prince2.comopen</a> in new window</p>
<p>)。PRINCE2定义了45个独立的子过程,并将它们分成8个过程组,如下所示:</p>
<ol>
<li>项目发起</li>
<li>项目规划</li>
<li>项目启动</li>
<li>项目指导</li>
<li>项目阶段控制</li>
<li>产品交付管理</li>
<li>阶段界限管理</li>
<li>项目收尾</li>
</ol>
</li>
<li><p>敏捷方法:如第 2 章所述,敏捷是一种自适应的产品生命周其期,适用于可交付成果具有高变更度、高交付频率的项目。”敏捷”这个术语经常被用来描述各种各样的方法。比如,《敏捷实践指南》(Agile Practice Guide)描述了了敏捷和作为精益管理<br>子集的看板管理。(有关”精益”(lean)的内容将在第 8 章中详细介绍)。一些流行的敏捷方法包括 Scrum,Scrumban(Scrum 和 Kanban 的结合),极限开发(ExtremeProgramming,XP),特征驱动开发(Feature Driven Development, FDD)等等</p>
</li>
<li><p>统一软件开发过程(RUP)框架(Rational Unified Process framework):RUP 是由 IBM 创建的迭代软件开发过程,它关注团队生产力,并使所有团队成员能够向组织交付最佳的软件。RUP 专家 Bill Cottrell 说:”RUP 包含了行业标准的管理和技术方法,目的是提供一个软件开发过程,这个过程尤其适用于创建并维护基于组件的软件系统解决方案。”</p>
</li>
<li><p>六西格玛方法论。很多组织采用六西格玛方法论做项目。项目质量专家的工作促进了今天六西格玛原则的发展。六西格玛项目经常采用的两两种方法论分别为:DMAIC,即定义(Define)、度量(Measure)、分析(Analysis)、改进(Improve)、控制(Control),用于改进已有业务流程;DMADV,即定义(Define)、度量(Measure)、分析(Analysis)、设计(Design)、证实(Verify),用于创造新产品品或过程设计,以取得可预测且无缺陷的业绩。(了解更多关于六西格玛的信息,请参见第 8 章。)</p>
</li>
</ul>
<h3 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h3><h4 id="项目的预启动及启动"><a href="#项目的预启动及启动" class="headerlink" title="项目的预启动及启动"></a>项目的预启动及启动</h4><ul>
<li>在项目管理中,启动包括识别和开始一个新的项目。组织在选择项目时要深思熟虑,要确保是为了一个恰当的原因而启动了一个恰当的项目。一个重要的项目取得中等的或较小的成功,要优于在一个不重要的项目上取得的巨大成功。</li>
<li>在决定开展哪些项目时,战略规划应当作为功项目决策的基础。组织的战略规划表明了该组织的愿景、使命、目的、目标和组织的战略。一个组织启动 IT 项目可能有多个原因,但最重要的原因是是支持业务目标。</li>
</ul>
<h4 id="项目预启动任务"><a href="#项目预启动任务" class="headerlink" title="项目预启动任务"></a>项目预启动任务</h4><p>在正式启动项目之前,为项目奠定良好的基础非常重要。为此,高级经理经常先完成一些任务,称为预启动任务,主要包括以下任务:</p>
<ul>
<li>决定项目的范围、时间和成本的约束因素。</li>
<li>确定项目发起人。</li>
<li>选择项目经理。</li>
<li>为项目开发一个商业论证。</li>
<li>与项目经理开会讨论项目管理过程及预期成果。</li>
<li>确定项目是否应该分成两个或两个以上的小项目。</li>
<li>决定项目是否需要被分为两个或更多子项目。</li>
</ul>
<h4 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h4><p>项目启动的主要任务是识别所有项目干系人,并制定项目章程。这一任务的主要输出包括:项目章程和干系人登记册。</p>
<h4 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h4><blockquote>
<p>计划过程组有许多潜在的输出,每个知识领域都包括在内。</p>
</blockquote>
<p>项目计划的主要目的是指导项目的执行。第 5~12 章从每个知识领域的角度再次描述了项目计划过程。</p>
<h4 id="项目监控"><a href="#项目监控" class="headerlink" title="项目监控"></a>项目监控</h4><p>项目监控是一个针对项目目标来衡量进展情况、监测计划的偏离情况,并采取纠正措施使项目进展与计划相匹配的过程。监控贯穿整个项目周期,滋步及所有 10 大项目管理知识领域。与监控过程组相关的模板在本章中的后面列出。</p>
<h4 id="项目收尾"><a href="#项目收尾" class="headerlink" title="项目收尾"></a>项目收尾</h4><p>收尾过程包括获得干系人和客户对最终产品和服务的验收,并使得项目或项目阶段有序地结束。它包括核实所有的成果是否已经完成,而且通常包括一个最终的项目报告和展示。</p>
<h3 id="关键术语-2"><a href="#关键术语-2" class="headerlink" title="关键术语"></a>关键术语</h3><p>敏捷方法(agilemethods)<br>工件(artifact)<br>每日例会(dailyScrum)<br>执行过程(executing processes)<br>启动过程(initiating processes)<br>启动会议(kick-off meeting)<br>方法论(methodology)<br>监控过程(monitoring and controlling processes)<br>计划过程(planning processes)<br>过程(process)<br>产品待办事项(productbacklog)<br>产品负责人(productowner)<br>项目管理过程组(projectmanagementprocess groups)<br>受控环境下的项目管理(PRINCE2)(PRojects IN Controlled Environments, PRINCE2)<br>统一软件开发(RUP)框架(Rational Unified Process (RUP) framework)<br>燃尽图(burndownchart)<br>收尾过程(closing processes)<br>敏捷教练(ScrumMaster)<br>Scrum 团队或开发团队(Scrum team or development team)<br>六西格玛(方法论)(SixSigmamethodologies)<br>冲刺(sprint)<br>冲刺待办事项(sprintbacklog)<br>冲刺计划会(sprintplanning session)<br>冲刺回顾会(sprintretrospectives)<br>冲刺评审会(sprintreviews)<br>干系人登记册(stakeholderregister)<br>标准(standard)<br>用户故事(userstories)</p>
<h2 id="CH4-项目一体化-整合-管理"><a href="#CH4-项目一体化-整合-管理" class="headerlink" title="CH4 项目一体化(整合)管理"></a>CH4 项目一体化(整合)管理</h2><blockquote>
<p>关键：</p>
<ol>
<li>项目集成管理的过程</li>
<li>选择 IT 项目的计划过程</li>
<li>选择项目的 5 个常用技术</li>
<li>NPV 的计算步骤</li>
<li>综合变更控制的 3 个主要目标</li>
<li>在组织中，设立变更请求书的意义？如何建立一个好的变更请求管理过程</li>
</ol>
</blockquote>
<h3 id="项目整合管理是什么"><a href="#项目整合管理是什么" class="headerlink" title="项目整合管理是什么"></a>项目整合管理是什么</h3><ul>
<li><code>项目整合管理(project integration management)</code>包括在整个项目生命周期中协调所有其他的项目管理知识领域。这种整合确保了项目的所有因素能在正确的时间集合在一起,从而成功地完成项目。根据《项目管理知识体系指南(第 6 版)》所述,项目整合管理包括 <strong>7 个主要过程</strong>：<ol>
<li><strong>制定项目章程</strong>。即与项目干系人一起合作,制定正式批准项目的文件——章程。</li>
<li><strong>制定项目管理计划</strong>。即协调项目计划的所有组成部分,并把它它们整合为一份一致的连贯的文件——项目管理计划。</li>
<li><strong>指导与管理项目工作</strong>。即通过实施项目管理计划中的活动,来执行项目管理计划。</li>
<li><strong>管理项目知识</strong>。即使用现有知识并生成新知识,以实现项目目标,并帮助组织学习。</li>
<li><strong>监控项目工作</strong>。即监督项目工作是否符合项目的绩效目标。</li>
<li><strong>实施整体变更控制</strong>。即在整个项目生命周期中识别、评估和管理变更。</li>
<li><strong>项目或阶段收尾</strong>。即终结项目或阶段的所有活动,从而而正式结束项目或阶段。</li>
</ol>
</li>
<li>项目经理要协调项目资源、统领全局，解决项目冲突，而完成这些任务的首要方法就是项目整合管理</li>
<li>良好的项目整合管理对满足干系人的需求至关重要。项目整合管理包括界面管理。<code>界面管理(interface management)</code>涉及明确和管理众多项目元素相互作用的交界点。界面管理的主要工具是沟通和关系。随着项目参与人员的增加,交界点的数量可能会呈现指数级增长。</li>
<li>项目整合管理是在整个组织的环境中进行的,而不仅仅发生在一个特定项目的内部。项目经理必须将项目的工作和组织的运营整合起来</li>
</ul>
<h3 id="战略计划和项目选择"><a href="#战略计划和项目选择" class="headerlink" title="战略计划和项目选择"></a>战略计划和项目选择</h3><h4 id="战略计划"><a href="#战略计划" class="headerlink" title="战略计划"></a>战略计划</h4><ul>
<li><code>战略计划(strategic planning)</code>包括:通过分析组织的优势和劣势来确定长期目标;研究商业环境中的机遇和威胁;预测未来趋势;预测对新产品和服务的需求。战略计划借助重要的信息来帮助组织识别并选择潜在的项目。</li>
</ul>
<blockquote>
<p>SWOT 分析法</p>
<p>SWOT 分析法(SWOT analysis),即分析</p>
<ul>
<li><strong>优势(strength)</strong></li>
<li><strong>劣势(weakness)</strong></li>
<li><strong>机会(opportunity)</strong></li>
<li><strong>威胁(thrent)</strong></li>
</ul>
<p>这是战略计划中使用的一种工具。有时会使用如图 4-1 所示的思维导图(mid mapping)来进行 SWOT 分析</p>
</blockquote>
<p><img src="https://chiichen.github.io/assets/image-1-BWHxsC76.png" alt="图4-1 思维导图——识别潜在项目的SWOT分析"></p>
<h4 id="识别潜在项目"><a href="#识别潜在项目" class="headerlink" title="识别潜在项目"></a>识别潜在项目</h4><p>除了使用 SWOT 分析法之外,组织还应该遵循具体的项目选选择过程。图 4-2 是选择 IT 项目计划过程的 4 个阶段,注意这个模型的层次结构以及每个阶段性的结果。顺序是从上到下</p>
<p><img src="https://chiichen.github.io/assets/image-BNZmYJNr.png" alt="图4-2 选择IT项目的计划过程"></p>
<h4 id="选择项目的方式"><a href="#选择项目的方式" class="headerlink" title="选择项目的方式"></a>选择项目的方式</h4><p>组织将识别众多有潜力的项目作为战略计划过程的一部分,组织需要缩小有潜力的项目列表,直到只剩下那些可使利益最大化的项目。通常,他们依赖经验丰富的项目经理来协助做出项目决策。有五种常见的方法：</p>
<p>-聚焦于重要的组织需求 -将 IT 项目分类 -进行净现值或其他财务分析 -使用加权评分模型 -实施平衡计分卡</p>
<h4 id="聚焦于重要的组织需求"><a href="#聚焦于重要的组织需求" class="headerlink" title="聚焦于重要的组织需求"></a>聚焦于重要的组织需求</h4><p>一种根据重要的组织需求来选择项目的方法是,首先确定它们是否符合 3 个重要的标准:需求、资金和意愿。</p>
<p>在组织中,人们需要实施这个项目吗?组织有决心和能力提供充足的资金来执行项目吗?有没有很强的决心来保证项目的成功</p>
<h4 id="在IT项目进行分类"><a href="#在IT项目进行分类" class="headerlink" title="在IT项目进行分类"></a>在IT项目进行分类</h4><p>另一个选择项目的方法是依据多种分类进行决策,例如功项目的动机、时间窗口以及一般优先权:</p>
<ul>
<li>项目的动机一般是对一个问题、一项机遇或一个个指令的反应。</li>
<li>IT 项目的另一种分类依据是基于时间的,即完成一个项目所需要的时间以及项目必须完成的截止时间。例如,某些潜在项目必须在一个特定的时间段内完成。如果到规定的日期还未完成,那它们便不再是有效的项目。</li>
<li>组织还可以根据当前的业务环境将不同的 IT 项目分为高、中、低不同的优先级别。例如,如果快速减少运营成本非常关键,则最有助于减少运营成成本的项目将被赋予最高优先级</li>
</ul>
<h3 id="进行财务分析"><a href="#进行财务分析" class="headerlink" title="进行财务分析"></a>进行财务分析</h3><h4 id="净现值分析"><a href="#净现值分析" class="headerlink" title="净现值分析"></a>净现值分析</h4><ul>
<li><p><code>净现值NPV</code>分析是一种计算项目预期净货币收益&#x2F;损失的方法，该方法将当前时间点之间的所有未来预期现金流入和流出都折现计算。</p>
</li>
<li><p>计算净现值时，必须假设一个特定的折现率。<strong>折现率</strong>是用于折现现金流的比率，不仅考虑金钱的时间价值，还考虑未来现金流的风险或不确定性。未来现金流的不确定性越大，折现率越高。折现率也称为<code>资本化率</code>或<code>资本机会成本</code>。</p>
<p><img src="https://chiichen.github.io/assets/image-2-CbDiMR36.png" alt="图4-3 净现值算例"></p>
</li>
<li><p>净现值可以通过以下步骤计算：</p>
<ol>
<li><p>为项目生命周期及项目产品确定预期成本和收益。</p>
</li>
<li><p>确定折现率</p>
</li>
<li><p>计算净现值</p>
</li>
<li><p>计算净现值公式：$NPV &#x3D; \sum_{t&#x3D;0…n} \frac{A_t}{(1+r)^t}$</p>
<p><em>t</em>表示现金流的年份</p>
<p><em>n</em>表示现金流的最后一年</p>
<p><em>A</em>表示每年的现金流</p>
<p><em>r</em>表示折现率</p>
<p>$\frac{1}{(1+r)^t}$表示折现因子 discount-factor</p>
</li>
</ol>
</li>
</ul>
<h4 id="折现回报率"><a href="#折现回报率" class="headerlink" title="折现回报率"></a>折现回报率</h4><ul>
<li><p><code>投资回报率 return-oninvestment,ROI</code>是项目的收益减去成本后，再除以成本的结果。<em>ROI</em>通常以百分比的形式出现，可正可负。</p>
<p>ROI计算公式：$ROI &#x3D; \frac{(折现收益总额 - 折现成本总额)}{折现成本}$</p>
<p>ROI越高越好，意味着成本越低而收益越高</p>
</li>
<li><p><code>要求回报率</code>：可接受的最低投资回报率，因为一个正常的组织对于项目都会有投资回报率的要求，项目需要有收益。</p>
</li>
<li><p><code>内部收益率</code>：通过找出导致项目净现值为零的折现率来确定</p>
</li>
</ul>
<h4 id="投资回报期分析"><a href="#投资回报期分析" class="headerlink" title="投资回报期分析"></a>投资回报期分析</h4><ul>
<li><p><code>投资回报期 payback-period</code>是以净现金流的方式，将项目中的总投资全部收回的时间。即成本回收</p>
<p><img src="https://chiichen.github.io/assets/image-4-8yfIZ-bp.png" alt="图4-5 绘制JWD咨询项目的回收期图"></p>
</li>
</ul>
<h3 id="使用加权评分模型"><a href="#使用加权评分模型" class="headerlink" title="使用加权评分模型"></a>使用加权评分模型</h3><p><code>加权评分模型 weighted-scoring-model</code>是一种基于多种标准进行<em>J</em>项目选择的系统方法这些标准可能包括多种要素，例如，满足重要的组织需求；解决问题、把握机会以及应对指令的能力；完成项目所需的时间；项目的总体优先级；项目的预期财务表现等。创建加权评分模型的基本步骤如下：</p>
<ol>
<li>确认对项目选择过程非常重要的标准。开发这些标准并达成一致可能很耗费时间，对于IT项目而言，一些可能的标准包括：<ol>
<li>支持核心业务目标或战略</li>
<li>有强势的内部发起人</li>
<li>有强大的客户支持</li>
<li>使用符合实际的技术</li>
<li>在一年内或更短的时间内实施</li>
<li>提供正的的净现值</li>
<li>在低风险水平下实现范围，时间和成本目标</li>
</ol>
</li>
<li>根据重要性为每项标准赋予一定的权重。确定权重同样需要协商并达成一致。你也可以基于百分比来分配权重，所有标准的权重总和必须 1 为 100%。然后，你可以针对每项标准对每个项目进行评分（如 0~100），这些分数代表了功项目符合每项标准的程度。</li>
</ol>
<h4 id="实施平衡计分卡"><a href="#实施平衡计分卡" class="headerlink" title="实施平衡计分卡"></a>实施平衡计分卡</h4><p><code>平衡计分卡 balanced-score-card</code>是一种战略计划和管理系统，可以使组织的业务活动与战略保持一致，改善沟通并根据战略目标监控绩效。</p>
<h3 id="制定项目章程"><a href="#制定项目章程" class="headerlink" title="制定项目章程"></a>制定项目章程</h3><p><code>项目章程 project-charter</code>是一份正式确认项目存在的文件，并对项目的目标与管理提供指导利用组织的资源来完成项目。</p>
<p>理想情况下，制定项目章程的过程中主要需要的输入为：</p>
<ul>
<li><p><strong>项目工作说明书</strong>：工作说明书是说明将要由项目组完成的产品或服务。</p>
<ul>
<li>项目的业务需求说明</li>
<li>产品&#x2F;服务的要求和特点的综述</li>
<li>组织信息</li>
</ul>
</li>
<li><p><strong>商业论证</strong>：上一章所述，许多项目都会用商业论证来证明项目的投资合理性。项目章程中包括的商业论证信息有：</p>
<ul>
<li>项目目标</li>
<li>高层要求、时间和成本目标</li>
</ul>
</li>
<li><p><strong>收益管理计划</strong>：收益管理计划描述了项目收益的交付时间和交付方式，以及如何对项目收益进行管理。收益管理计划涵盖的主题包括目标收益，战略一致，实现收益的时间计划，收益的持有人，度量标准，假设和风险。</p>
</li>
<li><p><strong>合同</strong>：如果根据外部客户的合同来实施项目，那么这份协议应该包含创建一个完整的项目章程所需要的大部分信息。有些人可能用合同&#x2F;协议来代替章程，然而，大部分合同的语言晦涩且多变。</p>
</li>
<li><p><strong>企业环境因素</strong>：包括政府&#x2F;行业的相关标准、组织的基础设施以及市场条件。</p>
</li>
<li><p><strong>组织过程资产 organization-process-assets</strong>：包括正式与非正式的计划、政策、程序、指南、信息系统…</p>
</li>
</ul>
<h3 id="制定项目管理计划"><a href="#制定项目管理计划" class="headerlink" title="制定项目管理计划"></a>制定项目管理计划</h3><ul>
<li><code>项目管理计划 project-management-plan</code>是用于协调所有项目计划文件，并帮助指导项目的执行与控制的文件。</li>
<li>制定项目管理计划阶段的主要输入：<ul>
<li>项目章程</li>
<li>其他过程的输出</li>
<li>企业环境因素</li>
<li>组织过程资产</li>
</ul>
</li>
</ul>
<h4 id="项目管理计划"><a href="#项目管理计划" class="headerlink" title="项目管理计划"></a>项目管理计划</h4><p>大部分项目管理计划存在：</p>
<ul>
<li>项目介绍&#x2F;概述</li>
<li>项目组织</li>
<li>项目管理和技术流程</li>
<li>项目待执行的工作（范围）</li>
<li>项目进度和预算信息</li>
<li>其他项目计划文件</li>
</ul>
<h3 id="监控项目工作"><a href="#监控项目工作" class="headerlink" title="监控项目工作"></a>监控项目工作</h3><ul>
<li>监控项目的工作包括<ul>
<li>收集、衡量、发布绩效信息</li>
<li>评估度量、分析趋势以确定可以进行哪些过程优化</li>
</ul>
</li>
<li>项目管理计划为识别和控制项目变更提供了<code>基准 baseline</code>——是被记录下来的一个起点、一组度量或一组观察值，能够用于将来的比较。</li>
<li>监控项目工作的重要输出包括：<ul>
<li>变更请求：<ul>
<li>纠正措施：改善项目绩效</li>
<li>预防措施：减少与项目风险相关的负面影响</li>
<li>缺陷补救措施：使有缺陷的可交付成果符合要求</li>
</ul>
</li>
<li>工作绩效报告</li>
</ul>
</li>
</ul>
<h3 id="实施整体变更控制"><a href="#实施整体变更控制" class="headerlink" title="实施整体变更控制"></a>实施整体变更控制</h3><p><code>整体变更控制 intergrated-change-control</code>涉及在整个项目生命周期中识别、评估和管理变更。整体变更控制的3个主要目标是：</p>
<ul>
<li>控制可能造成变更的因素以确保变更都是有益的</li>
<li>确认变更已发送</li>
<li>管理发生的变更</li>
</ul>
<h4 id="变更控制系统"><a href="#变更控制系统" class="headerlink" title="变更控制系统"></a>变更控制系统</h4><ul>
<li><strong>变更控制系统</strong>是一个正式的、文档化的过程，描述了正式的项目文件可能何时以及如何变更、授权进行变更的人员、变更所需的文书工作，以及项目将使用的任何自动&#x2F;手动的跟踪系统<ul>
<li>变更委员会</li>
<li>配置管理</li>
<li>沟通变更的过程</li>
</ul>
</li>
<li><strong>变更控制委员会 ChangeControl-Board CCB</strong>是负责批准或拒绝项目变更的正式团队</li>
<li><strong>配置管理</strong>确保项目产品的描述是正确的、完整的。</li>
</ul>
<h3 id="项目或阶段收尾"><a href="#项目或阶段收尾" class="headerlink" title="项目或阶段收尾"></a>项目或阶段收尾</h3><p>项目整合管理最后一步</p>
<p>为了终止一个项目，必须将所有活动收尾，并将已完成&#x2F;取消的工作移交给相应的人员。</p>
<p><strong>输入为</strong>：</p>
<ul>
<li>项目章程</li>
<li>项目管理计划</li>
<li>项目文件</li>
<li>验收的可交付成果</li>
<li>商业文件</li>
<li>协议</li>
<li>采购文件</li>
<li>组织过程资产</li>
</ul>
<h3 id="关键术语-3"><a href="#关键术语-3" class="headerlink" title="关键术语"></a>关键术语</h3><p>平衡计分卡(balancedscorecard)<br>基准(baseline)<br>资本化率(capitalization rate)<br>现金流(cashflow)<br>变更控制委员会(CCB)(changecontrolboard,CCB)<br>变更控制系统(changecontrolsystem)<br>配置管理(configuration management)<br>资本成本(cost of capital)<br>指令(directives)<br>折现因子(discountfactor)<br>折现率(discountrate)<br>显性知识(explicitknowledge)<br>整体变更控制(integrated change control)<br>界面管理(interface management)<br>内部收益率(IRR)(internal rate of return,IRR)<br>思维导图(mindmapping)<br>净现值(NPV)分析(net present value(NPV)analysis)<br>机会(opportunities)<br>资本机会成本(opportunity costof capital)<br>组织过程资产(organizational process assets)<br>投资回收期(payback period)<br>问题(problems)<br>项目章程(projectcharter)<br>项目整合管理(project integration management)<br>项目管理计划(project managementplan)<br>要求回报率(required rate of return)<br>投资回报率(ROI)(return on investment,ROI)<br>战略计划(strategic planning)<br>SWOT 分析法(SWOT analysis)<br>隐性知识(tacit knowledge)<br>加权评分模型(weighted scoring model)</p>
<h2 id="CH5-项目范围管理"><a href="#CH5-项目范围管理" class="headerlink" title="CH5 项目范围管理"></a>CH5 项目范围管理</h2><h3 id="什么是项目范围管理"><a href="#什么是项目范围管理" class="headerlink" title="什么是项目范围管理"></a>什么是项目范围管理</h3><ul>
<li>项目管理最重要也最难做的一项工作就是定义项目范围。<ul>
<li>范围是指：开发项目产品所涉及的所有工作和用于开发产品的所有过程。</li>
</ul>
</li>
<li>项目范围管理 project-scope-management是指定界定和控制项目中应包括什么和不包括什么所涉及的过程。</li>
</ul>
<h4 id="项目范围管理包含的6个主要过程："><a href="#项目范围管理包含的6个主要过程：" class="headerlink" title="项目范围管理包含的6个主要过程："></a>项目范围管理包含的6个主要过程：</h4><ol>
<li><strong>计划范围管理</strong>：确定如何管理项目的范围和需求</li>
<li><strong>收集需求</strong>：定义并记录产品的特点和功能以及开发这些产品的过程</li>
<li><strong>定义范围</strong>：审查范围管理计划、项目章程、需求文档和组织过程资产来制定一份范围说明书，并且在需求的扩展和变更请求得到批准时增加更多的信息</li>
<li><strong>创建工作分解结构</strong>：将主要的项目可交付成果分解成更细小和更易管理的组成部分</li>
<li><strong>确认范围</strong>：项目可交付成果的正式验收。</li>
<li><strong>控制范围</strong>：对项目范围的变化进行控制。范围变更经常影响团队实现项目的时间目标和成本目标的能力</li>
</ol>
<h3 id="计划范围管理"><a href="#计划范围管理" class="headerlink" title="计划范围管理"></a>计划范围管理</h3><h2 id="CH6-项目时间管理"><a href="#CH6-项目时间管理" class="headerlink" title="CH6 项目时间管理"></a>CH6 项目时间管理</h2><h2 id="CH7-项目成本管理"><a href="#CH7-项目成本管理" class="headerlink" title="CH7 项目成本管理"></a>CH7 项目成本管理</h2><blockquote>
<p><strong>成本</strong>：为实现一个特定目标而牺牲或放弃的资源。在本章的例子中使用美元货币数量)来衡量。</p>
<p><strong>成本超支 overrun</strong>：实际成本超过估计的额外百分比或金额</p>
</blockquote>
<h3 id="为什么需要进行项目成本的管理"><a href="#为什么需要进行项目成本的管理" class="headerlink" title="为什么需要进行项目成本的管理"></a>为什么需要进行项目成本的管理</h3><h4 id="项目0-成本管理是什么："><a href="#项目0-成本管理是什么：" class="headerlink" title="项目0.成本管理是什么："></a>项目0.成本管理是什么：</h4><ul>
<li><code>项目成本管理(project cost management)</code>包含用来确保项目团队在批准的预算内完成一个项目的必要过程。请注意这个定义中的两个关键短语:”一个项目”和”批准的预算”。项目经理必须确保他们的项目有恰当的定义、准确的进度计划和成本估算,并有他们参与批准通过的、切合实际的预算。</li>
</ul>
<h4 id="项目成本管理的四个过程："><a href="#项目成本管理的四个过程：" class="headerlink" title="项目成本管理的四个过程："></a>项目成本管理的四个过程：</h4><ol>
<li><strong>计划成本管理</strong>：包括确定用于计划、执行、控制项目成本的政策、程序和文档。这个过程主要输出成本管理计划。</li>
<li><strong>估算成本</strong>：包括完成项目所需资源的近似或估算成本。成本估算过程的主要输出是<strong>活动的成本估算、估算的基础和更新的项目文档。</strong></li>
<li><strong>制定预算</strong>：括将整体成本估算配置到各单项工作，以建立一个衡量绩效的基线。成本预算过程的主要输出是成本基线、项目资金需求和更新的项目文档。</li>
<li><strong>控制成本</strong>：包括控制项目预算的变更。在成本控制过程的主要输出是工作绩效信息、成本预测、请求变更、更新的项目管理计划、更新的项目文档和更新的组织过程资产。</li>
</ol>
<h3 id="成本管理的基本原理"><a href="#成本管理的基本原理" class="headerlink" title="成本管理的基本原理"></a>成本管理的基本原理</h3><ul>
<li><code>利润(profits)</code>：是收入减去支出。</li>
<li><code>利润率(profitmargin)</code>：是利润与收入的比率。</li>
<li><code>生命周期成本(life cycle costing)</code>：是对整个项目生命周期成本的全局认识。例如项目开发一年，运行十年，那么就要对整个生命周期(十年)的成本和收益进行估算</li>
<li><code>现金流分析(cash flow analysis)</code>：是确定项目的年度成本估算和收益以及由此产生的年度现金流的一种方法。项目经理必须进行现金流分析,以确定净现值。</li>
<li><code>有形成本或收益(tangible costs or benefits)</code>和<code>无形成本或收益(intangible costs or benefits)</code>分别表示<strong>容易和不容易</strong>用现金来衡量的成本与收益。</li>
<li><code>直接成本(direct costs)</code>是指那些与创造项目产品和服务直接相关的成本。比如员工的工资</li>
<li><code>间接成本(indirect costs)</code>与项目的产品或服务不直接相关,但它们与项目的工作绩效间接相关。例如,水电费、纸巾等必需品</li>
<li><code>沉没成本(sunk cost)</code>是过去已经花费的钱,它就像沉船一样消失了,永远也打捞不起来。在决定投资或继续哪些项目时,<strong>不应该考虑沉没成本</strong>。例如,赌徒因为输了钱而一直赌博就是因为没有忘记沉没成本</li>
<li><code>学习曲线理论(learning curve theory)</code>指出,当许多产品被重复生产时,这些产品的单位成本会随着产品数量的增加而有规律地降低。例如,假定 Surveyvor Pro 项目可能会生产</li>
<li><code>储备金(reserves)</code>包含于成本估算中,是为了消减由于未来难以预测而带来的成本风险而预先留出的资金。<ul>
<li><code>应急储备金(contingency reserves)</code>为一些可以部分预计的未来情况(有时称为<code>已知的未知(known unknowns)</code>)做准备,它包含在项目成本基准中。例如,如果一个组织知道 IT 人员的流动率为 20%,它就应该准备应急储备金来支付 IT 人员的招聘和培训成本。</li>
<li><code>管理储备金(management reserves)</code>考虑到未来不可预测的情况(有时称为<code>未知的未知(unknownunknowns)</code>)。例如,如果一个项目经理生病了两周,或者一个重要的供应商</li>
</ul>
</li>
</ul>
<h3 id="计划成本管理"><a href="#计划成本管理" class="headerlink" title="计划成本管理"></a>计划成本管理</h3><blockquote>
<p>项目成本管理的第一步是规划整个项目生命周期中的费用如何管理</p>
</blockquote>
<h4 id="成本管理计划的基本信息"><a href="#成本管理计划的基本信息" class="headerlink" title="成本管理计划的基本信息"></a>成本管理计划的基本信息</h4><ul>
<li><code>精确度</code>：活动成本估算通常有舍入准则，例如舍入到最近的100美元。</li>
<li><code>测量单位</code>：应定义各单位采用的成本测量</li>
<li><code>组织程序链接</code>：许多组织用于项目成本账户的**工作分解结构(WBS)**的组成结构，被称为控制账户(CA)。每个控制账户通常被分配一个唯一的代码，并用此链接到组织的会计系统。项目团队必须正确理解和使用这些代码。</li>
<li><code>控制临界值</code>：类似于进度偏差，成本通常有一定量的可允许的偏差区间。在区间内，无需采取行动，例如基准成本的±10%</li>
<li><code>绩效测量规则</code>：如果项目采用在本章的后面描述的挣值管理系统(EVM),成本管理计划将定义测量的规则，比如实际成本将被追踪到什么水平的细节。</li>
<li><code>报告模板</code>：描述项目成本报告的格式和频度。</li>
<li><code>过程描述</code>：描述如何执行所有的成本管理流程。</li>
</ul>
<h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><h4 id="成本估算类型："><a href="#成本估算类型：" class="headerlink" title="成本估算类型："></a>成本估算类型：</h4><ul>
<li><p><code>粗粒度估算(ROM)(Rough Order of Magnitude ROM estimate)</code>：提供了一个项目的粗略估算。ROM 估算也可以称作近似估算、猜算、虚估或泛算。准确度通常为-50%~+100%；</p>
</li>
<li><p><code>预算估算(budgetary estimate)</code>是用来分配资金到组织中的预算。许多组织制定至少未来两年的预算。预算在项目完成前 1<del>2 年做出。预算的准确度一般是-10%</del>+25%；</p>
</li>
<li><p><code>确定性估算(definitive estimate)</code>提供了对项目成本的准确估算。确定性估算用于做出许多需要准确估算的采购决策和估算最终的项目成本。</p>
</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241109112541888.png" alt="image-20241109112541888"></p>
<h4 id="成本估算的工具和技术"><a href="#成本估算的工具和技术" class="headerlink" title="成本估算的工具和技术"></a>成本估算的工具和技术</h4><ul>
<li><code>专家判断</code>：</li>
<li><code>类比估算(analogous estimates)</code>，也称为<code>自上而下估算(top-down estimates)</code>，使用以前类似项目的实际成本作为估算当前项目成本的依据。不准确</li>
<li><code>自下而上估算(bottom-up estimates)</code>，估算单个工作项或者活动的成本，相加得到整体估算。准确但是花费时间长，成本高</li>
<li><code>三点估算(three-point estimates)</code>包括估算项目最可能的、最乐观的和最悲观的成本。你可以使用第 6 章中描述的 PERT 加权平均公式,或者使用第 11 章中描述的蒙特卡罗模拟来进行成本估算。</li>
<li><code>参数估算(parametric estimating)</code>使用数学模型中的项目特征(参数)来估算项目成本。例如,参数化模型可能根据项目使用的编程语言、程序员的专业水平、所涉及数据的大小和复杂性等为软件开发项目提供每行代码 50 美元的估算。</li>
<li><code>质量成本</code></li>
<li><code>项目管理估算软件</code></li>
<li><code>供应商报价分析和储备分析</code></li>
<li>实践中，混合使用以上方法可以提供最佳的成本估算。</li>
</ul>
<h2 id="CH8-项目质量管理"><a href="#CH8-项目质量管理" class="headerlink" title="CH8 项目质量管理"></a>CH8 项目质量管理</h2><h2 id="CH9-项目资源管理"><a href="#CH9-项目资源管理" class="headerlink" title="CH9 项目资源管理"></a>CH9 项目资源管理</h2><h2 id="CH10-项目沟通管理"><a href="#CH10-项目沟通管理" class="headerlink" title="CH10 项目沟通管理"></a>CH10 项目沟通管理</h2><h2 id="CH11-项目风险管理"><a href="#CH11-项目风险管理" class="headerlink" title="CH11 项目风险管理"></a>CH11 项目风险管理</h2><h2 id="CH12-项目采购管理"><a href="#CH12-项目采购管理" class="headerlink" title="CH12 项目采购管理"></a>CH12 项目采购管理</h2><h2 id="CH13-项目干系人管理"><a href="#CH13-项目干系人管理" class="headerlink" title="CH13 项目干系人管理"></a>CH13 项目干系人管理</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" data-id="cm7pquzj2007rr8v23ngf5ruc" data-title="软件项目管理期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-课程学习/计算机专业课/软件架构设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.265Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">软件架构设计期末复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="软件架构设计期末复习"><a href="#软件架构设计期末复习" class="headerlink" title="软件架构设计期末复习"></a>软件架构设计期末复习</h1><h2 id="CH1-软件架构"><a href="#CH1-软件架构" class="headerlink" title="CH1 软件架构"></a>CH1 <strong>软件架构</strong></h2><h3 id="Software-Architecture-软件-架构"><a href="#Software-Architecture-软件-架构" class="headerlink" title="Software Architecture 软件&amp;架构"></a>Software Architecture 软件&amp;架构</h3><p><strong>什么是软件体系结构</strong>：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系</p>
<p>以及两者的属性。</p>
<h3 id="架构即即是一种软件结构"><a href="#架构即即是一种软件结构" class="headerlink" title="架构即即是一种软件结构"></a>架构即即是一种软件结构</h3><p>一系列的元素由某种关系串联起来构成一个结构 <strong>structure</strong></p>
<p>一个软件系统由许多的<strong>structure</strong>构成（单一个结构无法称之为架构）</p>
<h3 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture 架构"></a>Architecture <strong>架构</strong></h3><h4 id="三个重要特征："><a href="#三个重要特征：" class="headerlink" title="三个重要特征："></a>三个重要特征：</h4><ol>
<li><strong>Module 模块</strong></li>
</ol>
<ul>
<li>一些结构将系统划分为实现单元，我们称之为模块。</li>
<li>模块被分配具体的计算责任，并且是编程团队工作任务的基础。</li>
<li>在大型项目中，这些元素（模块）会被进一步划分，以便分配给子团队。</li>
</ul>
<ol start="2">
<li><strong>Component and Connector 组件和连接器</strong></li>
</ol>
<ul>
<li><p>其他结构关注于元素在<strong>运行时</strong>相互交互的方式，以执行系统的功能。这种运行时结构称之为<strong>Component and Connector (C&amp;C)结构 组件和连接器</strong>。</p>
</li>
<li><p>实际应用中，组件基本上都是运行时实体</p>
</li>
</ul>
<ol start="3">
<li><strong>Allocation</strong> <strong>分配</strong></li>
</ol>
<ul>
<li><p>分配结构描述了从软件结构到系统环境的映射</p>
</li>
<li><p>分配结构描述了软件系统的物理部署和资源管理，通常涉及如何将模块和组件映射到硬件资源上。这有助于优化系统性能和资源利用。</p>
</li>
</ul>
<h4 id="什么样的结构具有架构性"><a href="#什么样的结构具有架构性" class="headerlink" title="什么样的结构具有架构性"></a>什么样的结构具有架构性</h4><ul>
<li><p>可以实现对系统和系统性质的推理的<strong>结构structure</strong>是<strong>成结构性Architectural</strong></p>
</li>
<li><p>这种推理应该是关于系统的某个对利益相关者来说重要的属性。</p>
</li>
<li><p>这些属性包括：</p>
<ul>
<li>系统实现的功能</li>
<li>系统在面对故障时的可用性</li>
<li>对系统进行特定更改的难度</li>
<li>系统对用户请求的响应速度</li>
<li>其他许多属性。</li>
</ul>
</li>
</ul>
<h3 id="任何系统都有一个软件架构"><a href="#任何系统都有一个软件架构" class="headerlink" title="任何系统都有一个软件架构"></a>任何系统都有一个软件架构</h3><p>但是这个架构可能没有为任何人所知。</p>
<ul>
<li><p>可能所有设计该系统的人都已经离开。</p>
</li>
<li><p>可能文档已经消失（或从未产生）。</p>
</li>
<li><p>可能源代码已丢失（或从未提交）。</p>
</li>
</ul>
<h3 id="架构是一种抽象"><a href="#架构是一种抽象" class="headerlink" title="架构是一种抽象"></a>架构是一种抽象</h3><blockquote>
<p>它着眼于系统的整体结构和关键特性，而<strong>不涉及细节实现</strong>。</p>
</blockquote>
<ul>
<li><p>架构会省略元素的某些信息————在推理系统方面没有作用的信息</p>
</li>
<li><p>架构抽象允许我们从元素如何排列、如何交互、如何组合这一角度来看待系统。</p>
</li>
<li><p>对于系统的抽象有利于我们降低最终系统架构的复杂性</p>
</li>
</ul>
<h3 id="架构包含行为"><a href="#架构包含行为" class="headerlink" title="架构包含行为"></a>架构包含行为</h3><blockquote>
<p>行为可以体现系统内元素的关系</p>
</blockquote>
<ul>
<li><p>在能够用于推理系统的前提下，每个元素的行为都是架构的一部分。</p>
</li>
<li><p>这种行为体现了元素之间的相互作用，这显然是架构定义的一部分。</p>
</li>
</ul>
<h3 id="结构与视图"><a href="#结构与视图" class="headerlink" title="结构与视图"></a>结构与视图</h3><ul>
<li><p>视图是由系统设计参与者编写和读取的一组连贯的架构元素的表示</p>
</li>
<li><p>结构是元素本身的集合，本身存在于硬件或软件中</p>
</li>
<li><p>总结即是：视图是结构的一种表示形式</p>
</li>
<li><p>架构师设计结构时，使用文档记录结构的视图 views</p>
</li>
</ul>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><ul>
<li><p>模块结构代表着系统是如何通过一系列代码或数据单元进行结构化的</p>
</li>
<li><p>在任何模块结构中，元素都是某种类系的模块(如：class、layer、或者仅是功能的划分等等，都是实现单元)</p>
</li>
</ul>
<h3 id="组件和连接器结构"><a href="#组件和连接器结构" class="headerlink" title="组件和连接器结构"></a>组件和连接器结构</h3><ul>
<li><p>C&amp;C结构代表着系统是如何由一系列具有运行时行为（组件）和交互（连接器）的元素进行结构化的。</p>
</li>
<li><p><strong>元素element</strong>是运行时的<strong>组件component</strong>，如services、peers、clients、servers等</p>
</li>
<li><p><strong>连接器Connector</strong>是组件<strong>组件 component</strong>间相互交流的工具，如调用-返回、进程同步操作符、管道或其他操作符</p>
</li>
</ul>
<blockquote>
<p>MapReduce 映射&amp;归约</p>
<p><strong>Map 阶段</strong>：</p>
<ul>
<li>数据切割为小的数据块</li>
</ul>
<p><strong>Shuffle和Sort阶段</strong>：</p>
<ul>
<li>Map阶段的输出会传递给Shuffle和Sort阶段。这个阶段将相同的key聚集在一起并排序，为Reduce阶段做准备。</li>
</ul>
<p><strong>Reduce阶段</strong>：</p>
<ul>
<li>Reduce阶段会接收来自Shuffle和Sort的中间结果，进行归约计算。Reduce任务会对相同的key的&lt;key, value&gt;对进行处理，将它们合并成最终结果。</li>
<li>举例：在单词统计中，Reduce阶段会将相同单词的1相加，计算出每个单词的总次数，如 &lt;单词, 总次数&gt; 。</li>
</ul>
</blockquote>
<h3 id="分配结构"><a href="#分配结构" class="headerlink" title="分配结构"></a>分配结构</h3><ul>
<li><p>展示软件系统的逻辑设计与物理资源之间的映射关系。描述了如何将系统的模块和组件分配到硬件、网络和组织等实际环境中，从而体现系统的物理部署方式、资源使用和依赖关系。</p>
</li>
<li><p>主要关注系统如何与外部环境交互以及如何利用资源</p>
</li>
</ul>
<h4 id="分配结构包含以下三种视角："><a href="#分配结构包含以下三种视角：" class="headerlink" title="分配结构包含以下三种视角："></a>分配结构包含以下三种视角：</h4><p><strong>部署视图 Deployment View</strong></p>
<h3 id="常见的模块结构"><a href="#常见的模块结构" class="headerlink" title="常见的模块结构"></a>常见的模块结构</h3><h4 id="分解结构-Decomposition-structure"><a href="#分解结构-Decomposition-structure" class="headerlink" title="分解结构 Decomposition-structure"></a>分解结构 Decomposition-structure</h4><ul>
<li><p>用来展示模块是如何被划分成更小的模块的</p>
</li>
<li><p>分解结构在很大程度上决定了系统的可修改性，通过确保可能的变化是局部的。</p>
</li>
</ul>
<h4 id="使用结构-Uses-structure"><a href="#使用结构-Uses-structure" class="headerlink" title="使用结构 Uses-structure"></a>使用结构 Uses-structure</h4><ul>
<li><p>每一个在使用模块中的<strong>unit</strong>也是模块</p>
</li>
<li><p>单元间的联系是以使用与被使用，是依赖与被依赖的形式</p>
</li>
<li><p>如果<strong>A单元</strong>的合法使用需要使用到<strong>B单元</strong>的某个正确版本的功能，则说明：A单元正在使用B单元</p>
</li>
<li><p>轻松创建系统子集的能力允许进行增量开发。</p>
</li>
</ul>
<h4 id="分层结构-Layer-structure"><a href="#分层结构-Layer-structure" class="headerlink" title="分层结构 Layer-structure"></a>分层结构 Layer-structure</h4><ul>
<li><p>每一个模块都称为<strong>层</strong> <strong>layer</strong></p>
</li>
<li><p><strong>层</strong>被抽象为<strong>虚拟机</strong> <strong>virtual machine</strong>，通过接口提供一组内聚的服务</p>
</li>
<li><p>层以预先设定好的接口去使用其他的层，</p>
</li>
</ul>
<h4 id="类（或泛化）结构-Class-or-generalization-structure"><a href="#类（或泛化）结构-Class-or-generalization-structure" class="headerlink" title="类（或泛化）结构 Class (or generalization) structure"></a>类（或泛化）结构 Class (or generalization) structure</h4><h4 id="数据模型结构-Data-model-structure"><a href="#数据模型结构-Data-model-structure" class="headerlink" title="数据模型结构 Data model structure"></a>数据模型结构 Data model structure</h4><h4 id="服务结构-Service-structure"><a href="#服务结构-Service-structure" class="headerlink" title="服务结构 Service structure"></a>服务结构 Service structure</h4><h4 id="并发结构-Concurrency-structure"><a href="#并发结构-Concurrency-structure" class="headerlink" title="并发结构 Concurrency structure"></a>并发结构 Concurrency structure</h4><h3 id="常见的分配结构"><a href="#常见的分配结构" class="headerlink" title="常见的分配结构"></a>常见的分配结构</h3><h4 id="部署结构-Deployment-structure"><a href="#部署结构-Deployment-structure" class="headerlink" title="部署结构 Deployment structure"></a>部署结构 Deployment structure</h4><h4 id="实施结构-Implementation-structure"><a href="#实施结构-Implementation-structure" class="headerlink" title="实施结构 Implementation structure"></a>实施结构 Implementation structure</h4><h4 id="工作分配结构-Work-assignment-structure"><a href="#工作分配结构-Work-assignment-structure" class="headerlink" title="工作分配结构 Work assignment structure"></a>工作分配结构 Work assignment structure</h4><h4 id="架构模式-Architectural-Patterns"><a href="#架构模式-Architectural-Patterns" class="headerlink" title="架构模式 Architectural Patterns"></a>架构模式 Architectural Patterns</h4><h2 id="CH2-为什么需要软件架构"><a href="#CH2-为什么需要软件架构" class="headerlink" title="CH2 为什么需要软件架构"></a>CH2 为什么需要软件架构</h2><h3 id="禁止或启用系统的质量属性"><a href="#禁止或启用系统的质量属性" class="headerlink" title="禁止或启用系统的质量属性"></a>禁止或启用系统的质量属性</h3><ul>
<li><p>系统是否能够展示其期望的（或必需的）质量属性在很大程度上取决于其体系结构。</p>
<ul>
<li><p>性能</p>
</li>
<li><p>可修改性</p>
</li>
<li><p>安全性</p>
</li>
<li><p>可扩展性</p>
</li>
<li><p>可重用性</p>
</li>
</ul>
</li>
</ul>
<h3 id="推理和管理变更"><a href="#推理和管理变更" class="headerlink" title="推理和管理变更"></a>推理和管理变更</h3><ul>
<li><p>每个体系结构都将可能的更改划分为三类</p>
<ul>
<li>局部变更可以通过修改单个元素来实现</li>
<li>非局部的变更需要修改多个元素，但会保留底层框架</li>
<li>整个软件框架的变更，会影响元素相互作用的基本方式</li>
</ul>
</li>
<li><p>综上，局部的变更是最节约成本的，因此一个好的框架需要具备：最常见的更改是局部的</p>
</li>
</ul>
<h3 id="最早的设计决定"><a href="#最早的设计决定" class="headerlink" title="最早的设计决定"></a>最早的设计决定</h3><ul>
<li><p>软件体系结构即是关于系统的最早设计决策的表现。</p>
</li>
<li><p>这些早期决策会影响系统的剩余开发、部署和维护寿命</p>
</li>
</ul>
<h3 id="定义在实现-Implementation-上的约束"><a href="#定义在实现-Implementation-上的约束" class="headerlink" title="定义在实现(Implementation)上的约束"></a>定义在实现(Implementation)上的约束</h3><ul>
<li><p>如果实现符合体系结构规定的设计决策，则会展示一个体系结构。</p>
<ul>
<li><p>该实现必须作为规定的元素的集合来实现</p>
</li>
<li><p>这些元素必须以规定的方式相互作用</p>
</li>
</ul>
</li>
<li><p>每个计划都是对实现者的约束</p>
</li>
</ul>
<h3 id="体系结构影响着系统的组织结构"><a href="#体系结构影响着系统的组织结构" class="headerlink" title="体系结构影响着系统的组织结构"></a>体系结构影响着系统的组织结构</h3><ul>
<li><p>架构规定了正在开发中的系统的结构选择</p>
</li>
<li><p>架构通常作为 work-breakdown 结构的基础</p>
</li>
<li><p>而 work-breakdown 结构又可以反作用于：</p>
<ul>
<li><p>计划、计划和预算的单位</p>
</li>
<li><p>团队间通信渠道</p>
</li>
<li><p>配置和文件系统的组织结构</p>
</li>
<li><p>集成和测试计划和程序</p>
</li>
<li><p>维护活动</p>
</li>
</ul>
</li>
</ul>
<h3 id="定义好的架构可以作为系统骨架的原型"><a href="#定义好的架构可以作为系统骨架的原型" class="headerlink" title="定义好的架构可以作为系统骨架的原型"></a>定义好的架构可以作为系统骨架的原型</h3><ul>
<li><p>骨架系统是指在系统的大部分功能创建之前至少构建一些基础设施。</p>
</li>
<li><p>当原型部件被这些部件的完整版本替换时，系统的保真度就会提高</p>
</li>
<li><p>这种方法有助于开发过程，因为该系统在产品生命周期的早期就是可执行的。</p>
</li>
<li><p>这种方法允许在产品生命周期的早期发现潜在的性能问题</p>
</li>
<li><p>这些好处降低了项目中的潜在风险</p>
</li>
</ul>
<h3 id="有利于优化成本、开发进度的预估"><a href="#有利于优化成本、开发进度的预估" class="headerlink" title="有利于优化成本、开发进度的预估"></a>有利于优化成本、开发进度的预估</h3><ul>
<li><p>体系结构用于帮助项目经理在项目生命周期的早期创建成本和进度估算。</p>
</li>
<li><p>自上而下的估计数对于制定目标和分配预算很有用</p>
</li>
<li><p>自下而上的对系统各个部分的理解通常比那些纯粹基于自上而下的系统知识的理解更准确</p>
</li>
<li><p>最佳的成本和进度计划估算通常来自于自上而下的估算（由架构师和项目经理创建）和自下而上的估算（由开发人员创建）之间的共识。</p>
</li>
</ul>
<h3 id="可转换、可重用模型"><a href="#可转换、可重用模型" class="headerlink" title="可转换、可重用模型"></a>可转换、可重用模型</h3><ul>
<li><p>体系结构的重复使用为具有类似需求的系统提供了巨大的好处。</p>
<ul>
<li><p>不仅可以重用代码，而且首先导致架构的需求也可以重用代码</p>
</li>
<li><p>当体系结构决策可以跨多个系统重用时，所有的早期决策结果也会被转移</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用独立开发的组件"><a href="#使用独立开发的组件" class="headerlink" title="使用独立开发的组件"></a>使用独立开发的组件</h3><ul>
<li><p>基于体系结构的开发通常关注可能单独开发，甚至独立开发的组件</p>
</li>
<li><p>商业现成的组件、开源软件、公开可用的应用程序和网络服务都是可互换的软件组件的例子</p>
</li>
<li><p>回报可以是</p>
<ul>
<li><p>减少上市时间</p>
</li>
<li><p>提高可靠性</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH4-质量属性"><a href="#CH4-质量属性" class="headerlink" title="CH4 质量属性"></a>CH4 质量属性</h2><h3 id="架构与需求"><a href="#架构与需求" class="headerlink" title="架构与需求"></a>架构与需求</h3><h4 id="系统的需求可以大致分类为："><a href="#系统的需求可以大致分类为：" class="headerlink" title="系统的需求可以大致分类为："></a>系统的需求可以大致分类为：</h4><ul>
<li><p><strong>功能需求</strong>：说明系统必须做什么，它必须如何对运行时行为或刺激反应。</p>
</li>
<li><p><strong>质量属性需求</strong>：确定功能需求，例如，功能执行的速度，功能对错误输入的弹性等。</p>
</li>
<li><p><strong>约束</strong>：约束是一个具有零自由度的设计决策</p>
</li>
</ul>
<h3 id="功能性-functionality"><a href="#功能性-functionality" class="headerlink" title="功能性 functionality"></a>功能性 functionality</h3><ul>
<li><p>功能是指系统完成其预期的工作的能力</p>
</li>
<li><p>功能与架构有一种奇怪的关系：功能并不决定体系结构</p>
</li>
</ul>
<h3 id="质量属性分类"><a href="#质量属性分类" class="headerlink" title="质量属性分类"></a>质量属性分类</h3><h4 id="运行时属性"><a href="#运行时属性" class="headerlink" title="运行时属性"></a>运行时属性</h4><p>这些属性关注系统在运行时的行为和性能，包括：</p>
<ol>
<li><strong>性能</strong>：系统在特定时间内完成任务的能力，包括响应时间、吞吐量、资源使用等。</li>
</ol>
<ul>
<li><p>指标：响应时间、延迟、吞吐量。</p>
</li>
<li><p>方法：缓存、负载均衡、并行处理。</p>
</li>
</ul>
<ol start="2">
<li><strong>可用性</strong>：系统在特定时间内可以正常运行的能力。</li>
</ol>
<ul>
<li><p>指标：系统故障间隔时间（MTBF）、恢复时间（MTTR）。</p>
</li>
<li><p>方法：冗余设计、热备份、故障检测与切换。</p>
</li>
</ul>
<ol start="3">
<li><strong>安全性</strong>：保护数据和系统资源免受未经授权访问的能力。</li>
</ol>
<ul>
<li><p>指标：攻击成功率、数据泄露数量。</p>
</li>
<li><p>方法：身份认证、加密、访问控制。</p>
</li>
</ul>
<ol start="4">
<li><strong>可扩展性</strong>：系统随着需求变化，能够处理增长的用户数或数据量的能力。</li>
</ol>
<ul>
<li><p>指标：水平扩展的节点数、垂直扩展的性能增幅。</p>
</li>
<li><p>方法：分布式架构、分片。</p>
</li>
</ul>
<ol start="5">
<li><strong>可靠性</strong>：系统在规定时间内完成任务的能力。</li>
</ol>
<ul>
<li><p>指标：故障率、成功执行任务比例。</p>
</li>
<li><p>方法：异常处理、事务管理</p>
</li>
</ul>
<h4 id="非运行时属性"><a href="#非运行时属性" class="headerlink" title="非运行时属性"></a>非运行时属性</h4><p>这些属性关注系统的开发、维护和部署等非运行时特性，包括：</p>
<ol>
<li><strong>可维护性</strong>：系统被修改以适应新需求、修复缺陷的难易程度。</li>
</ol>
<ul>
<li>方法：模块化设计、清晰的接口、代码可读性。</li>
</ul>
<ol start="2">
<li><strong>可部署性</strong>：系统能否快速部署、更新和回滚。</li>
</ol>
<ul>
<li>方法：自动化部署、蓝绿部署、滚动升级。</li>
</ul>
<ol start="3">
<li><strong>可测试性</strong>：系统能否方便地进行测试。</li>
</ol>
<ul>
<li>方法：单元测试覆盖率、模拟器（Mock）工具、测试自动化框架。</li>
</ul>
<ol start="4">
<li><strong>可移植性</strong>：系统在不同环境或平台上的运行能力。</li>
</ol>
<ul>
<li>方法：容器化（如Docker）、跨平台设计。</li>
</ul>
<ol start="5">
<li><strong>互操作性</strong>：系统与其他系统或组件协同工作的能力。</li>
</ol>
<ul>
<li>方法：标准化协议、API设计。</li>
</ul>
<h3 id="质量属性需求-quality-attribute-requirements"><a href="#质量属性需求-quality-attribute-requirements" class="headerlink" title="质量属性需求 quality attribute requirements"></a>质量属性需求 quality attribute requirements</h3><h4 id="质量需求考虑-quality-attribute-considerations"><a href="#质量需求考虑-quality-attribute-considerations" class="headerlink" title="质量需求考虑 quality-attribute-considerations"></a>质量需求考虑 quality-attribute-considerations</h4><ul>
<li><p>如果一个功能性需求是“当用户按下绿色按钮时，选项对话框出现”：</p>
<ul>
<li><p>性能(performance qualification) 要求可能描述对话框出现的速度；</p>
</li>
<li><p>可用性要求(availability qualification) 可能描述这个功能会出现故障的频率以及修复的速度；</p>
</li>
<li><p>易用性要求(usability qualification) 可能描述学习这个功能的简易程度。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>两类质量属性</p>
<ul>
<li><p>描述系统在运行时的一些属性</p>
<ul>
<li>可用性、性能、易用性、安全性</li>
</ul>
</li>
<li><p>描述系统开发过程中的一些属性</p>
<ul>
<li>可修改性、可测试性</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>在之前关于质量属性的讨论中存在一些问题：</p>
<ul>
<li><p>不可测试的定义(Untestable definitions)。对某个属性提供的定义无法进行测试。说一个系统将是“可修改的”是没有意义的。</p>
</li>
<li><p>重叠的问题(Overlapping concerns)。系统故障是由于拒绝服务攻击还是与可用性、性能、安全性或可用性相关？</p>
</li>
</ul>
</li>
<li><p>解决这些问题（不可测试的定义和重叠的问题）的方法是使用质量属性场景来描述质量属性。</p>
</li>
</ul>
<h4 id="指定质量属性需求"><a href="#指定质量属性需求" class="headerlink" title="指定质量属性需求"></a>指定质量属性需求</h4><ul>
<li><p>我们使用一种通用形式，将所有质量属性需求都指定为场景。</p>
</li>
<li><p>我们对质量属性场景的表示包括以下几个部分：</p>
<ol>
<li>刺激（Stimulus）。刺激是一种在到达系统时需要产生响应的条件。</li>
<li>刺激源（Source of stimulus）。刺激源是某个实体（人、计算机系统或其他执行器），它产生了刺激。</li>
<li>响应（Response）。响应是作为刺激到达后所进行的活动。</li>
<li>响应度量（Response measure）。当响应发生时，应该以某种方式进行度量，以便对需求进行测试。</li>
<li>环境（Environment）。刺激发生在特定条件下。系统可能处于超负荷状态、正常运行状态或其他相关状态。</li>
<li>构件（Artifact）。这可以是一组系统、整个系统或其中的某个部分。某个构件被刺激。</li>
</ol>
</li>
<li><p>通用的质量属性场景(General quality attribute scenarios) 与具体的系统无关，可能适用于任何系统。</p>
</li>
<li><p>具体的质量属性场景(Concrete quality attribute scenarios) 则针对具体考虑的系统而定。</p>
</li>
</ul>
<h4 id="通过决策实现质量属性"><a href="#通过决策实现质量属性" class="headerlink" title="通过决策实现质量属性"></a>通过决策实现质量属性</h4><ul>
<li><p>架构师可以使用一系列基本的设计技术来实现质量属性响应。</p>
</li>
<li><p>我们将这些基本设计技术称为架构设计策略。</p>
</li>
<li><p>策略和设计模式一样，是架构师多年来一直在使用的技术。</p>
</li>
<li><p>我们并不是发明策略，而是简单地捕捉架构师在实践中所做的事情。例如资源调度就是用于性能的一种策略：</p>
<ul>
<li><p>给定条件：发布时间，每个任务的工作量</p>
</li>
<li><p>过程：确定每个任务何时执行</p>
</li>
<li><p>目标：最小化任务的平均完成时间</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>策略 vs. 架构模式</p>
<ul>
<li><p>策略是针对单个质量属性的设计决策。</p>
</li>
<li><p>策略不考虑质量属性之间的权衡。</p>
</li>
<li><p>架构模式可以被看作是策略的“套餐”，其中考虑了质量属性之间的权衡。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>我们需要对策略进行隔离、分类和描述。为什么要这样做？</p>
<ul>
<li><p>设计模式往往很复杂，并且很难直接应用；架构师需要对它们进行修改和适应。</p>
</li>
<li><p>如果没有现有的模式来实现架构师的设计目标，策略可以让架构师从“首要原则”构建设计片段。</p>
</li>
<li><p>通过对策略进行分类，我们可以在改进特定质量属性时选择多种策略。选择使用哪些策略取决于诸如实施成本等因素。</p>
</li>
</ul>
</li>
</ul>
<h4 id="指导质量设计决策"><a href="#指导质量设计决策" class="headerlink" title="指导质量设计决策"></a>指导质量设计决策</h4><ul>
<li>架构设计是一种系统化的设计决策方法。</li>
<li>我们将设计决策分为以下几类：<ol>
<li>职责分配(Allocation of responsibilities)</li>
<li>协调模型(Coordination model)</li>
<li>数据模型(Data model)</li>
<li>资源管理(Management of resources)</li>
<li>架构元素之间的映射(Mapping among architectural elements)</li>
<li>绑定时间决策(Binding time decisions)</li>
<li>技术选择(Choice of technology)</li>
</ol>
</li>
</ul>
<h4 id="指责分配"><a href="#指责分配" class="headerlink" title="指责分配"></a>指责分配</h4><ul>
<li><p>包括职责分配的决策内容：</p>
<ul>
<li><p>确定职责，包括基本系统功能、架构基础设施和满足质量属性。</p>
</li>
<li><p>确定如何将这些职责分配给非运行时和运行时元素（即模块、组件和连接器）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="协调模型"><a href="#协调模型" class="headerlink" title="协调模型"></a>协调模型</h4><p>关于协调模型的决策包括：</p>
<ul>
<li><p>确定系统中需要进行<strong>协调或禁止协调</strong>的元素。</p>
</li>
<li><p>确定协调的属性，例如<strong>及时性、实时性、正确性和一致性</strong>。</p>
</li>
<li><p>选择实现这些属性的通信机制。</p>
<ul>
<li><p>有状态 vs 无状态</p>
</li>
<li><p>同步 vs 异步</p>
</li>
<li><p>有保证 vs 无保证的传递</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>关于数据模型的决策包括：</p>
<ul>
<li><p><strong>选择主要的数据抽象、它们的操作和属性</strong>。</p>
<ul>
<li><strong>数据抽象</strong>：指的是数据的基本表现形式或模型，描述了系统如何抽象地表示和处理数据。例如，数据可以抽象为实体（如用户、订单）、关系（如用户与订单之间的关系）或文档（如JSON文档）。</li>
<li><strong>操作</strong>：指系统能够对数据执行的行为或操作，例如增删改查（CRUD 操作）、事务操作（如提交和回滚）、复杂查询（如聚合计算）。</li>
<li><strong>属性</strong>：描述与数据相关的细节，如数据字段及其数据类型。例如，用户实体可以有属性如用户名（字符串）、年龄（整数）和注册日期（日期类型）。</li>
<li><strong>决策点</strong>：<ul>
<li><p>确定哪些实体是核心数据对象，以及这些对象如何交互。</p>
</li>
<li><p>定义实体的字段和字段类型，以及这些字段是否需要验证规则（如长度限制、唯一性）。</p>
</li>
<li><p>决定支持哪些基本和高级操作，例如是否需要全文搜索、批量更新等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据一致解释所需的元数据</strong>。</p>
<ul>
<li><p><strong>元数据</strong>：是描述数据的数据，用于定义数据的结构、约束、语义以及解释规则。</p>
<ul>
<li><p>结构：定义表或文档的字段及其类型。</p>
</li>
<li><p>约束：定义字段的限制条件，如非空、唯一性等。</p>
</li>
<li><p>语义：说明数据的含义，如字段的业务意义或其作用。</p>
</li>
</ul>
</li>
<li><p>数据的一致解释：确保不同系统组件或用户对同一数据有统一的理解。元数据有助于标准化数据的存储和使用方式。</p>
</li>
<li><p><strong>决策点</strong>：</p>
<ul>
<li><p>定义元数据的存储方式，例如作为数据库中的元表存储，或以JSON Schema等格式嵌入系统中。</p>
</li>
<li><p>确保系统设计文档中明确数据模型的元数据，以便开发和维护人员理解数据的语义和约束。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据的组织方式，即决定数据是保存在关系型数据库、对象集合还是两者兼有</strong>。</p>
<ul>
<li><strong>决策点</strong>：<ul>
<li><p>选择数据库类型：关系型、非关系型或两者结合。</p>
</li>
<li><p>决定数据的存储模式：结构化数据（表格形式）还是半结构化&#x2F;非结构化数据（JSON文档、文件形式）。</p>
</li>
<li><p>考虑数据的存取需求：如事务一致性、高可用性、查询复杂度、扩展性。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><ul>
<li><p>资源管理的决策包括：</p>
<ul>
<li><p>确定需要管理的资源，并确定每个资源的限制。</p>
</li>
<li><p>确定哪个系统元素管理每个资源。</p>
</li>
<li><p>确定资源共享的方式以及在资源争用时采用的策略。</p>
</li>
<li><p>确定饱和对不同资源的影响</p>
</li>
</ul>
</li>
</ul>
<h4 id="架构元素间的映射"><a href="#架构元素间的映射" class="headerlink" title="架构元素间的映射"></a>架构元素间的映射</h4><ul>
<li><p>有用的映射包括：</p>
<ul>
<li><p>模块和运行时元素之间的映射。</p>
</li>
<li><p>将运行时元素分配给处理器。</p>
</li>
<li><p>将数据模型中的项分配给数据存储。</p>
</li>
<li><p>将模块和运行时元素映射到交付单元</p>
</li>
</ul>
</li>
</ul>
<h4 id="绑定时间决策"><a href="#绑定时间决策" class="headerlink" title="绑定时间决策"></a>绑定时间决策</h4><ul>
<li><p>其他类别中的决策都与绑定时间决策相关。此类绑定时间决策的示例包括：</p>
<ul>
<li><p>构建时间 vs. 运行时间</p>
</li>
<li><p>对于协调模型的选择，您可以设计运行时协议的协商。</p>
</li>
<li><p>对于资源管理，您可以设计一个系统，在运行时接受新的外设设备插入</p>
</li>
</ul>
</li>
</ul>
<h4 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h4><ul>
<li><p>技术选择决策涉及：</p>
<ul>
<li><p>决定哪些技术可用来实现在其他类别中做出的决策。</p>
</li>
<li><p>确定支持该技术的工具（IDE、模拟器、测试工具等）是否足够。</p>
</li>
<li><p>确定对该技术的内部熟悉程度和外部支持程度（例如课程、教程、示例、承包商的可用性）。</p>
</li>
<li><p>确定选择某项技术的副作用，如所需的协调模型或受限的资源管理机会。</p>
</li>
<li><p>确定新技术是否与现有技术堆栈兼容。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH5-可用性"><a href="#CH5-可用性" class="headerlink" title="CH5 可用性"></a>CH5 可用性</h2><h3 id="可用性-availability"><a href="#可用性-availability" class="headerlink" title="可用性 availability"></a>可用性 availability</h3><ul>
<li><p>可用性指的是软件具备在需要时随时可用并准备好执行任务的属性。</p>
</li>
<li><p>可用性是指系统能够<strong>掩盖或修复故障</strong>，以使累积的服务中断时间不超过指定时间间隔内的要求值。</p>
</li>
<li><p>可用性的目标是<strong>通过减轻故障来最小化服务中断时间</strong>。</p>
</li>
</ul>
<blockquote>
<p>可用性(<strong>Availability</strong>)与可靠性(<strong>reliability</strong>)或可信性(<strong>trustworthiness</strong>)的区别</p>
<ul>
<li><p>可用性包括通常所称的可靠性。</p>
</li>
<li><p>可用性还涵盖了其他考虑因素，例如由于定期维护导致的服务中断。</p>
</li>
<li><p>可用性与以下因素密切相关</p>
<ul>
<li>安全性，例如拒绝服务攻击</li>
<li>性能</li>
<li>…</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">关注点</th>
<th align="center">关键指标</th>
<th align="center">实现方法</th>
<th align="center">用户感知</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可用性</td>
<td align="center">服务是否随时可用</td>
<td align="center">可用率，停机时间</td>
<td align="center">冗余设计、自动切换、监控</td>
<td align="center">系统是否能被访问和使用</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">服务运行过程中是否出错</td>
<td align="center">平均故障间隔时间（MTBF）、故障率</td>
<td align="center">容错设计、数据校验、严格测试</td>
<td align="center">系统是否能长时间无故障运行</td>
</tr>
<tr>
<td align="center">可信性</td>
<td align="center">数据和操作结果是否值得信赖</td>
<td align="center">数据完整性、安全性、用户满意度</td>
<td align="center">加密、验证、审计</td>
<td align="center">系统提供的结果和数据是否可靠</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="可用性决策的目标"><a href="#可用性决策的目标" class="headerlink" title="可用性决策的目标"></a>可用性决策的目标</h3><blockquote>
<p>故障(Fault) vs 失败(Failure)？</p>
<ul>
<li><p>失败发生在系统不再按照其规范提供服务时</p>
<ul>
<li>此故障可以被系统的参与者观察到。</li>
</ul>
</li>
<li><p>故障（或故障的组合）有可能导致失败。</p>
</li>
</ul>
</blockquote>
<p>可用性策略使系统能够忍受故障，以便服务保持符合其规格说明。这些策略可以防止故障导致失败，或至少限制故障的影响，并使修复成为可能。</p>
<h4 id="检测故障-detect-faults"><a href="#检测故障-detect-faults" class="headerlink" title="检测故障 detect-faults"></a>检测故障 detect-faults</h4><ul>
<li><p><strong>Ping&#x2F;echo</strong>：用于确定与相关网络路径的连通性和往返延迟。</p>
</li>
<li><p><strong>心跳(Heartbeat)</strong>：系统监视器与被监视的进程之间的定期消息交换。</p>
<ul>
<li><p>进程定期在其监视器中重置看门狗计时器，</p>
</li>
<li><p>将心跳消息与其他控制消息捆绑在一起，减少开销。</p>
</li>
<li><p>**”ping”<strong>和</strong>“heartbeat”**之间的区别是谁发起健康检查？</p>
<ul>
<li><p>ping 是检查者主动发信息，</p>
</li>
<li><p>heartbeat 是被检查者发信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>监视器(Monitor)</strong>：用于监控系统其他部分的健康状态的组件。</p>
</li>
<li><p><strong>时间戳(Timestamp)</strong>：用于检测分布式消息传递系统中的事件顺序错误。</p>
</li>
<li><p><strong>条件监控(Condition Monitoring)</strong>：检查进程或设备中的条件，或验证设计过程中的假设。</p>
<ul>
<li>例如，在数据存储和传输中使用校验和(checksum)。</li>
</ul>
</li>
<li><p><strong>投票(Voting)</strong>：这种策略的常见实现是三重模块冗余(Triple Modular Redundancy TMR)。</p>
</li>
</ul>
<h4 id="故障恢复-准备和修复-recover-from-faults-preparation-repair"><a href="#故障恢复-准备和修复-recover-from-faults-preparation-repair" class="headerlink" title="故障恢复 (准备和修复) recover-from-faults(preparation &amp; repair)"></a>故障恢复 (准备和修复) recover-from-faults(preparation &amp; repair)</h4><ul>
<li><p><strong>主动冗余(热备份) active-redundancy (hot-spare)</strong>：</p>
<ul>
<li><p>通过保持多个冗余组件同时运行，确保在一个组件发生故障时，其他组件可以立即接替其工作，从而最小化系统停机时间和数据丢失风险</p>
</li>
<li><p>保护组中的所有组件（主要活动组件和冗余备份组件）以并行方式处理相同的输入，允许冗余备份的组件与活动组件保持同步状态。</p>
</li>
</ul>
</li>
<li><p><strong>备用(冷备份) spare (cold-spare)</strong>：保护组的冗余备份保持停机状态，直到发生故障切换，此时在将冗余备份投入使用之前，会启动电源复位程序。</p>
</li>
<li><p><strong>被动冗余(温备份) passive-redundancy (warm-spare)</strong>：只有保护组的活动成员处理输入流量；</p>
<ul>
<li>其中一个职责是向冗余备份提供定期的状态更新。</li>
</ul>
</li>
<li><p><strong>回滚rollback</strong>：恢复到先前已知的良好状态，称为”回滚点”。</p>
<ul>
<li><p>这种策略与冗余策略结合使用。</p>
</li>
<li><p>在发生回滚后，故障组件的备用版本变为活动状态。</p>
</li>
<li><p>回滚依赖于先前状态的副本（检查点）。</p>
</li>
<li><p>检查点可以存储在固定位置，并需要定期更新。</p>
</li>
</ul>
</li>
<li><p><strong>重试retry</strong>：当故障是暂时性的，重新尝试操作可能会成功。</p>
<ul>
<li>例如，网络重传。</li>
</ul>
</li>
<li><p><strong>忽略错误行为(Ignore-faulty-behavior)</strong>：当确定某个消息是伪造的时，忽略来自该消息源的消息。</p>
<ul>
<li>例如，忽略来自拒绝服务攻击者的消息。</li>
</ul>
</li>
<li><p><strong>退化degradation</strong>：在组件故障的情况下保持最关键的系统功能，放弃较不关键的功能。</p>
</li>
<li><p><strong>重新配置reconfiguration</strong>：将责任重新分配给仍然正常运行的资源，同时尽可能保持功能性。</p>
</li>
</ul>
<h4 id="防止故障-prevent-faults"><a href="#防止故障-prevent-faults" class="headerlink" title="防止故障 prevent-faults"></a>防止故障 prevent-faults</h4><ul>
<li><p><strong>服务移除 removal-from-service</strong>：将系统组件暂时置于停机状态，以减轻潜在的系统故障。</p>
</li>
<li><p><strong>事务 transactions</strong>：将状态更新打包，使分布式组件之间交换的异步消息具有原子性、一致性、隔</p>
</li>
<li><p>离性和持久性。</p>
</li>
<li><p><strong>预测模型 predictive-model</strong>：在检测到预测可能的未来故障的条件时采取纠正措施。</p>
</li>
<li><p><strong>增加能力集合</strong>：设计一个组件以处理更多的情况（故障），作为其正常操作的一部分。</p>
</li>
</ul>
<h2 id="CH6-互操作性"><a href="#CH6-互操作性" class="headerlink" title="CH6 互操作性"></a>CH6 互操作性</h2><h3 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h3><ul>
<li><p>互操作性是指在<strong>特定环境下，两个或多个系统能够通过接口有意义地交换</strong>信息的程度。</p>
</li>
<li><p>对于系统的互操作性的任何讨论都需要明确指出与谁以及在什么情况下进行交互。</p>
</li>
<li><p>语法互操作性是指交换数据的能力。</p>
</li>
<li><p>语义互操作性是指解释交换的数据的能力。</p>
</li>
<li><p>实现互操作性的两种视角：</p>
<ul>
<li><p>在了解外部系统接口的基础上，将该知识设计到系统中。</p>
</li>
<li><p>在没有了解其他系统的情况下，以更通用的方式设计系统以实现互操作性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul>
<li><p>系统提供一个服务，供一组未知系统使用，例如 Google 地图。</p>
</li>
<li><p>系统由现有系统构建而成，例如：</p>
<ul>
<li><p>产生对所感知内容的表示</p>
</li>
<li><p>解释数据</p>
</li>
<li><p>处理原始数据</p>
</li>
<li><p>感知环境</p>
</li>
</ul>
</li>
</ul>
<h4 id="互操作性的两个重要作用"><a href="#互操作性的两个重要作用" class="headerlink" title="互操作性的两个重要作用"></a>互操作性的两个重要作用</h4><ul>
<li>发现。服务的使用者必须发现服务的位置、身份和接口。</li>
<li>处理响应。有三种可能性：<ul>
<li><p>服务向请求者报告返回结果。</p>
</li>
<li><p>服务将其响应发送给另一个系统。</p>
</li>
<li><p>服务向任何感兴趣的方发送广播响应。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>SOAP 和 REST</p>
<ul>
<li><p>两种技术选项，用于实现基于 Web 的应用程序之间的互操作性。</p>
</li>
<li><p>SOAP 在 SOA 系统中与一组协议一起使用。</p>
<ul>
<li><p>服务描述和发现，例如 WSDL、UDDI。</p>
</li>
<li><p>服务组合，例如 BPEL。</p>
</li>
</ul>
</li>
<li><p>SOAP 更复杂，用于交换带有结构化数据的消息，而 REST 更简单，用于小型消息。</p>
</li>
</ul>
</blockquote>
<h3 id="互操作性的目标和决策"><a href="#互操作性的目标和决策" class="headerlink" title="互操作性的目标和决策"></a>互操作性的目标和决策</h3><ul>
<li><p>为了使两个或多个系统能够有意义地交换信息，它们必须：</p>
<ul>
<li><p>了解彼此。这就是定位策略(locate tactic)的目的。</p>
</li>
<li><p>以语义上有意义的方式交换信息。这就是管理接口策略(manage interfaces tactics)的目的。</p>
<p>交换的两个方面是：</p>
<ul>
<li><p>按正确的顺序提供服务。</p>
</li>
<li><p>将一个参与者产生的信息修改为第二个参与者可接受的形式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul>
<li><p>服务发现(Service Discovery)：通过搜索来定位一个服务</p>
</li>
<li><p>有许多服务发现机制：</p>
<ul>
<li><p>用于 Web 服务的 UDDI</p>
</li>
<li><p>用于 Java 对象的 Jini</p>
</li>
<li><p>通用即插即用（Universal plug-and-play，UPnP）中使用的简单服务发现协议（SSDP）</p>
</li>
<li><p>DNS 服务发现（DNS-SD）</p>
</li>
<li><p>蓝牙服务发现协议（SDP）</p>
</li>
</ul>
</li>
</ul>
<h3 id="搜索方法"><a href="#搜索方法" class="headerlink" title="搜索方法"></a>搜索方法</h3><h4 id="主动搜索"><a href="#主动搜索" class="headerlink" title="主动搜索"></a>主动搜索</h4><ul>
<li><p><strong>泛洪&#x2F;广播请求(Flood&#x2F;Broadcast request)</strong>：</p>
<ul>
<li><p>向每个实体询问并等待回答</p>
</li>
<li><p>示例</p>
<ul>
<li><p>在位置区域进行寻呼以找到移动终端</p>
</li>
<li><p>DHCP 发现：客户端在本地子网上进行广播，以找到可用的服务器以获取 IP 地址</p>
</li>
</ul>
</li>
<li><p>对于搜索者来说，高效且资源消耗较少</p>
</li>
<li><p>对于被搜索的实体来说，资源消耗较低</p>
</li>
<li><p>但对于环境来说，会造成干扰和资源消耗。</p>
</li>
</ul>
</li>
<li><p><strong>连续请求(Successive request)</strong>：</p>
<ul>
<li><p>逐个询问实体并进行匹配。</p>
</li>
<li><p>如果没有匹配项，则继续下一个直到找到匹配项。</p>
</li>
<li><p>对于搜索者来说，效率较低且资源消耗较高。</p>
</li>
<li><p>但对于环境来说，干扰较少且资源消耗较少。</p>
</li>
</ul>
</li>
<li><p><strong>连续&#x2F;定期广告(Continuous&#x2F;periodical advertisement)</strong>：</p>
<ul>
<li><p>连续或定期发布广告，以便每个搜索者都能注意到并做出响应。</p>
</li>
<li><p>对于被搜索的实体来说，效率高但资源消耗较高。</p>
</li>
<li><p>对于搜索者来说，资源需求较低。</p>
</li>
<li><p>对于环境来说，干扰和资源消耗较高。</p>
</li>
</ul>
</li>
<li><p><strong>新实体到达时的广告(Advertisement upon arrival of new entity)</strong>：</p>
<ul>
<li><p>例如，当有新人进入大厅时自我介绍。</p>
</li>
<li><p>需要在新实体到达时进行检测机制。</p>
</li>
<li><p>对于被搜索的实体来说，资源消耗较低。</p>
</li>
<li><p>对于搜索者来说，资源需求较低。</p>
</li>
<li><p>对于环境来说，干扰和资源消耗较少。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ul>
<li><p>引入“中间人” - 注册表</p>
<ul>
<li><p>被搜索的实体向注册表注册</p>
</li>
<li><p>搜索者可以通过注册表获取信息并找到被搜索的实体</p>
</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li>服务提供者在 UDDI 注册表中注册其 Web 服务，可以被服务请求者搜索和找到</li>
</ul>
</li>
<li><p>这种方法对搜索者和被搜索者的资源消耗较低，对环境的干扰也较少，但前提是注册表必须可用、可靠和正确</p>
</li>
</ul>
<h2 id="CH7-可修改性"><a href="#CH7-可修改性" class="headerlink" title="CH7 可修改性"></a>CH7 可修改性</h2><h3 id="什么是可修改性-modifiability"><a href="#什么是可修改性-modifiability" class="headerlink" title="什么是可修改性 modifiability"></a>什么是可修改性 modifiability</h3><ul>
<li><p>可修改涉及变化，我们对它的兴趣在于变化的成本和风险。</p>
</li>
<li><p>为了规划可修改性，架构师必须考虑四个问题：</p>
<ul>
<li><p>什么可以改变？</p>
</li>
<li><p>变化的可能性有多大？</p>
</li>
<li><p>变化何时发生，由谁进行？</p>
</li>
<li><p>变化的成本是多少？</p>
</li>
</ul>
</li>
</ul>
<h4 id="什么是可以改变的"><a href="#什么是可以改变的" class="headerlink" title="什么是可以改变的"></a>什么是可以改变的</h4><ul>
<li><p>系统的功能</p>
</li>
<li><p>平台、即硬件、操作系统和中间件</p>
</li>
<li><p>系统运行的环境</p>
<ul>
<li><p>必须与之互操作的系统</p>
</li>
<li><p>用于通信的协议</p>
</li>
</ul>
</li>
<li><p>容量</p>
<ul>
<li><p>支持的用户数量</p>
</li>
<li><p>同时操作的数量</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化何时发生，由谁进行"><a href="#变化何时发生，由谁进行" class="headerlink" title="变化何时发生，由谁进行"></a>变化何时发生，由谁进行</h4><ul>
<li><p>在实施过程中可以进行的更改：</p>
<ul>
<li><p>通过修改源代码进行实施</p>
</li>
<li><p>通过选择库进行构建</p>
</li>
<li><p>通过参数设置、插件等进行执行</p>
</li>
</ul>
</li>
<li><p>更改也可以由以下人员进行：</p>
<ul>
<li><p>开发人员</p>
</li>
<li><p>最终用户</p>
</li>
<li><p>系统管理员</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化的成本"><a href="#变化的成本" class="headerlink" title="变化的成本"></a>变化的成本</h4><p>包括两种类型的成本：</p>
<ul>
<li><p>引入机制以使系统更具可修改性的成本</p>
</li>
<li><p>使用这些机制进行修改的成本</p>
</li>
</ul>
<h3 id="可修改性策略的目标"><a href="#可修改性策略的目标" class="headerlink" title="可修改性策略的目标"></a>可修改性策略的目标</h3><ul>
<li><p>控制进行变更的复杂性</p>
</li>
<li><p>控制进行变更的时间和成本</p>
</li>
</ul>
<h3 id="可修改策略"><a href="#可修改策略" class="headerlink" title="可修改策略"></a>可修改策略</h3><h4 id="减小模块的大小"><a href="#减小模块的大小" class="headerlink" title="减小模块的大小"></a>减小模块的大小</h4><ul>
<li><strong>分割模块</strong>：如果要修改的模块包含大量功能，修改的成本可能会较高</li>
<li>将模块细分为几个较小的模块应该会降低未来变更的平均成本</li>
</ul>
<h4 id="增加内聚性"><a href="#增加内聚性" class="headerlink" title="增加内聚性"></a>增加内聚性</h4><ul>
<li><p>增加语义连贯性：如果模块中的职责 A 和 B 不具有相同的目的，它们应该放置在不同的模块中。</p>
</li>
<li><p>这可能涉及创建一个新的模块，或者将职责移动到现有的模块中。</p>
</li>
</ul>
<h4 id="减少耦合性"><a href="#减少耦合性" class="headerlink" title="减少耦合性"></a>减少耦合性</h4><ul>
<li><p>什么是耦合性？</p>
<ul>
<li><p>如果两个模块的职责重叠，一个变更可能会同时影响它们</p>
</li>
<li><p>耦合性通过这种重叠来衡量，即修改一个模块将会传播到另一个模块的概率</p>
</li>
<li><p>高耦合性是可修改性的敌人。</p>
</li>
</ul>
</li>
<li><p>减少耦合性的方法：</p>
<ul>
<li><p>封装：封装为模块引入了一个明确的接口。该接口包括一个 API 及其相关的职责。</p>
</li>
<li><p>使用中间层：如果职责 A 和职责 B 之间存在依赖关系（例如，首先执行 A 需要执行 B），可</p>
</li>
<li><p>以通过使用一个中间层来打破依赖。</p>
</li>
<li><p>使用发布&#x2F;订阅模型 (Publish&#x2F;Subscribe model)</p>
</li>
<li><p>限制依赖关系：限制一个模块与其交互或依赖的模块。</p>
<ul>
<li><p>通过限制模块的可见性和授权来实现。</p>
</li>
<li><p>例如，一个层次结构允许访问其底层的模块</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CH8-性能"><a href="#CH8-性能" class="headerlink" title="CH8 性能"></a>CH8 性能</h2><h3 id="什么是性能"><a href="#什么是性能" class="headerlink" title="什么是性能"></a>什么是性能</h3><ul>
<li><p>它与时间有关</p>
</li>
<li><p>性能是关于时间以及软件系统满足时间要求的能力</p>
</li>
<li><p>当事件发生时，系统必须及时对其做出响应</p>
<ul>
<li>事件包括<strong>中断、消息、来自用户或其他系统的请求</strong>，或标记时间流逝的时钟事件</li>
</ul>
</li>
</ul>
<h4 id="性能建模"><a href="#性能建模" class="headerlink" title="性能建模"></a>性能建模</h4><ul>
<li><p>响应时间的两个基本因素</p>
</li>
<li><p>处理时间指系统用于响应的工作时间</p>
</li>
<li><p>阻塞时间指系统无法响应的时间</p>
</li>
<li><p>阻塞时间的原因包括</p>
<ul>
<li><p>资源争用</p>
</li>
<li><p>资源的可用性</p>
</li>
<li><p>对其他因素的依赖</p>
</li>
</ul>
</li>
</ul>
<h3 id="性能策略的目标"><a href="#性能策略的目标" class="headerlink" title="性能策略的目标"></a>性能策略的目标</h3><ul>
<li><p>在基于时间的约束条件内，对进入系统的事件生成响应。</p>
</li>
<li><p>事件可以是单个事件或事件流，并且是执行计算的触发器。</p>
</li>
</ul>
<h3 id="两种策略类别"><a href="#两种策略类别" class="headerlink" title="两种策略类别"></a>两种策略类别</h3><ul>
<li><p>控制资源需求</p>
<ul>
<li><p>降低对资源的需求量</p>
</li>
<li><p>在需求方面进行操作</p>
</li>
</ul>
</li>
<li><p>管理资源</p>
<ul>
<li><p>使现有资源在处理需求时更有效</p>
</li>
<li><p>在响应方面进行操作</p>
<p>::info 资源</p>
</li>
</ul>
</li>
<li><p>硬件资源，例如 CPU、数据存储、网络带宽和内存</p>
</li>
<li><p>软件资源，例如缓冲区或关键区域</p>
</li>
</ul>
<h3 id="性能策略"><a href="#性能策略" class="headerlink" title="性能策略"></a>性能策略</h3><h4 id="控制资源需求"><a href="#控制资源需求" class="headerlink" title="控制资源需求"></a>控制资源需求</h4><ul>
<li><p><strong>管理采样率(Manage Sampling Rate)</strong>：降低对数据流进行采样的频率</p>
</li>
<li><p><strong>优先处理事件(Prioritize Events)</strong>：引入优先级方案，根据重要性对事件进行排序</p>
<ul>
<li>当资源不足时，忽略低优先级事件</li>
</ul>
</li>
<li><p><strong>减少开销(Reduce Overhead)</strong>：使用中间件会增加处理事件流所消耗的资源；移除中间件可以提高响应延迟。</p>
<ul>
<li>在可修改性和性能之间进行权衡</li>
</ul>
</li>
<li><p><strong>限制执行时间(Bound Execution Times)</strong>：设置响应事件所使用的执行时间上限。</p>
<ul>
<li><p>在算法设计中，限制迭代次数是控制执行时间的方法之一。</p>
</li>
<li><p>在性能和准确性之间进行权衡</p>
</li>
</ul>
</li>
<li><p><strong>提高资源效率(Increase Resource Efficiency)</strong>：改进关键领域中使用的算法将减少延迟。</p>
<ul>
<li>减少算法的复杂性</li>
</ul>
</li>
</ul>
<h4 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h4><ul>
<li><p>增加资源(Increase Resources:)：更快的处理器、额外的处理器、额外的内存和更快的网络都有可能减少延迟。</p>
</li>
<li><p>增加并发性( Increase Concurrency)：如果请求可以并行处理，阻塞时间可以减少。</p>
<ul>
<li>可以通过在不同线程上处理不同的事件流来引入并发性。</li>
</ul>
</li>
</ul>
<h4 id="维护多个计算副本-Maintain-Multiple-Copies-of-Computations"><a href="#维护多个计算副本-Maintain-Multiple-Copies-of-Computations" class="headerlink" title="维护多个计算副本(Maintain Multiple Copies of Computations)"></a>维护多个计算副本(Maintain Multiple Copies of Computations)</h4><ul>
<li><p>复制的目的是减少单个服务器上的资源争用</p>
</li>
<li><p>负载均衡器将新任务分配给其中一个副本服务器</p>
</li>
<li><p><strong>数据缓存(Data caching)</strong> 是将数据的副本保存在具有不同访问速度的存储介质上。- 例如，内存访</p>
</li>
<li><p>问与磁盘访问，本地访问与通过网络的远程访问。</p>
</li>
<li><p><strong>数据复制(Data replication)</strong> 是保留数据的独立副本，以减少多个同时访问所带来的争用。</p>
</li>
<li><p>如何选择要缓存&#x2F;复制的数据？</p>
</li>
<li><p>如何确保多个副本的一致性？</p>
</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul>
<li><p>当资源存在争用时，需要对资源进行调度。</p>
<ul>
<li><p>处理器需要进行调度</p>
</li>
<li><p>缓冲区需要进行调度</p>
</li>
<li><p>网络需要进行调度</p>
</li>
</ul>
</li>
</ul>
<h3 id="3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem"><a href="#3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem" class="headerlink" title="3维度调度框架问题(3-Dimension Framework for Scheduling Problem)"></a>3维度调度框架问题(3-Dimension Framework for Scheduling Problem)</h3><ul>
<li><p>任务(Tasks)</p>
</li>
<li><p>资源(Resources)</p>
</li>
<li><p>目标(Objectives)</p>
</li>
</ul>
<h4 id="任务模型-Task-Model"><a href="#任务模型-Task-Model" class="headerlink" title="任务模型(Task Model)"></a>任务模型(Task Model)</h4><ul>
<li><p>任务包（Bag of tasks）</p>
</li>
<li><p>有向无环图（Directed Acyclic Graph，DAG）</p>
</li>
<li><p>周期性&#x2F;循环性任务（Periodic&#x2F;cyclic tasks）</p>
</li>
<li><p>任务属性</p>
<ul>
<li><p>执行成本（Execution cost）</p>
</li>
<li><p>传输成本（Transmission cost）</p>
</li>
<li><p>到达时间（Arrival time）</p>
</li>
<li><p>截止时间（Deadline）</p>
</li>
<li><p>抢占或非抢占（Preemptive or non-preemptive）</p>
</li>
</ul>
</li>
</ul>
<h4 id="资源模型-Resource-Model"><a href="#资源模型-Resource-Model" class="headerlink" title="资源模型(Resource Model)"></a>资源模型(Resource Model)</h4><ul>
<li><p>资源包括一组通过网络连接的机器&#x2F;处理器</p>
</li>
<li><p>机器&#x2F;处理器模型</p>
<ul>
<li>处理能力&#x2F;速度，能量消耗</li>
</ul>
</li>
<li><p>网络模型</p>
<ul>
<li><p>网络拓扑</p>
</li>
<li><p>带宽</p>
</li>
<li><p>消息和能量消耗</p>
</li>
<li><p>例如，传感器网络、数据中心网络、移动云</p>
</li>
</ul>
</li>
</ul>
<h3 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h3><ul>
<li><p>最小化完成时间</p>
</li>
<li><p>满足截止时间</p>
</li>
<li><p>最大化吞吐量</p>
</li>
<li><p>最小化数据传输&#x2F;消息数量</p>
</li>
<li><p>最小化能量消耗</p>
</li>
</ul>
<h3 id="调度的分类"><a href="#调度的分类" class="headerlink" title="调度的分类"></a>调度的分类</h3><ul>
<li><p>实时调度与非实时调度</p>
</li>
<li><p>静态调度与动态调度</p>
</li>
<li><p>离线调度与在线调度</p>
</li>
<li><p>确定性调度与随机调度</p>
</li>
</ul>
<h3 id="任务调度问题"><a href="#任务调度问题" class="headerlink" title="任务调度问题"></a>任务调度问题</h3><ol>
<li>单处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>多处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>异构处理器上的有向无环图（DAG）调度</li>
<li>作业车间调度（Job shop scheduling）</li>
<li>周期性任务调度（Periodic tasks scheduling）</li>
</ol>
<h4 id="单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）"><a href="#单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）" class="headerlink" title="单处理器上的任务包调度（Bag-of-Tasks on Single Processor）"></a>单处理器上的任务包调度（Bag-of-Tasks on Single Processor）</h4><p>给定：每个任务的发布时间、工作量或截止时间</p>
<p>确定每个任务的执行时间</p>
<p>目标：任务的平均完成时间或满足截止时间</p>
<h4 id="多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）"><a href="#多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）" class="headerlink" title="多处理器上的任务包调度（Bag-of-Tasks on Multi-Processors）"></a>多处理器上的任务包调度（Bag-of-Tasks on Multi-Processors）</h4><p>给定：每个任务的发布时间和工作量</p>
<p>确定每个任务在何时何地执行</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）"><a href="#在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）" class="headerlink" title="在异构处理器上调度有向无环图（DAGs Scheduling on HeterogeneousProcessors）"></a>在异构处理器上调度有向无环图（DAGs Scheduling on HeterogeneousProcessors）</h4><p>给定：每个任务在每个处理器上的处理时间，边缘上的通信时间</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="作业车间问题（Job-Shop-Problem，JSP）"><a href="#作业车间问题（Job-Shop-Problem，JSP）" class="headerlink" title="作业车间问题（Job Shop Problem，JSP）"></a>作业车间问题（Job Shop Problem，JSP）</h4><p>Job Shop Problem (JSP)</p>
<p>给定：每个作业在每个处理器上的处理时间</p>
<p>目标：最小化总执行时间（makespan）…</p>
<h4 id="周期性任务调度-Periodic-tasks-scheduling"><a href="#周期性任务调度-Periodic-tasks-scheduling" class="headerlink" title="周期性任务调度(Periodic tasks scheduling)"></a>周期性任务调度(Periodic tasks scheduling)</h4><p>任务按周期性发布，并在流水线中执行。</p>
<p>Periodic tasks scheduling</p>
<h3 id="类似的术语-Similar-Terminologies"><a href="#类似的术语-Similar-Terminologies" class="headerlink" title="类似的术语(Similar Terminologies)"></a>类似的术语(Similar Terminologies)</h3><ul>
<li><p>任务分配（Task assignment）</p>
</li>
<li><p>任务放置（Task placement）</p>
</li>
<li><p>任务分配（Task allocation）</p>
</li>
<li><p>资源分配（Resource allocation）</p>
</li>
<li><p>资源调度（Resource scheduling）</p>
</li>
</ul>
<p>上述问题被视为调度问题的特殊情况&#x2F;实例。</p>
<h3 id="调度算法的类型"><a href="#调度算法的类型" class="headerlink" title="调度算法的类型"></a>调度算法的类型</h3><p>解决优化问题的算法</p>
<ol>
<li>数学规划，例如整数规划、线性规划</li>
<li>进化算法，例如遗传算法（GA）、粒子群算法（PSO）、蚁群算法</li>
<li>简单且有效的启发式算法，例如列表调度</li>
<li>基于机器学习的算法，例如深度强化学习</li>
</ol>
<p>调度方法：系统考虑因素</p>
<ul>
<li><p>以机器为中心的方法</p>
<ul>
<li><p>当一台机器空闲时触发调度</p>
</li>
<li><p>对于每台空闲机器，根据一些策略选择任务，例如：</p>
<ul>
<li><p>先到先得（First-Come-First-Serve，FCFS）</p>
</li>
<li><p>最短作业优先（Shortest Job First，SJF）</p>
</li>
<li><p>最早截止时间优先（Earliest Deadline First，EDF）</p>
</li>
<li><p>首先选择等待时间最长的作业，…</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以任务为中心的方法</p>
<ul>
<li><p>当一个新任务到达时触发调度</p>
</li>
<li><p>对于每个被调度的任务，根据一些策略选择机器，例如最早完成时间，…</p>
</li>
</ul>
</li>
</ul>
<h4 id="列表调度方法"><a href="#列表调度方法" class="headerlink" title="列表调度方法"></a>列表调度方法</h4><p>computingopen in new window</p>
<ol>
<li>步骤 1：任务选择</li>
</ol>
<p>通过为每个任务分配优先级构建一个有序任务列表，然后按照它们的优先级顺序选择任务。</p>
<ol start="2">
<li>步骤 2：处理器选择</li>
</ol>
<p>将每个选定的任务调度到能够最小化预定义成本函数的处理器上。</p>
<ol start="3">
<li>重复执行步骤 1 和步骤 2，直到所有任务都被调度。</li>
</ol>
<p>例如：</p>
<p>Example: List Scheduling</p>
<ol>
<li>Step 1: 任务选择 - 上行排名（Upward rank）</li>
</ol>
<p>节点 i 的上行排名是最长路径的长度。</p>
<p>计算方法</p>
<p>在我们的算法中，任务按照基于向上和向下排名的调度优先级进行排序。任务 ni 的向上排名由</p>
<p>ranku(ni)&#x3D;wi―+maxnj∈succ(ni)(ci,j―+ranku(nj)),</p>
<p>递归定义。其中 succni 是任务ni的直接后继集合，ci,j― 是边(i,j)的平均通信成本；wi― 为任务 ni 的平均</p>
<p>计算成本。由于 Rank 是通过向上遍历任务图递归计算的，因此从退出任务开始，称为向上 Rank。对于</p>
<p>退出任务nexit，向上 Rank 值等于</p>
<p>ranku(nexit)&#x3D;wexit―.</p>
<p>基本上，ranku(ni) 是从任务 ni 到退出任务的关键路径的长度，包括任务 ni 的计算成本。文献中有一些</p>
<p>算法仅使用计算成本来计算排名值，其中称为静态向上排名，rankus。类似地，任务ni的向下排名由</p>
<p>rankd(ni)&#x3D;maxnj∈pred(ni){rankd(nj)+wj―+cj,i―}递归定义；其中pred(ni)是任务ni的直接前驱集合。通过从图的入口任务开始向下遍历任务图来递归地计</p>
<p>算向下排名。对于入口任务nentry，向下排名值等于 0。基本上，rankd(ni) 是从入口任务到任务ni的最</p>
<p>长距离，不包括任务本身的计算成本。</p>
<p>::: 2. Step 2: 处理器选择 - 最早完成时间</p>
<p>在处理器选择阶段，选择能够最早完成任务的处理器。这意味着根据任务的执行时间和处理器的当前状</p>
<p>态，选择能够最快完成任务的处理器进行调度。</p>
<p>Processor Selection – EarlistFinishTime</p>
<p>计算方法</p>
<p>EST(ni,,pj) 和 EFT(ni,pj) 分别是任务 ni 在处理器 pj 上的最早执行开始时间和最早执行结束时间。对于入</p>
<p>口任务 nentry，</p>
<p>EST(nentry,pj)&#x3D;0</p>
<p>对于图中的其他任务，从入口任务开始递归计算 EFT 和 EST 值，分别如下所示。为了计算任务 ni 的</p>
<p>EFT，需要计算任务 ni 的所有直接前置任务你肯定已经被安排好了。</p>
<p>EST(ni,pj)&#x3D;max{avail[j],maxnm∈pred(ni)</p>
<p>(AFT(nm)+cm,i)}EFT(ni,pj)&#x3D;wi,j+EST(ni,pj)AFT(ni)&#x3D;min∀jEFT(ni,pj)(AFT——ActualFinishTime)</p>
<p>其中 pred(ni) 是任务 ni 的直接前置任务的集合， </p>
<p>是处理器 pj 准备好执行任务的最早时间。如</p>
<p>果 nk 是处理器 pj 上最后分配的任务，则avail[j] 是当我们有基于非插入的调度策略时处理器 pj ，完成了</p>
<p>任务 nk 的执行，并且准备好执行另一个任务的时间。EST 方程中的内部 max 块返回就绪时间，即 ni 所</p>
<p>需的所有数据都已到达处理器pj的时间</p>
<p>任务 nm 在处理器 pj 上调度后， nm 在处理器 pj 上的最早开始时间和最早完成时间分别等于任务 nm</p>
<p>的实际开始时间 AST(nm) 和实际完成时间 AFT(nm) 。当一个图中的所有任务都被调度后，调度长度（即</p>
<p>总体完成时间）是退出任务nexit的实际完成时间。如果有多个退出任务并且插入伪退出任务的约定不适</p>
<p>用，调度长度(也称为makespan)定义为</p>
<p>makespan&#x3D;max{AFT(nexit)}</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>性能是指在特定类型需求的面前有效管理系统资源，以实现可接受的时间行为。</p>
<p>对于交互式和嵌入式实时系统，性能可以通过吞吐量和延迟来衡量。</p>
<p>通过减少需求或更合理地管理资源，可以提高性能。</p>
<h2 id="CH9-安全性"><a href="#CH9-安全性" class="headerlink" title="CH9 安全性"></a>CH9 安全性</h2><h3 id="什么是安全-security"><a href="#什么是安全-security" class="headerlink" title="什么是安全 security"></a>什么是安全 security</h3><ul>
<li><p>安全是系统保护数据和信息免受未经授权访问的能力的度量，同时仍然向经授权的人员和系统提供访问权限。</p>
</li>
<li><p>针对计算机系统的有意为害行为称为攻击。</p>
</li>
<li><p>攻击可以采取不同形式：</p>
<ul>
<li><p>未经授权的尝试访问&#x2F;修改数据或服务</p>
</li>
<li><p>旨在拒绝合法用户的服务</p>
</li>
</ul>
</li>
<li><p>安全具有三个主要特征，即 CIA：</p>
</li>
<li><p>保密性(Confidentiality)是数据或服务受到未经授权访问的保护性质。</p>
<ul>
<li>例如，黑客无法在政府计算机上访问您的个人所得税申报表。</li>
</ul>
</li>
<li><p>完整性(Integrity)是数据或服务不受未经授权操纵的性质。</p>
<ul>
<li>例如，您的成绩自从教师分配以来没有被更改。</li>
</ul>
</li>
<li><p>可用性(Availability)是系统能够供合法使用的性质。</p>
<ul>
<li>例如，拒绝服务攻击阻止您从在线书店订购一本书。</li>
</ul>
</li>
<li><p>支持 CIA 的其他特征包括：</p>
<ul>
<li><p>身份验证验证交易参与方的身份，并检查他们是否真实身份与其所声称的一致。</p>
</li>
<li><p>授权授予用户执行任务的权限。</p>
</li>
</ul>
</li>
</ul>
<h3 id="安全性策略-security-tatics"><a href="#安全性策略-security-tatics" class="headerlink" title="安全性策略 security-tatics"></a>安全性策略 security-tatics</h3><h4 id="检测攻击-detect-attacks"><a href="#检测攻击-detect-attacks" class="headerlink" title="检测攻击 detect-attacks"></a>检测攻击 detect-attacks</h4><ul>
<li><p>检测入侵(Detect Intrusion)：将系统内的网络流量或服务请求模式与存储在数据库中的恶意行为的一组签名或已知模式进行比较。</p>
</li>
<li><p>检测服务拒绝(Detect Service Denial)：将系统接收到的网络流量的模式或签名与已知拒绝服务（DOS）攻击的历史配置文件进行比较</p>
</li>
</ul>
<blockquote>
<p>DOS(Deny of Service Attack)</p>
<ul>
<li><p>Ping of Death（死亡之 Ping）是一种利用发送异常大的 ICMP 回显请求（Ping）来攻击目标系统的方法，超出系统处理能力导致系统崩溃或变得不稳定。</p>
</li>
<li><p>UDP Flood（UDP 洪泛）是通过发送大量伪造的 UDP 数据包来占用目标系统的网络带宽和资源，导致系统无法正常处理合法的网络请求。</p>
</li>
<li><p>TCP SYN（TCP 半开连接）攻击是通过发送大量伪造的 TCP 连接请求（SYN 包）来消耗目标系统的资源，使其无法建立新的有效连接，从而导致服务不可用。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>验证消息完整性(Verify Message Integrity): 使用校验和或哈希值等技术来验证消息、资源文件、部</p>
</li>
<li><p>署文件和配置文件的完整性。检测消息延迟: 通过检查传递消息所需的时间，可以检测到可疑的时间行为，即中间人攻击。</p>
</li>
</ul>
<h4 id="抵御攻击-resist-attacks"><a href="#抵御攻击-resist-attacks" class="headerlink" title="抵御攻击 resist-attacks"></a>抵御攻击 resist-attacks</h4><ul>
<li><p>识别参与者(Identify Actors)：识别系统接收的任何外部输入的来源。</p>
</li>
<li><p>对参与者进行身份验证(Authenticate Actors)：确保用户或远程计算机的实际身份与其所声称的身</p>
</li>
<li><p>份相符。</p>
</li>
<li><p>授权参与者(Authorize Actors)：确保经过身份验证的参与者有权访问和修改数据或服务。</p>
</li>
<li><p>限制访问(Limit Access)：限制对诸如内存、网络连接或访问点等资源的访问。</p>
</li>
<li><p>限制曝光(Limit Exposure)：通过尽可能减少访问点的数量来最小化系统的攻击面。</p>
<ul>
<li><p>例如，防火墙是对内部网络的单一访问点。</p>
</li>
<li><p>例如，关闭一个端口。</p>
</li>
<li><p>被动防御。</p>
</li>
</ul>
</li>
<li><p>加密数据(Encrypt Data)：对数据和通信应用某种形式的加密。</p>
</li>
<li><p>分离实体(Separate Entities)：可以通过在不同服务器上进行物理分离，使用虚拟机等方式实现。</p>
</li>
<li><p>更改默认设置(Change Default Settings)：强制用户更改默认分配的设置</p>
</li>
</ul>
<h4 id="应对攻击-react-to-attacks"><a href="#应对攻击-react-to-attacks" class="headerlink" title="应对攻击 react-to-attacks"></a>应对攻击 react-to-attacks</h4><ul>
<li><p>撤销访问权限( Revoke Access)：如果怀疑存在攻击，即使针对通常合法的用户和用途，也限制对</p>
</li>
<li><p>敏感资源的访问。</p>
</li>
<li><p>锁定计算机(Lock Computer)：如果有多次尝试访问失败，限制对资源的访问。</p>
</li>
<li><p>通知参与者(Inform Actors)：在怀疑或检测到攻击时，通知操作员、其他人员或合作系统</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>对系统的攻击可以归纳为针对系统的机密性、完整性或可用性的攻击。</p>
</li>
<li><p>识别、验证和授权参与者是旨在确定哪些用户或系统有权以何种方式访问系统的策略。</p>
</li>
<li><p>存在用于检测攻击、限制攻击传播以及对攻击做出反应和恢复的策略</p>
</li>
</ul>
<h2 id="CH10-可测试性"><a href="#CH10-可测试性" class="headerlink" title="CH10 可测试性"></a>CH10 可测试性</h2><h3 id="什么是可测试性"><a href="#什么是可测试性" class="headerlink" title="什么是可测试性"></a>什么是可测试性</h3><ul>
<li>软件的可测试性是指通过（通常是基于执行的）测试来展示其错误的难易程度</li>
<li>可测试性是指系统在下一次测试执行中失败的概率</li>
<li>如果系统存在错误，我们希望在测试阶段中尽快失败，及早修正</li>
<li>要使一个系统具有可测试性，必须能够控制每个组件的输入（并可能操作其内部状态），然后观察其输出（以及可能的内部状态）</li>
</ul>
<h3 id="可测试性策略的目标"><a href="#可测试性策略的目标" class="headerlink" title="可测试性策略的目标"></a>可测试性策略的目标</h3><ul>
<li>可测试性测量的目标是在软件开发完成的一个增量中实现更容易的测试</li>
<li>可测试性测量可以分为两个类别：<ul>
<li>第一个类别设计向系统添加可控性和可观察性</li>
<li>第二个类别设计限制系统设计中的复杂性</li>
</ul>
</li>
</ul>
<h3 id="可测试性策略"><a href="#可测试性策略" class="headerlink" title="可测试性策略"></a>可测试性策略</h3><p><img src="https://chiichen.github.io/assets/image-J21vDhO7.png" alt="Testability Tactics"></p>
<h4 id="控制和观察系统状态-control-and-observe-system-state"><a href="#控制和观察系统状态-control-and-observe-system-state" class="headerlink" title="控制和观察系统状态 control-and-observe-system-state"></a>控制和观察系统状态 control-and-observe-system-state</h4><ul>
<li>记录&#x2F;回放 record&#x2F;playback：捕获通过接口传递的信息，并将其用作进一步测试的输入。</li>
<li>本地化状态存储 localize-state-storage：为了测试，将系统置于任意状态时，如果该状态存储在一个单独的位置则最为方便。</li>
<li>专用接口 specialized-interfaces<ul>
<li>通过正常执行来控制或捕获组件的变量值</li>
<li>一组用于设置和获取变量的方法</li>
<li>一个返回对象状态的报告方法</li>
<li>一个用于设置内部状态的重置方法</li>
</ul>
</li>
<li>沙河 sandbox：将系统和真实世界隔离开来，以便进行实验。</li>
<li>可执行断言 executable-assertions：手动编写断言，并将其放置在所需位置，以指示程序何时以及在何处处于错误状态</li>
</ul>
<h4 id="限制复杂性-limit-complexity"><a href="#限制复杂性-limit-complexity" class="headerlink" title="限制复杂性 limit-complexity"></a>限制复杂性 limit-complexity</h4><ul>
<li>限制结构复杂性：避免或解决组件间的循环依赖，并减少组件间的依赖关系<ul>
<li>例如：限制继承树的深度</li>
</ul>
</li>
<li>高内聚低耦合</li>
<li>限制非确定性：找出所有非确定性的来源，例如无约束的并行性，尽可能消除</li>
</ul>
<blockquote>
<p> 测试可行性与容错性</p>
<ul>
<li>测试可行性旨在更容易地显示错误。</li>
<li>容错性试图隐藏错误，并使其难以暴露。</li>
<li>这两个设计目标是否不兼容？</li>
</ul>
<p>测试可行性和容错性是两个不同的设计目标，但并不一定是不兼容的。测试可行性旨在通过测试过程中更容易地检测和暴露错误，以便及早修复它们。容错性旨在使系统能够继续正常运行，即使在面临错误或故障的情况下也能提供可接受的性能和可靠性。</p>
<p>尽管两者有不同的关注点，但它们可以在系统设计中相互支持。例如，通过增加系统的容错能力，可以减少错误的发生率，从而提高测试的有效性。在设计过程中，可以采用合适的策略和技术来平衡测试可行性和容错性的需求，以确保系统在各个方面都具备良好的质量和可靠性。</p>
</blockquote>
<h2 id="CH11-易用性"><a href="#CH11-易用性" class="headerlink" title="CH11 易用性"></a>CH11 易用性</h2><h3 id="什么是易用性"><a href="#什么是易用性" class="headerlink" title="什么是易用性"></a>什么是易用性</h3><ul>
<li>易用性关注用户完成所需任务的难易程度以及系统提供的用户支持</li>
<li>易用性是改善系统质量的最便宜和最简单的方法之一</li>
<li>易用性主要包含：<ul>
<li>高效使用系统</li>
<li>学习系统的功能</li>
<li>尽量减少错误的影响</li>
<li>使系统适应用户需求</li>
<li>提高用户的信心和满意度</li>
</ul>
</li>
</ul>
<h3 id="易用性测量"><a href="#易用性测量" class="headerlink" title="易用性测量"></a>易用性测量</h3><p><img src="https://chiichen.github.io/assets/image-hYSiaVbE.png" alt="Usability tactics"></p>
<h3 id="支持用户主动性-support-user-initiative"><a href="#支持用户主动性-support-user-initiative" class="headerlink" title="支持用户主动性 support-user-initiative"></a>支持用户主动性 support-user-initiative</h3><ul>
<li>取消cancel：系统必须监听取消请求；<ul>
<li>被取消的命令必须终止</li>
<li>使用的资源必须释放</li>
<li>合作组件必须被通知</li>
</ul>
</li>
<li>暂停&#x2F;恢复 pause&#x2F;resume：临时释放资源，以便可以重新分配给其他任务<ul>
<li>用于长时间运行的操作</li>
</ul>
</li>
<li>恢复restore：保持足够的系统状态信息，以便可以恢复到先前的状态</li>
<li>组合aggregate：能够将较低级别的对象聚合成一个组，以便可以对该组应用用户操作，从而用户免于进行重复操作</li>
</ul>
<h3 id="支持系统主动性support-system-initiative"><a href="#支持系统主动性support-system-initiative" class="headerlink" title="支持系统主动性support-system-initiative"></a>支持系统主动性support-system-initiative</h3><ul>
<li>维护任务模型maintain-task-model：确定上下文，以便系统可以对用户的尝试有一定的了解，并提供帮助。</li>
<li>维护系统模型maintain-system-model：系统维护自身的显式模型。这用于确定预期的系统行为，以便向用户提供适当的反馈</li>
</ul>
<h2 id="CH12-其他质量属性"><a href="#CH12-其他质量属性" class="headerlink" title="CH12 其他质量属性"></a>CH12 其他质量属性</h2><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul>
<li>可移植性也是一种特殊的可修改性</li>
<li>可移植性指的是将为一个平台搭建的软件更改为在不同平台运行的便携程度</li>
</ul>
<h3 id="开发可分发性"><a href="#开发可分发性" class="headerlink" title="开发可分发性"></a>开发可分发性</h3><ul>
<li>开发可分发性是指设计软件以支持分布式软件开发的质量</li>
<li>系统是使用全球分布的团队开发的</li>
<li>目的是最大限度减少团队间的协调</li>
</ul>
<h3 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h3><ul>
<li>水平可拓展性（拓展外部）：指向逻辑单元添加更多资源，例如向集群添加另一个服务器</li>
<li>垂直可拓展性（拓展内部）：指向物理单元添加更多资源，例如向计算机添加更多的内存</li>
<li>可产生可衡量的改进，而无需中断操作</li>
</ul>
<blockquote>
<p>集中式与分散式</p>
<ul>
<li>在集中式架构中，控制和决策集中在一个单一的中央实体或服务器上。这种方法可以提供更好的资源协调和管理，但可能会成为单点故障并限制可扩展性。</li>
<li>相比之下，分散式架构将控制和决策分布在多个实体或服务器之间。这种方法可以提供更好的容错性、可扩展性和弹性，但可能会引入协调和一致性方面的挑战。</li>
</ul>
</blockquote>
<h3 id="部署性"><a href="#部署性" class="headerlink" title="部署性"></a>部署性</h3><ul>
<li>部署性关注的是可执行文件如何达到主机平台以及如何被调用</li>
<li>例如：<ul>
<li>javascript脚本</li>
<li>病毒</li>
<li>代理程序</li>
</ul>
</li>
</ul>
<h3 id="可监控性"><a href="#可监控性" class="headerlink" title="可监控性"></a>可监控性</h3><ul>
<li>可监控性涉及运维人员在系统执行过程中监控系统的能力</li>
<li>例如：<ul>
<li>各个组件的运行状态</li>
<li>平均事务处理时间</li>
<li>队列长度</li>
</ul>
</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>软件安全性涉及软件避免进入会导致损害、伤害或生命丧失的状态，并在进入不良状态时进行恢复和限制损害的能力</li>
<li>在安全性方面，框架关注的问题与可用性几乎一致</li>
</ul>
<h3 id="标准的质量属性列表"><a href="#标准的质量属性列表" class="headerlink" title="标准的质量属性列表"></a>标准的质量属性列表</h3><p><img src="https://chiichen.github.io/assets/image-DQ2sDQ7v.png" alt=" The ISO&#x2F;IEC FCD 25010 product quality standard"></p>
<h2 id="CH13-模式和策略"><a href="#CH13-模式和策略" class="headerlink" title="CH13 模式和策略"></a>CH13 模式和策略</h2><h3 id="什么是模式pattern"><a href="#什么是模式pattern" class="headerlink" title="什么是模式pattern"></a>什么是模式pattern</h3><ul>
<li><code>架构模型 an architecture-pattern</code>是一组在实践中反复出现的设计决策集合</li>
<li>具有已知的可复用性，并描述了一类框架</li>
</ul>
<h3 id="框架模式-an-architecture-pattern"><a href="#框架模式-an-architecture-pattern" class="headerlink" title="框架模式 an architecture-pattern"></a>框架模式 an architecture-pattern</h3><ul>
<li>模块模式<ul>
<li>分层模式</li>
</ul>
</li>
<li>组件与连接器模式<ul>
<li>代理模式</li>
<li>模式-视图-控制器模式</li>
<li>管道-过滤器模式</li>
<li>客户端-服务器模式</li>
<li>对等模式</li>
<li>面向服务的框架模式</li>
<li>发布-订阅模式</li>
<li>共享数据模式</li>
</ul>
</li>
<li>分配模式<ul>
<li>Map-reduce模式</li>
<li>多层模式</li>
</ul>
</li>
</ul>
<h3 id="分层模式-layered-pattern"><a href="#分层模式-layered-pattern" class="headerlink" title="分层模式 layered-pattern"></a>分层模式 layered-pattern</h3><ul>
<li><p>分层模式将软件划分为以“层 layer”为单位组成的集合</p>
</li>
<li><p>每个层是一个模块，提供一套协调一致的服务</p>
</li>
<li><p>每个层通过<code>公共接口 public-interface</code>进行暴露</p>
</li>
<li><p>使用必须是<strong>单向</strong>的</p>
</li>
<li><p>常见的分层模式有：</p>
<ul>
<li>三层架构：表示层，业务逻辑层和数据访问层</li>
<li>计算机网络TCP五层架构</li>
<li>OSI七层架构</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>分层模式定义了层与层之间的单向允许使用关系</li>
<li>约束条件 constraints<ul>
<li>每个软件部件都被分配到恰好一个层中</li>
<li>至少有两个层</li>
<li>不存在循环使用关系</li>
</ul>
</li>
<li>问题：<ul>
<li>添加层会导致系统的成本和复杂性的提高</li>
<li>层会对性能产生负面影响</li>
</ul>
</li>
</ul>
<h3 id="组件与连接器模式-component-and-connector-pattern"><a href="#组件与连接器模式-component-and-connector-pattern" class="headerlink" title="组件与连接器模式 component-and-connector-pattern"></a>组件与连接器模式 component-and-connector-pattern</h3><ul>
<li>组件与连接器模式是一种用于描述系统架构的模式</li>
<li>组件：是能够执行某些任务的模块</li>
<li>连接器：负责不同组件间的通信</li>
<li>该模式强调将系统划分为可供复用的独立组件，并通过连接器进行交互</li>
</ul>
<h3 id="代理模式-proxy-pattern"><a href="#代理模式-proxy-pattern" class="headerlink" title="代理模式 proxy-pattern"></a>代理模式 proxy-pattern</h3><ul>
<li>问题背景：许多系统由分布在多个服务器上的一组服务构建而成，如何构建<code>分布式软件 distributed-software</code>，使得服务使用者不需要知道服务提供者的性质和位置</li>
<li>解决思路：代理模式通过插入一个<code>中间层 intermediary</code>，称为代理，将客户端与服务提供者服务器分离开来。</li>
</ul>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>代理模式定义了一个运行时组件，称为代理，它在多个客户端和服务器之间充当进行通信和中介</li>
<li>组成部分：<ul>
<li>客户端 client：服务的请求者</li>
<li>服务器 server：服务的提供者</li>
<li>代理 broker，中间层，用于定位适合客户端请求的服务器，将请求转发给服务器，并将结果返回给客户端</li>
</ul>
</li>
<li>约束条件：客户端只能连接到代理，服务器也只能连接到代理</li>
<li>问题：<ul>
<li>代理会增加客户端与服务器之间的延迟，可能成为通信瓶颈</li>
<li>代理可能成为单点故障</li>
<li>代理可能成为安全攻击的目标</li>
</ul>
</li>
</ul>
<h3 id="模型-视图-控制器模式-model-view-controller-pattern"><a href="#模型-视图-控制器模式-model-view-controller-pattern" class="headerlink" title="模型-视图-控制器模式 model-view-controller-pattern"></a>模型-视图-控制器模式 model-view-controller-pattern</h3><ul>
<li>问题背景：用户界面软件是交互式应用程序中经常修改的部分，如何将用户界面功能和应用程序功能分开，同时仍能响应用户输入或底层应用程序数据的更改（当底层应用程序数据发生变化时，如何创建、维护和协调多个用户界面视图）</li>
</ul>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>MVC模式将应用程序分为三种组件<ul>
<li>M：包含应用程序的数据</li>
<li>V：显式底层数据的一部分并与用户交互</li>
<li>C：在 M 和 V 之间进行中介，并管理状态变化的通知</li>
</ul>
</li>
<li>约束条件：<ul>
<li>M，V 和 C 必须至少有一个实例</li>
</ul>
</li>
<li>问题：<ul>
<li>对于简单的用户界面来说，复杂性可能过高</li>
</ul>
</li>
</ul>
<h3 id="管道-过滤器模式-pipe-and-filter-pattern"><a href="#管道-过滤器模式-pipe-and-filter-pattern" class="headerlink" title="管道-过滤器模式 pipe-and-filter-pattern"></a>管道-过滤器模式 pipe-and-filter-pattern</h3><ul>
<li>问题背景：流式数据处理中，如何加快数据处理速度</li>
<li>解决思路：数据到达过滤器的输入端口后，结果转换，然后通过管道传递到下一个过滤器输入端口<ul>
<li>单个过滤器可以从管道中消费数据，也可以生产数据</li>
</ul>
</li>
</ul>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>组成：<ul>
<li>过滤器：一种将从输入端口读取的数据转换成写入其输出端口的数据的组件</li>
<li>管道：一种将数据从一个过滤器输出端口传递到另一个过滤器的输入端口的连接器</li>
</ul>
</li>
<li>关系：附加关系将过滤器的输出与管道的输入相关联，反之亦然</li>
<li>约束条件：<ul>
<li>连接的过滤器必须就沿着连接管道传递的数据类型达成一致</li>
</ul>
</li>
</ul>
<h3 id="客户端-服务器模式"><a href="#客户端-服务器模式" class="headerlink" title="客户端-服务器模式"></a>客户端-服务器模式</h3><ul>
<li>问题背景：存在<code>共享资源和服务</code>，许多分布式客户端希望访问这些资源和服务，希望<strong>控制对其的访问或提供服务的 质量</strong>，通过<strong>集中控制</strong>这些资源和服务阿里提高可用性</li>
<li>解决思路：客户端通过请求服务器的服务进行交互<ul>
<li>可能存在一个中央服务器和多个分布式服务器</li>
</ul>
</li>
</ul>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>问题：<ul>
<li>服务器可能成为性能瓶颈</li>
<li>服务器可能成为单点故障</li>
<li>在系统构建后，关于功能定位（在客户端还是服务器中）的决策复杂且成本高</li>
</ul>
</li>
</ul>
<h3 id="点多点模式-peer-to-peer-pattern"><a href="#点多点模式-peer-to-peer-pattern" class="headerlink" title="点多点模式 peer-to-peer-pattern"></a>点多点模式 peer-to-peer-pattern</h3><ul>
<li>问题背景：如何通过一个共同的协议将一组“相等的”分布式计算实体连接起来，让他们能以高可用性和可拓展性来阻止和共享其服务</li>
<li>解决思路：在点对点P2P模式中，组件作为对等体直接进行交互。所有对等体都是“相等的”。<ul>
<li>P2P通常是一种请求&#x2F;响应的交互方式，<strong>没有客户端-服务器模式的非对称性</strong></li>
</ul>
</li>
</ul>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>问题：<ul>
<li>管理数据一致性、数据&#x2F;服务的可用性、备份和恢复等都更加复杂</li>
<li>较小的P2P系统可能无法实现性能和可用性等质量目标</li>
</ul>
</li>
</ul>
<h3 id="面向服务的体系结构模式-service-oriented-architecture-pattern"><a href="#面向服务的体系结构模式-service-oriented-architecture-pattern" class="headerlink" title="面向服务的体系结构模式 service-oriented-architecture-pattern"></a>面向服务的体系结构模式 service-oriented-architecture-pattern</h3><ul>
<li>问题背景：如何支持在不同平台上运行、使用不同实现语言编写、由不同组织提供并分布在互联网上的分布式组件之间的互操作性</li>
<li>解决思路：面向服务的体系结构SOA模式描述了一组提供 和&#x2F;或 消费服务的分布式组件</li>
</ul>
<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>组成：<ul>
<li>组件：<ul>
<li>服务提供者：通过已发布的接口提供一个或多个服务</li>
<li>服务消费者：直接或通过中间件调用服务</li>
<li>企业服务总线 enterpise-service-bus ESB：作为<strong>中间件元素</strong>，可以在服务提供者和消费者之间路由和转化信息</li>
<li>服务注册表：供应商可使用注册表注册其服务，并运行时由消费者发现服务</li>
</ul>
</li>
<li>连接器：<ul>
<li>SOAP 连接器：使用SOAP协议进行Web服务之间的同步通信，通常通过HTTP进行</li>
<li>REST 连接器：依赖于HTTP协议的基本请求&#x2F;响应操作。</li>
<li>异步消息连接器：使用消息系统进行P2P或分布-订阅的**异步消息交换 asynchronous-message-exchange</li>
</ul>
</li>
</ul>
</li>
<li>问题：<ul>
<li>中间件存在与性能相关的开销，可能存在性能瓶颈，并且通常不提供性能保证</li>
</ul>
</li>
</ul>
<h3 id="分布-订阅模式-publish-subscirbe-pattern"><a href="#分布-订阅模式-publish-subscirbe-pattern" class="headerlink" title="分布-订阅模式 publish-subscirbe-pattern"></a>分布-订阅模式 publish-subscirbe-pattern</h3><p>问题背景：如何在生产者和消费者之间传递消息，使它们对彼此的身份&#x2F;存在毫不知情</p>
<h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>优势</p>
<ul>
<li>非常适合移动应用程序、普适计算和分布式嵌入式系统</li>
<li>鲁棒性 - 发布者或订阅者的故障不会导致整个系统崩溃</li>
<li>可扩展性 - 适用于构建由大量实体组成的分布式应用程序</li>
</ul>
</li>
<li><p>发布-订阅模式的缺点</p>
<ul>
<li>可靠性<ul>
<li>无法对代理服务器向订阅者传递内容提供强有力的保证。发布者发布事件后，假设所有相应的订阅者都将收到该事件。</li>
</ul>
</li>
<li>当订阅者和发布者过载代理服务器时，可能会在代理服务器中出现瓶颈。（可以通过负载均衡技术来解决</li>
</ul>
</li>
</ul>
<h3 id="共享数据模式"><a href="#共享数据模式" class="headerlink" title="共享数据模式"></a>共享数据模式</h3><ul>
<li><p>问题背景：各种计算组件需要共享和操作大量数据。这些数据<strong>不仅仅属于其中任何一个组件</strong>，系统如何存储和操作多个独立组件都有访问需求的<strong>持久数据</strong></p>
</li>
<li><p>解决思路：在共享数据模式中，交互主要通过多个数据访问者和至少一个共享数据存储组件的持久数据交换来实现</p>
<ul>
<li>交换可以由访问者或数据存储发起，连接器是数据读取和写入</li>
<li></li>
</ul>
</li>
<li><p>核心：</p>
<ul>
<li><strong>共享数据存储区</strong>：系统中的数据不保存在某个特定的组件或节点上，而是存储在一个共享的、全局可访问的地方。</li>
<li><strong>访问控制</strong>：由于多个组件可能会同时访问共享数据，如何控制对共享数据的访问和修改变得至关重要。通常需要引入锁机制、事务机制或版本控制来保证数据的一致性和避免并发冲突。</li>
<li><strong>数据一致性</strong>：共享数据模式面临的一个挑战是如何保持数据的一致性。由于数据由多个组件共享，在某一组件修改数据时，其他组件也应该能够感知并获取到最新的数据。这通常需要依赖某种同步机制，确保系统中的所有节点看到相同的视图。</li>
<li><strong>分布式共享</strong>：在分布式系统中，多个节点可能会有不同的副本或缓存副本，因此如何确保数据在多个副本之间同步、避免数据不一致是共享数据模式中的一个重要问题。</li>
</ul>
</li>
</ul>
<h3 id="Map-Reduce-分布式计算模式"><a href="#Map-Reduce-分布式计算模式" class="headerlink" title="Map-Reduce 分布式计算模式"></a>Map-Reduce 分布式计算模式</h3><p>- </p>
<h3 id="多层模式"><a href="#多层模式" class="headerlink" title="多层模式"></a>多层模式</h3><h3 id="策略和模式间的关系"><a href="#策略和模式间的关系" class="headerlink" title="策略和模式间的关系"></a>策略和模式间的关系</h3><h4 id="模式是由策略构建的"><a href="#模式是由策略构建的" class="headerlink" title="模式是由策略构建的"></a>模式是由策略构建的</h4><ul>
<li>多种策略的相互组合形成一种模式</li>
<li>MVC应用了：<ul>
<li>增加语义一致性</li>
<li>封装</li>
<li>使用中介者 intermediary</li>
</ul>
</li>
</ul>
<p>策略是用来解决特定问题的单个行动或技术，而模式是一种更高级别的设计解决方案，它将多个策略组合在一起，以解决更复杂的问题。模式提供一种通用的架构和组织原则，而策略则提供了具体的实现细节。策略是构成模式的组成要素</p>
<h4 id="策略增强了模式"><a href="#策略增强了模式" class="headerlink" title="策略增强了模式"></a>策略增强了模式</h4><ul>
<li>模式解决了特定的问题，但在某些方面可能存在问题</li>
<li>例如：代理模式中可能存在性能瓶颈、单点故障等</li>
<li>使用策略，增加资源以提高性能；维护多个副本以提高可用性</li>
</ul>
<p>策略用来增强模式，解决模式在某些方面的限制或弱点。通过合适的策略，可以改善模式的性能、可用性等质量属性，适应实际需求</p>
<h4 id="策略和模式相互作用"><a href="#策略和模式相互作用" class="headerlink" title="策略和模式相互作用"></a>策略和模式相互作用</h4><ul>
<li><p>每个策略都有优缺点</p>
</li>
<li><p>使用策略可以帮助减轻缺点</p>
</li>
<li><p>但没有万金油，一个常见的检测故障策略是 ping&#x2F;echo，但也存在问题：</p>
<ul>
<li>安全性，如何防止 ping 洪水攻击</li>
<li>性能：如何使 ping&#x2F;echo 开销最小</li>
<li>可修改性：如何将 ping&#x2F;echo 添加到现有架构中</li>
</ul>
</li>
<li><p>一个用于解决性能副作用的策略是“增加可用资源”（Increase Available Resources）。增加可用资源的常见副作用包括：</p>
<ul>
<li>成本：增加资源会带来额外的成本。</li>
<li>性能：如何高效利用增加的资源？</li>
</ul>
</li>
<li><p>一个用于解决资源高效利用副作用的策略是“调度策略”（Scheduling Policy）。调度策略的常见副作用包括：</p>
<ul>
<li>可修改性：如何将调度策略添加到现有架构中？</li>
<li>可修改性：如何在将来更改调度策略？</li>
</ul>
</li>
<li><p>架构模式是在实践中反复出现的设计决策的集合。</p>
</li>
<li><p>架构模式具有已知的属性，可以进行重复使用，并描述了一类架构。</p>
</li>
<li><p>策略比模式更简单。</p>
</li>
<li><p>模式对于真实系统来说是不完全的，因此需要通过策略进行补充。</p>
<ul>
<li>当满足特定系统的需求时，对模式的补充就会结束。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" data-id="cm7pquzij003er8v2glamcahv" data-title="软件架构设计期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/typora/">typora</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E9%A9%AC-%E5%90%8E%E7%AB%AF/">黑马:后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E5%9F%BA%E7%A1%80/" rel="tag">Vue基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html%E5%9F%BA%E7%A1%80/" rel="tag">html基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%BA%95%E5%B1%82/" rel="tag">java底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80/" rel="tag">js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" rel="tag">单体架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%B3%E6%B3%95/" rel="tag">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" rel="tag">闲杂经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC/" rel="tag">黑马</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDBC/" style="font-size: 11.67px;">JDBC</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Vue%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Vue基础</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/html%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">html基础</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/java%E5%BA%95%E5%B1%82/" style="font-size: 10px;">java底层</a> <a href="/tags/java%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">java框架</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">js基础</a> <a href="/tags/juc/" style="font-size: 10px;">juc</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">关系型</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" style="font-size: 11.67px;">单体架构</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 16.67px;">后端</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">基础</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 15px;">大学专业课</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" style="font-size: 11.67px;">学习规划</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 18.33px;">工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="font-size: 20px;">期末复习</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" style="font-size: 13.33px;">计算机四大件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">设计架构</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件架构设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">软件项目管理</a> <a href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">闲杂经验</a> <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">非关系型</a> <a href="/tags/%E9%AB%98%E9%98%B6/" style="font-size: 10px;">高阶</a> <a href="/tags/%E9%BB%91%E9%A9%AC/" style="font-size: 11.67px;">黑马</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/">markdown语法</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/LeetCode/">Leetcode刷题题解</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>