<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 线程池 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 线程池 池技术在实际开发当中是十分常见的，例如数据库连接池、http 连接池以及本次要研究的线程池都是对池思想的实际应用。池技术的核心思想就是完成对资源的复用，避免重复创建和销毁资源造成的开销，提高对资源的利用率。 线程池介绍 顾名思义就是一个以线程作为复用资源的池技术，提供了一种限制和管理线程资源的方式，每个线程池还会维护基本统计信息，例如已经完成任务的数量等 线程池技术的好处大致有：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池">
<meta property="og:url" content="http://example.com/2025/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="Java 线程池 池技术在实际开发当中是十分常见的，例如数据库连接池、http 连接池以及本次要研究的线程池都是对池思想的实际应用。池技术的核心思想就是完成对资源的复用，避免重复创建和销毁资源造成的开销，提高对资源的利用率。 线程池介绍 顾名思义就是一个以线程作为复用资源的池技术，提供了一种限制和管理线程资源的方式，每个线程池还会维护基本统计信息，例如已经完成任务的数量等 线程池技术的好处大致有：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/3.jpg">
<meta property="article:published_time" content="2025-03-29T14:38:15.000Z">
<meta property="article:modified_time" content="2025-03-30T05:45:20.521Z">
<meta property="article:author" content="moru">
<meta property="article:tag" content="java 并发">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/3.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 线程池",
  "url": "http://example.com/2025/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
  "image": "http://example.com/img/3.jpg",
  "datePublished": "2025-03-29T14:38:15.000Z",
  "dateModified": "2025-03-30T05:45:20.521Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 线程池',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(./img/3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 线程池</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java 线程池</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-29T14:38:15.000Z" title="发表于 2025-03-29 22:38:15">2025-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-30T05:45:20.521Z" title="更新于 2025-03-30 13:45:20">2025-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java-线程池"><a class="header-anchor" href="#Java-线程池"></a>Java 线程池</h1>
<p>池技术在实际开发当中是十分常见的，例如数据库连接池、http 连接池以及本次要研究的线程池都是对池思想的实际应用。池技术的核心思想就是完成对资源的复用，避免重复创建和销毁资源造成的开销，提高对资源的利用率。</p>
<h2 id="线程池介绍"><a class="header-anchor" href="#线程池介绍"></a>线程池介绍</h2>
<p>顾名思义就是一个以线程作为复用资源的池技术，提供了一种限制和管理线程资源的方式，每个线程池还会维护基本统计信息，例如已经完成任务的数量等</p>
<p>线程池技术的好处大致有：</p>
<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ul>
<p>【线程池一般用于执行多个不相关联的耗时任务，没有多线程情况下，程序是阻塞式的顺序执行，而使用线程池的话可以让多个不相关的任务同时执行，提高效率】</p>
<h2 id="Executor-框架介绍"><a class="header-anchor" href="#Executor-框架介绍"></a>Executor 框架介绍</h2>
<p>java 5 之后引入的，通过 Executor 来启动线程比使用 Thread 的 start 更优，其中最关键的一点是：避免了 this 逃逸问题</p>
<blockquote>
<p>this 逃逸指的是构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发问题。</p>
</blockquote>
<p>Executor 框架提供了线程池的管理、线程工厂、队列以及拒绝策略等，Executor 框架让并发编程更简单</p>
<h3 id="框架组成："><a class="header-anchor" href="#框架组成："></a>框架组成：</h3>
<h4 id="任务-Runnable-Callable"><a class="header-anchor" href="#任务-Runnable-Callable"></a>任务 Runnable/Callable</h4>
<p>执行任务需要实现 Runnable/Callable 接口，Runnable/Callable 接口实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadExecutor 执行。</p>
<h4 id="任务的执行-Executor"><a class="header-anchor" href="#任务的执行-Executor"></a>任务的执行 Executor</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503292250650.png" alt="Executor 的继承实现关系"></p>
<p>重点关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在实际使用线程池的过程中使用频率较高。</p>
<h3 id="异步计算的结果-Future"><a class="header-anchor" href="#异步计算的结果-Future"></a>异步计算的结果 Future</h3>
<p>Future 接口及其实现类 FutureTask 类都可以代表异步计算的结果</p>
<h3 id="Executor-的执行过程"><a class="header-anchor" href="#Executor-的执行过程"></a>Executor 的执行过程</h3>
<p>当我们把 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p>
<p><strong><code>Executor</code> 框架的使用示意图</strong>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503292255192.png" alt="Executor 框架的使用示意图">、</p>
<ol>
<li>主线程创建实现了 Runnable/Callable 接口的任务对象</li>
<li>将任务对象交给 ExecutorService 执行：通过 execute 方法或 submit 方法来执行任务对象（如果执行 submit 方法 ExecutorService 会返回一个 FutureTask 对象）</li>
<li>主线程执行 FutureTask 的 get 方法来等待任务执行完毕，主线程也可以使用 cancel 方法来取消任务的执行。</li>
</ol>
<h3 id="ThreadPoolExecutor-类介绍"><a class="header-anchor" href="#ThreadPoolExecutor-类介绍"></a>ThreadPoolExecutor 类介绍</h3>
<p>线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类</p>
<h3 id="参数介绍"><a class="header-anchor" href="#参数介绍"></a>参数介绍</h3>
<p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个重要的参数：</p>
<ol>
<li>corePoolSize：任务队列未达到队列容量时，最大可以同时运行的线程数量</li>
<li>maximumPoolSize：任务队列达到容量时，最大可以同时运行的线程数量（负载状态，上限增大了）</li>
<li>workQueue：新任务达到时，会先判断当前运行的线程数量是否达到核心线程数，如果达到了就放进队列中。</li>
</ol>
<p>其他参数：</p>
<ul>
<li>keepAliveTime：线程池中的线程数量大于 corePoolSize 时，如果没有新任务提交，核心线程外的线程不会立即消耗，而是会等待，直到等待时间超过 keepAliveTime 才会被销毁</li>
<li>unit：keepAliveTime 参数的时间单位</li>
<li>threadFactory：Executor 创建新线程用到的</li>
<li>handler：拒绝策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503292321562.png" alt="线程池各个参数的关系"></p>
<p>拒绝策略：当同时运行的线程数量达到最大线程数量且队列已满时，对新到达任务如何处理的策略。</p>
<p><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。（默认使用的）</p>
<p><code>ThreadPoolExecutor.CallerRunsPolicy</code>：将任务回退给调用者，使用调用者的线程来执行任务。调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p>
<p><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</p>
<p><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</p>
<h3 id="线程池创建方式"><a class="header-anchor" href="#线程池创建方式"></a>线程池创建方式</h3>
<h4 id="通过构造函数创建（推荐）"><a class="header-anchor" href="#通过构造函数创建（推荐）"></a>通过构造函数创建（推荐）</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503292326866.png" alt="构造函数"></p>
<h4 id="通过-Executor-框架的工具类-Executors-创建（一般不采用）"><a class="header-anchor" href="#通过-Executor-框架的工具类-Executors-创建（一般不采用）"></a>通过 Executor 框架的工具类 Executors 创建（一般不采用）</h4>
<p>通过该工具类可以创建多种类型的线程池：</p>
<ul>
<li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<h3 id="线程池常用的阻塞队列"><a class="header-anchor" href="#线程池常用的阻塞队列"></a>线程池常用的阻塞队列</h3>
<p>不同的线程池会采用不同的阻塞队列</p>
<ul>
<li>无界队列 LinkedBlockingQueue（容量为 Integer.MAX_VALUE，相当于无限大了）：FixedThreadPool 和 SingleThreadExecutor 采用的队列。</li>
<li>同步队列 SynchronousQueue，CachedThreadPool 采用的阻塞队列，没有容量，不存储元素，没事保证对于提交的任务，如果有空闲线程就用空闲线程，否则创建一个新线程来处理任务。即 CachedThreadPool 的最大线程数量为 Integer.MAX_VALUE，可能会导致 OOM</li>
<li>延迟阻塞队列：ScheduledThreadPool 和 SingleThreadScheduledExecutor 采用。延迟阻塞队列内部的元素按照 delay 的时间长短来对任务进行排序，采用堆结构，可以保证每次出兑对任务都是队列中执行时间最靠前对。有扩容机制（1.5 倍扩容，最大容量是 Integer.MAX_VALUE）</li>
</ul>
<h2 id="常见对比"><a class="header-anchor" href="#常见对比"></a>常见对比</h2>
<h3 id="Runnabl-vs-Callable"><a class="header-anchor" href="#Runnabl-vs-Callable"></a>Runnabl vs Callable</h3>
<p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<code>Runnable</code> 接口不会返回结果或抛出检查异常，但是 <code>Callable</code> 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口，这样代码看起来会更加简洁。</p>
<p><code>Runnable.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execute-vs-submit"><a class="header-anchor" href="#execute-vs-submit"></a>execute() vs submit()</h3>
<ul>
<li>返回值：execute 方法用于提交不需要返回值的任务，通常用于执行 Runnable 任务，无法判断任务是否执行成功；submit 方法用于提交需要返回值的任务，可以提交 Runnable 或 Callable 任务。submit 返回一个 Future 对象，通过该对象可以判断任务是否执行成功并获取任务返回值（get 方法会阻塞当前线程直到任务完成，<code>get（long timeout，TimeUnit unit）</code>多了一个超时时间，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出）</li>
<li>异常处理：使用 submit 方法可以通过 Future 对象处理任务执行过程中抛出的异常；使用 execute 方法时，异常处理需要通过自定义 ThreadFactory 或 ThreadPoolExecutor 的 afterExecutr 方法阿里处理</li>
</ul>
<h3 id="shutdown-vs-shutdownNow"><a class="header-anchor" href="#shutdown-vs-shutdownNow"></a>shutdown vs shutdownNow</h3>
<ul>
<li>shutdown：关闭线程池，线程池状态变为 SHUTDOWN，线程池不再接受新任务，但是队列里的任务必须执行完毕</li>
<li>shutdownNow：关闭线程池，线程池的状态变为 STOP，线程池会终止当前正在运行的任务，并通知处理排队的任务并返回正在等待执行的 List</li>
</ul>
<h3 id="isTerminated-vs-isShutdown"><a class="header-anchor" href="#isTerminated-vs-isShutdown"></a>isTerminated vs isShutdown</h3>
<ul>
<li>isTerminated：当调用 shutdown 方法后，并且所有任务提交的任务完成后会返回 true</li>
<li>isShutdown：当调用 shutdown 方法后，返回true</li>
</ul>
<h2 id="线程池最佳实践"><a class="header-anchor" href="#线程池最佳实践"></a>线程池最佳实践</h2>
<h3 id="正确声明"><a class="header-anchor" href="#正确声明"></a>正确声明</h3>
<p>必须通过手动调用 ThreadPoolExecutor 的构造函数来声明，避免使用 Executor 类创建线程池，可能有 OOM 风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong>：使用的是阻塞队列 <code>LinkedBlockingQueue</code>，任务队列的默认长度和最大长度为 <code>Integer.MAX_VALUE</code>，可以看作是无界队列，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong>：使用的是同步队列 <code>SynchronousQueue</code>，允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<p>说白了内置的线程池都因为使用了无界队列，会导致过多请求的积压而产生 OOM问题，自定义线程池则可以<strong>使用有界队列，控制线程创建数量。</strong></p>
<p>除了 OOM 之外，还有其他两个原因：实际使用中需要根据设备的性能、具体业务场景来配置线程池的参数，例如核心线程数、使用的任务队列以及拒绝策略等；显式的为线程池命名有利于后期问题的排查和解决。</p>
<h3 id="监控线程池运行状态"><a class="header-anchor" href="#监控线程池运行状态"></a>监控线程池运行状态</h3>
<p>可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件，还可以利用 <code>ThreadPoolExecutor</code> 的相关 API 做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p>
<h3 id="不同类别的业务使用不同的线程池"><a class="header-anchor" href="#不同类别的业务使用不同的线程池"></a>不同类别的业务使用不同的线程池</h3>
<p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p>
<p>真实事故案例 <a target="_blank" rel="noopener" href="https://heapdump.cn/article/646639">线程池运用不当的一次线上事故 | HeapDump性能社区</a></p>
<h3 id="线程池命名"><a class="header-anchor" href="#线程池命名"></a>线程池命名</h3>
<p>初始化线程池的时候需要显式命名（设置线程池名称前缀），有利于定位问题</p>
<p>线程的默认命名是：<code>pool-1-thread-n</code> ，没有业务含义，不利于我们定位问题。</p>
<h4 id="两种命名方式"><a class="header-anchor" href="#两种命名方式"></a>两种命名方式</h4>
<p>利用 guava 的 ThreadFactoryBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure>
<p>自己实现 <code>ThreadFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确配置线程池参数"><a class="header-anchor" href="#正确配置线程池参数"></a>正确配置线程池参数</h3>
<p>对于核心线程数的设置，有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务 (N)：</strong> 这种任务消耗的主要是 CPU 资源，线程数应设置为 N（CPU 核心数）。由于任务主要瓶颈在于 CPU 计算能力，与核心数相等的线程数能够最大化 CPU 利用率，过多线程反而会导致竞争和上下文切换开销。【为什么不是 N+1，设置为 N+1 的初衷是希望预留线程处理突发暂停，但是实际上处理缺页中断等情况仍然需要占用 cpu 核心】</li>
<li><strong>I/O 密集型任务(M * N)：</strong> 这类任务大部分时间处理 I/O 交互，线程在等待 I/O 时不占用 CPU。 为了充分利用 CPU 资源，线程数可以设置为 M * N，其中 N 是 CPU 核心数，M 是一个大于 1 的倍数，建议默认设置为 2 ，具体取值取决于 I/O 等待时间和任务特点，需要通过测试和监控找到最佳平衡点。</li>
</ul>
<p>【如何判断 cpu 密集还是 io 密集，如果需要对数据进行大量的操作，例如计算或排序，这就是 cpu 密集，如果涉及到网络读写，文件读写这类就是 io 密集，这类任务特点是 cpu 计算耗时相比于 io 操作完成的时间比较少，大部分时间在等待 io 操作上】</p>
<p>更严谨的计算公式：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）= 线程运行总时间 - ST（线程计算时间）</code>。</p>
<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队</a></p>
<h3 id="记住要关闭线程池"><a class="header-anchor" href="#记住要关闭线程池"></a>记住要关闭线程池</h3>
<p>线程池提供了两个关闭方法：</p>
<ul>
<li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<hr>
<p>原文链接：https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">http://example.com/2025/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E5%B9%B6%E5%8F%91/">java 并发</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/./img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/30/Java/JavaIO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" title="JavaIO模型详解"><img class="cover" src="/./img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaIO模型详解</div></div><div class="info-2"><div class="info-item-1">[TOC] 参考文献：  Java IO 模型详解 | JavaGuide   Java IO 模型详解 什么是 IO 想要了解什么是 Java IO 的模型就需要先知道 IO 是什么？IO（Input/Output），顾名思义就是输入/输出 可以先从计算机结构的视角来理解 IO：冯诺依曼体系中，IO 描述了计算机系统与外部设备之间通信的过程， 再从应用角度来理解 IO：在 OS 相关知识可以得知，为了保证系统稳定性和安全性，进程地址空间被划分为用户态和内核态，平时运行的程序都是在用户态的，之后内核态才可以进行系统级资源的操作，例如文件管理、进程通信、内存管理等。而 IO 操作也就是需要通过内核态度权限才可以进行的操作。而用户态下的应用程序是无法直接访问内核态的资源的，因此每当需要执行 IO 操作，就需要由应用发起一次系统调用请求 os 帮助完成。这就涉及到了用户态和内核态度相互切换，因此会就消耗一部分的性能 常见的 IO 模型 UNIX 系统下，IO 一共有五种：同步阻塞 IO、同步非阻塞 IO、IO 多路复用、信号驱动 IO 和异步 IO Java 中常见的三种 IO...</div></div></div></a><a class="pagination-related" href="/2025/03/23/Java/javaweb/" title="javaweb"><img class="cover" src="/./img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">javaweb</div></div><div class="info-2"><div class="info-item-1">[TOC] JavaWeb基础 参考资料： 尚硅谷全新JavaWeb教程，企业主流javaweb技术栈_哔哩哔哩_bilibili。 Tomcat 10  Tomcat 是一款服务器软件，是专门用来运行 web 应用的软件。也是由 java 开发的  常见的 javaweb：  Tomcat：当前应用最广的 JavaWeb 服务器。 Jetty：更轻量级、更灵活的 servlet 容器。 GlassFish：Oracle 开发的 JavaWeb 服务器，应用不是很广泛。 Resin：支持 JavaEE，应用越来越广。 Weblogic：付费，支持 JavaEE，适合大型项目。 Websphere：付费，支持 JavaEE，适合大型项目。  Tomcat 文件夹中的 log 文件记录的是日志相关，随着使用时间增长，可能会占用比较大的空间，注意定时请理。我们平时如果要对 web 项目进行部署，需要将项目部署到 webapps 文件夹当中。 WebAPP 中的项目 项目文件结构 app：本应用目录 —-...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">Java 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">线程池介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">Executor 框架介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">框架组成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-Runnable-Callable"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">任务 Runnable&#x2F;Callable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C-Executor"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">任务的执行 Executor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9C-Future"><span class="toc-number">1.2.2.</span> <span class="toc-text">异步计算的结果 Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">Executor 的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor-%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">ThreadPoolExecutor 类介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.</span> <span class="toc-text">参数介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.6.</span> <span class="toc-text">线程池创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">通过构造函数创建（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB-Executors-%E5%88%9B%E5%BB%BA%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E9%87%87%E7%94%A8%EF%BC%89"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">通过 Executor 框架的工具类 Executors 创建（一般不采用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">线程池常用的阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">常见对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnabl-vs-Callable"><span class="toc-number">1.3.1.</span> <span class="toc-text">Runnabl vs Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute-vs-submit"><span class="toc-number">1.3.2.</span> <span class="toc-text">execute() vs submit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-vs-shutdownNow"><span class="toc-number">1.3.3.</span> <span class="toc-text">shutdown vs shutdownNow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isTerminated-vs-isShutdown"><span class="toc-number">1.3.4.</span> <span class="toc-text">isTerminated vs isShutdown</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.4.</span> <span class="toc-text">线程池最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E"><span class="toc-number">1.4.1.</span> <span class="toc-text">正确声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">监控线程池运行状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.4.3.</span> <span class="toc-text">不同类别的业务使用不同的线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%BD%E5%90%8D"><span class="toc-number">1.4.4.</span> <span class="toc-text">线程池命名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">两种命名方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">正确配置线程池参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E4%BD%8F%E8%A6%81%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.4.6.</span> <span class="toc-text">记住要关闭线程池</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件测试"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件测试"/></a><div class="content"><a class="title" href="/2025/04/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件测试">软件测试</a><time datetime="2025-04-21T13:28:31.000Z" title="发表于 2025-04-21 21:28:31">2025-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树状数组"/></a><div class="content"><a class="title" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组">树状数组</a><time datetime="2025-04-15T04:47:39.000Z" title="发表于 2025-04-15 12:47:39">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线段树"/></a><div class="content"><a class="title" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树">线段树</a><time datetime="2025-04-15T04:40:24.000Z" title="发表于 2025-04-15 12:40:24">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202504281520603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2025/04/03/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2025-04-03T05:08:18.000Z" title="发表于 2025-04-03 13:08:18">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/Java/FreeMarker/" title="FreeMarker"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FreeMarker"/></a><div class="content"><a class="title" href="/2025/04/01/Java/FreeMarker/" title="FreeMarker">FreeMarker</a><time datetime="2025-04-01T08:37:43.000Z" title="发表于 2025-04-01 16:37:43">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>