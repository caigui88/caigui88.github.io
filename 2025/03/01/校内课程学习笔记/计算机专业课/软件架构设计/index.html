<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>软件架构设计期末复习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="软件架构设计期末复习CH1 软件架构Software Architecture 软件&amp;架构什么是软件体系结构：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系 以及两者的属性。 架构即即是一种软件结构一系列的元素由某种关系串联起来构成一个结构 structure 一个软件系统由许多的structure构成（单一个结构无法称之为架构） Architecture 架构三个">
<meta property="og:type" content="article">
<meta property="og:title" content="软件架构设计期末复习">
<meta property="og:url" content="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="软件架构设计期末复习CH1 软件架构Software Architecture 软件&amp;架构什么是软件体系结构：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系 以及两者的属性。 架构即即是一种软件结构一系列的元素由某种关系串联起来构成一个结构 structure 一个软件系统由许多的structure构成（单一个结构无法称之为架构） Architecture 架构三个">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://chiichen.github.io/assets/image-J21vDhO7.png">
<meta property="og:image" content="https://chiichen.github.io/assets/image-hYSiaVbE.png">
<meta property="og:image" content="https://chiichen.github.io/assets/image-DQ2sDQ7v.png">
<meta property="article:published_time" content="2025-03-01T03:35:47.265Z">
<meta property="article:modified_time" content="2025-02-19T14:53:18.472Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="期末复习">
<meta property="article:tag" content="软件架构设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chiichen.github.io/assets/image-J21vDhO7.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-校内课程学习笔记/计算机专业课/软件架构设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.265Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      软件架构设计期末复习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="软件架构设计期末复习"><a href="#软件架构设计期末复习" class="headerlink" title="软件架构设计期末复习"></a>软件架构设计期末复习</h1><h2 id="CH1-软件架构"><a href="#CH1-软件架构" class="headerlink" title="CH1 软件架构"></a>CH1 <strong>软件架构</strong></h2><h3 id="Software-Architecture-软件-架构"><a href="#Software-Architecture-软件-架构" class="headerlink" title="Software Architecture 软件&amp;架构"></a>Software Architecture 软件&amp;架构</h3><p><strong>什么是软件体系结构</strong>：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系</p>
<p>以及两者的属性。</p>
<h3 id="架构即即是一种软件结构"><a href="#架构即即是一种软件结构" class="headerlink" title="架构即即是一种软件结构"></a>架构即即是一种软件结构</h3><p>一系列的元素由某种关系串联起来构成一个结构 <strong>structure</strong></p>
<p>一个软件系统由许多的<strong>structure</strong>构成（单一个结构无法称之为架构）</p>
<h3 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture 架构"></a>Architecture <strong>架构</strong></h3><h4 id="三个重要特征："><a href="#三个重要特征：" class="headerlink" title="三个重要特征："></a>三个重要特征：</h4><ol>
<li><strong>Module 模块</strong></li>
</ol>
<ul>
<li>一些结构将系统划分为实现单元，我们称之为模块。</li>
<li>模块被分配具体的计算责任，并且是编程团队工作任务的基础。</li>
<li>在大型项目中，这些元素（模块）会被进一步划分，以便分配给子团队。</li>
</ul>
<ol start="2">
<li><strong>Component and Connector 组件和连接器</strong></li>
</ol>
<ul>
<li><p>其他结构关注于元素在<strong>运行时</strong>相互交互的方式，以执行系统的功能。这种运行时结构称之为<strong>Component and Connector (C&amp;C)结构 组件和连接器</strong>。</p>
</li>
<li><p>实际应用中，组件基本上都是运行时实体</p>
</li>
</ul>
<ol start="3">
<li><strong>Allocation</strong> <strong>分配</strong></li>
</ol>
<ul>
<li><p>分配结构描述了从软件结构到系统环境的映射</p>
</li>
<li><p>分配结构描述了软件系统的物理部署和资源管理，通常涉及如何将模块和组件映射到硬件资源上。这有助于优化系统性能和资源利用。</p>
</li>
</ul>
<h4 id="什么样的结构具有架构性"><a href="#什么样的结构具有架构性" class="headerlink" title="什么样的结构具有架构性"></a>什么样的结构具有架构性</h4><ul>
<li><p>可以实现对系统和系统性质的推理的<strong>结构structure</strong>是<strong>成结构性Architectural</strong></p>
</li>
<li><p>这种推理应该是关于系统的某个对利益相关者来说重要的属性。</p>
</li>
<li><p>这些属性包括：</p>
<ul>
<li>系统实现的功能</li>
<li>系统在面对故障时的可用性</li>
<li>对系统进行特定更改的难度</li>
<li>系统对用户请求的响应速度</li>
<li>其他许多属性。</li>
</ul>
</li>
</ul>
<h3 id="任何系统都有一个软件架构"><a href="#任何系统都有一个软件架构" class="headerlink" title="任何系统都有一个软件架构"></a>任何系统都有一个软件架构</h3><p>但是这个架构可能没有为任何人所知。</p>
<ul>
<li><p>可能所有设计该系统的人都已经离开。</p>
</li>
<li><p>可能文档已经消失（或从未产生）。</p>
</li>
<li><p>可能源代码已丢失（或从未提交）。</p>
</li>
</ul>
<h3 id="架构是一种抽象"><a href="#架构是一种抽象" class="headerlink" title="架构是一种抽象"></a>架构是一种抽象</h3><blockquote>
<p>它着眼于系统的整体结构和关键特性，而<strong>不涉及细节实现</strong>。</p>
</blockquote>
<ul>
<li><p>架构会省略元素的某些信息————在推理系统方面没有作用的信息</p>
</li>
<li><p>架构抽象允许我们从元素如何排列、如何交互、如何组合这一角度来看待系统。</p>
</li>
<li><p>对于系统的抽象有利于我们降低最终系统架构的复杂性</p>
</li>
</ul>
<h3 id="架构包含行为"><a href="#架构包含行为" class="headerlink" title="架构包含行为"></a>架构包含行为</h3><blockquote>
<p>行为可以体现系统内元素的关系</p>
</blockquote>
<ul>
<li><p>在能够用于推理系统的前提下，每个元素的行为都是架构的一部分。</p>
</li>
<li><p>这种行为体现了元素之间的相互作用，这显然是架构定义的一部分。</p>
</li>
</ul>
<h3 id="结构与视图"><a href="#结构与视图" class="headerlink" title="结构与视图"></a>结构与视图</h3><ul>
<li><p>视图是由系统设计参与者编写和读取的一组连贯的架构元素的表示</p>
</li>
<li><p>结构是元素本身的集合，本身存在于硬件或软件中</p>
</li>
<li><p>总结即是：视图是结构的一种表示形式</p>
</li>
<li><p>架构师设计结构时，使用文档记录结构的视图 views</p>
</li>
</ul>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><ul>
<li><p>模块结构代表着系统是如何通过一系列代码或数据单元进行结构化的</p>
</li>
<li><p>在任何模块结构中，元素都是某种类系的模块(如：class、layer、或者仅是功能的划分等等，都是实现单元)</p>
</li>
</ul>
<h3 id="组件和连接器结构"><a href="#组件和连接器结构" class="headerlink" title="组件和连接器结构"></a>组件和连接器结构</h3><ul>
<li><p>C&amp;C结构代表着系统是如何由一系列具有运行时行为（组件）和交互（连接器）的元素进行结构化的。</p>
</li>
<li><p><strong>元素element</strong>是运行时的<strong>组件component</strong>，如services、peers、clients、servers等</p>
</li>
<li><p><strong>连接器Connector</strong>是组件<strong>组件 component</strong>间相互交流的工具，如调用-返回、进程同步操作符、管道或其他操作符</p>
</li>
</ul>
<blockquote>
<p>MapReduce 映射&amp;归约</p>
<p><strong>Map 阶段</strong>：</p>
<ul>
<li>数据切割为小的数据块</li>
</ul>
<p><strong>Shuffle和Sort阶段</strong>：</p>
<ul>
<li>Map阶段的输出会传递给Shuffle和Sort阶段。这个阶段将相同的key聚集在一起并排序，为Reduce阶段做准备。</li>
</ul>
<p><strong>Reduce阶段</strong>：</p>
<ul>
<li>Reduce阶段会接收来自Shuffle和Sort的中间结果，进行归约计算。Reduce任务会对相同的key的&lt;key, value&gt;对进行处理，将它们合并成最终结果。</li>
<li>举例：在单词统计中，Reduce阶段会将相同单词的1相加，计算出每个单词的总次数，如 &lt;单词, 总次数&gt; 。</li>
</ul>
</blockquote>
<h3 id="分配结构"><a href="#分配结构" class="headerlink" title="分配结构"></a>分配结构</h3><ul>
<li><p>展示软件系统的逻辑设计与物理资源之间的映射关系。描述了如何将系统的模块和组件分配到硬件、网络和组织等实际环境中，从而体现系统的物理部署方式、资源使用和依赖关系。</p>
</li>
<li><p>主要关注系统如何与外部环境交互以及如何利用资源</p>
</li>
</ul>
<h4 id="分配结构包含以下三种视角："><a href="#分配结构包含以下三种视角：" class="headerlink" title="分配结构包含以下三种视角："></a>分配结构包含以下三种视角：</h4><p><strong>部署视图 Deployment View</strong></p>
<h3 id="常见的模块结构"><a href="#常见的模块结构" class="headerlink" title="常见的模块结构"></a>常见的模块结构</h3><h4 id="分解结构-Decomposition-structure"><a href="#分解结构-Decomposition-structure" class="headerlink" title="分解结构 Decomposition-structure"></a>分解结构 Decomposition-structure</h4><ul>
<li><p>用来展示模块是如何被划分成更小的模块的</p>
</li>
<li><p>分解结构在很大程度上决定了系统的可修改性，通过确保可能的变化是局部的。</p>
</li>
</ul>
<h4 id="使用结构-Uses-structure"><a href="#使用结构-Uses-structure" class="headerlink" title="使用结构 Uses-structure"></a>使用结构 Uses-structure</h4><ul>
<li><p>每一个在使用模块中的<strong>unit</strong>也是模块</p>
</li>
<li><p>单元间的联系是以使用与被使用，是依赖与被依赖的形式</p>
</li>
<li><p>如果<strong>A单元</strong>的合法使用需要使用到<strong>B单元</strong>的某个正确版本的功能，则说明：A单元正在使用B单元</p>
</li>
<li><p>轻松创建系统子集的能力允许进行增量开发。</p>
</li>
</ul>
<h4 id="分层结构-Layer-structure"><a href="#分层结构-Layer-structure" class="headerlink" title="分层结构 Layer-structure"></a>分层结构 Layer-structure</h4><ul>
<li><p>每一个模块都称为<strong>层</strong> <strong>layer</strong></p>
</li>
<li><p><strong>层</strong>被抽象为<strong>虚拟机</strong> <strong>virtual machine</strong>，通过接口提供一组内聚的服务</p>
</li>
<li><p>层以预先设定好的接口去使用其他的层，</p>
</li>
</ul>
<h4 id="类（或泛化）结构-Class-or-generalization-structure"><a href="#类（或泛化）结构-Class-or-generalization-structure" class="headerlink" title="类（或泛化）结构 Class (or generalization) structure"></a>类（或泛化）结构 Class (or generalization) structure</h4><h4 id="数据模型结构-Data-model-structure"><a href="#数据模型结构-Data-model-structure" class="headerlink" title="数据模型结构 Data model structure"></a>数据模型结构 Data model structure</h4><h4 id="服务结构-Service-structure"><a href="#服务结构-Service-structure" class="headerlink" title="服务结构 Service structure"></a>服务结构 Service structure</h4><h4 id="并发结构-Concurrency-structure"><a href="#并发结构-Concurrency-structure" class="headerlink" title="并发结构 Concurrency structure"></a>并发结构 Concurrency structure</h4><h3 id="常见的分配结构"><a href="#常见的分配结构" class="headerlink" title="常见的分配结构"></a>常见的分配结构</h3><h4 id="部署结构-Deployment-structure"><a href="#部署结构-Deployment-structure" class="headerlink" title="部署结构 Deployment structure"></a>部署结构 Deployment structure</h4><h4 id="实施结构-Implementation-structure"><a href="#实施结构-Implementation-structure" class="headerlink" title="实施结构 Implementation structure"></a>实施结构 Implementation structure</h4><h4 id="工作分配结构-Work-assignment-structure"><a href="#工作分配结构-Work-assignment-structure" class="headerlink" title="工作分配结构 Work assignment structure"></a>工作分配结构 Work assignment structure</h4><h4 id="架构模式-Architectural-Patterns"><a href="#架构模式-Architectural-Patterns" class="headerlink" title="架构模式 Architectural Patterns"></a>架构模式 Architectural Patterns</h4><h2 id="CH2-为什么需要软件架构"><a href="#CH2-为什么需要软件架构" class="headerlink" title="CH2 为什么需要软件架构"></a>CH2 为什么需要软件架构</h2><h3 id="禁止或启用系统的质量属性"><a href="#禁止或启用系统的质量属性" class="headerlink" title="禁止或启用系统的质量属性"></a>禁止或启用系统的质量属性</h3><ul>
<li><p>系统是否能够展示其期望的（或必需的）质量属性在很大程度上取决于其体系结构。</p>
<ul>
<li><p>性能</p>
</li>
<li><p>可修改性</p>
</li>
<li><p>安全性</p>
</li>
<li><p>可扩展性</p>
</li>
<li><p>可重用性</p>
</li>
</ul>
</li>
</ul>
<h3 id="推理和管理变更"><a href="#推理和管理变更" class="headerlink" title="推理和管理变更"></a>推理和管理变更</h3><ul>
<li><p>每个体系结构都将可能的更改划分为三类</p>
<ul>
<li>局部变更可以通过修改单个元素来实现</li>
<li>非局部的变更需要修改多个元素，但会保留底层框架</li>
<li>整个软件框架的变更，会影响元素相互作用的基本方式</li>
</ul>
</li>
<li><p>综上，局部的变更是最节约成本的，因此一个好的框架需要具备：最常见的更改是局部的</p>
</li>
</ul>
<h3 id="最早的设计决定"><a href="#最早的设计决定" class="headerlink" title="最早的设计决定"></a>最早的设计决定</h3><ul>
<li><p>软件体系结构即是关于系统的最早设计决策的表现。</p>
</li>
<li><p>这些早期决策会影响系统的剩余开发、部署和维护寿命</p>
</li>
</ul>
<h3 id="定义在实现-Implementation-上的约束"><a href="#定义在实现-Implementation-上的约束" class="headerlink" title="定义在实现(Implementation)上的约束"></a>定义在实现(Implementation)上的约束</h3><ul>
<li><p>如果实现符合体系结构规定的设计决策，则会展示一个体系结构。</p>
<ul>
<li><p>该实现必须作为规定的元素的集合来实现</p>
</li>
<li><p>这些元素必须以规定的方式相互作用</p>
</li>
</ul>
</li>
<li><p>每个计划都是对实现者的约束</p>
</li>
</ul>
<h3 id="体系结构影响着系统的组织结构"><a href="#体系结构影响着系统的组织结构" class="headerlink" title="体系结构影响着系统的组织结构"></a>体系结构影响着系统的组织结构</h3><ul>
<li><p>架构规定了正在开发中的系统的结构选择</p>
</li>
<li><p>架构通常作为 work-breakdown 结构的基础</p>
</li>
<li><p>而 work-breakdown 结构又可以反作用于：</p>
<ul>
<li><p>计划、计划和预算的单位</p>
</li>
<li><p>团队间通信渠道</p>
</li>
<li><p>配置和文件系统的组织结构</p>
</li>
<li><p>集成和测试计划和程序</p>
</li>
<li><p>维护活动</p>
</li>
</ul>
</li>
</ul>
<h3 id="定义好的架构可以作为系统骨架的原型"><a href="#定义好的架构可以作为系统骨架的原型" class="headerlink" title="定义好的架构可以作为系统骨架的原型"></a>定义好的架构可以作为系统骨架的原型</h3><ul>
<li><p>骨架系统是指在系统的大部分功能创建之前至少构建一些基础设施。</p>
</li>
<li><p>当原型部件被这些部件的完整版本替换时，系统的保真度就会提高</p>
</li>
<li><p>这种方法有助于开发过程，因为该系统在产品生命周期的早期就是可执行的。</p>
</li>
<li><p>这种方法允许在产品生命周期的早期发现潜在的性能问题</p>
</li>
<li><p>这些好处降低了项目中的潜在风险</p>
</li>
</ul>
<h3 id="有利于优化成本、开发进度的预估"><a href="#有利于优化成本、开发进度的预估" class="headerlink" title="有利于优化成本、开发进度的预估"></a>有利于优化成本、开发进度的预估</h3><ul>
<li><p>体系结构用于帮助项目经理在项目生命周期的早期创建成本和进度估算。</p>
</li>
<li><p>自上而下的估计数对于制定目标和分配预算很有用</p>
</li>
<li><p>自下而上的对系统各个部分的理解通常比那些纯粹基于自上而下的系统知识的理解更准确</p>
</li>
<li><p>最佳的成本和进度计划估算通常来自于自上而下的估算（由架构师和项目经理创建）和自下而上的估算（由开发人员创建）之间的共识。</p>
</li>
</ul>
<h3 id="可转换、可重用模型"><a href="#可转换、可重用模型" class="headerlink" title="可转换、可重用模型"></a>可转换、可重用模型</h3><ul>
<li><p>体系结构的重复使用为具有类似需求的系统提供了巨大的好处。</p>
<ul>
<li><p>不仅可以重用代码，而且首先导致架构的需求也可以重用代码</p>
</li>
<li><p>当体系结构决策可以跨多个系统重用时，所有的早期决策结果也会被转移</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用独立开发的组件"><a href="#使用独立开发的组件" class="headerlink" title="使用独立开发的组件"></a>使用独立开发的组件</h3><ul>
<li><p>基于体系结构的开发通常关注可能单独开发，甚至独立开发的组件</p>
</li>
<li><p>商业现成的组件、开源软件、公开可用的应用程序和网络服务都是可互换的软件组件的例子</p>
</li>
<li><p>回报可以是</p>
<ul>
<li><p>减少上市时间</p>
</li>
<li><p>提高可靠性</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH4-质量属性"><a href="#CH4-质量属性" class="headerlink" title="CH4 质量属性"></a>CH4 质量属性</h2><h3 id="架构与需求"><a href="#架构与需求" class="headerlink" title="架构与需求"></a>架构与需求</h3><h4 id="系统的需求可以大致分类为："><a href="#系统的需求可以大致分类为：" class="headerlink" title="系统的需求可以大致分类为："></a>系统的需求可以大致分类为：</h4><ul>
<li><p><strong>功能需求</strong>：说明系统必须做什么，它必须如何对运行时行为或刺激反应。</p>
</li>
<li><p><strong>质量属性需求</strong>：确定功能需求，例如，功能执行的速度，功能对错误输入的弹性等。</p>
</li>
<li><p><strong>约束</strong>：约束是一个具有零自由度的设计决策</p>
</li>
</ul>
<h3 id="功能性-functionality"><a href="#功能性-functionality" class="headerlink" title="功能性 functionality"></a>功能性 functionality</h3><ul>
<li><p>功能是指系统完成其预期的工作的能力</p>
</li>
<li><p>功能与架构有一种奇怪的关系：功能并不决定体系结构</p>
</li>
</ul>
<h3 id="质量属性分类"><a href="#质量属性分类" class="headerlink" title="质量属性分类"></a>质量属性分类</h3><h4 id="运行时属性"><a href="#运行时属性" class="headerlink" title="运行时属性"></a>运行时属性</h4><p>这些属性关注系统在运行时的行为和性能，包括：</p>
<ol>
<li><strong>性能</strong>：系统在特定时间内完成任务的能力，包括响应时间、吞吐量、资源使用等。</li>
</ol>
<ul>
<li><p>指标：响应时间、延迟、吞吐量。</p>
</li>
<li><p>方法：缓存、负载均衡、并行处理。</p>
</li>
</ul>
<ol start="2">
<li><strong>可用性</strong>：系统在特定时间内可以正常运行的能力。</li>
</ol>
<ul>
<li><p>指标：系统故障间隔时间（MTBF）、恢复时间（MTTR）。</p>
</li>
<li><p>方法：冗余设计、热备份、故障检测与切换。</p>
</li>
</ul>
<ol start="3">
<li><strong>安全性</strong>：保护数据和系统资源免受未经授权访问的能力。</li>
</ol>
<ul>
<li><p>指标：攻击成功率、数据泄露数量。</p>
</li>
<li><p>方法：身份认证、加密、访问控制。</p>
</li>
</ul>
<ol start="4">
<li><strong>可扩展性</strong>：系统随着需求变化，能够处理增长的用户数或数据量的能力。</li>
</ol>
<ul>
<li><p>指标：水平扩展的节点数、垂直扩展的性能增幅。</p>
</li>
<li><p>方法：分布式架构、分片。</p>
</li>
</ul>
<ol start="5">
<li><strong>可靠性</strong>：系统在规定时间内完成任务的能力。</li>
</ol>
<ul>
<li><p>指标：故障率、成功执行任务比例。</p>
</li>
<li><p>方法：异常处理、事务管理</p>
</li>
</ul>
<h4 id="非运行时属性"><a href="#非运行时属性" class="headerlink" title="非运行时属性"></a>非运行时属性</h4><p>这些属性关注系统的开发、维护和部署等非运行时特性，包括：</p>
<ol>
<li><strong>可维护性</strong>：系统被修改以适应新需求、修复缺陷的难易程度。</li>
</ol>
<ul>
<li>方法：模块化设计、清晰的接口、代码可读性。</li>
</ul>
<ol start="2">
<li><strong>可部署性</strong>：系统能否快速部署、更新和回滚。</li>
</ol>
<ul>
<li>方法：自动化部署、蓝绿部署、滚动升级。</li>
</ul>
<ol start="3">
<li><strong>可测试性</strong>：系统能否方便地进行测试。</li>
</ol>
<ul>
<li>方法：单元测试覆盖率、模拟器（Mock）工具、测试自动化框架。</li>
</ul>
<ol start="4">
<li><strong>可移植性</strong>：系统在不同环境或平台上的运行能力。</li>
</ol>
<ul>
<li>方法：容器化（如Docker）、跨平台设计。</li>
</ul>
<ol start="5">
<li><strong>互操作性</strong>：系统与其他系统或组件协同工作的能力。</li>
</ol>
<ul>
<li>方法：标准化协议、API设计。</li>
</ul>
<h3 id="质量属性需求-quality-attribute-requirements"><a href="#质量属性需求-quality-attribute-requirements" class="headerlink" title="质量属性需求 quality attribute requirements"></a>质量属性需求 quality attribute requirements</h3><h4 id="质量需求考虑-quality-attribute-considerations"><a href="#质量需求考虑-quality-attribute-considerations" class="headerlink" title="质量需求考虑 quality-attribute-considerations"></a>质量需求考虑 quality-attribute-considerations</h4><ul>
<li><p>如果一个功能性需求是“当用户按下绿色按钮时，选项对话框出现”：</p>
<ul>
<li><p>性能(performance qualification) 要求可能描述对话框出现的速度；</p>
</li>
<li><p>可用性要求(availability qualification) 可能描述这个功能会出现故障的频率以及修复的速度；</p>
</li>
<li><p>易用性要求(usability qualification) 可能描述学习这个功能的简易程度。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>两类质量属性</p>
<ul>
<li><p>描述系统在运行时的一些属性</p>
<ul>
<li>可用性、性能、易用性、安全性</li>
</ul>
</li>
<li><p>描述系统开发过程中的一些属性</p>
<ul>
<li>可修改性、可测试性</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>在之前关于质量属性的讨论中存在一些问题：</p>
<ul>
<li><p>不可测试的定义(Untestable definitions)。对某个属性提供的定义无法进行测试。说一个系统将是“可修改的”是没有意义的。</p>
</li>
<li><p>重叠的问题(Overlapping concerns)。系统故障是由于拒绝服务攻击还是与可用性、性能、安全性或可用性相关？</p>
</li>
</ul>
</li>
<li><p>解决这些问题（不可测试的定义和重叠的问题）的方法是使用质量属性场景来描述质量属性。</p>
</li>
</ul>
<h4 id="指定质量属性需求"><a href="#指定质量属性需求" class="headerlink" title="指定质量属性需求"></a>指定质量属性需求</h4><ul>
<li><p>我们使用一种通用形式，将所有质量属性需求都指定为场景。</p>
</li>
<li><p>我们对质量属性场景的表示包括以下几个部分：</p>
<ol>
<li>刺激（Stimulus）。刺激是一种在到达系统时需要产生响应的条件。</li>
<li>刺激源（Source of stimulus）。刺激源是某个实体（人、计算机系统或其他执行器），它产生了刺激。</li>
<li>响应（Response）。响应是作为刺激到达后所进行的活动。</li>
<li>响应度量（Response measure）。当响应发生时，应该以某种方式进行度量，以便对需求进行测试。</li>
<li>环境（Environment）。刺激发生在特定条件下。系统可能处于超负荷状态、正常运行状态或其他相关状态。</li>
<li>构件（Artifact）。这可以是一组系统、整个系统或其中的某个部分。某个构件被刺激。</li>
</ol>
</li>
<li><p>通用的质量属性场景(General quality attribute scenarios) 与具体的系统无关，可能适用于任何系统。</p>
</li>
<li><p>具体的质量属性场景(Concrete quality attribute scenarios) 则针对具体考虑的系统而定。</p>
</li>
</ul>
<h4 id="通过决策实现质量属性"><a href="#通过决策实现质量属性" class="headerlink" title="通过决策实现质量属性"></a>通过决策实现质量属性</h4><ul>
<li><p>架构师可以使用一系列基本的设计技术来实现质量属性响应。</p>
</li>
<li><p>我们将这些基本设计技术称为架构设计策略。</p>
</li>
<li><p>策略和设计模式一样，是架构师多年来一直在使用的技术。</p>
</li>
<li><p>我们并不是发明策略，而是简单地捕捉架构师在实践中所做的事情。例如资源调度就是用于性能的一种策略：</p>
<ul>
<li><p>给定条件：发布时间，每个任务的工作量</p>
</li>
<li><p>过程：确定每个任务何时执行</p>
</li>
<li><p>目标：最小化任务的平均完成时间</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>策略 vs. 架构模式</p>
<ul>
<li><p>策略是针对单个质量属性的设计决策。</p>
</li>
<li><p>策略不考虑质量属性之间的权衡。</p>
</li>
<li><p>架构模式可以被看作是策略的“套餐”，其中考虑了质量属性之间的权衡。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>我们需要对策略进行隔离、分类和描述。为什么要这样做？</p>
<ul>
<li><p>设计模式往往很复杂，并且很难直接应用；架构师需要对它们进行修改和适应。</p>
</li>
<li><p>如果没有现有的模式来实现架构师的设计目标，策略可以让架构师从“首要原则”构建设计片段。</p>
</li>
<li><p>通过对策略进行分类，我们可以在改进特定质量属性时选择多种策略。选择使用哪些策略取决于诸如实施成本等因素。</p>
</li>
</ul>
</li>
</ul>
<h4 id="指导质量设计决策"><a href="#指导质量设计决策" class="headerlink" title="指导质量设计决策"></a>指导质量设计决策</h4><ul>
<li>架构设计是一种系统化的设计决策方法。</li>
<li>我们将设计决策分为以下几类：<ol>
<li>职责分配(Allocation of responsibilities)</li>
<li>协调模型(Coordination model)</li>
<li>数据模型(Data model)</li>
<li>资源管理(Management of resources)</li>
<li>架构元素之间的映射(Mapping among architectural elements)</li>
<li>绑定时间决策(Binding time decisions)</li>
<li>技术选择(Choice of technology)</li>
</ol>
</li>
</ul>
<h4 id="指责分配"><a href="#指责分配" class="headerlink" title="指责分配"></a>指责分配</h4><ul>
<li><p>包括职责分配的决策内容：</p>
<ul>
<li><p>确定职责，包括基本系统功能、架构基础设施和满足质量属性。</p>
</li>
<li><p>确定如何将这些职责分配给非运行时和运行时元素（即模块、组件和连接器）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="协调模型"><a href="#协调模型" class="headerlink" title="协调模型"></a>协调模型</h4><p>关于协调模型的决策包括：</p>
<ul>
<li><p>确定系统中需要进行<strong>协调或禁止协调</strong>的元素。</p>
</li>
<li><p>确定协调的属性，例如<strong>及时性、实时性、正确性和一致性</strong>。</p>
</li>
<li><p>选择实现这些属性的通信机制。</p>
<ul>
<li><p>有状态 vs 无状态</p>
</li>
<li><p>同步 vs 异步</p>
</li>
<li><p>有保证 vs 无保证的传递</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>关于数据模型的决策包括：</p>
<ul>
<li><p><strong>选择主要的数据抽象、它们的操作和属性</strong>。</p>
<ul>
<li><strong>数据抽象</strong>：指的是数据的基本表现形式或模型，描述了系统如何抽象地表示和处理数据。例如，数据可以抽象为实体（如用户、订单）、关系（如用户与订单之间的关系）或文档（如JSON文档）。</li>
<li><strong>操作</strong>：指系统能够对数据执行的行为或操作，例如增删改查（CRUD 操作）、事务操作（如提交和回滚）、复杂查询（如聚合计算）。</li>
<li><strong>属性</strong>：描述与数据相关的细节，如数据字段及其数据类型。例如，用户实体可以有属性如用户名（字符串）、年龄（整数）和注册日期（日期类型）。</li>
<li><strong>决策点</strong>：<ul>
<li><p>确定哪些实体是核心数据对象，以及这些对象如何交互。</p>
</li>
<li><p>定义实体的字段和字段类型，以及这些字段是否需要验证规则（如长度限制、唯一性）。</p>
</li>
<li><p>决定支持哪些基本和高级操作，例如是否需要全文搜索、批量更新等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据一致解释所需的元数据</strong>。</p>
<ul>
<li><p><strong>元数据</strong>：是描述数据的数据，用于定义数据的结构、约束、语义以及解释规则。</p>
<ul>
<li><p>结构：定义表或文档的字段及其类型。</p>
</li>
<li><p>约束：定义字段的限制条件，如非空、唯一性等。</p>
</li>
<li><p>语义：说明数据的含义，如字段的业务意义或其作用。</p>
</li>
</ul>
</li>
<li><p>数据的一致解释：确保不同系统组件或用户对同一数据有统一的理解。元数据有助于标准化数据的存储和使用方式。</p>
</li>
<li><p><strong>决策点</strong>：</p>
<ul>
<li><p>定义元数据的存储方式，例如作为数据库中的元表存储，或以JSON Schema等格式嵌入系统中。</p>
</li>
<li><p>确保系统设计文档中明确数据模型的元数据，以便开发和维护人员理解数据的语义和约束。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据的组织方式，即决定数据是保存在关系型数据库、对象集合还是两者兼有</strong>。</p>
<ul>
<li><strong>决策点</strong>：<ul>
<li><p>选择数据库类型：关系型、非关系型或两者结合。</p>
</li>
<li><p>决定数据的存储模式：结构化数据（表格形式）还是半结构化&#x2F;非结构化数据（JSON文档、文件形式）。</p>
</li>
<li><p>考虑数据的存取需求：如事务一致性、高可用性、查询复杂度、扩展性。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><ul>
<li><p>资源管理的决策包括：</p>
<ul>
<li><p>确定需要管理的资源，并确定每个资源的限制。</p>
</li>
<li><p>确定哪个系统元素管理每个资源。</p>
</li>
<li><p>确定资源共享的方式以及在资源争用时采用的策略。</p>
</li>
<li><p>确定饱和对不同资源的影响</p>
</li>
</ul>
</li>
</ul>
<h4 id="架构元素间的映射"><a href="#架构元素间的映射" class="headerlink" title="架构元素间的映射"></a>架构元素间的映射</h4><ul>
<li><p>有用的映射包括：</p>
<ul>
<li><p>模块和运行时元素之间的映射。</p>
</li>
<li><p>将运行时元素分配给处理器。</p>
</li>
<li><p>将数据模型中的项分配给数据存储。</p>
</li>
<li><p>将模块和运行时元素映射到交付单元</p>
</li>
</ul>
</li>
</ul>
<h4 id="绑定时间决策"><a href="#绑定时间决策" class="headerlink" title="绑定时间决策"></a>绑定时间决策</h4><ul>
<li><p>其他类别中的决策都与绑定时间决策相关。此类绑定时间决策的示例包括：</p>
<ul>
<li><p>构建时间 vs. 运行时间</p>
</li>
<li><p>对于协调模型的选择，您可以设计运行时协议的协商。</p>
</li>
<li><p>对于资源管理，您可以设计一个系统，在运行时接受新的外设设备插入</p>
</li>
</ul>
</li>
</ul>
<h4 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h4><ul>
<li><p>技术选择决策涉及：</p>
<ul>
<li><p>决定哪些技术可用来实现在其他类别中做出的决策。</p>
</li>
<li><p>确定支持该技术的工具（IDE、模拟器、测试工具等）是否足够。</p>
</li>
<li><p>确定对该技术的内部熟悉程度和外部支持程度（例如课程、教程、示例、承包商的可用性）。</p>
</li>
<li><p>确定选择某项技术的副作用，如所需的协调模型或受限的资源管理机会。</p>
</li>
<li><p>确定新技术是否与现有技术堆栈兼容。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH5-可用性"><a href="#CH5-可用性" class="headerlink" title="CH5 可用性"></a>CH5 可用性</h2><h3 id="可用性-availability"><a href="#可用性-availability" class="headerlink" title="可用性 availability"></a>可用性 availability</h3><ul>
<li><p>可用性指的是软件具备在需要时随时可用并准备好执行任务的属性。</p>
</li>
<li><p>可用性是指系统能够<strong>掩盖或修复故障</strong>，以使累积的服务中断时间不超过指定时间间隔内的要求值。</p>
</li>
<li><p>可用性的目标是<strong>通过减轻故障来最小化服务中断时间</strong>。</p>
</li>
</ul>
<blockquote>
<p>可用性(<strong>Availability</strong>)与可靠性(<strong>reliability</strong>)或可信性(<strong>trustworthiness</strong>)的区别</p>
<ul>
<li><p>可用性包括通常所称的可靠性。</p>
</li>
<li><p>可用性还涵盖了其他考虑因素，例如由于定期维护导致的服务中断。</p>
</li>
<li><p>可用性与以下因素密切相关</p>
<ul>
<li>安全性，例如拒绝服务攻击</li>
<li>性能</li>
<li>…</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">关注点</th>
<th align="center">关键指标</th>
<th align="center">实现方法</th>
<th align="center">用户感知</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可用性</td>
<td align="center">服务是否随时可用</td>
<td align="center">可用率，停机时间</td>
<td align="center">冗余设计、自动切换、监控</td>
<td align="center">系统是否能被访问和使用</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">服务运行过程中是否出错</td>
<td align="center">平均故障间隔时间（MTBF）、故障率</td>
<td align="center">容错设计、数据校验、严格测试</td>
<td align="center">系统是否能长时间无故障运行</td>
</tr>
<tr>
<td align="center">可信性</td>
<td align="center">数据和操作结果是否值得信赖</td>
<td align="center">数据完整性、安全性、用户满意度</td>
<td align="center">加密、验证、审计</td>
<td align="center">系统提供的结果和数据是否可靠</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="可用性决策的目标"><a href="#可用性决策的目标" class="headerlink" title="可用性决策的目标"></a>可用性决策的目标</h3><blockquote>
<p>故障(Fault) vs 失败(Failure)？</p>
<ul>
<li><p>失败发生在系统不再按照其规范提供服务时</p>
<ul>
<li>此故障可以被系统的参与者观察到。</li>
</ul>
</li>
<li><p>故障（或故障的组合）有可能导致失败。</p>
</li>
</ul>
</blockquote>
<p>可用性策略使系统能够忍受故障，以便服务保持符合其规格说明。这些策略可以防止故障导致失败，或至少限制故障的影响，并使修复成为可能。</p>
<h4 id="检测故障-detect-faults"><a href="#检测故障-detect-faults" class="headerlink" title="检测故障 detect-faults"></a>检测故障 detect-faults</h4><ul>
<li><p><strong>Ping&#x2F;echo</strong>：用于确定与相关网络路径的连通性和往返延迟。</p>
</li>
<li><p><strong>心跳(Heartbeat)</strong>：系统监视器与被监视的进程之间的定期消息交换。</p>
<ul>
<li><p>进程定期在其监视器中重置看门狗计时器，</p>
</li>
<li><p>将心跳消息与其他控制消息捆绑在一起，减少开销。</p>
</li>
<li><p>**”ping”<strong>和</strong>“heartbeat”**之间的区别是谁发起健康检查？</p>
<ul>
<li><p>ping 是检查者主动发信息，</p>
</li>
<li><p>heartbeat 是被检查者发信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>监视器(Monitor)</strong>：用于监控系统其他部分的健康状态的组件。</p>
</li>
<li><p><strong>时间戳(Timestamp)</strong>：用于检测分布式消息传递系统中的事件顺序错误。</p>
</li>
<li><p><strong>条件监控(Condition Monitoring)</strong>：检查进程或设备中的条件，或验证设计过程中的假设。</p>
<ul>
<li>例如，在数据存储和传输中使用校验和(checksum)。</li>
</ul>
</li>
<li><p><strong>投票(Voting)</strong>：这种策略的常见实现是三重模块冗余(Triple Modular Redundancy TMR)。</p>
</li>
</ul>
<h4 id="故障恢复-准备和修复-recover-from-faults-preparation-repair"><a href="#故障恢复-准备和修复-recover-from-faults-preparation-repair" class="headerlink" title="故障恢复 (准备和修复) recover-from-faults(preparation &amp; repair)"></a>故障恢复 (准备和修复) recover-from-faults(preparation &amp; repair)</h4><ul>
<li><p><strong>主动冗余(热备份) active-redundancy (hot-spare)</strong>：</p>
<ul>
<li><p>通过保持多个冗余组件同时运行，确保在一个组件发生故障时，其他组件可以立即接替其工作，从而最小化系统停机时间和数据丢失风险</p>
</li>
<li><p>保护组中的所有组件（主要活动组件和冗余备份组件）以并行方式处理相同的输入，允许冗余备份的组件与活动组件保持同步状态。</p>
</li>
</ul>
</li>
<li><p><strong>备用(冷备份) spare (cold-spare)</strong>：保护组的冗余备份保持停机状态，直到发生故障切换，此时在将冗余备份投入使用之前，会启动电源复位程序。</p>
</li>
<li><p><strong>被动冗余(温备份) passive-redundancy (warm-spare)</strong>：只有保护组的活动成员处理输入流量；</p>
<ul>
<li>其中一个职责是向冗余备份提供定期的状态更新。</li>
</ul>
</li>
<li><p><strong>回滚rollback</strong>：恢复到先前已知的良好状态，称为”回滚点”。</p>
<ul>
<li><p>这种策略与冗余策略结合使用。</p>
</li>
<li><p>在发生回滚后，故障组件的备用版本变为活动状态。</p>
</li>
<li><p>回滚依赖于先前状态的副本（检查点）。</p>
</li>
<li><p>检查点可以存储在固定位置，并需要定期更新。</p>
</li>
</ul>
</li>
<li><p><strong>重试retry</strong>：当故障是暂时性的，重新尝试操作可能会成功。</p>
<ul>
<li>例如，网络重传。</li>
</ul>
</li>
<li><p><strong>忽略错误行为(Ignore-faulty-behavior)</strong>：当确定某个消息是伪造的时，忽略来自该消息源的消息。</p>
<ul>
<li>例如，忽略来自拒绝服务攻击者的消息。</li>
</ul>
</li>
<li><p><strong>退化degradation</strong>：在组件故障的情况下保持最关键的系统功能，放弃较不关键的功能。</p>
</li>
<li><p><strong>重新配置reconfiguration</strong>：将责任重新分配给仍然正常运行的资源，同时尽可能保持功能性。</p>
</li>
</ul>
<h4 id="防止故障-prevent-faults"><a href="#防止故障-prevent-faults" class="headerlink" title="防止故障 prevent-faults"></a>防止故障 prevent-faults</h4><ul>
<li><p><strong>服务移除 removal-from-service</strong>：将系统组件暂时置于停机状态，以减轻潜在的系统故障。</p>
</li>
<li><p><strong>事务 transactions</strong>：将状态更新打包，使分布式组件之间交换的异步消息具有原子性、一致性、隔</p>
</li>
<li><p>离性和持久性。</p>
</li>
<li><p><strong>预测模型 predictive-model</strong>：在检测到预测可能的未来故障的条件时采取纠正措施。</p>
</li>
<li><p><strong>增加能力集合</strong>：设计一个组件以处理更多的情况（故障），作为其正常操作的一部分。</p>
</li>
</ul>
<h2 id="CH6-互操作性"><a href="#CH6-互操作性" class="headerlink" title="CH6 互操作性"></a>CH6 互操作性</h2><h3 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h3><ul>
<li><p>互操作性是指在<strong>特定环境下，两个或多个系统能够通过接口有意义地交换</strong>信息的程度。</p>
</li>
<li><p>对于系统的互操作性的任何讨论都需要明确指出与谁以及在什么情况下进行交互。</p>
</li>
<li><p>语法互操作性是指交换数据的能力。</p>
</li>
<li><p>语义互操作性是指解释交换的数据的能力。</p>
</li>
<li><p>实现互操作性的两种视角：</p>
<ul>
<li><p>在了解外部系统接口的基础上，将该知识设计到系统中。</p>
</li>
<li><p>在没有了解其他系统的情况下，以更通用的方式设计系统以实现互操作性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul>
<li><p>系统提供一个服务，供一组未知系统使用，例如 Google 地图。</p>
</li>
<li><p>系统由现有系统构建而成，例如：</p>
<ul>
<li><p>产生对所感知内容的表示</p>
</li>
<li><p>解释数据</p>
</li>
<li><p>处理原始数据</p>
</li>
<li><p>感知环境</p>
</li>
</ul>
</li>
</ul>
<h4 id="互操作性的两个重要作用"><a href="#互操作性的两个重要作用" class="headerlink" title="互操作性的两个重要作用"></a>互操作性的两个重要作用</h4><ul>
<li>发现。服务的使用者必须发现服务的位置、身份和接口。</li>
<li>处理响应。有三种可能性：<ul>
<li><p>服务向请求者报告返回结果。</p>
</li>
<li><p>服务将其响应发送给另一个系统。</p>
</li>
<li><p>服务向任何感兴趣的方发送广播响应。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>SOAP 和 REST</p>
<ul>
<li><p>两种技术选项，用于实现基于 Web 的应用程序之间的互操作性。</p>
</li>
<li><p>SOAP 在 SOA 系统中与一组协议一起使用。</p>
<ul>
<li><p>服务描述和发现，例如 WSDL、UDDI。</p>
</li>
<li><p>服务组合，例如 BPEL。</p>
</li>
</ul>
</li>
<li><p>SOAP 更复杂，用于交换带有结构化数据的消息，而 REST 更简单，用于小型消息。</p>
</li>
</ul>
</blockquote>
<h3 id="互操作性的目标和决策"><a href="#互操作性的目标和决策" class="headerlink" title="互操作性的目标和决策"></a>互操作性的目标和决策</h3><ul>
<li><p>为了使两个或多个系统能够有意义地交换信息，它们必须：</p>
<ul>
<li><p>了解彼此。这就是定位策略(locate tactic)的目的。</p>
</li>
<li><p>以语义上有意义的方式交换信息。这就是管理接口策略(manage interfaces tactics)的目的。</p>
<p>交换的两个方面是：</p>
<ul>
<li><p>按正确的顺序提供服务。</p>
</li>
<li><p>将一个参与者产生的信息修改为第二个参与者可接受的形式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul>
<li><p>服务发现(Service Discovery)：通过搜索来定位一个服务</p>
</li>
<li><p>有许多服务发现机制：</p>
<ul>
<li><p>用于 Web 服务的 UDDI</p>
</li>
<li><p>用于 Java 对象的 Jini</p>
</li>
<li><p>通用即插即用（Universal plug-and-play，UPnP）中使用的简单服务发现协议（SSDP）</p>
</li>
<li><p>DNS 服务发现（DNS-SD）</p>
</li>
<li><p>蓝牙服务发现协议（SDP）</p>
</li>
</ul>
</li>
</ul>
<h3 id="搜索方法"><a href="#搜索方法" class="headerlink" title="搜索方法"></a>搜索方法</h3><h4 id="主动搜索"><a href="#主动搜索" class="headerlink" title="主动搜索"></a>主动搜索</h4><ul>
<li><p><strong>泛洪&#x2F;广播请求(Flood&#x2F;Broadcast request)</strong>：</p>
<ul>
<li><p>向每个实体询问并等待回答</p>
</li>
<li><p>示例</p>
<ul>
<li><p>在位置区域进行寻呼以找到移动终端</p>
</li>
<li><p>DHCP 发现：客户端在本地子网上进行广播，以找到可用的服务器以获取 IP 地址</p>
</li>
</ul>
</li>
<li><p>对于搜索者来说，高效且资源消耗较少</p>
</li>
<li><p>对于被搜索的实体来说，资源消耗较低</p>
</li>
<li><p>但对于环境来说，会造成干扰和资源消耗。</p>
</li>
</ul>
</li>
<li><p><strong>连续请求(Successive request)</strong>：</p>
<ul>
<li><p>逐个询问实体并进行匹配。</p>
</li>
<li><p>如果没有匹配项，则继续下一个直到找到匹配项。</p>
</li>
<li><p>对于搜索者来说，效率较低且资源消耗较高。</p>
</li>
<li><p>但对于环境来说，干扰较少且资源消耗较少。</p>
</li>
</ul>
</li>
<li><p><strong>连续&#x2F;定期广告(Continuous&#x2F;periodical advertisement)</strong>：</p>
<ul>
<li><p>连续或定期发布广告，以便每个搜索者都能注意到并做出响应。</p>
</li>
<li><p>对于被搜索的实体来说，效率高但资源消耗较高。</p>
</li>
<li><p>对于搜索者来说，资源需求较低。</p>
</li>
<li><p>对于环境来说，干扰和资源消耗较高。</p>
</li>
</ul>
</li>
<li><p><strong>新实体到达时的广告(Advertisement upon arrival of new entity)</strong>：</p>
<ul>
<li><p>例如，当有新人进入大厅时自我介绍。</p>
</li>
<li><p>需要在新实体到达时进行检测机制。</p>
</li>
<li><p>对于被搜索的实体来说，资源消耗较低。</p>
</li>
<li><p>对于搜索者来说，资源需求较低。</p>
</li>
<li><p>对于环境来说，干扰和资源消耗较少。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ul>
<li><p>引入“中间人” - 注册表</p>
<ul>
<li><p>被搜索的实体向注册表注册</p>
</li>
<li><p>搜索者可以通过注册表获取信息并找到被搜索的实体</p>
</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li>服务提供者在 UDDI 注册表中注册其 Web 服务，可以被服务请求者搜索和找到</li>
</ul>
</li>
<li><p>这种方法对搜索者和被搜索者的资源消耗较低，对环境的干扰也较少，但前提是注册表必须可用、可靠和正确</p>
</li>
</ul>
<h2 id="CH7-可修改性"><a href="#CH7-可修改性" class="headerlink" title="CH7 可修改性"></a>CH7 可修改性</h2><h3 id="什么是可修改性-modifiability"><a href="#什么是可修改性-modifiability" class="headerlink" title="什么是可修改性 modifiability"></a>什么是可修改性 modifiability</h3><ul>
<li><p>可修改涉及变化，我们对它的兴趣在于变化的成本和风险。</p>
</li>
<li><p>为了规划可修改性，架构师必须考虑四个问题：</p>
<ul>
<li><p>什么可以改变？</p>
</li>
<li><p>变化的可能性有多大？</p>
</li>
<li><p>变化何时发生，由谁进行？</p>
</li>
<li><p>变化的成本是多少？</p>
</li>
</ul>
</li>
</ul>
<h4 id="什么是可以改变的"><a href="#什么是可以改变的" class="headerlink" title="什么是可以改变的"></a>什么是可以改变的</h4><ul>
<li><p>系统的功能</p>
</li>
<li><p>平台、即硬件、操作系统和中间件</p>
</li>
<li><p>系统运行的环境</p>
<ul>
<li><p>必须与之互操作的系统</p>
</li>
<li><p>用于通信的协议</p>
</li>
</ul>
</li>
<li><p>容量</p>
<ul>
<li><p>支持的用户数量</p>
</li>
<li><p>同时操作的数量</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化何时发生，由谁进行"><a href="#变化何时发生，由谁进行" class="headerlink" title="变化何时发生，由谁进行"></a>变化何时发生，由谁进行</h4><ul>
<li><p>在实施过程中可以进行的更改：</p>
<ul>
<li><p>通过修改源代码进行实施</p>
</li>
<li><p>通过选择库进行构建</p>
</li>
<li><p>通过参数设置、插件等进行执行</p>
</li>
</ul>
</li>
<li><p>更改也可以由以下人员进行：</p>
<ul>
<li><p>开发人员</p>
</li>
<li><p>最终用户</p>
</li>
<li><p>系统管理员</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化的成本"><a href="#变化的成本" class="headerlink" title="变化的成本"></a>变化的成本</h4><p>包括两种类型的成本：</p>
<ul>
<li><p>引入机制以使系统更具可修改性的成本</p>
</li>
<li><p>使用这些机制进行修改的成本</p>
</li>
</ul>
<h3 id="可修改性策略的目标"><a href="#可修改性策略的目标" class="headerlink" title="可修改性策略的目标"></a>可修改性策略的目标</h3><ul>
<li><p>控制进行变更的复杂性</p>
</li>
<li><p>控制进行变更的时间和成本</p>
</li>
</ul>
<h3 id="可修改策略"><a href="#可修改策略" class="headerlink" title="可修改策略"></a>可修改策略</h3><h4 id="减小模块的大小"><a href="#减小模块的大小" class="headerlink" title="减小模块的大小"></a>减小模块的大小</h4><ul>
<li><strong>分割模块</strong>：如果要修改的模块包含大量功能，修改的成本可能会较高</li>
<li>将模块细分为几个较小的模块应该会降低未来变更的平均成本</li>
</ul>
<h4 id="增加内聚性"><a href="#增加内聚性" class="headerlink" title="增加内聚性"></a>增加内聚性</h4><ul>
<li><p>增加语义连贯性：如果模块中的职责 A 和 B 不具有相同的目的，它们应该放置在不同的模块中。</p>
</li>
<li><p>这可能涉及创建一个新的模块，或者将职责移动到现有的模块中。</p>
</li>
</ul>
<h4 id="减少耦合性"><a href="#减少耦合性" class="headerlink" title="减少耦合性"></a>减少耦合性</h4><ul>
<li><p>什么是耦合性？</p>
<ul>
<li><p>如果两个模块的职责重叠，一个变更可能会同时影响它们</p>
</li>
<li><p>耦合性通过这种重叠来衡量，即修改一个模块将会传播到另一个模块的概率</p>
</li>
<li><p>高耦合性是可修改性的敌人。</p>
</li>
</ul>
</li>
<li><p>减少耦合性的方法：</p>
<ul>
<li><p>封装：封装为模块引入了一个明确的接口。该接口包括一个 API 及其相关的职责。</p>
</li>
<li><p>使用中间层：如果职责 A 和职责 B 之间存在依赖关系（例如，首先执行 A 需要执行 B），可</p>
</li>
<li><p>以通过使用一个中间层来打破依赖。</p>
</li>
<li><p>使用发布&#x2F;订阅模型 (Publish&#x2F;Subscribe model)</p>
</li>
<li><p>限制依赖关系：限制一个模块与其交互或依赖的模块。</p>
<ul>
<li><p>通过限制模块的可见性和授权来实现。</p>
</li>
<li><p>例如，一个层次结构允许访问其底层的模块</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CH8-性能"><a href="#CH8-性能" class="headerlink" title="CH8 性能"></a>CH8 性能</h2><h3 id="什么是性能"><a href="#什么是性能" class="headerlink" title="什么是性能"></a>什么是性能</h3><ul>
<li><p>它与时间有关</p>
</li>
<li><p>性能是关于时间以及软件系统满足时间要求的能力</p>
</li>
<li><p>当事件发生时，系统必须及时对其做出响应</p>
<ul>
<li>事件包括<strong>中断、消息、来自用户或其他系统的请求</strong>，或标记时间流逝的时钟事件</li>
</ul>
</li>
</ul>
<h4 id="性能建模"><a href="#性能建模" class="headerlink" title="性能建模"></a>性能建模</h4><ul>
<li><p>响应时间的两个基本因素</p>
</li>
<li><p>处理时间指系统用于响应的工作时间</p>
</li>
<li><p>阻塞时间指系统无法响应的时间</p>
</li>
<li><p>阻塞时间的原因包括</p>
<ul>
<li><p>资源争用</p>
</li>
<li><p>资源的可用性</p>
</li>
<li><p>对其他因素的依赖</p>
</li>
</ul>
</li>
</ul>
<h3 id="性能策略的目标"><a href="#性能策略的目标" class="headerlink" title="性能策略的目标"></a>性能策略的目标</h3><ul>
<li><p>在基于时间的约束条件内，对进入系统的事件生成响应。</p>
</li>
<li><p>事件可以是单个事件或事件流，并且是执行计算的触发器。</p>
</li>
</ul>
<h3 id="两种策略类别"><a href="#两种策略类别" class="headerlink" title="两种策略类别"></a>两种策略类别</h3><ul>
<li><p>控制资源需求</p>
<ul>
<li><p>降低对资源的需求量</p>
</li>
<li><p>在需求方面进行操作</p>
</li>
</ul>
</li>
<li><p>管理资源</p>
<ul>
<li><p>使现有资源在处理需求时更有效</p>
</li>
<li><p>在响应方面进行操作</p>
<p>::info 资源</p>
</li>
</ul>
</li>
<li><p>硬件资源，例如 CPU、数据存储、网络带宽和内存</p>
</li>
<li><p>软件资源，例如缓冲区或关键区域</p>
</li>
</ul>
<h3 id="性能策略"><a href="#性能策略" class="headerlink" title="性能策略"></a>性能策略</h3><h4 id="控制资源需求"><a href="#控制资源需求" class="headerlink" title="控制资源需求"></a>控制资源需求</h4><ul>
<li><p><strong>管理采样率(Manage Sampling Rate)</strong>：降低对数据流进行采样的频率</p>
</li>
<li><p><strong>优先处理事件(Prioritize Events)</strong>：引入优先级方案，根据重要性对事件进行排序</p>
<ul>
<li>当资源不足时，忽略低优先级事件</li>
</ul>
</li>
<li><p><strong>减少开销(Reduce Overhead)</strong>：使用中间件会增加处理事件流所消耗的资源；移除中间件可以提高响应延迟。</p>
<ul>
<li>在可修改性和性能之间进行权衡</li>
</ul>
</li>
<li><p><strong>限制执行时间(Bound Execution Times)</strong>：设置响应事件所使用的执行时间上限。</p>
<ul>
<li><p>在算法设计中，限制迭代次数是控制执行时间的方法之一。</p>
</li>
<li><p>在性能和准确性之间进行权衡</p>
</li>
</ul>
</li>
<li><p><strong>提高资源效率(Increase Resource Efficiency)</strong>：改进关键领域中使用的算法将减少延迟。</p>
<ul>
<li>减少算法的复杂性</li>
</ul>
</li>
</ul>
<h4 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h4><ul>
<li><p>增加资源(Increase Resources:)：更快的处理器、额外的处理器、额外的内存和更快的网络都有可能减少延迟。</p>
</li>
<li><p>增加并发性( Increase Concurrency)：如果请求可以并行处理，阻塞时间可以减少。</p>
<ul>
<li>可以通过在不同线程上处理不同的事件流来引入并发性。</li>
</ul>
</li>
</ul>
<h4 id="维护多个计算副本-Maintain-Multiple-Copies-of-Computations"><a href="#维护多个计算副本-Maintain-Multiple-Copies-of-Computations" class="headerlink" title="维护多个计算副本(Maintain Multiple Copies of Computations)"></a>维护多个计算副本(Maintain Multiple Copies of Computations)</h4><ul>
<li><p>复制的目的是减少单个服务器上的资源争用</p>
</li>
<li><p>负载均衡器将新任务分配给其中一个副本服务器</p>
</li>
<li><p><strong>数据缓存(Data caching)</strong> 是将数据的副本保存在具有不同访问速度的存储介质上。- 例如，内存访</p>
</li>
<li><p>问与磁盘访问，本地访问与通过网络的远程访问。</p>
</li>
<li><p><strong>数据复制(Data replication)</strong> 是保留数据的独立副本，以减少多个同时访问所带来的争用。</p>
</li>
<li><p>如何选择要缓存&#x2F;复制的数据？</p>
</li>
<li><p>如何确保多个副本的一致性？</p>
</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul>
<li><p>当资源存在争用时，需要对资源进行调度。</p>
<ul>
<li><p>处理器需要进行调度</p>
</li>
<li><p>缓冲区需要进行调度</p>
</li>
<li><p>网络需要进行调度</p>
</li>
</ul>
</li>
</ul>
<h3 id="3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem"><a href="#3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem" class="headerlink" title="3维度调度框架问题(3-Dimension Framework for Scheduling Problem)"></a>3维度调度框架问题(3-Dimension Framework for Scheduling Problem)</h3><ul>
<li><p>任务(Tasks)</p>
</li>
<li><p>资源(Resources)</p>
</li>
<li><p>目标(Objectives)</p>
</li>
</ul>
<h4 id="任务模型-Task-Model"><a href="#任务模型-Task-Model" class="headerlink" title="任务模型(Task Model)"></a>任务模型(Task Model)</h4><ul>
<li><p>任务包（Bag of tasks）</p>
</li>
<li><p>有向无环图（Directed Acyclic Graph，DAG）</p>
</li>
<li><p>周期性&#x2F;循环性任务（Periodic&#x2F;cyclic tasks）</p>
</li>
<li><p>任务属性</p>
<ul>
<li><p>执行成本（Execution cost）</p>
</li>
<li><p>传输成本（Transmission cost）</p>
</li>
<li><p>到达时间（Arrival time）</p>
</li>
<li><p>截止时间（Deadline）</p>
</li>
<li><p>抢占或非抢占（Preemptive or non-preemptive）</p>
</li>
</ul>
</li>
</ul>
<h4 id="资源模型-Resource-Model"><a href="#资源模型-Resource-Model" class="headerlink" title="资源模型(Resource Model)"></a>资源模型(Resource Model)</h4><ul>
<li><p>资源包括一组通过网络连接的机器&#x2F;处理器</p>
</li>
<li><p>机器&#x2F;处理器模型</p>
<ul>
<li>处理能力&#x2F;速度，能量消耗</li>
</ul>
</li>
<li><p>网络模型</p>
<ul>
<li><p>网络拓扑</p>
</li>
<li><p>带宽</p>
</li>
<li><p>消息和能量消耗</p>
</li>
<li><p>例如，传感器网络、数据中心网络、移动云</p>
</li>
</ul>
</li>
</ul>
<h3 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h3><ul>
<li><p>最小化完成时间</p>
</li>
<li><p>满足截止时间</p>
</li>
<li><p>最大化吞吐量</p>
</li>
<li><p>最小化数据传输&#x2F;消息数量</p>
</li>
<li><p>最小化能量消耗</p>
</li>
</ul>
<h3 id="调度的分类"><a href="#调度的分类" class="headerlink" title="调度的分类"></a>调度的分类</h3><ul>
<li><p>实时调度与非实时调度</p>
</li>
<li><p>静态调度与动态调度</p>
</li>
<li><p>离线调度与在线调度</p>
</li>
<li><p>确定性调度与随机调度</p>
</li>
</ul>
<h3 id="任务调度问题"><a href="#任务调度问题" class="headerlink" title="任务调度问题"></a>任务调度问题</h3><ol>
<li>单处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>多处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>异构处理器上的有向无环图（DAG）调度</li>
<li>作业车间调度（Job shop scheduling）</li>
<li>周期性任务调度（Periodic tasks scheduling）</li>
</ol>
<h4 id="单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）"><a href="#单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）" class="headerlink" title="单处理器上的任务包调度（Bag-of-Tasks on Single Processor）"></a>单处理器上的任务包调度（Bag-of-Tasks on Single Processor）</h4><p>给定：每个任务的发布时间、工作量或截止时间</p>
<p>确定每个任务的执行时间</p>
<p>目标：任务的平均完成时间或满足截止时间</p>
<h4 id="多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）"><a href="#多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）" class="headerlink" title="多处理器上的任务包调度（Bag-of-Tasks on Multi-Processors）"></a>多处理器上的任务包调度（Bag-of-Tasks on Multi-Processors）</h4><p>给定：每个任务的发布时间和工作量</p>
<p>确定每个任务在何时何地执行</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）"><a href="#在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）" class="headerlink" title="在异构处理器上调度有向无环图（DAGs Scheduling on HeterogeneousProcessors）"></a>在异构处理器上调度有向无环图（DAGs Scheduling on HeterogeneousProcessors）</h4><p>给定：每个任务在每个处理器上的处理时间，边缘上的通信时间</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="作业车间问题（Job-Shop-Problem，JSP）"><a href="#作业车间问题（Job-Shop-Problem，JSP）" class="headerlink" title="作业车间问题（Job Shop Problem，JSP）"></a>作业车间问题（Job Shop Problem，JSP）</h4><p>Job Shop Problem (JSP)</p>
<p>给定：每个作业在每个处理器上的处理时间</p>
<p>目标：最小化总执行时间（makespan）…</p>
<h4 id="周期性任务调度-Periodic-tasks-scheduling"><a href="#周期性任务调度-Periodic-tasks-scheduling" class="headerlink" title="周期性任务调度(Periodic tasks scheduling)"></a>周期性任务调度(Periodic tasks scheduling)</h4><p>任务按周期性发布，并在流水线中执行。</p>
<p>Periodic tasks scheduling</p>
<h3 id="类似的术语-Similar-Terminologies"><a href="#类似的术语-Similar-Terminologies" class="headerlink" title="类似的术语(Similar Terminologies)"></a>类似的术语(Similar Terminologies)</h3><ul>
<li><p>任务分配（Task assignment）</p>
</li>
<li><p>任务放置（Task placement）</p>
</li>
<li><p>任务分配（Task allocation）</p>
</li>
<li><p>资源分配（Resource allocation）</p>
</li>
<li><p>资源调度（Resource scheduling）</p>
</li>
</ul>
<p>上述问题被视为调度问题的特殊情况&#x2F;实例。</p>
<h3 id="调度算法的类型"><a href="#调度算法的类型" class="headerlink" title="调度算法的类型"></a>调度算法的类型</h3><p>解决优化问题的算法</p>
<ol>
<li>数学规划，例如整数规划、线性规划</li>
<li>进化算法，例如遗传算法（GA）、粒子群算法（PSO）、蚁群算法</li>
<li>简单且有效的启发式算法，例如列表调度</li>
<li>基于机器学习的算法，例如深度强化学习</li>
</ol>
<p>调度方法：系统考虑因素</p>
<ul>
<li><p>以机器为中心的方法</p>
<ul>
<li><p>当一台机器空闲时触发调度</p>
</li>
<li><p>对于每台空闲机器，根据一些策略选择任务，例如：</p>
<ul>
<li><p>先到先得（First-Come-First-Serve，FCFS）</p>
</li>
<li><p>最短作业优先（Shortest Job First，SJF）</p>
</li>
<li><p>最早截止时间优先（Earliest Deadline First，EDF）</p>
</li>
<li><p>首先选择等待时间最长的作业，…</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以任务为中心的方法</p>
<ul>
<li><p>当一个新任务到达时触发调度</p>
</li>
<li><p>对于每个被调度的任务，根据一些策略选择机器，例如最早完成时间，…</p>
</li>
</ul>
</li>
</ul>
<h4 id="列表调度方法"><a href="#列表调度方法" class="headerlink" title="列表调度方法"></a>列表调度方法</h4><p>computingopen in new window</p>
<ol>
<li>步骤 1：任务选择</li>
</ol>
<p>通过为每个任务分配优先级构建一个有序任务列表，然后按照它们的优先级顺序选择任务。</p>
<ol start="2">
<li>步骤 2：处理器选择</li>
</ol>
<p>将每个选定的任务调度到能够最小化预定义成本函数的处理器上。</p>
<ol start="3">
<li>重复执行步骤 1 和步骤 2，直到所有任务都被调度。</li>
</ol>
<p>例如：</p>
<p>Example: List Scheduling</p>
<ol>
<li>Step 1: 任务选择 - 上行排名（Upward rank）</li>
</ol>
<p>节点 i 的上行排名是最长路径的长度。</p>
<p>计算方法</p>
<p>在我们的算法中，任务按照基于向上和向下排名的调度优先级进行排序。任务 ni 的向上排名由</p>
<p>ranku(ni)&#x3D;wi―+maxnj∈succ(ni)(ci,j―+ranku(nj)),</p>
<p>递归定义。其中 succni 是任务ni的直接后继集合，ci,j― 是边(i,j)的平均通信成本；wi― 为任务 ni 的平均</p>
<p>计算成本。由于 Rank 是通过向上遍历任务图递归计算的，因此从退出任务开始，称为向上 Rank。对于</p>
<p>退出任务nexit，向上 Rank 值等于</p>
<p>ranku(nexit)&#x3D;wexit―.</p>
<p>基本上，ranku(ni) 是从任务 ni 到退出任务的关键路径的长度，包括任务 ni 的计算成本。文献中有一些</p>
<p>算法仅使用计算成本来计算排名值，其中称为静态向上排名，rankus。类似地，任务ni的向下排名由</p>
<p>rankd(ni)&#x3D;maxnj∈pred(ni){rankd(nj)+wj―+cj,i―}递归定义；其中pred(ni)是任务ni的直接前驱集合。通过从图的入口任务开始向下遍历任务图来递归地计</p>
<p>算向下排名。对于入口任务nentry，向下排名值等于 0。基本上，rankd(ni) 是从入口任务到任务ni的最</p>
<p>长距离，不包括任务本身的计算成本。</p>
<p>::: 2. Step 2: 处理器选择 - 最早完成时间</p>
<p>在处理器选择阶段，选择能够最早完成任务的处理器。这意味着根据任务的执行时间和处理器的当前状</p>
<p>态，选择能够最快完成任务的处理器进行调度。</p>
<p>Processor Selection – EarlistFinishTime</p>
<p>计算方法</p>
<p>EST(ni,,pj) 和 EFT(ni,pj) 分别是任务 ni 在处理器 pj 上的最早执行开始时间和最早执行结束时间。对于入</p>
<p>口任务 nentry，</p>
<p>EST(nentry,pj)&#x3D;0</p>
<p>对于图中的其他任务，从入口任务开始递归计算 EFT 和 EST 值，分别如下所示。为了计算任务 ni 的</p>
<p>EFT，需要计算任务 ni 的所有直接前置任务你肯定已经被安排好了。</p>
<p>EST(ni,pj)&#x3D;max{avail[j],maxnm∈pred(ni)</p>
<p>(AFT(nm)+cm,i)}EFT(ni,pj)&#x3D;wi,j+EST(ni,pj)AFT(ni)&#x3D;min∀jEFT(ni,pj)(AFT——ActualFinishTime)</p>
<p>其中 pred(ni) 是任务 ni 的直接前置任务的集合， </p>
<p>是处理器 pj 准备好执行任务的最早时间。如</p>
<p>果 nk 是处理器 pj 上最后分配的任务，则avail[j] 是当我们有基于非插入的调度策略时处理器 pj ，完成了</p>
<p>任务 nk 的执行，并且准备好执行另一个任务的时间。EST 方程中的内部 max 块返回就绪时间，即 ni 所</p>
<p>需的所有数据都已到达处理器pj的时间</p>
<p>任务 nm 在处理器 pj 上调度后， nm 在处理器 pj 上的最早开始时间和最早完成时间分别等于任务 nm</p>
<p>的实际开始时间 AST(nm) 和实际完成时间 AFT(nm) 。当一个图中的所有任务都被调度后，调度长度（即</p>
<p>总体完成时间）是退出任务nexit的实际完成时间。如果有多个退出任务并且插入伪退出任务的约定不适</p>
<p>用，调度长度(也称为makespan)定义为</p>
<p>makespan&#x3D;max{AFT(nexit)}</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>性能是指在特定类型需求的面前有效管理系统资源，以实现可接受的时间行为。</p>
<p>对于交互式和嵌入式实时系统，性能可以通过吞吐量和延迟来衡量。</p>
<p>通过减少需求或更合理地管理资源，可以提高性能。</p>
<h2 id="CH9-安全性"><a href="#CH9-安全性" class="headerlink" title="CH9 安全性"></a>CH9 安全性</h2><h3 id="什么是安全-security"><a href="#什么是安全-security" class="headerlink" title="什么是安全 security"></a>什么是安全 security</h3><ul>
<li><p>安全是系统保护数据和信息免受未经授权访问的能力的度量，同时仍然向经授权的人员和系统提供访问权限。</p>
</li>
<li><p>针对计算机系统的有意为害行为称为攻击。</p>
</li>
<li><p>攻击可以采取不同形式：</p>
<ul>
<li><p>未经授权的尝试访问&#x2F;修改数据或服务</p>
</li>
<li><p>旨在拒绝合法用户的服务</p>
</li>
</ul>
</li>
<li><p>安全具有三个主要特征，即 CIA：</p>
</li>
<li><p>保密性(Confidentiality)是数据或服务受到未经授权访问的保护性质。</p>
<ul>
<li>例如，黑客无法在政府计算机上访问您的个人所得税申报表。</li>
</ul>
</li>
<li><p>完整性(Integrity)是数据或服务不受未经授权操纵的性质。</p>
<ul>
<li>例如，您的成绩自从教师分配以来没有被更改。</li>
</ul>
</li>
<li><p>可用性(Availability)是系统能够供合法使用的性质。</p>
<ul>
<li>例如，拒绝服务攻击阻止您从在线书店订购一本书。</li>
</ul>
</li>
<li><p>支持 CIA 的其他特征包括：</p>
<ul>
<li><p>身份验证验证交易参与方的身份，并检查他们是否真实身份与其所声称的一致。</p>
</li>
<li><p>授权授予用户执行任务的权限。</p>
</li>
</ul>
</li>
</ul>
<h3 id="安全性策略-security-tatics"><a href="#安全性策略-security-tatics" class="headerlink" title="安全性策略 security-tatics"></a>安全性策略 security-tatics</h3><h4 id="检测攻击-detect-attacks"><a href="#检测攻击-detect-attacks" class="headerlink" title="检测攻击 detect-attacks"></a>检测攻击 detect-attacks</h4><ul>
<li><p>检测入侵(Detect Intrusion)：将系统内的网络流量或服务请求模式与存储在数据库中的恶意行为的一组签名或已知模式进行比较。</p>
</li>
<li><p>检测服务拒绝(Detect Service Denial)：将系统接收到的网络流量的模式或签名与已知拒绝服务（DOS）攻击的历史配置文件进行比较</p>
</li>
</ul>
<blockquote>
<p>DOS(Deny of Service Attack)</p>
<ul>
<li><p>Ping of Death（死亡之 Ping）是一种利用发送异常大的 ICMP 回显请求（Ping）来攻击目标系统的方法，超出系统处理能力导致系统崩溃或变得不稳定。</p>
</li>
<li><p>UDP Flood（UDP 洪泛）是通过发送大量伪造的 UDP 数据包来占用目标系统的网络带宽和资源，导致系统无法正常处理合法的网络请求。</p>
</li>
<li><p>TCP SYN（TCP 半开连接）攻击是通过发送大量伪造的 TCP 连接请求（SYN 包）来消耗目标系统的资源，使其无法建立新的有效连接，从而导致服务不可用。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>验证消息完整性(Verify Message Integrity): 使用校验和或哈希值等技术来验证消息、资源文件、部</p>
</li>
<li><p>署文件和配置文件的完整性。检测消息延迟: 通过检查传递消息所需的时间，可以检测到可疑的时间行为，即中间人攻击。</p>
</li>
</ul>
<h4 id="抵御攻击-resist-attacks"><a href="#抵御攻击-resist-attacks" class="headerlink" title="抵御攻击 resist-attacks"></a>抵御攻击 resist-attacks</h4><ul>
<li><p>识别参与者(Identify Actors)：识别系统接收的任何外部输入的来源。</p>
</li>
<li><p>对参与者进行身份验证(Authenticate Actors)：确保用户或远程计算机的实际身份与其所声称的身</p>
</li>
<li><p>份相符。</p>
</li>
<li><p>授权参与者(Authorize Actors)：确保经过身份验证的参与者有权访问和修改数据或服务。</p>
</li>
<li><p>限制访问(Limit Access)：限制对诸如内存、网络连接或访问点等资源的访问。</p>
</li>
<li><p>限制曝光(Limit Exposure)：通过尽可能减少访问点的数量来最小化系统的攻击面。</p>
<ul>
<li><p>例如，防火墙是对内部网络的单一访问点。</p>
</li>
<li><p>例如，关闭一个端口。</p>
</li>
<li><p>被动防御。</p>
</li>
</ul>
</li>
<li><p>加密数据(Encrypt Data)：对数据和通信应用某种形式的加密。</p>
</li>
<li><p>分离实体(Separate Entities)：可以通过在不同服务器上进行物理分离，使用虚拟机等方式实现。</p>
</li>
<li><p>更改默认设置(Change Default Settings)：强制用户更改默认分配的设置</p>
</li>
</ul>
<h4 id="应对攻击-react-to-attacks"><a href="#应对攻击-react-to-attacks" class="headerlink" title="应对攻击 react-to-attacks"></a>应对攻击 react-to-attacks</h4><ul>
<li><p>撤销访问权限( Revoke Access)：如果怀疑存在攻击，即使针对通常合法的用户和用途，也限制对</p>
</li>
<li><p>敏感资源的访问。</p>
</li>
<li><p>锁定计算机(Lock Computer)：如果有多次尝试访问失败，限制对资源的访问。</p>
</li>
<li><p>通知参与者(Inform Actors)：在怀疑或检测到攻击时，通知操作员、其他人员或合作系统</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>对系统的攻击可以归纳为针对系统的机密性、完整性或可用性的攻击。</p>
</li>
<li><p>识别、验证和授权参与者是旨在确定哪些用户或系统有权以何种方式访问系统的策略。</p>
</li>
<li><p>存在用于检测攻击、限制攻击传播以及对攻击做出反应和恢复的策略</p>
</li>
</ul>
<h2 id="CH10-可测试性"><a href="#CH10-可测试性" class="headerlink" title="CH10 可测试性"></a>CH10 可测试性</h2><h3 id="什么是可测试性"><a href="#什么是可测试性" class="headerlink" title="什么是可测试性"></a>什么是可测试性</h3><ul>
<li>软件的可测试性是指通过（通常是基于执行的）测试来展示其错误的难易程度</li>
<li>可测试性是指系统在下一次测试执行中失败的概率</li>
<li>如果系统存在错误，我们希望在测试阶段中尽快失败，及早修正</li>
<li>要使一个系统具有可测试性，必须能够控制每个组件的输入（并可能操作其内部状态），然后观察其输出（以及可能的内部状态）</li>
</ul>
<h3 id="可测试性策略的目标"><a href="#可测试性策略的目标" class="headerlink" title="可测试性策略的目标"></a>可测试性策略的目标</h3><ul>
<li>可测试性测量的目标是在软件开发完成的一个增量中实现更容易的测试</li>
<li>可测试性测量可以分为两个类别：<ul>
<li>第一个类别设计向系统添加可控性和可观察性</li>
<li>第二个类别设计限制系统设计中的复杂性</li>
</ul>
</li>
</ul>
<h3 id="可测试性策略"><a href="#可测试性策略" class="headerlink" title="可测试性策略"></a>可测试性策略</h3><p><img src="https://chiichen.github.io/assets/image-J21vDhO7.png" alt="Testability Tactics"></p>
<h4 id="控制和观察系统状态-control-and-observe-system-state"><a href="#控制和观察系统状态-control-and-observe-system-state" class="headerlink" title="控制和观察系统状态 control-and-observe-system-state"></a>控制和观察系统状态 control-and-observe-system-state</h4><ul>
<li>记录&#x2F;回放 record&#x2F;playback：捕获通过接口传递的信息，并将其用作进一步测试的输入。</li>
<li>本地化状态存储 localize-state-storage：为了测试，将系统置于任意状态时，如果该状态存储在一个单独的位置则最为方便。</li>
<li>专用接口 specialized-interfaces<ul>
<li>通过正常执行来控制或捕获组件的变量值</li>
<li>一组用于设置和获取变量的方法</li>
<li>一个返回对象状态的报告方法</li>
<li>一个用于设置内部状态的重置方法</li>
</ul>
</li>
<li>沙河 sandbox：将系统和真实世界隔离开来，以便进行实验。</li>
<li>可执行断言 executable-assertions：手动编写断言，并将其放置在所需位置，以指示程序何时以及在何处处于错误状态</li>
</ul>
<h4 id="限制复杂性-limit-complexity"><a href="#限制复杂性-limit-complexity" class="headerlink" title="限制复杂性 limit-complexity"></a>限制复杂性 limit-complexity</h4><ul>
<li>限制结构复杂性：避免或解决组件间的循环依赖，并减少组件间的依赖关系<ul>
<li>例如：限制继承树的深度</li>
</ul>
</li>
<li>高内聚低耦合</li>
<li>限制非确定性：找出所有非确定性的来源，例如无约束的并行性，尽可能消除</li>
</ul>
<blockquote>
<p> 测试可行性与容错性</p>
<ul>
<li>测试可行性旨在更容易地显示错误。</li>
<li>容错性试图隐藏错误，并使其难以暴露。</li>
<li>这两个设计目标是否不兼容？</li>
</ul>
<p>测试可行性和容错性是两个不同的设计目标，但并不一定是不兼容的。测试可行性旨在通过测试过程中更容易地检测和暴露错误，以便及早修复它们。容错性旨在使系统能够继续正常运行，即使在面临错误或故障的情况下也能提供可接受的性能和可靠性。</p>
<p>尽管两者有不同的关注点，但它们可以在系统设计中相互支持。例如，通过增加系统的容错能力，可以减少错误的发生率，从而提高测试的有效性。在设计过程中，可以采用合适的策略和技术来平衡测试可行性和容错性的需求，以确保系统在各个方面都具备良好的质量和可靠性。</p>
</blockquote>
<h2 id="CH11-易用性"><a href="#CH11-易用性" class="headerlink" title="CH11 易用性"></a>CH11 易用性</h2><h3 id="什么是易用性"><a href="#什么是易用性" class="headerlink" title="什么是易用性"></a>什么是易用性</h3><ul>
<li>易用性关注用户完成所需任务的难易程度以及系统提供的用户支持</li>
<li>易用性是改善系统质量的最便宜和最简单的方法之一</li>
<li>易用性主要包含：<ul>
<li>高效使用系统</li>
<li>学习系统的功能</li>
<li>尽量减少错误的影响</li>
<li>使系统适应用户需求</li>
<li>提高用户的信心和满意度</li>
</ul>
</li>
</ul>
<h3 id="易用性测量"><a href="#易用性测量" class="headerlink" title="易用性测量"></a>易用性测量</h3><p><img src="https://chiichen.github.io/assets/image-hYSiaVbE.png" alt="Usability tactics"></p>
<h3 id="支持用户主动性-support-user-initiative"><a href="#支持用户主动性-support-user-initiative" class="headerlink" title="支持用户主动性 support-user-initiative"></a>支持用户主动性 support-user-initiative</h3><ul>
<li>取消cancel：系统必须监听取消请求；<ul>
<li>被取消的命令必须终止</li>
<li>使用的资源必须释放</li>
<li>合作组件必须被通知</li>
</ul>
</li>
<li>暂停&#x2F;恢复 pause&#x2F;resume：临时释放资源，以便可以重新分配给其他任务<ul>
<li>用于长时间运行的操作</li>
</ul>
</li>
<li>恢复restore：保持足够的系统状态信息，以便可以恢复到先前的状态</li>
<li>组合aggregate：能够将较低级别的对象聚合成一个组，以便可以对该组应用用户操作，从而用户免于进行重复操作</li>
</ul>
<h3 id="支持系统主动性support-system-initiative"><a href="#支持系统主动性support-system-initiative" class="headerlink" title="支持系统主动性support-system-initiative"></a>支持系统主动性support-system-initiative</h3><ul>
<li>维护任务模型maintain-task-model：确定上下文，以便系统可以对用户的尝试有一定的了解，并提供帮助。</li>
<li>维护系统模型maintain-system-model：系统维护自身的显式模型。这用于确定预期的系统行为，以便向用户提供适当的反馈</li>
</ul>
<h2 id="CH12-其他质量属性"><a href="#CH12-其他质量属性" class="headerlink" title="CH12 其他质量属性"></a>CH12 其他质量属性</h2><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul>
<li>可移植性也是一种特殊的可修改性</li>
<li>可移植性指的是将为一个平台搭建的软件更改为在不同平台运行的便携程度</li>
</ul>
<h3 id="开发可分发性"><a href="#开发可分发性" class="headerlink" title="开发可分发性"></a>开发可分发性</h3><ul>
<li>开发可分发性是指设计软件以支持分布式软件开发的质量</li>
<li>系统是使用全球分布的团队开发的</li>
<li>目的是最大限度减少团队间的协调</li>
</ul>
<h3 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h3><ul>
<li>水平可拓展性（拓展外部）：指向逻辑单元添加更多资源，例如向集群添加另一个服务器</li>
<li>垂直可拓展性（拓展内部）：指向物理单元添加更多资源，例如向计算机添加更多的内存</li>
<li>可产生可衡量的改进，而无需中断操作</li>
</ul>
<blockquote>
<p>集中式与分散式</p>
<ul>
<li>在集中式架构中，控制和决策集中在一个单一的中央实体或服务器上。这种方法可以提供更好的资源协调和管理，但可能会成为单点故障并限制可扩展性。</li>
<li>相比之下，分散式架构将控制和决策分布在多个实体或服务器之间。这种方法可以提供更好的容错性、可扩展性和弹性，但可能会引入协调和一致性方面的挑战。</li>
</ul>
</blockquote>
<h3 id="部署性"><a href="#部署性" class="headerlink" title="部署性"></a>部署性</h3><ul>
<li>部署性关注的是可执行文件如何达到主机平台以及如何被调用</li>
<li>例如：<ul>
<li>javascript脚本</li>
<li>病毒</li>
<li>代理程序</li>
</ul>
</li>
</ul>
<h3 id="可监控性"><a href="#可监控性" class="headerlink" title="可监控性"></a>可监控性</h3><ul>
<li>可监控性涉及运维人员在系统执行过程中监控系统的能力</li>
<li>例如：<ul>
<li>各个组件的运行状态</li>
<li>平均事务处理时间</li>
<li>队列长度</li>
</ul>
</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>软件安全性涉及软件避免进入会导致损害、伤害或生命丧失的状态，并在进入不良状态时进行恢复和限制损害的能力</li>
<li>在安全性方面，框架关注的问题与可用性几乎一致</li>
</ul>
<h3 id="标准的质量属性列表"><a href="#标准的质量属性列表" class="headerlink" title="标准的质量属性列表"></a>标准的质量属性列表</h3><p><img src="https://chiichen.github.io/assets/image-DQ2sDQ7v.png" alt=" The ISO&#x2F;IEC FCD 25010 product quality standard"></p>
<h2 id="CH13-模式和策略"><a href="#CH13-模式和策略" class="headerlink" title="CH13 模式和策略"></a>CH13 模式和策略</h2><h3 id="什么是模式pattern"><a href="#什么是模式pattern" class="headerlink" title="什么是模式pattern"></a>什么是模式pattern</h3><ul>
<li><code>架构模型 an architecture-pattern</code>是一组在实践中反复出现的设计决策集合</li>
<li>具有已知的可复用性，并描述了一类框架</li>
</ul>
<h3 id="框架模式-an-architecture-pattern"><a href="#框架模式-an-architecture-pattern" class="headerlink" title="框架模式 an architecture-pattern"></a>框架模式 an architecture-pattern</h3><ul>
<li>模块模式<ul>
<li>分层模式</li>
</ul>
</li>
<li>组件与连接器模式<ul>
<li>代理模式</li>
<li>模式-视图-控制器模式</li>
<li>管道-过滤器模式</li>
<li>客户端-服务器模式</li>
<li>对等模式</li>
<li>面向服务的框架模式</li>
<li>发布-订阅模式</li>
<li>共享数据模式</li>
</ul>
</li>
<li>分配模式<ul>
<li>Map-reduce模式</li>
<li>多层模式</li>
</ul>
</li>
</ul>
<h3 id="分层模式-layered-pattern"><a href="#分层模式-layered-pattern" class="headerlink" title="分层模式 layered-pattern"></a>分层模式 layered-pattern</h3><ul>
<li><p>分层模式将软件划分为以“层 layer”为单位组成的集合</p>
</li>
<li><p>每个层是一个模块，提供一套协调一致的服务</p>
</li>
<li><p>每个层通过<code>公共接口 public-interface</code>进行暴露</p>
</li>
<li><p>使用必须是<strong>单向</strong>的</p>
</li>
<li><p>常见的分层模式有：</p>
<ul>
<li>三层架构：表示层，业务逻辑层和数据访问层</li>
<li>计算机网络TCP五层架构</li>
<li>OSI七层架构</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>分层模式定义了层与层之间的单向允许使用关系</li>
<li>约束条件 constraints<ul>
<li>每个软件部件都被分配到恰好一个层中</li>
<li>至少有两个层</li>
<li>不存在循环使用关系</li>
</ul>
</li>
<li>问题：<ul>
<li>添加层会导致系统的成本和复杂性的提高</li>
<li>层会对性能产生负面影响</li>
</ul>
</li>
</ul>
<h3 id="组件与连接器模式-component-and-connector-pattern"><a href="#组件与连接器模式-component-and-connector-pattern" class="headerlink" title="组件与连接器模式 component-and-connector-pattern"></a>组件与连接器模式 component-and-connector-pattern</h3><ul>
<li>组件与连接器模式是一种用于描述系统架构的模式</li>
<li>组件：是能够执行某些任务的模块</li>
<li>连接器：负责不同组件间的通信</li>
<li>该模式强调将系统划分为可供复用的独立组件，并通过连接器进行交互</li>
</ul>
<h3 id="代理模式-proxy-pattern"><a href="#代理模式-proxy-pattern" class="headerlink" title="代理模式 proxy-pattern"></a>代理模式 proxy-pattern</h3><ul>
<li>问题背景：许多系统由分布在多个服务器上的一组服务构建而成，如何构建<code>分布式软件 distributed-software</code>，使得服务使用者不需要知道服务提供者的性质和位置</li>
<li>解决思路：代理模式通过插入一个<code>中间层 intermediary</code>，称为代理，将客户端与服务提供者服务器分离开来。</li>
</ul>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>代理模式定义了一个运行时组件，称为代理，它在多个客户端和服务器之间充当进行通信和中介</li>
<li>组成部分：<ul>
<li>客户端 client：服务的请求者</li>
<li>服务器 server：服务的提供者</li>
<li>代理 broker，中间层，用于定位适合客户端请求的服务器，将请求转发给服务器，并将结果返回给客户端</li>
</ul>
</li>
<li>约束条件：客户端只能连接到代理，服务器也只能连接到代理</li>
<li>问题：<ul>
<li>代理会增加客户端与服务器之间的延迟，可能成为通信瓶颈</li>
<li>代理可能成为单点故障</li>
<li>代理可能成为安全攻击的目标</li>
</ul>
</li>
</ul>
<h3 id="模型-视图-控制器模式-model-view-controller-pattern"><a href="#模型-视图-控制器模式-model-view-controller-pattern" class="headerlink" title="模型-视图-控制器模式 model-view-controller-pattern"></a>模型-视图-控制器模式 model-view-controller-pattern</h3><ul>
<li>问题背景：用户界面软件是交互式应用程序中经常修改的部分，如何将用户界面功能和应用程序功能分开，同时仍能响应用户输入或底层应用程序数据的更改（当底层应用程序数据发生变化时，如何创建、维护和协调多个用户界面视图）</li>
</ul>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>MVC模式将应用程序分为三种组件<ul>
<li>M：包含应用程序的数据</li>
<li>V：显式底层数据的一部分并与用户交互</li>
<li>C：在 M 和 V 之间进行中介，并管理状态变化的通知</li>
</ul>
</li>
<li>约束条件：<ul>
<li>M，V 和 C 必须至少有一个实例</li>
</ul>
</li>
<li>问题：<ul>
<li>对于简单的用户界面来说，复杂性可能过高</li>
</ul>
</li>
</ul>
<h3 id="管道-过滤器模式-pipe-and-filter-pattern"><a href="#管道-过滤器模式-pipe-and-filter-pattern" class="headerlink" title="管道-过滤器模式 pipe-and-filter-pattern"></a>管道-过滤器模式 pipe-and-filter-pattern</h3><ul>
<li>问题背景：流式数据处理中，如何加快数据处理速度</li>
<li>解决思路：数据到达过滤器的输入端口后，结果转换，然后通过管道传递到下一个过滤器输入端口<ul>
<li>单个过滤器可以从管道中消费数据，也可以生产数据</li>
</ul>
</li>
</ul>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>组成：<ul>
<li>过滤器：一种将从输入端口读取的数据转换成写入其输出端口的数据的组件</li>
<li>管道：一种将数据从一个过滤器输出端口传递到另一个过滤器的输入端口的连接器</li>
</ul>
</li>
<li>关系：附加关系将过滤器的输出与管道的输入相关联，反之亦然</li>
<li>约束条件：<ul>
<li>连接的过滤器必须就沿着连接管道传递的数据类型达成一致</li>
</ul>
</li>
</ul>
<h3 id="客户端-服务器模式"><a href="#客户端-服务器模式" class="headerlink" title="客户端-服务器模式"></a>客户端-服务器模式</h3><ul>
<li>问题背景：存在<code>共享资源和服务</code>，许多分布式客户端希望访问这些资源和服务，希望<strong>控制对其的访问或提供服务的 质量</strong>，通过<strong>集中控制</strong>这些资源和服务阿里提高可用性</li>
<li>解决思路：客户端通过请求服务器的服务进行交互<ul>
<li>可能存在一个中央服务器和多个分布式服务器</li>
</ul>
</li>
</ul>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>问题：<ul>
<li>服务器可能成为性能瓶颈</li>
<li>服务器可能成为单点故障</li>
<li>在系统构建后，关于功能定位（在客户端还是服务器中）的决策复杂且成本高</li>
</ul>
</li>
</ul>
<h3 id="点多点模式-peer-to-peer-pattern"><a href="#点多点模式-peer-to-peer-pattern" class="headerlink" title="点多点模式 peer-to-peer-pattern"></a>点多点模式 peer-to-peer-pattern</h3><ul>
<li>问题背景：如何通过一个共同的协议将一组“相等的”分布式计算实体连接起来，让他们能以高可用性和可拓展性来阻止和共享其服务</li>
<li>解决思路：在点对点P2P模式中，组件作为对等体直接进行交互。所有对等体都是“相等的”。<ul>
<li>P2P通常是一种请求&#x2F;响应的交互方式，<strong>没有客户端-服务器模式的非对称性</strong></li>
</ul>
</li>
</ul>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>问题：<ul>
<li>管理数据一致性、数据&#x2F;服务的可用性、备份和恢复等都更加复杂</li>
<li>较小的P2P系统可能无法实现性能和可用性等质量目标</li>
</ul>
</li>
</ul>
<h3 id="面向服务的体系结构模式-service-oriented-architecture-pattern"><a href="#面向服务的体系结构模式-service-oriented-architecture-pattern" class="headerlink" title="面向服务的体系结构模式 service-oriented-architecture-pattern"></a>面向服务的体系结构模式 service-oriented-architecture-pattern</h3><ul>
<li>问题背景：如何支持在不同平台上运行、使用不同实现语言编写、由不同组织提供并分布在互联网上的分布式组件之间的互操作性</li>
<li>解决思路：面向服务的体系结构SOA模式描述了一组提供 和&#x2F;或 消费服务的分布式组件</li>
</ul>
<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>组成：<ul>
<li>组件：<ul>
<li>服务提供者：通过已发布的接口提供一个或多个服务</li>
<li>服务消费者：直接或通过中间件调用服务</li>
<li>企业服务总线 enterpise-service-bus ESB：作为<strong>中间件元素</strong>，可以在服务提供者和消费者之间路由和转化信息</li>
<li>服务注册表：供应商可使用注册表注册其服务，并运行时由消费者发现服务</li>
</ul>
</li>
<li>连接器：<ul>
<li>SOAP 连接器：使用SOAP协议进行Web服务之间的同步通信，通常通过HTTP进行</li>
<li>REST 连接器：依赖于HTTP协议的基本请求&#x2F;响应操作。</li>
<li>异步消息连接器：使用消息系统进行P2P或分布-订阅的**异步消息交换 asynchronous-message-exchange</li>
</ul>
</li>
</ul>
</li>
<li>问题：<ul>
<li>中间件存在与性能相关的开销，可能存在性能瓶颈，并且通常不提供性能保证</li>
</ul>
</li>
</ul>
<h3 id="分布-订阅模式-publish-subscirbe-pattern"><a href="#分布-订阅模式-publish-subscirbe-pattern" class="headerlink" title="分布-订阅模式 publish-subscirbe-pattern"></a>分布-订阅模式 publish-subscirbe-pattern</h3><p>问题背景：如何在生产者和消费者之间传递消息，使它们对彼此的身份&#x2F;存在毫不知情</p>
<h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>优势</p>
<ul>
<li>非常适合移动应用程序、普适计算和分布式嵌入式系统</li>
<li>鲁棒性 - 发布者或订阅者的故障不会导致整个系统崩溃</li>
<li>可扩展性 - 适用于构建由大量实体组成的分布式应用程序</li>
</ul>
</li>
<li><p>发布-订阅模式的缺点</p>
<ul>
<li>可靠性<ul>
<li>无法对代理服务器向订阅者传递内容提供强有力的保证。发布者发布事件后，假设所有相应的订阅者都将收到该事件。</li>
</ul>
</li>
<li>当订阅者和发布者过载代理服务器时，可能会在代理服务器中出现瓶颈。（可以通过负载均衡技术来解决</li>
</ul>
</li>
</ul>
<h3 id="共享数据模式"><a href="#共享数据模式" class="headerlink" title="共享数据模式"></a>共享数据模式</h3><ul>
<li><p>问题背景：各种计算组件需要共享和操作大量数据。这些数据<strong>不仅仅属于其中任何一个组件</strong>，系统如何存储和操作多个独立组件都有访问需求的<strong>持久数据</strong></p>
</li>
<li><p>解决思路：在共享数据模式中，交互主要通过多个数据访问者和至少一个共享数据存储组件的持久数据交换来实现</p>
<ul>
<li>交换可以由访问者或数据存储发起，连接器是数据读取和写入</li>
<li></li>
</ul>
</li>
<li><p>核心：</p>
<ul>
<li><strong>共享数据存储区</strong>：系统中的数据不保存在某个特定的组件或节点上，而是存储在一个共享的、全局可访问的地方。</li>
<li><strong>访问控制</strong>：由于多个组件可能会同时访问共享数据，如何控制对共享数据的访问和修改变得至关重要。通常需要引入锁机制、事务机制或版本控制来保证数据的一致性和避免并发冲突。</li>
<li><strong>数据一致性</strong>：共享数据模式面临的一个挑战是如何保持数据的一致性。由于数据由多个组件共享，在某一组件修改数据时，其他组件也应该能够感知并获取到最新的数据。这通常需要依赖某种同步机制，确保系统中的所有节点看到相同的视图。</li>
<li><strong>分布式共享</strong>：在分布式系统中，多个节点可能会有不同的副本或缓存副本，因此如何确保数据在多个副本之间同步、避免数据不一致是共享数据模式中的一个重要问题。</li>
</ul>
</li>
</ul>
<h3 id="Map-Reduce-分布式计算模式"><a href="#Map-Reduce-分布式计算模式" class="headerlink" title="Map-Reduce 分布式计算模式"></a>Map-Reduce 分布式计算模式</h3><p>- </p>
<h3 id="多层模式"><a href="#多层模式" class="headerlink" title="多层模式"></a>多层模式</h3><h3 id="策略和模式间的关系"><a href="#策略和模式间的关系" class="headerlink" title="策略和模式间的关系"></a>策略和模式间的关系</h3><h4 id="模式是由策略构建的"><a href="#模式是由策略构建的" class="headerlink" title="模式是由策略构建的"></a>模式是由策略构建的</h4><ul>
<li>多种策略的相互组合形成一种模式</li>
<li>MVC应用了：<ul>
<li>增加语义一致性</li>
<li>封装</li>
<li>使用中介者 intermediary</li>
</ul>
</li>
</ul>
<p>策略是用来解决特定问题的单个行动或技术，而模式是一种更高级别的设计解决方案，它将多个策略组合在一起，以解决更复杂的问题。模式提供一种通用的架构和组织原则，而策略则提供了具体的实现细节。策略是构成模式的组成要素</p>
<h4 id="策略增强了模式"><a href="#策略增强了模式" class="headerlink" title="策略增强了模式"></a>策略增强了模式</h4><ul>
<li>模式解决了特定的问题，但在某些方面可能存在问题</li>
<li>例如：代理模式中可能存在性能瓶颈、单点故障等</li>
<li>使用策略，增加资源以提高性能；维护多个副本以提高可用性</li>
</ul>
<p>策略用来增强模式，解决模式在某些方面的限制或弱点。通过合适的策略，可以改善模式的性能、可用性等质量属性，适应实际需求</p>
<h4 id="策略和模式相互作用"><a href="#策略和模式相互作用" class="headerlink" title="策略和模式相互作用"></a>策略和模式相互作用</h4><ul>
<li><p>每个策略都有优缺点</p>
</li>
<li><p>使用策略可以帮助减轻缺点</p>
</li>
<li><p>但没有万金油，一个常见的检测故障策略是 ping&#x2F;echo，但也存在问题：</p>
<ul>
<li>安全性，如何防止 ping 洪水攻击</li>
<li>性能：如何使 ping&#x2F;echo 开销最小</li>
<li>可修改性：如何将 ping&#x2F;echo 添加到现有架构中</li>
</ul>
</li>
<li><p>一个用于解决性能副作用的策略是“增加可用资源”（Increase Available Resources）。增加可用资源的常见副作用包括：</p>
<ul>
<li>成本：增加资源会带来额外的成本。</li>
<li>性能：如何高效利用增加的资源？</li>
</ul>
</li>
<li><p>一个用于解决资源高效利用副作用的策略是“调度策略”（Scheduling Policy）。调度策略的常见副作用包括：</p>
<ul>
<li>可修改性：如何将调度策略添加到现有架构中？</li>
<li>可修改性：如何在将来更改调度策略？</li>
</ul>
</li>
<li><p>架构模式是在实践中反复出现的设计决策的集合。</p>
</li>
<li><p>架构模式具有已知的属性，可以进行重复使用，并描述了一类架构。</p>
</li>
<li><p>策略比模式更简单。</p>
</li>
<li><p>模式对于真实系统来说是不完全的，因此需要通过策略进行补充。</p>
<ul>
<li>当满足特定系统的需求时，对模式的补充就会结束。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" data-id="cm7pnj2a2006kucv29ma53wte" data-title="软件架构设计期末复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          软件项目管理期末复习
        
      </div>
    </a>
  
  
    <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">计算机网络期末复习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/typora/">typora</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E9%A9%AC-%E5%90%8E%E7%AB%AF/">黑马:后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E5%9F%BA%E7%A1%80/" rel="tag">Vue基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html%E5%9F%BA%E7%A1%80/" rel="tag">html基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%BA%95%E5%B1%82/" rel="tag">java底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80/" rel="tag">js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" rel="tag">单体架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%B3%E6%B3%95/" rel="tag">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" rel="tag">闲杂经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC/" rel="tag">黑马</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDBC/" style="font-size: 11.67px;">JDBC</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Vue%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Vue基础</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/html%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">html基础</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/java%E5%BA%95%E5%B1%82/" style="font-size: 10px;">java底层</a> <a href="/tags/java%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">java框架</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">js基础</a> <a href="/tags/juc/" style="font-size: 10px;">juc</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">关系型</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" style="font-size: 11.67px;">单体架构</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.33px;">后端</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">基础</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 16.67px;">大学专业课</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" style="font-size: 13.33px;">学习规划</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.33px;">数据库</a> <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="font-size: 20px;">期末复习</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" style="font-size: 15px;">计算机四大件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">设计架构</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件架构设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">软件项目管理</a> <a href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">闲杂经验</a> <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">非关系型</a> <a href="/tags/%E9%AB%98%E9%98%B6/" style="font-size: 10px;">高阶</a> <a href="/tags/%E9%BB%91%E9%A9%AC/" style="font-size: 11.67px;">黑马</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/LeetCode/">Leetcode刷题题解</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>