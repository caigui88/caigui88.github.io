<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Bookdone开发日记第一个工作：redis缓存redis缓存一般只用于对于更新不算特别频繁但是前端又需要频繁调用的数据，为了提供更好的用户即时交互体验。 在本次任务中，我编写了对于知识点的缓存：  为了提高数据的响应效率，对于根据固定文章内容生成的基本不变的知识点内容列表，可以考虑使用缓存技术以提高用户的反复查询体验。  本次需求实现采用的是redis 非关系型数据库作为缓存工具，基本流程为：">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Bookdone开发日记第一个工作：redis缓存redis缓存一般只用于对于更新不算特别频繁但是前端又需要频繁调用的数据，为了提供更好的用户即时交互体验。 在本次任务中，我编写了对于知识点的缓存：  为了提高数据的响应效率，对于根据固定文章内容生成的基本不变的知识点内容列表，可以考虑使用缓存技术以提高用户的反复查询体验。  本次需求实现采用的是redis 非关系型数据库作为缓存工具，基本流程为：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/.%5Cbookdone.assets%5Cimage-20250226143135446.png">
<meta property="og:image" content="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/bookdone.assets/image-20250222230854595.png">
<meta property="og:image" content="http://example.com/.%5Cbookdone.assets%5COssUploadHandler.png">
<meta property="og:image" content="http://example.com/.%5Cbookdone.assets%5Cdiagram.png">
<meta property="article:published_time" content="2025-03-01T03:35:47.131Z">
<meta property="article:modified_time" content="2025-02-26T15:35:36.729Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.%5Cbookdone.assets%5Cimage-20250226143135446.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-后端开发/实习/bookdone" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/" class="article-date">
  <time class="dt-published" datetime="2025-03-01T03:35:47.131Z" itemprop="datePublished">2025-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Bookdone开发日记"><a href="#Bookdone开发日记" class="headerlink" title="Bookdone开发日记"></a>Bookdone开发日记</h1><h2 id="第一个工作：redis缓存"><a href="#第一个工作：redis缓存" class="headerlink" title="第一个工作：redis缓存"></a>第一个工作：redis缓存</h2><p>redis缓存一般只用于对于更新不算特别频繁但是前端又需要频繁调用的数据，为了提供更好的用户即时交互体验。</p>
<p>在本次任务中，我编写了对于知识点的缓存：</p>
<ol>
<li><p>为了提高数据的响应效率，对于根据固定文章内容生成的基本不变的知识点内容列表，可以考虑使用缓存技术以提高用户的反复查询体验。</p>
</li>
<li><p>本次需求实现采用的是redis 非关系型数据库作为缓存工具，基本流程为：</p>
<ol>
<li>根据用户查询的chapterId进入redis中进行查询</li>
<li>假如得到正确的返回结果，则直接将结果返回或进行流传输</li>
<li>假如返回结果为空，说明缓存中不存在该内容，则进入到Dao层进行数据库查询</li>
<li>将数据库查询出的内容进行redis缓存并设置键值对有效周期为 30min，以便用户短时间内频繁切换不同章节时可以更快的展示。</li>
</ol>
</li>
<li><p>开发过程中遇到的问题：</p>
<ol>
<li>最好将数据库查询操作与redis缓存操作进行原子化，原因是，只有在每次缓存中查找不到信息时才会进入DAO层查询数据库，而在进入DAO层查询数据库时就应当顺便做完缓存操作</li>
<li>本次开发犯的问题是，原本是为了将redis缓存操作放在流传输之后，但是由于没有考虑到如果未与数据库查询操作进行原子化，就会频繁进行redis的更新，增加了无端的内存开销。</li>
</ol>
</li>
<li><p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;KnowledgeNode&gt; <span class="title function_">getKnowledgeNodeList</span><span class="params">(Long chapterId)</span> &#123;</span><br><span class="line">    List&lt;KnowledgeNode&gt; knowledgeNodeList;</span><br><span class="line">   </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisKeyConstant.KNOWLEDGE_NODE + chapterId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dataJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果 redis 中有知识点列表，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNoneBlank(dataJson))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            knowledgeNodeList = objectMapper.readValue(dataJson, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;KnowledgeNode&gt;&gt;()&#123;&#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JsonProcessingException e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;反序列化知识点异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;获取知识点异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果 redis 中没有知识点列表，从数据库中查询</span></span><br><span class="line">        knowledgeNodeList = knowledgeNodeMapper.selectList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;KnowledgeNode&gt;()</span><br><span class="line">                        .eq(<span class="string">&quot;chapter_id&quot;</span>, chapterId)</span><br><span class="line">                        .eq(<span class="string">&quot;is_deleted&quot;</span>, WhetherEnum.NO.getType())</span><br><span class="line">                        .orderByAsc(<span class="string">&quot;sort&quot;</span>));</span><br><span class="line">        <span class="comment">// 查询到知识点列表后，缓存到 redis</span></span><br><span class="line">        cache4Redis(key, knowledgeNodeList);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> knowledgeNodeList;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cache4Redis</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, objectMapper.writeValueAsString(value), <span class="number">30L</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;序列化缓存失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="简历可能提问准备："><a href="#简历可能提问准备：" class="headerlink" title="简历可能提问准备："></a>简历可能提问准备：</h2><p><img src="/.%5Cbookdone.assets%5Cimage-20250226143135446.png" alt="image-20250226143135446"></p>
<h3 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h3><ol>
<li><p>进行 redis 缓存采用的 key 是怎么设计的： </p>
<p>根据具体的业务场景来定义常量</p>
<p>例如 CHAPTER_ORIGINAL_CONTENT &#x3D; “book:chapter_original_content:” ➕ 全局分布式唯一ID 的形式设置为 key，确保了 key 的唯一性。</p>
</li>
<li><p>redis 相关的好处</p>
</li>
</ol>
<h3 id="Redisson："><a href="#Redisson：" class="headerlink" title="Redisson："></a>Redisson：</h3><ul>
<li><p>分布式锁实现：</p>
<p>Redisson 基于 Redis 的 Lua 脚本和 Pub&#x2F;Sub 机制实现分布式锁</p>
<ul>
<li>可重入锁</li>
<li>自动续期</li>
<li>公平锁&#x2F;非公平锁</li>
</ul>
</li>
</ul>
<p>Redisson 和 SENTNX 的对比</p>
<h3 id="责任链相关"><a href="#责任链相关" class="headerlink" title="责任链相关"></a>责任链相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookUploadContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户 id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件原名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String originalFilename;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析操作是否完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean finished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件存储在 oss 的 url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件哈希值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fileHash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * oss 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OssTypeEnum ossType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * book id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long bookId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本解析结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BookAnalysisDTO bookAnalysisDTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 知识点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;KnowledgeNode&gt; knowledgeNodeList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String contentType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lang;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>责任链是如何设计的：</p>
<p>责任链全流程为：</p>
<ul>
<li>用户上传电子书</li>
<li>查询是否存在可重用的书本<ul>
<li>计算当前电子书哈希值</li>
<li>查表，看看是否有相同的且解析完成的书本</li>
<li>如果存在则插入新用户的书本相关内容，如章节、章节关系、章节摘要、章节知识点、知识点关系</li>
<li>如果不存在则直接返回，进入下一个处理器</li>
</ul>
</li>
<li>文件云存储，该步骤如果失败终止后续</li>
<li>将拆解后的章节内容落表存储</li>
<li>章节知识处理</li>
</ul>
</li>
</ol>
<h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h3><h3 id="OSS-服务相关"><a href="#OSS-服务相关" class="headerlink" title="OSS 服务相关"></a>OSS 服务相关</h3><p>STS 服务为什么更安全：</p>
<ul>
<li><p><strong>传统长期密钥的风险</strong><br>长期有效的AccessKey一旦泄露（如代码泄露、员工误操作），攻击者可在密钥有效期内无限次访问云资源，造成数据泄露或资源滥用。</p>
<p>STS生成<strong>短期有效的临时凭证</strong>（默认15分钟~36小时），即使凭证被截获，攻击窗口期也大幅缩短</p>
</li>
<li><p><strong>动态权限控制</strong><br>每次生成临时凭证时，可附加<strong>细粒度的权限策略</strong>，仅授予执行当前任务所需的最小权限。</p>
</li>
<li><p><strong>客户端无长期密钥存储</strong><br>在移动端或浏览器端场景中，应用可通过STS动态获取临时凭证，无需在客户端存储长期AccessKey</p>
</li>
</ul>
<h2 id="主要业务："><a href="#主要业务：" class="headerlink" title="主要业务："></a>主要业务：</h2><h3 id="UserController-用户管理接口"><a href="#UserController-用户管理接口" class="headerlink" title="UserController 用户管理接口"></a>UserController 用户管理接口</h3><h3 id="FileController-书本文件上传接口"><a href="#FileController-书本文件上传接口" class="headerlink" title="FileController 书本文件上传接口"></a>FileController 书本文件上传接口</h3><p>书本上传功能的实现类为： FileServiceImpl</p>
<p>文件的上传涉及到的技术为：对象存储服务，在 bookdone 项目中使用的对象存储服务是 阿里云对象存储服务。</p>
<p>文件的上传需要获取 oss 上传临时凭证，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;获取 oss 上传临时凭证&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/oss-temp-credential&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;OssTempCredentialVO&gt; <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(fileService.getOssTempCredential());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> OssTempCredentialVO <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliOssUtil.getOssTempCredential();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssTempCredentialVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String expiration; <span class="comment">// 临时凭证的过期时间。</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId; <span class="comment">// 临时访问密钥ID。</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret; <span class="comment">// 临时访问密钥。</span></span><br><span class="line">    <span class="keyword">private</span> String securityToken; <span class="comment">// 安全令牌。</span></span><br><span class="line">    <span class="keyword">private</span> String requestId; <span class="comment">// 请求的唯一标识符。</span></span><br><span class="line">    <span class="keyword">private</span> String bucket; <span class="comment">// OSS存储桶的名称。</span></span><br><span class="line">    <span class="keyword">private</span> String region; <span class="comment">// OSS存储桶所在的区域。</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint; <span class="comment">// OSS服务的访问端点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OssTempCredentialVO <span class="title function_">getOssTempCredential</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">OssTempCredentialVO</span> <span class="variable">ossTempCredentialVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OssTempCredentialVO</span>();</span><br><span class="line">      ossTempCredentialVO.setBucket(aliOssProperties.getBucketName());</span><br><span class="line">      ossTempCredentialVO.setRegion(aliOssProperties.getRegion());</span><br><span class="line">      ossTempCredentialVO.setEndpoint(aliOssProperties.getEndpoint());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STS服务接入点，例如sts.cn-hangzhou.aliyuncs.com。您可以通过公网或者VPC接入STS服务。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;sts.cn-guangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line">      <span class="comment">// 从环境变量中获取步骤1生成的RAM用户的访问密钥（AccessKey ID和AccessKey Secret）。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOssProperties.getAccessKeyId();</span><br><span class="line">      <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOssProperties.getAccessKeySecret();</span><br><span class="line">      <span class="comment">// 从环境变量中获取步骤3生成的RAM角色的RamRoleArn。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">roleArn</span> <span class="operator">=</span> aliOssProperties.getStsArn();</span><br><span class="line">      <span class="comment">// 自定义角色会话名称，用来区分不同的令牌，例如可填写为SessionTest。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">roleSessionName</span> <span class="operator">=</span> <span class="string">&quot;bookdone-upload-session&quot;</span>;</span><br><span class="line">      <span class="comment">// 临时访问凭证将获得角色拥有的所有权限。</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 临时访问凭证的有效时间，单位为秒。最小值为900，最大值以当前角色设定的最大会话时间为准。当前角色最大会话时间取值范围为3600秒~43200秒，默认值为3600秒。</span></span><br><span class="line">      <span class="comment">// 在上传大文件或者其他较耗时的使用场景中，建议合理设置临时访问凭证的有效时间，确保在完成目标任务前无需反复调用STS服务以获取临时访问凭证。</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">durationSeconds</span> <span class="operator">=</span> <span class="number">3600L</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发起STS请求所在的地域。建议保留默认值，默认值为空字符串（&quot;&quot;）。</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">regionId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">          <span class="comment">// 添加endpoint。适用于Java SDK 3.12.0及以上版本。</span></span><br><span class="line">          DefaultProfile.addEndpoint(regionId, <span class="string">&quot;Sts&quot;</span>, endpoint);</span><br><span class="line">          <span class="comment">// 添加endpoint。适用于Java SDK 3.12.0以下版本。</span></span><br><span class="line">          <span class="comment">// DefaultProfile.addEndpoint(&quot;&quot;,regionId, &quot;Sts&quot;, endpoint);</span></span><br><span class="line">          <span class="comment">// 构造default profile。</span></span><br><span class="line">          <span class="type">IClientProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);</span><br><span class="line">          <span class="comment">// 构造client。</span></span><br><span class="line">          <span class="type">DefaultAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line">          <span class="keyword">final</span> <span class="type">AssumeRoleRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AssumeRoleRequest</span>();</span><br><span class="line">          <span class="comment">// 适用于Java SDK 3.12.0及以上版本。</span></span><br><span class="line">          request.setSysMethod(MethodType.POST);</span><br><span class="line">          request.setRoleArn(roleArn);</span><br><span class="line">          request.setRoleSessionName(roleSessionName);</span><br><span class="line">          request.setPolicy(policy);</span><br><span class="line">          request.setDurationSeconds(durationSeconds);</span><br><span class="line">          <span class="keyword">final</span> <span class="type">AssumeRoleResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getAcsResponse(request);</span><br><span class="line">          System.out.println(<span class="string">&quot;Expiration: &quot;</span> + response.getCredentials().getExpiration());</span><br><span class="line">          ossTempCredentialVO.setExpiration(response.getCredentials().getExpiration());</span><br><span class="line">          System.out.println(<span class="string">&quot;Access Key Id: &quot;</span> + response.getCredentials().getAccessKeyId());</span><br><span class="line">          ossTempCredentialVO.setAccessKeyId(response.getCredentials().getAccessKeyId());</span><br><span class="line">          System.out.println(<span class="string">&quot;Access Key Secret: &quot;</span> + response.getCredentials().getAccessKeySecret());</span><br><span class="line">          ossTempCredentialVO.setAccessKeySecret(response.getCredentials().getAccessKeySecret());</span><br><span class="line">          System.out.println(<span class="string">&quot;Security Token: &quot;</span> + response.getCredentials().getSecurityToken());</span><br><span class="line">          ossTempCredentialVO.setSecurityToken(response.getCredentials().getSecurityToken());</span><br><span class="line">          System.out.println(<span class="string">&quot;RequestId: &quot;</span> + response.getRequestId());</span><br><span class="line">          ossTempCredentialVO.setRequestId(response.getRequestId());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Failed：&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Error code: &quot;</span> + e.getErrorCode());</span><br><span class="line">          System.out.println(<span class="string">&quot;Error message: &quot;</span> + e.getErrorMessage());</span><br><span class="line">          System.out.println(<span class="string">&quot;RequestId: &quot;</span> + e.getRequestId());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ServerException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.aliyuncs.exceptions.ClientException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ossTempCredentialVO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><h4 id="初始化-OssTempCredentialVO-对象"><a href="#初始化-OssTempCredentialVO-对象" class="headerlink" title="初始化 OssTempCredentialVO 对象"></a>初始化 <code>OssTempCredentialVO</code> 对象</h4><p>首先通过注入了配置文件信息的 <code>private AliOssProperties aliOssProperties</code> 来初始化 <code>OssTempCredentialVO</code> 对象</p>
<h4 id="STS-服务配置"><a href="#STS-服务配置" class="headerlink" title="STS 服务配置"></a>STS 服务配置</h4><p><strong>STS（Security Token Service，安全令牌服务）</strong> 是阿里云提供的一种服务，用于生成和管理临时访问凭证（临时安全令牌）。这些临时凭证可以代替长期有效的访问密钥（AccessKey），用于访问阿里云的资源（如OSS、ECS、RDS等），从而提高系统的安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STS服务接入点，例如sts.cn-hangzhou.aliyuncs.com。您可以通过公网或者VPC接入STS服务。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;sts.cn-guangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 从环境变量中获取步骤1生成的RAM用户的访问密钥（AccessKey ID和AccessKey Secret）。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOssProperties.getAccessKeyId();</span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOssProperties.getAccessKeySecret();</span><br><span class="line"><span class="comment">// 从环境变量中获取步骤3生成的RAM角色的RamRoleArn。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">roleArn</span> <span class="operator">=</span> aliOssProperties.getStsArn();</span><br><span class="line"><span class="comment">// 自定义角色会话名称，用来区分不同的令牌，例如可填写为SessionTest。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">roleSessionName</span> <span class="operator">=</span> <span class="string">&quot;bookdone-upload-session&quot;</span>;</span><br><span class="line"><span class="comment">// 临时访问凭证将获得角色拥有的所有权限。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<p>主要分为两个上传方式：</p>
<p><code>upload</code></p>
<ul>
<li>功能：上传文件、计算文件哈希值、检查文件是否已存在、解析文件内容、保存文件到本地、创建图书记录、异步处理文件上传和解析任务。</li>
</ul>
<p>代码流程：</p>
<ol>
<li><p>用户登陆检验</p>
<p>如果用户未登陆会抛出异常 <code>RuntimeException(&quot;用户未登录&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> Optional.ofNullable(UserContextHolder.getCurrentUser())</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件非空检查</p>
<p>如果文件为空，抛出异常 <code>RuntimeException(&quot;文件为空&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = Optional.ofNullable(file)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件为空&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算文件哈希值</p>
<ul>
<li>使用 <code>DigestUtils.md5DigestAsHex</code> 计算文件的 MD5 哈希值；如果哈希值计算失败抛出异常 <code>RuntimeException(&quot;文件 hash 计算失败&quot;)</code></li>
<li>检查数据库中是否已存在相同哈希值的文件（避免重复上传）。</li>
<li>如果文件已存在，抛出业务异常 <code>BusinessException(ErrorCode.BOOK_EXIST_ERROR, &quot;该书已存在&quot;)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String fileHash;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileHash = DigestUtils.md5DigestAsHex(file.getInputStream());</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> bookMapper.selectFileHashCount(fileHash, currentUser.getId());</span><br><span class="line">    ThrowUtils.throwIf(count &gt; <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.BOOK_EXIST_ERROR, <span class="string">&quot;该书已存在&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;文件 hash 计算失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件 hash 计算失败&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;文件已存在&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.BOOK_EXIST_ERROR, <span class="string">&quot;该书已存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件类型检查</p>
<ul>
<li>提取文件扩展名，并检查是否为 <code>EPUB</code> 格式。</li>
<li>如果文件类型不符合要求，抛出业务异常 <code>BusinessException(ErrorCode.File_TYPE_ERROR, &quot;文件类型错误，必须为 epub&quot;)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">ThrowUtils.throwIf(StringUtils.isBlank(filename), <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件名为空&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">ThrowUtils.throwIf(!FileExtentionEnum.EPUB.getDesc().equals(fileExtension.toLowerCase()), </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.File_TYPE_ERROR, <span class="string">&quot;文件类型错误，必须为 epub&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户解析额度检查</p>
</li>
<li><p>文件解析</p>
<ol>
<li>调用 <code>analyzeBook</code> 方法解析文件内容。</li>
</ol>
</li>
<li><p>文件存储</p>
<ol>
<li><p>先生成分布式唯一图书 ID</p>
</li>
<li><p>构建文件本地保存路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCAL_DIR</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;upload&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其中 System.getProperty(“user.dir”) 是当前工作目录（即运行 Java 程序的目录）。</p>
<p><code>File.separator</code>: 系统文件路径分隔符（在 Windows 上是 <code>\</code>，在 Linux 和 macOS 上是 <code>/</code>）。</p>
<p><code>&quot;upload&quot;</code>: 在项目根目录下创建一个名为 <code>upload</code> 的文件夹，用于存储上传的文件。</p>
<p>综上 LOCAL_DIR 的值为：<code>&lt;项目根目录&gt;/upload</code></p>
</li>
<li><p>构建用户和图书的目录结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">localFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(LOCAL_DIR + File.separator + userId + File.separator + bookId + filename);</span><br></pre></td></tr></table></figure>

<p>根据以上逻辑最终存储路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;项目根目录&gt;/upload/userId/bookId+filename.epub</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>创建图书记录</p>
<ul>
<li>创建 <code>Book</code> 对象并设置相关属性（ID、文件哈希值、状态、OSS 类型、语言等）。</li>
<li>提取封面图片并上传到阿里云 OSS。</li>
<li>设置书名并保存图书信息到数据库。</li>
</ul>
</li>
<li><p>保存用户-图书关系</p>
<ul>
<li>创建 <code>UserBook</code> 对象并设置用户 ID 和图书 ID。</li>
<li>保存用户-图书关系到数据库。</li>
</ul>
</li>
<li><p>异步处理上传和解析任务</p>
<ul>
<li>创建 <code>BookUploadTask</code> 任务，并使用责任链模式调用多个处理器处理上传和解析任务。</li>
<li>将任务提交到线程池 <code>CoreBusinessPoolHolder</code> 中异步执行。</li>
</ul>
</li>
<li><p>返回生成的唯一图书 UID</p>
</li>
</ol>
<p><code>uploadV2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="书本和用户的关系"><a href="#书本和用户的关系" class="headerlink" title="书本和用户的关系"></a>书本和用户的关系</h3><h3 id="ChapterController-章节相关接口"><a href="#ChapterController-章节相关接口" class="headerlink" title="ChapterController 章节相关接口"></a>ChapterController 章节相关接口</h3><h4 id="获取章节知识点"><a href="#获取章节知识点" class="headerlink" title="获取章节知识点"></a>获取章节知识点</h4><p>简单的根据章节 id 到数据库获取知识点，组装入 vo 对象直接返回给前端处理即可</p>
<h4 id="获取章节知识树"><a href="#获取章节知识树" class="headerlink" title="获取章节知识树"></a>获取章节知识树</h4><h5 id="技术使用："><a href="#技术使用：" class="headerlink" title="技术使用："></a>技术使用：</h5><ol>
<li><strong>redis</strong>： 知识树内容不多，选择缓存知识树，减少对数据库的查询，快速响应用户阅览<ul>
<li>缓存优先：首先从 redis 中根据 key 获取知识树，如果缓存命中则直接返回</li>
<li>未命中再从数据库或算法服务中获取数据，并将结果缓存到 Redis。</li>
</ul>
</li>
<li><h2 id="分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。"><a href="#分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。" class="headerlink" title="分布式锁：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。"></a><strong>分布式锁</strong>：并发场景下确保同一章节的知识树生成任务不会重复执行，防止同一章节的知识树被多次生成，浪费资源。</h2></li>
<li><strong>自定义异常处理</strong>：</li>
</ol>
<h4 id="获取章节摘要"><a href="#获取章节摘要" class="headerlink" title="获取章节摘要"></a>获取章节摘要</h4><h4 id="获取章节知识点原文"><a href="#获取章节知识点原文" class="headerlink" title="获取章节知识点原文"></a>获取章节知识点原文</h4><h4 id="获取章节知识点自生成内容"><a href="#获取章节知识点自生成内容" class="headerlink" title="获取章节知识点自生成内容"></a>获取章节知识点自生成内容</h4><h4 id="章节自测题-SelftTest"><a href="#章节自测题-SelftTest" class="headerlink" title="章节自测题 SelftTest"></a>章节自测题 SelftTest</h4><p>总共三个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;生成章节自测题&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/gen-self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Void&gt; <span class="title function_">generateSelfTest</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;chapterId&quot;)</span> Long chapterId,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;是否重新生成：0-否；1-是，不传默认为 0&quot;)</span> <span class="meta">@RequestParam(value = &quot;reGenerate&quot;, required = false)</span> Integer reGenerate,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;生成选择题数量，不传默认为 2&quot;)</span> <span class="meta">@RequestParam(value = &quot;choiceQuestionNum&quot;, required = false)</span> Integer choiceQuestionNum,</span></span><br><span class="line"><span class="params">        <span class="meta">@ApiParam(&quot;生成判断题数量，不传默认为 2&quot;)</span> <span class="meta">@RequestParam(value = &quot;judgeQuestionNum&quot;, required = false)</span> Integer judgeQuestionNum)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(chapterContentService.generateSelfTest(chapterId, reGenerate, choiceQuestionNum, judgeQuestionNum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;获取章节自测题&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;ChapterTestQuestionVO&gt; <span class="title function_">getSelfTest</span><span class="params">(<span class="meta">@RequestParam(&quot;chapterId&quot;)</span> Long chapterId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(chapterContentService.getSelfTest(chapterId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;判断用户是否掌握此章节&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/self-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;SelfTestResultVO&gt; <span class="title function_">judgeSelfTest</span><span class="params">(<span class="meta">@RequestBody</span> SelfTestSubmitReq selfTestSubmitReq)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(chapterContentService.judgeSelfTest(selfTestSubmitReq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生成自测问题"><a href="#生成自测问题" class="headerlink" title="生成自测问题"></a>生成自测问题</h5><p>采用了线程池技术进行<strong>异步生成对应章节的自测题</strong>。</p>
<ul>
<li><p>首先创建 <code>GenTestQuestionTask</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenTestQuestionTask</span> <span class="variable">genTestQuestionTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenTestQuestionTask</span>(questionMapper, redisIdWorker, algConfig, knowledgeNodeMapper, chapterId, redissonClient);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将 <code>GenTestQuestionTask</code> 对象放入核心业务线程池中执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoreBusinessPoolHolder.execute(genTestQuestionTask);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenTestQuestionTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br></pre></td></tr></table></figure>

<p>由于 <code>GenTestQuestionTask</code> 实习了接口 <code>Runnable</code> ，因此将该任务放入线程池后，线程池会自动调用 <code>run</code> 方法，从而实现异步生成章节自测题。</p>
</li>
<li><p><code>GenTestQuestionTask</code> 中实现的 <code>run</code> 方法：</p>
<p>首先获取分布式锁：</p>
<p>确保同一个章节的自测题生成任务不会出现并发执行，防止重复生成或造成数据不一致</p>
<p><strong>实现细节</strong>：</p>
<ul>
<li>在获取 lock 时使用的是 <code>tryLock</code> 方法，该方法是非阻塞式的，也就意味着 “<strong>尝试获取锁，但不会无限期等待</strong>”。允许调用者在获取锁失败时立即返回或执行其他逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;chapter:content:question:lock:&quot;</span> + chapterId);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;章节 &#123;&#125; 生成自测题任务已被其他线程执行&quot;</span>, chapterId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而后查询章节下的知识点列表、封装好请求参数后</p>
<p>使用 <code>OkHttpClient</code> 发送 POST 请求到算法端，调用算法端服务生成题目</p>
<p>获取算法端解析完毕的响应，得到生成好的对应章节的题目列表</p>
<p>将获取到的题目列表封装到 Question 的列表中而后落表存储题目数据</p>
<p>最后释放分布式锁</p>
</li>
</ul>
<h5 id="获取章节自测题"><a href="#获取章节自测题" class="headerlink" title="获取章节自测题"></a>获取章节自测题</h5><p>根据请求的 <code>chapterId</code>，在数据库中查询在章节下是否已经有对应的自测题</p>
<p>如果有封装成 <code>List&lt;CommonQuestionVO&gt;</code> 封装入 <code>ChapterTestQuestionVO</code> 对象后直接返回。</p>
<p>如果没有会进入 生成自测题 的业务，生成自测题后再重新获取数据库中的题目列表再返回给前端。</p>
<p><strong>实现细节</strong>:</p>
<ul>
<li><p>在获取 lock 时使用的是 <code>tryLock</code> 方法，该方法是非阻塞式的，也就意味着 “<strong>尝试获取锁，但不会无限期等待</strong>”。允许调用者在获取锁失败时立即返回或执行其他逻辑</p>
</li>
<li><p>同时自定义锁的获取策略：设置好了重试次数、重试间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isLocked) &#123;</span><br><span class="line">    <span class="comment">// 获取不到锁，说明有其他线程在生成题目</span></span><br><span class="line">    log.info(<span class="string">&quot;chapterId: &#123;&#125; 等待其他线程生成题目&quot;</span>, chapterId);</span><br><span class="line">    CoreBusinessPoolHolder.executeNormal(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retryTimes</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRetryTimes</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!questionsGenerated.get()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;chapterId: &#123;&#125; 轮询第 &#123;&#125; 次尝试获取锁&quot;</span>, chapterId, retryTimes++);</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; maxRetryTimes) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;chapterId: &#123;&#125; 轮询尝试获取锁超过最大次数&quot;</span>, chapterId);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;获取题目失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line">                    questionsGenerated.set(<span class="literal">true</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line"><span class="comment">//                    &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//                        lock.unlock();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有获取到锁，短暂休眠</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            log.error(<span class="string">&quot;获取锁异常&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待后台线程轮询</span></span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取到锁的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    log.info(<span class="string">&quot;chapterId: &#123;&#125; 题目未生成，主线程执行生成题目任务&quot;</span>, chapterId);</span><br><span class="line">	    <span class="comment">// 如果成功获取锁，说明题目未生成</span></span><br><span class="line">	    <span class="type">GenTestQuestionTask</span> <span class="variable">genTestQuestionTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenTestQuestionTask</span>(questionMapper, redisIdWorker, algConfig, knowledgeNodeMapper, chapterId, redissonClient);</span><br><span class="line">	    <span class="comment">// 在主线程运行</span></span><br><span class="line">	    genTestQuestionTask.run();</span><br><span class="line">	    <span class="comment">// 标记题目已生成</span></span><br><span class="line">	    questionsGenerated.set(<span class="literal">true</span>);</span><br><span class="line">	    <span class="comment">// 计数器减一</span></span><br><span class="line">	    latch.countDown();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (!questionsGenerated.get()) lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体逻辑为：</p>
<ul>
<li>假设有 A、B、C 三个请求到达</li>
<li>A 先获取到了分布式锁</li>
<li>那么 B、C 获取不到锁进入到 if 代码块，A 进入 else 代码块</li>
<li>A 执行了生成自测题的逻辑，B、C 进入轮询获取锁资源的逻辑</li>
<li>假设 A 在 5s 内成功完了自测题的生成，那么 A 释放了锁资源同时将计算器减一</li>
<li>而 B、C 任一获取到锁资源后说明 A 已经成功将自测题生成了，那么就可以将变量 <code>questionsGenerated</code> 设置为true</li>
<li>直接到数据库层获取已经生成的题目列表即可。</li>
</ul>
</li>
</ul>
<h5 id="判断用户是否掌握此章节，自测题答题情况"><a href="#判断用户是否掌握此章节，自测题答题情况" class="headerlink" title="判断用户是否掌握此章节，自测题答题情况"></a>判断用户是否掌握此章节，自测题答题情况</h5><p>业务流程：</p>
<ul>
<li><p>接收用户的答题情况，章节 id 和题目列表（题目 id 和 用户答案）</p>
</li>
<li><p>将用户的答案落库存储，而后对用户的答案进行评定</p>
</li>
<li><p>评定过程：</p>
<ul>
<li><p>先读取已经更新过的 question 库，其中包括了一系列参数，封装到了 <code>List&lt;FullQuestionMetaDTO&gt;</code> 后再封装到 <code>LearningStateEvaParamDTO</code> 当中作为 http:GET 请求的参数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> q.question <span class="keyword">as</span> question,</span><br><span class="line">q.sort <span class="keyword">as</span> sort,</span><br><span class="line">q.type <span class="keyword">as</span> type,</span><br><span class="line">q.analysis <span class="keyword">as</span> analysis,</span><br><span class="line">q.answer <span class="keyword">as</span> answer,</span><br><span class="line">q.user_answer <span class="keyword">as</span> userAnswer,</span><br><span class="line">kn.id <span class="keyword">as</span> knowledgeNodeId,</span><br><span class="line">kn.name <span class="keyword">as</span> name,</span><br><span class="line">kn.original_content <span class="keyword">as</span> originalContent</span><br><span class="line"><span class="keyword">from</span> question q</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> knowledge_node kn <span class="keyword">on</span> q.knowledge_node_id <span class="operator">=</span> kn.id</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;questionIdList != null and questionIdList.size() &gt; 0&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">and</span> q.id <span class="keyword">in</span></span><br><span class="line">    <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;questionIdList&quot; item<span class="operator">=</span>&quot;questionId&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot; separator<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">        #&#123;questionId&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">and</span> q.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">and</span> kn.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过发送 http 请求到算法端请求 用户学习状态的评估结果 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 okhttp 客户端</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .readTimeout(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">        .writeTimeout(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build();</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(learningStateEvaParamDTO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求体</span></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> RequestBody.create(json, MediaType.get(<span class="string">&quot;application/json; charset=utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从配置获取 url</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> algConfig.getBaseUrl() + algConfig.getLearningStateEvaluateUrl();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 post 请求</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line"></span><br><span class="line">ThrowUtils.throwIf(!response.isSuccessful(), <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;判断用户学习状态异常&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Objects.requireNonNull(response.body()).string();</span><br></pre></td></tr></table></figure>
</li>
<li><p>而后更新用户的 chapter 数据库，记录其正确回答了哪些题目，并向前端返回其正确回答的题目。</p>
</li>
</ul>
</li>
</ul>
<h2 id="项目技术"><a href="#项目技术" class="headerlink" title="项目技术"></a>项目技术</h2><h3 id="SSE-Server-Sent-Events"><a href="#SSE-Server-Sent-Events" class="headerlink" title="SSE Server-Sent Events"></a>SSE Server-Sent Events</h3><p>使用到哪些技术，为什么要使用到这门技术，为什么这么设计，用到的技术都去学一遍</p>
<p>看看数据库表，怎么设计的，有哪些表，哪些有设计索引，为啥这么设计</p>
<h4 id="为什么要使用-SSE"><a href="#为什么要使用-SSE" class="headerlink" title="为什么要使用 SSE"></a>为什么要使用 SSE</h4><ul>
<li>SSE 是一种基于 HTTP 的服务器向客户端实时推送数据的技术。可以通过构建长连接实现服务器向客户端进行单向的数据推送。</li>
<li>使用的是纯文本格式进行数据传输，在本项目采用的是常见的 JSON 格式</li>
<li>长连接 Long Polling：<ul>
<li>通过保持 HTTP 连接打开，可以实现服务器向客户端的实时数据推送</li>
<li>减少了不必要的请求和响应开销</li>
</ul>
</li>
<li>事件驱动型：<ul>
<li>SSE 支持事件驱动，服务器可以发送多个事件，客户端通过监听事件来处理数据</li>
</ul>
</li>
<li>重连机制：<ul>
<li>可以通过预设重连机制来进行错误恢复</li>
</ul>
</li>
<li>浏览器支持，框架支持</li>
</ul>
<h4 id="TODO-项目独特优化"><a href="#TODO-项目独特优化" class="headerlink" title="TODO 项目独特优化"></a>TODO 项目独特优化</h4><ol>
<li><strong>连接管理</strong>：限制最大连接数，定期清理无效连接。</li>
<li><strong>消息推送</strong>：异步重试机制，配置化重试参数。</li>
<li><strong>心跳机制</strong>：定期发送心跳消息，检测客户端状态。</li>
<li><strong>异常处理</strong>：集中处理异常，分类处理不同类型异常。</li>
<li><strong>性能优化</strong>：批量推送消息，使用 HTTP&#x2F;2。</li>
<li><strong>安全性</strong>：客户端身份验证，启用 HTTPS。</li>
</ol>
<h4 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h4><ul>
<li>类型：<code>ConcurrentHashMap&lt;String, SseEmitter&gt;</code>。</li>
<li>作用：存储客户端 ID 和对应的 <code>SseEmitter</code> 对象，用于管理客户端的长连接。</li>
<li>线程安全：使用 <code>ConcurrentHashMap</code> 确保多线程环境下的线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器，保存连接，用于输出返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, SseEmitter&gt; sseCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><h5 id="创建-SSE-长连接"><a href="#创建-SSE-长连接" class="headerlink" title="创建 SSE 长连接"></a>创建 SSE 长连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SseEmitter <span class="title function_">createSseConnect</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置超时时间，0表示不过期。默认30秒，超过时间未完成会抛出异常：AsyncRequestTimeoutException</span></span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">0L</span>); <span class="comment">// 超时时间为 0，表示连接永不过期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*是否需要给客户端推送ID</span></span><br><span class="line"><span class="comment">    if (StringUtils.isBlank(clientId)) &#123;</span></span><br><span class="line"><span class="comment">        clientId = IdUtil.simpleUUID();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">    sseEmitter.onCompletion(completionCallBack(clientId));</span><br><span class="line">    sseCache.put(clientId, sseEmitter);</span><br><span class="line">    log.info(<span class="string">&quot;创建新的sse连接，当前用户：&#123;&#125;&quot;</span>, clientId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sseEmitter.send(SseEmitter.event().id(clientId).data(<span class="string">&quot;连接创建成功&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;SseEmitterServiceImpl[createSseConnect]: 创建长链接异常，客户端ID:&#123;&#125;&quot;</span>, clientId, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sseEmitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关闭指定客户端的-SSE-连接。"><a href="#关闭指定客户端的-SSE-连接。" class="headerlink" title="关闭指定客户端的 SSE 连接。"></a>关闭指定客户端的 SSE 连接。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeSseConnect</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> sseCache.get(clientId);</span><br><span class="line">    <span class="keyword">if</span> (sseEmitter != <span class="literal">null</span>) &#123;</span><br><span class="line">        sseEmitter.complete();</span><br><span class="line">        removeUser(clientId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="根据客户端-ID-获取-SseEmitter-对象。"><a href="#根据客户端-ID-获取-SseEmitter-对象。" class="headerlink" title="根据客户端 ID 获取 SseEmitter 对象。"></a>根据客户端 ID 获取 <code>SseEmitter</code> 对象。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据客户端id获取SseEmitter对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SseEmitter <span class="title function_">getSseEmitterByClientId</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sseCache.get(clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="检查客户端是否存在。"><a href="#检查客户端是否存在。" class="headerlink" title="检查客户端是否存在。"></a>检查客户端是否存在。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkClientIsExist</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.nonNull(getSseEmitterByClientId(clientId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="向指定客户端推送消息。"><a href="#向指定客户端推送消息。" class="headerlink" title="向指定客户端推送消息。"></a>向指定客户端推送消息。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgToClientByClientId</span><span class="params">(String clientId, String eventName, Object data)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 客户Id 获取 SseEmitter</span></span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> getSseEmitterByClientId(clientId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sseEmitter == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]: 推送消息失败：客户端&#123;&#125;未创建长链接,失败消息:&#123;&#125;&quot;</span>,</span><br><span class="line">                    clientId, data.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;该连接通道不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SseEmitter.SseEventBuilder sendData = SseEmitter.event().id(SseEmitterConstant.TASK_RESULT).data(data, MediaType.APPLICATION_JSON);</span></span><br><span class="line">        SseEmitter.<span class="type">SseEventBuilder</span> <span class="variable">sendData</span> <span class="operator">=</span> SseEmitter.event().id(clientId).name(eventName).data(data, MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sseEmitter.send(sendData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 推送消息失败，记录错误日志，进行重推</span></span><br><span class="line">            log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]: clientId:&#123;&#125; 推送消息失败：&#123;&#125;，尝试进行重推，事件名称:&#123;&#125;&quot;</span>, clientId, data, eventName, e);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 推送消息失败后，每隔 10s 推送一次，推送 5 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    sseEmitter = sseCache.get(clientId);</span><br><span class="line">                    <span class="keyword">if</span> (sseEmitter == <span class="literal">null</span>) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推失败，未创建长链接&quot;</span>, clientId, i + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sseEmitter.send(sendData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推失败&quot;</span>, clientId, i + <span class="number">1</span>, ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;SseEmitterServiceImpl[sendMsgToClient]：&#123;&#125;的第&#123;&#125;次消息重推成功,&#123;&#125;&quot;</span>, clientId, i + <span class="number">1</span>, data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Jwt令牌认证"><a href="#Jwt令牌认证" class="headerlink" title="Jwt令牌认证"></a>Jwt令牌认证</h3><h3 id="阿里云对象存储"><a href="#阿里云对象存储" class="headerlink" title="阿里云对象存储"></a>阿里云对象存储</h3><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>使用<strong>Redis</strong>来缓存电子书章节内容、知识点、知识树等数据，提高系统的响应速度</p>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h3 id="完整规范的自定义异常处理"><a href="#完整规范的自定义异常处理" class="headerlink" title="完整规范的自定义异常处理"></a>完整规范的自定义异常处理</h3><h3 id="分布式唯一-Id，"><a href="#分布式唯一-Id，" class="headerlink" title="分布式唯一 Id，"></a>分布式唯一 Id，</h3><p>基于 Redis 的分布式 ID 生成器，借鉴了分布式雪花算法，用于生成全局唯一 ID。结合了时间戳和 Redis 的自增序列号来生成 ID，</p>
<h4 id="核心设计："><a href="#核心设计：" class="headerlink" title="核心设计："></a>核心设计：</h4><ul>
<li><strong>时间戳部分</strong>：使用当前时间与固定起始时间（<code>BEGIN_TIMESTAMP</code>）的差值作为 ID 的高位部分</li>
<li><strong>序列号部分</strong>：使用 Redis 的自增操作生成唯一的序列号，作为 ID 的低位部分</li>
<li><strong>拼接方式</strong>：将时间戳与 redis 序列号拼接组成最终的 ID。</li>
</ul>
<h4 id="常量定义："><a href="#常量定义：" class="headerlink" title="常量定义："></a>常量定义：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到今年第一天的秒数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">COUNT_TIMESTAMP</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成时间戳</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成序列号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">today</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;irc:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + today);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_TIMESTAMP | count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拼接的核心逻辑</strong>:</p>
<p><strong>左移操作 (<code>&lt;&lt;</code>)</strong>:</p>
<ul>
<li><code>timeStamp &lt;&lt; COUNT_TIMESTAMP</code> 将时间戳左移 32 位，腾出低 32 位给序列号。</li>
<li>左移后，时间戳部分占据了 ID 的高 32 位。</li>
<li>用于 <code>timestamp</code> 是 <code>long</code> 类型，因此当 <code>timestamp</code> 变量左移 32 位后原本的高 32 位被丢弃，同时挪出低 32 位来拼接 <code>count</code></li>
</ul>
<p><strong>按位或操作 (<code>|</code>)</strong>:</p>
<ul>
<li><code>timeStamp &lt;&lt; COUNT_TIMESTAMP | count</code> 将左移后的时间戳与序列号进行按位或操作，拼接成一个 64 位的长整型 ID。</li>
</ul>
<h3 id="为什么分布式雪花算法"><a href="#为什么分布式雪花算法" class="headerlink" title="为什么分布式雪花算法"></a>为什么分布式雪花算法</h3><h3 id="文件解析处理业务——责任链模式"><a href="#文件解析处理业务——责任链模式" class="headerlink" title="文件解析处理业务——责任链模式"></a>文件解析处理业务——责任链模式</h3><img src=".\bookdone.assets\image-20250222230854595.png" alt="image-20250222230854595" style="zoom: 67%;" /> 

<p><img src="/.%5Cbookdone.assets%5COssUploadHandler.png" alt="OssUploadHandler"></p>
<p>对于书本文件的解析采用了责任链模式：</p>
<p>责任链模式（Chain of Responsibility Pattern）允许多个对象有机会处理请求，从而避免请求的发送者与接收者之间的耦合。责任链模式将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为止。</p>
<p>本项目的责任链模式被用于处理图书上传的多个步骤。每个步骤由一个处理器（Handler）负责，处理器之间通过链式调用依次执行。</p>
<p>在 SpringBoot 项目当中可以通过 @Order 注解来实现责任链模式，以本项目为例：</p>
<p><img src="/.%5Cbookdone.assets%5Cdiagram.png" alt="diagram"></p>
<p>实现同一个接口 <code>BookUploadHandler</code></p>
<h4 id="定义抽象的处理器接口"><a href="#定义抽象的处理器接口" class="headerlink" title="定义抽象的处理器接口"></a>定义抽象的处理器接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookUploadHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器是否适配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否适配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否可以执行 Handle 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 判断结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBookUploadHandler</span> <span class="keyword">implements</span> <span class="title class_">BookUploadHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义处理器子类实现"><a href="#定义处理器子类实现" class="headerlink" title="定义处理器子类实现"></a>定义处理器子类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookCacheHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractBookUploadHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssUploadHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractBookUploadHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canHandle</span><span class="params">(BookUploadContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="封装组合责任链"><a href="#封装组合责任链" class="headerlink" title="封装组合责任链"></a>封装组合责任链</h4><ul>
<li>通过 @Autowired 修饰责任链（处理器的集合），spring 会按照 @Order 的顺序组装成一个有序的 list 集合。</li>
<li>@Order 注解里面的数组越小代表优先级越高</li>
</ul>
<h4 id="使用责任链模式的好处"><a href="#使用责任链模式的好处" class="headerlink" title="使用责任链模式的好处"></a>使用责任链模式的好处</h4><ul>
<li><p>职责分离:每个处理器类负责各自己的独立任务，有助于代码的模块化与可维护性</p>
</li>
<li><p>易于扩展:如果需要添加或修改某个功能，只需要添加一个处理器类或者在单个处理器类内进行修改</p>
</li>
<li><p>灵活性高:通过调整处理器在链中的顺序，可以改变处理流程</p>
</li>
<li><p>减少耦合度:各个处理器之间是松耦合的,降低了系统的复杂性与依赖关系</p>
</li>
</ul>
<h4 id="使用模式的缺点"><a href="#使用模式的缺点" class="headerlink" title="使用模式的缺点"></a>使用模式的缺点</h4><ul>
<li>增加了程序的复杂度，需要根据实际业务需求评估后再决定是否使用，不能为了设计模式而设计。</li>
</ul>
<h3 id="线程池设计与任务"><a href="#线程池设计与任务" class="headerlink" title="线程池设计与任务"></a>线程池设计与任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoreBusinessPoolHolder</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务器核心数动态计算的默认核心线程池大小</span></span><br><span class="line"><span class="comment">     * 默认为 CPU 核心数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CORE_POOL_SIZE</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程池的最大线程数</span></span><br><span class="line"><span class="comment">     * 经验最佳数量（具体最佳最大线程数需要压测） = 2* CPU数目 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">2</span> * DEFAULT_CORE_POOL_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL_CORE_POOL_SIZE</span> <span class="operator">=</span> DEFAULT_CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超过核心线程后，空闲线程等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DEFAULT_KEEP_ALIVE_SECONDS</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NORMAL_KEEP_ALIVE_SECONDS</span> <span class="operator">=</span> <span class="number">60L</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列长度</span></span><br><span class="line"><span class="comment">     * 默认：最大线程池大小*3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAIT_QUEUE_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心业务 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor corePool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor normalPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/**等待执行的线程队列*/</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">        corePool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(DEFAULT_CORE_POOL_SIZE</span><br><span class="line">                , DEFAULT_CORE_POOL_SIZE</span><br><span class="line">                , <span class="number">0</span></span><br><span class="line">                , TimeUnit.SECONDS</span><br><span class="line">                , workQueue</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;coreBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueueNormal = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(WAIT_QUEUE_SIZE);</span><br><span class="line">        normalPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(NORMAL_CORE_POOL_SIZE</span><br><span class="line">                , DEFAULT_MAXIMUM_POOL_SIZE</span><br><span class="line">                , NORMAL_KEEP_ALIVE_SECONDS</span><br><span class="line">                , TimeUnit.SECONDS</span><br><span class="line">                , workQueueNormal</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;normalBusinessPool-t-%d&quot;</span>).build()</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">BlockingQueueRejectedHandler</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心业务执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        corePool.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通业务执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">executeNormal</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        normalPool.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于管理和执行核心业务和普通业务的异步任务。它通过静态初始化块创建了两个线程池：<strong>核心业务线程池</strong>和<strong>普通业务线程池</strong>，并提供了执行任务的方法。</p>
<h4 id="类功能"><a href="#类功能" class="headerlink" title="类功能"></a>类功能</h4><ul>
<li><strong>核心功能</strong>:<ul>
<li>创建并管理两个线程池：<code>corePool</code>（核心业务线程池）和 <code>normalPool</code>（普通业务线程池）。</li>
<li>提供静态方法 <code>execute</code> 和 <code>executeNormal</code>，用于提交任务到对应的线程池中执行。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>适用于需要异步执行任务的场景，例如文件上传、数据处理、任务调度等。</li>
<li>通过区分核心业务和普通业务，可以更好地管理线程资源，确保核心业务的高优先级执行。</li>
</ul>
</li>
</ul>
<h4 id="关于线程池知识拓展"><a href="#关于线程池知识拓展" class="headerlink" title="关于线程池知识拓展"></a>关于线程池知识拓展</h4><h5 id="ThreadPoolExecutor-主要有以下几个参数"><a href="#ThreadPoolExecutor-主要有以下几个参数" class="headerlink" title="ThreadPoolExecutor 主要有以下几个参数:"></a>ThreadPoolExecutor 主要有以下几个参数:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="线程池的配置，参数详解"><a href="#线程池的配置，参数详解" class="headerlink" title="线程池的配置，参数详解"></a>线程池的配置，参数详解</h5><ol>
<li><strong>corePoolSize 核心线程数</strong></li>
<li><strong>maximumPoolSize 最大线程数</strong></li>
<li><strong>keepAliveTime 空闲线程存活时间</strong></li>
<li><strong>TimeUnit 时间单位</strong></li>
<li><strong>workQueue 任务队列</strong></li>
<li><strong>threadFactory 线程工厂</strong></li>
<li><strong>RejectedExecutionHandler 拒绝策略</strong></li>
</ol>
<h4 id="整个业务流程"><a href="#整个业务流程" class="headerlink" title="整个业务流程"></a>整个业务流程</h4><ol>
<li><strong>初始化线程池</strong>：<ul>
<li>在 <code>CoreBusinessPoolHolder</code> 的静态代码块中，初始化核心业务线程池和普通业务线程池。</li>
</ul>
</li>
<li><strong>创建任务</strong>：<ul>
<li>创建 <code>BookUploadContext</code> 对象，并设置任务的相关属性。</li>
<li>创建 <code>BookUploadTask</code> 对象，传入上下文和处理器列表。</li>
</ul>
</li>
<li><strong>提交任务</strong>：<ul>
<li>调用 <code>CoreBusinessPoolHolder.execute(task)</code>，将任务提交到核心业务线程池。</li>
</ul>
</li>
<li><strong>任务执行</strong>：<ul>
<li>线程池中的线程从队列中取出任务，调用 <code>BookUploadTask.run()</code> 方法。</li>
<li>遍历处理器列表，依次处理任务。</li>
</ul>
</li>
<li><strong>异常处理</strong>：<ul>
<li>如果任务执行过程中发生异常，记录错误日志。</li>
</ul>
</li>
</ol>
<p><strong>模式优点</strong></p>
<ol>
<li><strong>高并发处理</strong>：通过线程池提高任务处理能力。</li>
<li><strong>职责分离</strong>：线程池管理、任务定义和任务提交逻辑分离，代码结构清晰。</li>
<li><strong>扩展性强</strong>：通过责任链模式，可以灵活扩展任务处理器。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/bookdone/" data-id="cm7pnj29e0024ucv25dj164ls" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%B9%A0/Java%E9%9A%8F%E7%AC%94/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java随笔
        
      </div>
    </a>
  
  
    <a href="/2025/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java%E5%9F%BA%E7%A1%80%E2%9E%95%E9%AB%98%E9%98%B6/JUC%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JUC学习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode%E5%88%B7%E9%A2%98/">leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/typora/">typora</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/">大学公共基础课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/">学习规划路线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/">计算机重要基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E9%A9%AC-%E5%90%8E%E7%AB%AF/">黑马:后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E5%9F%BA%E7%A1%80/" rel="tag">Vue基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html%E5%9F%BA%E7%A1%80/" rel="tag">html基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%BA%95%E5%B1%82/" rel="tag">java底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6/" rel="tag">java框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%9F%BA%E7%A1%80/" rel="tag">js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" rel="tag">单体架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">大学专业课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" rel="tag">学习规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%B3%E6%B3%95/" rel="tag">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag">期末复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag">离散数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" rel="tag">计算机四大件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" rel="tag">设计架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag">软件架构设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">软件设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">软件项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" rel="tag">闲杂经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" rel="tag">非关系型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6/" rel="tag">高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC/" rel="tag">黑马</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDBC/" style="font-size: 11.67px;">JDBC</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Vue%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Vue基础</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/html%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">html基础</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/java%E5%BA%95%E5%B1%82/" style="font-size: 10px;">java底层</a> <a href="/tags/java%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">java框架</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">js基础</a> <a href="/tags/juc/" style="font-size: 10px;">juc</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">关系型</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" style="font-size: 11.67px;">单体架构</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.33px;">后端</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">基础</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 16.67px;">大学专业课</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" style="font-size: 13.33px;">学习规划</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%83%B3%E6%B3%95/" style="font-size: 10px;">想法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.33px;">数据库</a> <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="font-size: 20px;">期末复习</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/" style="font-size: 15px;">计算机四大件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">设计架构</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件架构设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">软件设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">软件项目管理</a> <a href="/tags/%E9%97%B2%E6%9D%82%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">闲杂经验</a> <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B/" style="font-size: 10px;">非关系型</a> <a href="/tags/%E9%AB%98%E9%98%B6/" style="font-size: 10px;">高阶</a> <a href="/tags/%E9%BB%91%E9%A9%AC/" style="font-size: 11.67px;">黑马</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">经典算法学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E7%AE%97%E6%B3%95/LeetCode/">Leetcode刷题题解</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络学习</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="/2025/03/01/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>