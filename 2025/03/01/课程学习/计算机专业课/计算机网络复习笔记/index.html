<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络复习笔记 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络 引言 1.2 Network edge several type of access networks  residential access nets 住宅接入网 institutional access networks (school, company) 机构接入网 wireless access networks 无线接入网 bandwidth bit per second 带">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络复习笔记">
<meta property="og:url" content="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="计算机网络 引言 1.2 Network edge several type of access networks  residential access nets 住宅接入网 institutional access networks (school, company) 机构接入网 wireless access networks 无线接入网 bandwidth bit per second 带">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/5.jpg">
<meta property="article:published_time" content="2025-03-01T03:35:47.264Z">
<meta property="article:modified_time" content="2025-03-01T11:39:20.798Z">
<meta property="article:author" content="moru">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/5.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络复习笔记",
  "url": "http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "http://example.com/img/5.jpg",
  "datePublished": "2025-03-01T03:35:47.264Z",
  "dateModified": "2025-03-01T11:39:20.798Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络复习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(./img/5.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络复习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络复习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T03:35:47.264Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-01T11:39:20.798Z" title="更新于 2025-03-01 19:39:20">2025-03-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h1>
<h1 id="引言"><a class="header-anchor" href="#引言"></a>引言</h1>
<h2 id="1-2-Network-edge"><a class="header-anchor" href="#1-2-Network-edge"></a>1.2 Network edge</h2>
<p><strong>several type of access networks</strong></p>
<ul>
<li>residential access nets 住宅接入网</li>
<li>institutional access networks (school, company) 机构接入网</li>
<li>wireless access networks 无线接入网</li>
<li>bandwidth bit per second 带宽 bps</li>
</ul>
<p><strong>Physical media: twisted pair</strong></p>
<ul>
<li>Twisted copper wire / Twisted pair 双绞铜线</li>
<li>coax/coaxial cable 同轴电缆</li>
<li>fiber optic 光纤</li>
<li>radio 无线电</li>
</ul>
<h2 id="1-3-network-core"><a class="header-anchor" href="#1-3-network-core"></a>1.3 network core</h2>
<p>Difference of performance between Packet-switching &amp; circuit switching</p>
<ol>
<li>分组交换不适合实时服务，端到端的时延是可变和不可预测的</li>
<li>分组交换有着比电路交换更好的网络共享；</li>
<li>比电路交换更简单、有效，实现成本更低；</li>
</ol>
<h2 id="1-4-Performance"><a class="header-anchor" href="#1-4-Performance"></a>1.4 Performance:</h2>
<p>delay, loss and throughput in packet-switched networks</p>
<h3 id="四种时延：时延的大小不是一个常数，而是和拥塞程度有关"><a class="header-anchor" href="#四种时延：时延的大小不是一个常数，而是和拥塞程度有关"></a>四种时延：时延的大小不是一个常数，而是和拥塞程度有关</h3>
<ul>
<li><strong>传输时延</strong>：Transmission delay 取决于数据包的长度和传输速率。</li>
<li><strong>传播时延</strong>：Propagation delay 取决于传输媒介的传播速度和距离。</li>
<li><strong>排队时延</strong>：querying delay 取决于网络节点的<strong>队列长度</strong>、<strong>流量和服务质量</strong>。</li>
<li><strong>处理时延</strong>：processing delay 取决于设备的<strong>处理能力和负载</strong>情况。</li>
</ul>
<h4 id="特点："><a class="header-anchor" href="#特点："></a>特点：</h4>
<p><strong>传输时延</strong>：从packet的第一个bit开始到最后一个bit传送到链路所需要的时间</p>
<p>传输时延 = 数据包长度（比特）/ 传输速率（比特/秒）</p>
<p><strong>传播时延</strong>：数据在信道介质中的传播时间，即数据从发送端到接收端所需时间</p>
<p><strong>排队时延</strong>：数据在节点的输出队列中等待被发送的时间</p>
<p><strong>处理时延</strong>：数据在在网络节点中被路由器、交换机或终端设备处理所需时间</p>
<p>loss and throughput</p>
<h3 id="丢包："><a class="header-anchor" href="#丢包："></a>丢包：</h3>
<ul>
<li><strong>数据包丢失</strong>：在到达目的地之前丢弃或丢失的数据包。可能由于拥塞、错误或缓冲区溢出等原因造成。</li>
<li><strong>比特错误率（BER）</strong>：接收到的错误比特数与发送的总比特数的比率。反映了传输媒介的可靠性。</li>
</ul>
<h3 id="吞吐量："><a class="header-anchor" href="#吞吐量："></a>吞吐量：</h3>
<ul>
<li><strong>有效吞吐量</strong>：单位时间内传输的实际有用数据量，不包括协议开销和重传。反映了数据传输的有效速率。</li>
<li><strong>链路利用率</strong>：链路被使用来传输数据的时间百分比。反映了链路容量的有效利用程度。</li>
</ul>
<h3 id="对网络性能的影响"><a class="header-anchor" href="#对网络性能的影响"></a>对网络性能的影响</h3>
<ul>
<li><strong>延迟</strong>：高延迟会导致响应时间增加和实时通信性能下降。</li>
<li><strong>丢包</strong>：数据包丢失会降低数据传输的质量，影响网络的可靠性。</li>
<li><strong>吞吐量</strong>：较高的吞吐量表示网络容量和性能更好，允许在给定时间内传输更多的数据。</li>
</ul>
<h2 id="1-5-Protocol-layers-service-models"><a class="header-anchor" href="#1-5-Protocol-layers-service-models"></a>1.5 Protocol layers, service models</h2>
<p>Data encapsulation process and reassemble porcess of TCP/IP</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011918280.png" alt="image-20240613094945502"></p>
<h3 id="Protocols-in-each-layer-of-TCP-IP"><a class="header-anchor" href="#Protocols-in-each-layer-of-TCP-IP"></a>Protocols in each layer of TCP/IP</h3>
<p><strong>应用层（Application Layer）</strong>：</p>
<ul>
<li>HTTP（超文本传输协议）:Electronic mail 80</li>
<li>HTTPS（安全超文本传输协议）</li>
<li>FTP（文件传输协议）：Pile transfer 21</li>
<li>SMTP（简单邮件传输协议）25</li>
<li>POP3（邮局协议版本3）110</li>
<li>IMAP（Internet消息访问协议）</li>
<li>DNS（域名系统）53号</li>
<li>DHCP（动态主机配置协议）</li>
<li>Telnet():Remote termind access 23</li>
</ul>
<p><strong>传输层（Transport Layer）</strong>：</p>
<ul>
<li>TCP（传输控制协议）</li>
<li>UDP（用户数据报协议）</li>
<li>RTP():</li>
</ul>
<p><strong>网络层（Network Layer）</strong>：</p>
<ul>
<li>
<p>IP（Internet协议）</p>
</li>
<li>
<p>ICMP（Internet控制消息协议）</p>
</li>
<li>
<p>ARP（地址解析协议）</p>
<ul>
<li>ARP查询包封装在以太网帧（Ethernet frame）的数据字段中。通过这种方式，ARP请求能够在局域网中进行广播，从而解析目标设备的MAC地址。</li>
</ul>
</li>
<li>
<p>RARP（逆地址解析协议）</p>
</li>
<li>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
</li>
</ul>
<p><strong>数据链路层（Data Link Layer）</strong>：</p>
<ul>
<li>Ethernet（以太网）</li>
<li>ARP（地址解析协议）</li>
<li>PPP（点对点协议）</li>
<li>HDLC（高级数据链路控制）</li>
<li>Frame Relay（帧中继）</li>
</ul>
<h3 id="protocol-stacks-in-Internet"><a class="header-anchor" href="#protocol-stacks-in-Internet"></a>protocol stacks in Internet</h3>
<ol>
<li>application</li>
<li>transport：进程与进程间通信：TCP/UDP</li>
<li>network：从源主机到目的主机的数据报路由：IP，routing protocols</li>
<li>link：相邻网络节点间的数据传输</li>
<li>physical</li>
</ol>
<h1 id="应用层"><a class="header-anchor" href="#应用层"></a>应用层</h1>
<h2 id="2-1-Principles-of-network-applications"><a class="header-anchor" href="#2-1-Principles-of-network-applications"></a>2.1 Principles of network applications</h2>
<p>Application layer protocol and Underlying transport protocol and why?</p>
<p>(such as Web, SMTP, POP3,Telnet, HTTP, FTP )</p>
<p>How to design or judge an architecture of computer network</p>
<h2 id="2-2-Web-and-HTTP"><a class="header-anchor" href="#2-2-Web-and-HTTP"></a>2.2 Web and HTTP</h2>
<p>HTTP request message &amp; respond message<br>
HTTP 1.0 (non-persistent HTTP) &amp; HTTP 1.1 (persistent HTTP)<br>
Meaning of Response Status code (2xx : 成功,3xx : 重定向,4xx : 请求<br>
错误,和服务端无关, 5xx : 服务器错误,)</p>
<p>Function of cookie and cache</p>
<ol>
<li>reduce response time for client request 减少对客户请求的响应时间</li>
<li>reduce traffic on an institution’s access link.减少机构接入链路的流量。</li>
<li>Internet dense with caches: enables “poor” content providers to effectively deliver content (but so does P2P file sharing)<br>
互联网密集的缓存:使内容提供者能够有效地提供内容(但P2P文件共享也是如此)</li>
</ol>
<h2 id="2-3-FTP"><a class="header-anchor" href="#2-3-FTP"></a>2.3 FTP</h2>
<p>used for transferring files, based on <strong>TCP of transport layer</strong><br>
FTP client contacts FTP server at port 21 (for control), but opens 2nd TCP connectionto client at port 20 (for file) --control connection: “out of band”<br>
FTP客户端在端口21连接FTP服务器(用于控制FTP服务)，在端口20建立：控制连接:&quot; out of band &quot;用于控制FTP连接继续与否</p>
<h2 id="2-4-Electronic-Mail"><a class="header-anchor" href="#2-4-Electronic-Mail"></a>2.4 Electronic Mail</h2>
<p>SMTP: sending email to the receiver’s server (only 7-bit ASCII code text)<br>
POP3 and IMAP: receive email from receiver’s server</p>
<h2 id="2-5-DNS-域名系统"><a class="header-anchor" href="#2-5-DNS-域名系统"></a>2.5 DNS 域名系统</h2>
<p>应用层协议</p>
<h3 id="Funcation-of-DNS"><a class="header-anchor" href="#Funcation-of-DNS"></a>Funcation of DNS</h3>
<p>distributed database implemented in hierarchy of many name servers application-layer protocol host, router, name servers to communicate to resolve names<br>
分布式数据库实现了多层域名服务器的应用层协议主机、路由器、域名服务器之间的通信来解析域名</p>
<p>Layer architecture of DNS system</p>
<ol>
<li>防止单点故障</li>
<li>易于拓展</li>
<li>负载均衡</li>
</ol>
<h2 id="2-6-Peer-to-Peer-Applications"><a class="header-anchor" href="#2-6-Peer-to-Peer-Applications"></a>2.6 Peer-to-Peer Applications</h2>
<p>Comparing features of Client-server with P2P</p>
<ol>
<li>P2P具有自拓展性，因而对等方数量增多时不会降低性能；C/S拓展能力有限</li>
<li>P2P去中心化，C/S具有中心服务器</li>
<li>P2P网络健壮性好，不用担心单点故障，C/S存在单点故障的问题</li>
<li>P2P不易于集中管理；C/S可以进行集中式的管理</li>
<li>P2P减轻了服务器的计算压力，而C/S对服务器的性能要求较高</li>
<li></li>
</ol>
<h2 id="socket"><a class="header-anchor" href="#socket"></a>socket</h2>
<p>主机本地的应用程序创建的由操作系统控制的接口(“门”)，应用程序进程可以在其中向另一个应用程序进程发送和接收消息</p>
<h3 id="TCP-SOCKET："><a class="header-anchor" href="#TCP-SOCKET："></a>TCP-SOCKET：</h3>
<p>TCP是面向连接的协议，每个TCP连接通过以下四个要素唯一标识：</p>
<ol>
<li><strong>源IP地址</strong>：发送方的IP地址。 source IP address</li>
<li><strong>源端口号</strong>：发送方的端口号。 source port number</li>
<li><strong>目标IP地址</strong>：接收方的IP地址。 dest IP address</li>
<li><strong>目标端口号</strong>：接收方的端口号。 dest port number</li>
</ol>
<p>这些要素组成了一个四元组（source IP, source port, destination IP, destination port），它唯一标识了一个TCP连接。</p>
<p>TCP套接字需要使用四元组（源IP地址、源端口号、目标IP地址、目标端口号）来唯一标识一个连接。这是因为在同一个IP地址和端口号上，可以同时建立多个到不同目标的连接，每个连接都需要独立的状态维护。</p>
<h3 id="UDP-Socket"><a class="header-anchor" href="#UDP-Socket"></a>UDP-Socket</h3>
<p>UDP是无连接的协议，每个UDP通信通过以下两个要素唯一标识：</p>
<ol>
<li><strong>目标IP地址</strong>：接收方的IP地址。dest IP address</li>
<li><strong>目标端口号</strong>：接收方的端口号。 dest port number</li>
</ol>
<p>由于UDP不建立连接，每个数据报（datagram）是独立的，因此UDP套接字的标识只依赖于目的IP地址和端口号。</p>
<p>由于UDP是无连接和无状态的，套接字标识只需要包含目标IP地址和端口号即可。这是因为每个数据包是独立的，源IP地址和端口号不需要用来维持连接状态。</p>
<h1 id="传输层"><a class="header-anchor" href="#传输层"></a>传输层</h1>
<h2 id="3-1-Transport-layer-services"><a class="header-anchor" href="#3-1-Transport-layer-services"></a>3.1 Transport-layer services</h2>
<p>provide logical communication between app processes running on different hosts</p>
<p><strong>传输层的主要作用：</strong> 为运行在不同主机上的应用程序进程提供逻辑通信</p>
<h3 id="Differences-on-providing-data-transmission-services"><a class="header-anchor" href="#Differences-on-providing-data-transmission-services"></a>Differences on providing data transmission services</h3>
<ul>
<li>network layer: between end-to-end hosts</li>
<li>transport layer: between application processes</li>
</ul>
<h3 id="Features-of-TCP"><a class="header-anchor" href="#Features-of-TCP"></a>Features of TCP</h3>
<ol>
<li>Reliable data transfer 可靠数据传输</li>
<li>congestion control 拥塞控制</li>
<li>flow control 流控制</li>
<li>connection management  连接管理</li>
</ol>
<h3 id="Differences-of-TCP-UDP"><a class="header-anchor" href="#Differences-of-TCP-UDP"></a>Differences of TCP &amp; UDP</h3>
<ol>
<li>可靠性：TCP提供可靠数据传输服务，UDP提供的是不可靠的</li>
<li>有无连接：TCP是面向连接的，UDP是无连接的</li>
<li>分组结构：TCP头部至少有 20 bytes，最多可以有 60 bytes；UDP头部只有 8 bytes</li>
<li>流量和拥塞控制：TCP具有流量控制，拥塞控制等机制，UDP没有。</li>
<li></li>
</ol>
<h2 id="3-2-Multiplexing-and-demultiplexing"><a class="header-anchor" href="#3-2-Multiplexing-and-demultiplexing"></a>3.2 Multiplexing and demultiplexing</h2>
<h3 id="Functions-of-multiplexing-and-demultiplexing"><a class="header-anchor" href="#Functions-of-multiplexing-and-demultiplexing"></a>Functions of multiplexing and demultiplexing</h3>
<ol>
<li>复用: 从多个sockets中获取数据，并用header进行封装 (header后续用于解复用)多路复用就是一个封装的过程</li>
<li>解复用：将传输层收到的segments 传输到 correct socket 解复用就是一个解封装的过程</li>
</ol>
<h3 id="Port-number-length-16-bits"><a class="header-anchor" href="#Port-number-length-16-bits"></a>Port number (length-16 bits)</h3>
<p><strong>常用的一些port</strong>：TELNET:23; SMTP:25 ; POP3:110;HTTP: 80 ; FTP: 20/21; DNS：53</p>
<h2 id="使用了-TCP-UDP-作为传输协议的应用"><a class="header-anchor" href="#使用了-TCP-UDP-作为传输协议的应用"></a>使用了 TCP/UDP 作为传输协议的应用</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919575.png" alt="image-20240618212826989"></p>
<h2 id="3-3-Connectionless-transport-UDP"><a class="header-anchor" href="#3-3-Connectionless-transport-UDP"></a>3.3 Connectionless transport: UDP</h2>
<h3 id="UDP-format"><a class="header-anchor" href="#UDP-format"></a>UDP format</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919872.png" alt="image-20240619103942315"></p>
<p>4 bytes source + 4 bytes dest port + 4 bytes length + 4 bytes checksum检验和</p>
<p>校验和的计算：</p>
<ol>
<li>
<p>将整个报文段按照每 16 bits 为一个加数划分，不足16位的补0，再将这些加数全部加起来，如果有溢出则在末尾加上1。</p>
</li>
<li>
<p>假设现在有三个16位的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0110011001100000</span><br><span class="line">0101010101010101</span><br><span class="line">1000111100001100</span><br></pre></td></tr></table></figure>
<p>则：将三个数相加，溢出的第17位和后面的16位相加，可以得到：0100 1010 1100 0010</p>
</li>
<li>
<p>对得到的和取反：1011 0101 0011 1101</p>
</li>
<li>
<p>最后在接收方，将三个数字和checksum再相加一次，如果结果全为1，则没有出错。</p>
</li>
</ol>
<h3 id="UDP存在的原因："><a class="header-anchor" href="#UDP存在的原因："></a>UDP存在的原因：</h3>
<ol>
<li>无须建立连接，简单</li>
<li>分组的头部小</li>
<li>没有拥塞控制，UDP可以尽可能快速的传播</li>
</ol>
<h2 id="3-4-Principles-of-reliable-data-transfer"><a class="header-anchor" href="#3-4-Principles-of-reliable-data-transfer"></a>3.4 Principles of reliable data transfer</h2>
<h3 id="Principles-of-different-version-of-rdt-reliable-data-transfer-1-0、2-0、2-1、2-2、3-0"><a class="header-anchor" href="#Principles-of-different-version-of-rdt-reliable-data-transfer-1-0、2-0、2-1、2-2、3-0"></a>Principles of different version of rdt reliable data transfer(1.0、2.0、2.1、2.2、3.0)</h3>
<ul>
<li>每一版本的rdt都多解决了一种进程间通信可能出现的问题</li>
</ul>
<h4 id="rdt1-0-reliable-transfer-over-a-reliable-channel"><a class="header-anchor" href="#rdt1-0-reliable-transfer-over-a-reliable-channel"></a>rdt1.0 reliable transfer over a reliable channel</h4>
<p><strong>问题背景</strong>：假设底层通道是可靠的，即不会丢包、出错或乱序。</p>
<p><strong>解决问题</strong>：无特别的传输可靠性问题需要解决，只是简单的发送和接收数据。</p>
<p><strong>机制</strong>：直接发送数据，没有任何校验或确认机制。</p>
<h4 id="rdt2-0-channel-with-bit-errors"><a class="header-anchor" href="#rdt2-0-channel-with-bit-errors"></a>rdt2.0 channel with bit errors</h4>
<p><strong>问题背景</strong>：底层通道可能会引入比特错误（但不丢包）。</p>
<p><strong>解决问题</strong>：确保在存在比特错误的情况下，数据能够被正确接收。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>使用错误检测机制（如校验和）来检测错误。</li>
<li>接收方在接收到数据后发送确认（ACK）或否认（NAK）消息。</li>
<li>发送方在收到NAK时重传数据。</li>
</ul>
<p>解决措施：使用 ack 和 nak 接收方<strong>反馈机制和重传机制</strong></p>
<h4 id="rdt2-1-处理出错的ack和nak"><a class="header-anchor" href="#rdt2-1-处理出错的ack和nak"></a>rdt2.1 处理出错的ack和nak</h4>
<p><strong>问题背景</strong>：处理可能的比特错误，同时应对ACK和NAK本身可能出错的情况。</p>
<p><strong>解决问题</strong>：提供额外的机制来确保ACK和NAK的可靠传输。</p>
<p><strong>机制</strong>：</p>
<ul>
<li><strong>引入序列号</strong>来区分不同的分组（即使分组被重传）。</li>
<li>发送方在发送分组时附加序列号，接收方在ACK/NAK中也包含序列号。</li>
</ul>
<h4 id="rdt2-2"><a class="header-anchor" href="#rdt2-2"></a>rdt2.2</h4>
<p><strong>问题背景</strong>：改进rdt2.1，使其不依赖NAK，仅使用ACK。</p>
<p><strong>解决问题</strong>：进一步简化协议，只使用ACK来确认接收到的分组，重传丢失或出错的分组。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>使用ACK中的序列号来确认特定的分组。</li>
<li>接收方在收到错误或丢失的分组时，重复发送上次的ACK来触发发送方重传。</li>
</ul>
<h4 id="rdt3-0"><a class="header-anchor" href="#rdt3-0"></a>rdt3.0</h4>
<p><strong>问题背景</strong>：底层通道可能会丢包。</p>
<p><strong>解决问题</strong>：确保数据包在存在丢包的情况下也能够被正确接收。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>引入<strong>超时和重传</strong>机制：<strong>发送方</strong>在发送数据包后启动定时器，如果在超时前没有收到ACK，则重传数据包。</li>
<li>继续使用序列号和ACK机制来确认数据包的接收。</li>
</ul>
<h3 id="Comparisons-of-sliding-window-protocols-GBN-SR"><a class="header-anchor" href="#Comparisons-of-sliding-window-protocols-GBN-SR"></a>Comparisons of sliding window protocols (GBN &amp; SR)</h3>
<h4 id="滑动窗口-SlideWindow-协议："><a class="header-anchor" href="#滑动窗口-SlideWindow-协议："></a>滑动窗口(SlideWindow)协议：</h4>
<p><strong>缓冲区</strong>：暂时存放已发送的分组，以备检错重发和超时重发；但是存放在发送缓冲区的分组不一定都是已发送的。缓冲区的大小决定了一次可以发送多少个未经确认的分组。</p>
<table>
<thead>
<tr>
<th>发送方窗口大小</th>
<th>接收方窗口大小</th>
<th>协议</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>stop-wait</td>
<td></td>
</tr>
<tr>
<td>N&gt;1</td>
<td>1</td>
<td>GBN go back n steps</td>
<td>累计确认</td>
</tr>
<tr>
<td>N&gt;1</td>
<td>M&gt;1</td>
<td>SR select_repeat</td>
<td>非累计确认</td>
</tr>
</tbody>
</table>
<p>Different of features</p>
<p>Size of sending windows &amp; receiving windows of GBN &amp; SR, and why?</p>
<h2 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h2>
<h3 id="TCP的标志位："><a class="header-anchor" href="#TCP的标志位："></a>TCP的标志位：</h3>
<p>标志位：</p>
<ul>
<li>
<p>URG：紧急指针，为1时表示紧急指针有效</p>
</li>
<li>
<p><strong>SYN</strong>：同步序号，用于建立连接，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p>
</li>
<li>
<p><strong>FIN</strong>：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li>
<p><strong>RST</strong>：重置连接标志，</p>
</li>
<li>
<p><strong>ACK</strong>：确认序号标志，为1时表示确认号ack有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
</ul>
<h3 id="重传"><a class="header-anchor" href="#重传"></a>重传</h3>
<ul>
<li>
<p>一直顺序到达：</p>
<p>暂缓发送ack，设置一个定时器，在定时器超时之前如果又来了一个新的顺序分组，则重启定时器，再次暂缓发送ack，直到超时；因为累计确认，则在超时发送的那个ack之前的那些分组都是确认过的了</p>
</li>
<li>
<p>乱序到达：</p>
<p>赶紧将需要的顺序最小的期待收到的发一个ack通知发送方重新发送</p>
</li>
<li>
<p>前面顺序，中间有一个乱序：</p>
<p>有一部分gap未到达：缺那部分发哪部分的ack通知重传</p>
</li>
<li>
<p>快速重传：三个冗余ack触发的重传，无须等待发送方的计时器超时</p>
<p>例如：[30,39] [40,44] [45,50] [51,60] [60,70]</p>
<p>其中除了[40,44]其他几个都已到达</p>
<p>[30,39] 发送第一个正常的ack_40；后面三个分组则会发送三个冗余的ack_40给发送方，从而触发快速重传机制</p>
</li>
</ul>
<h3 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h3>
<p>将本地空闲缓冲区的大小反馈发送方，告知其接下来可以发送数据的大小规模，则不会因为发送方发送过多，接收方处理能力无法跟上导致的数据被大量舍弃。</p>
<h3 id="连接管理（就是三次握手）"><a class="header-anchor" href="#连接管理（就是三次握手）"></a>连接管理（就是三次握手）</h3>
<p>Three way handshake</p>
<ol>
<li>客户端发送 TCP SYN segment 给服务器：该分组不含数据，用于初始化序号</li>
<li>服务器接收到 SYN（同步）segment后，响应一个 SYN ACK segment；同时服务器分配buffer——接受窗口、初始化序号</li>
<li>客户端收到 SYNACK，回复 ACK segment（这一个回复的ack分组可能携带数据）</li>
</ol>
<h2 id="TCP拥塞控制-Congestion-Control"><a class="header-anchor" href="#TCP拥塞控制-Congestion-Control"></a>TCP拥塞控制 Congestion Control</h2>
<p>网络有太多数据，超过了网络的处理能力</p>
<p>两种控制方法：</p>
<ol>
<li>端到端拥塞控制：
<ol>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件判断是否有拥塞</li>
<li>TCP采用的方式</li>
</ol>
</li>
<li>网络辅助的拥塞控制</li>
</ol>
<h3 id="Difference-between-flow-control-congestion-control"><a class="header-anchor" href="#Difference-between-flow-control-congestion-control"></a>Difference between flow control &amp; congestion control</h3>
<ul>
<li>Flow control of TCP-receive window (rwnd) -in the header of TCP<br>
流量控制使用的是反馈接收方的接受窗口大小进而调整发送速率，采用捎带机制带回</li>
<li>Congestion control of TCP - congestion window (cwnd)<br>
拥塞控制通过检测网络拥塞状态自调整拥塞窗口大小从而达到拥塞控制的目的</li>
<li>Size of sending windows need to meet满足 the requirements of flow control &amp; congestion control at the same time.<br>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919547.png" alt="image-20240619100307223"></li>
</ul>
<h3 id="如何判断是否拥塞："><a class="header-anchor" href="#如何判断是否拥塞："></a>如何判断是否拥塞：</h3>
<ol>
<li>
<p><strong>超时</strong>:</p>
</li>
<li>
<p><strong>三个冗余ACK</strong>:</p>
</li>
</ol>
<h3 id="如何控制发送方发送速率"><a class="header-anchor" href="#如何控制发送方发送速率"></a>如何控制发送方发送速率</h3>
<ul>
<li>
<p>维持一个拥塞窗口：CongWin</p>
</li>
<li>
<p>发送方限制已发送但未确认的数据量（的上限）</p>
</li>
<li>
<p>从而粗略控制发送方往网络中注入的速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">rate = \frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>SS slow start 慢启动阶段：加倍增加（每个RTT）</p>
</li>
<li>
<p>CA congestion avoidance避免阶段阶段：线性增加（每个RTT）</p>
</li>
<li>
<p>CongWin是动态的，可以感知到网络拥塞程度的函数</p>
<ul>
<li>超时：CongWin降为 1 MSS，进入SS阶段然后再倍增到 CongWin/2(每个RTT)，从而进入CA阶段</li>
<li>冗余ACK：CongWin降为CongWin/2，CA阶段</li>
<li>否则（即正常收到ACK）：CongWin跃跃欲试</li>
</ul>
</li>
</ul>
<h3 id="联合控制："><a class="header-anchor" href="#联合控制："></a>联合控制：</h3>
<ul>
<li>
<p>发送方已发送但未确认的数据量不超过接收窗口的空闲尺寸、也不超过拥塞窗口</p>
</li>
<li>
<p>可以同时满足拥塞控制和流量控制</p>
</li>
<li>
<p>$SendWin = min { CongWin,RecvWin } $</p>
</li>
</ul>
<h3 id="控制策略"><a class="header-anchor" href="#控制策略"></a>控制策略</h3>
<ul>
<li>慢启动 ss
<ul>
<li>连接刚建立：CongWin = 1 MSS</li>
<li>每收到一个确认，CongWin加倍增长，指数级增长——必然导致拥塞</li>
<li>超时后：重置为 1 MSS，而后加倍达到标记处(CongWin/2)，而后进行线性增长(一个个MSS增加)</li>
<li>冗余ACK后：重置为 CongWin/2</li>
</ul>
</li>
<li>AIMD：线性增长、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919365.png" alt="image-20240529221931664"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919405.png" alt="image-20240613201038705"></p>
<h3 id="拥塞控制各阶段转换图"><a class="header-anchor" href="#拥塞控制各阶段转换图"></a>拥塞控制各阶段转换图</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919265.png" alt="image-20240618203633975"></p>
<p>SS，CA，FR</p>
<ul>
<li><strong>MSS</strong>：最大报文段长度，<code>TCP</code>双方发送的报文段中，包含的数据部分的最大字节数；</li>
<li><strong>cwnd</strong>：拥塞窗口，<code>TCP</code>发送但还没有得到确认的报文的序号都在这个区间；</li>
<li><strong>RTT</strong>：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；</li>
<li><strong>ssthresh</strong>：慢启动阈值，慢启动阶段，若<code>cwnd</code>的大小达到这个值，将转换到拥塞避免模式；</li>
</ul>
<h3 id="TCP-Slow-Start-–figure-3-53-transmission-round-CongWin"><a class="header-anchor" href="#TCP-Slow-Start-–figure-3-53-transmission-round-CongWin"></a>TCP Slow Start –figure 3.53- transmission round/CongWin</h3>
<p>Two phase: Slow start, congestion avoidance</p>
<p>understand of TCP congestion control according to the figure</p>
<h1 id="网络层"><a class="header-anchor" href="#网络层"></a>网络层</h1>
<h2 id="4-1-Services-of-Network-Layer"><a class="header-anchor" href="#4-1-Services-of-Network-Layer"></a>4.1 Services of Network-Layer</h2>
<p>提供主机间的逻辑通信</p>
<ul>
<li>
<p>transport segment from sending to receiving host</p>
</li>
<li>
<p>发送方将分组封装到datagram中</p>
</li>
<li>
<p>接收方接受datagram，提取出segment传送到传输层</p>
</li>
<li>
<p>每一台主机或路由器当中都有网络层协议</p>
</li>
<li>
<p>网络层服务两个重要功能：转发与路由及其含义</p>
<ul>
<li>forwarding and routing and the meanings</li>
</ul>
</li>
</ul>
<p>路由器检查所有经过它的IP数据报的报头字段</p>
<p>router examines header fields in all IP datagrams passing through it</p>
<p><strong>转发</strong>：将分组从路由的输入端移动到正确的输出端，datagram经过路由器的过程：通过单一立交的过程</p>
<p><strong>路由</strong>：确定datagram从源端到目的端的路由。使用路由选择算法 规划从源到目的的路径</p>
<h2 id="4-2-Virtual-circuit-and-datagram-networks"><a class="header-anchor" href="#4-2-Virtual-circuit-and-datagram-networks"></a>4.2 Virtual circuit and datagram networks</h2>
<p>Features of Virtual Circuit &amp; datagram network</p>
<ol>
<li><strong>virtual-circuit network</strong> provides network-layer <strong>connection service 有连接的服务</strong></li>
<li><strong>datagram network</strong> provides network-layer <strong>connectionless service 无连接的服务</strong></li>
</ol>
<p>网络层的有连接和无连接具有互斥性，因为是网络层的有连接服务是基于网络核心的硬件组成的，因此有了有连接服务之后就不能有无连接了</p>
<p>从电路交换 到 报文交换 到 分组交换 ，异步程度不断增加，文件传输效率也不断增加。（分组可以采用管道增大吞吐量）</p>
<p>Which is used in Internet and why?</p>
<p>使用 datagram network 应用于因特网中</p>
<p>原因：</p>
<ol>
<li>datagram网络更为灵活</li>
<li>自适应能力强</li>
<li>具有错误恢复的能力</li>
</ol>
<p>Comparison of Virtual Circuit &amp; Circuit switching (</p>
<p>Same: 都使用了路由器 Using the same route</p>
<p>Diff:</p>
<p>宽带资源的预先分配问题 Bandwidth resources pre-allocated</p>
<p>电路交换的资源不共享</p>
<p>建立连接</p>
<p>电路交换传播速率恒定</p>
<p>实时场景</p>
<h2 id="4-3-What’s-Inside-a-Router"><a class="header-anchor" href="#4-3-What’s-Inside-a-Router"></a>4.3 What’s Inside a Router?</h2>
<p>交换结构-通过存储器，通过总线，通过互连网络</p>
<p>switching fabric结构 –via memory, via bus, via interconnection network</p>
<p>两个关键的路由器功能：</p>
<ul>
<li>run <strong>routing algorithms</strong>/protocol (RIP, OSPF, BGP)</li>
<li><strong>forwarding datagrams</strong> from incoming to outgoing link</li>
</ul>
<h2 id="4-4-IP-Internet-Protocol"><a class="header-anchor" href="#4-4-IP-Internet-Protocol"></a>4.4 IP: Internet Protocol</h2>
<h3 id="Format-of-IPv4-datagram-header"><a class="header-anchor" href="#Format-of-IPv4-datagram-header"></a>Format of IPv4 datagram (header)</h3>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919340.png" alt="image-20240619104639933" style="zoom:67%;" /> 
<p>对于过大的分组，需要进行分片，假如一个1000bytes的分组到来，但是单个datagram MTU为：400bytes，则需要对分组分成小的data再封装成IP的数据报</p>
<p>⚠️⚠️⚠️因为IP datagram 中 IP协议的header固定占有20bytes，则实际可以存放data的大小为 380bytes。</p>
<p>每个分片的数据部分必须是8字节的倍数（<strong>除最后一个分片外</strong>），因为IP分片的<strong>偏移量字段以8字节</strong>为单位。</p>
<p>则计算出距离380最近的那个8的倍数：376 每个offset大小为 376/8 = 47</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919554.png" alt="image-20240613213127409"></p>
<p>IPv4 addressing (length)</p>
<h3 id="CIDR-Classless-InterDomain-Routing-子网掩码（一种寻址方式）："><a class="header-anchor" href="#CIDR-Classless-InterDomain-Routing-子网掩码（一种寻址方式）："></a>CIDR Classless InterDomain Routing 子网掩码（一种寻址方式）：</h3>
<ul>
<li>
<p>子网的IP位和主机位是任意的，按照子网掩码进行划分。</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919366.png" alt="image-20240613213403557"></p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919069.png" alt="image-20240613213432670"></p>
</li>
<li>
<p>subnet mask/prefix (子网中可用的IP地址个数，子网主机号长度至少为2位)</p>
</li>
<li>
<p>E.p:</p>
<ul>
<li>CIDR address:206.13.01.48/25</li>
<li>being same to 206.13.01.48 ~ 255.255.255.128</li>
</ul>
</li>
<li>
<p>Calculations about broadcast address based on Ip address and its submask</p>
</li>
</ul>
<p>主机位全为1的IP地址为广播地址；</p>
<p>主机位全为0的IP地址是网关地址，子网地址，指示本网络</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919363.png" alt="image-20240619104833346"></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a class="header-anchor" href="#DHCP-Dynamic-Host-Configuration-Protocol"></a>DHCP Dynamic Host Configuration Protocol</h3>
<ul>
<li>
<p>功能：让主机在加入网络时可以动态地从网络服务器获取到IP address</p>
</li>
<li>
<p>具体过程：</p>
<ul>
<li>DHCP的步骤:</li>
<li>主机广播 dhcp discover msg</li>
<li>DHCP服务器响应 DHCP offer msg</li>
<li>主机使用 DHCP request msg 请求 IP address</li>
<li>DHCP服务器用 DHCP ack msg 发出IP地址</li>
</ul>
</li>
<li>
<p>Calculating of IPv4 address about a subnet partitioning &amp; Routing aggregation</p>
</li>
</ul>
<h2 id="NAT"><a class="header-anchor" href="#NAT"></a>NAT</h2>
<h3 id="使用NAT的原因："><a class="header-anchor" href="#使用NAT的原因："></a>使用NAT的原因：</h3>
<ul>
<li>range of addresses not needed from ISP: just one IP address for all devices<br>
不需要来自ISP的地址范围，只需要一个IP地址即可标识所有设备</li>
<li>can change addresses of devices in local network without notifying outside world<br>
在不影响外界的情况下修改本地网络中各个设备的地址哦</li>
<li>can change ISP without changing addresses of devices in local network<br>
可以任意修改ISP且不影响本地网络中各个设备的地址</li>
</ul>
<h3 id="如何实现："><a class="header-anchor" href="#如何实现："></a>如何实现：</h3>
<h4 id="Outgoing-Datagram"><a class="header-anchor" href="#Outgoing-Datagram"></a>Outgoing Datagram</h4>
<p>当一个数据报从内部网络（私有IP地址）发往外部网络（公共IP地址）时：</p>
<ul>
<li><strong>替换源IP地址和端口号</strong>：将每个出站数据报的源IP地址和端口号替换为NAT的公共IP地址和一个新的端口号。</li>
<li><strong>记录翻译信息</strong>：在NAT翻译表中记录每个（源IP地址，端口号）和（NAT IP地址，新端口号）之间的对应关系。</li>
</ul>
<h4 id="Incoming-Datagram"><a class="header-anchor" href="#Incoming-Datagram"></a>Incoming Datagram</h4>
<p>当一个数据报从外部网络返回内部网络时，</p>
<ul>
<li><strong>查找翻译信息</strong>：在NAT翻译表中查找与目标（NAT IP地址，端口号）对应的（源IP地址，端口号）。</li>
<li><strong>替换目标IP地址和端口号</strong>：将目标IP地址和端口号替换为翻译表中存储的原始源IP地址和端口号。</li>
</ul>
<p>内往外——将内部的IP地址转化为(通过路由器)NAT IP地址<br>
外往内——通过路由器的表格将NAT IP地址转化为内网里面的内部的地址</p>
<p>端口号是有限的,如果主机数量过多,那么就不能将端口作为定位主机的IP地址的一部分</p>
<p>Function of NAT &amp; why be helpful for IPv4</p>
<p>一个子网用一个具体的IP地址，子网内部用自己的IP地址，未区分不同的设备</p>
<p>可以改变子网内部的主机设备的地址而不影响外部网络</p>
<p>外部网络发送改变也不影响子网内主机设备的地址</p>
<h3 id="ICMP"><a class="header-anchor" href="#ICMP"></a>ICMP:</h3>
<p>Internet Control Message Protocol 网络控制信息协议<br>
用于主机和路由器之间在网络层的信息交流。</p>
<p><strong>ICMP数据包的结构</strong>：ICMP消息被封装在IP数据包中，并作为IP数据包的负载。ICMP本身没有专用的传输层协议类型，它直接在网络层上运行。</p>
<p><strong>IP头部</strong>：IP数据包头部中的协议字段（Protocol Field）值为1表示这个IP数据包的负载是一个ICMP消息。</p>
<p><strong>icmp主要用于错误信息的播报和ping服务</strong></p>
<p>When ICMP message arrives,source calculates RTT Traceroute does this 3 times<br>
当ICMP消息到达时，源计算RTT <strong>Traceroute</strong>这样做3次</p>
<h4 id="常见ICMP"><a class="header-anchor" href="#常见ICMP"></a>常见ICMP</h4>
<p><strong>回显请求（Echo Request）和回显应答（Echo Reply）</strong>：用于Ping操作，用于测试目标主机是否可达以及计算往返时间。</p>
<ul>
<li>回显请求：类型8，代码0。</li>
<li>回显应答：类型0，代码0。</li>
</ul>
<p><strong>目的不可达（Destination Unreachable）</strong>：当路由器或主机无法将数据包传递给目的地时发送。</p>
<ul>
<li>类型3，不同的代码值表示不同的不可达原因，例如网络不可达、主机不可达、端口不可达等。</li>
</ul>
<p><strong>时间超过（Time Exceeded）</strong>：当数据包的TTL（Time to Live）字段减到零时发送，通常用于<strong>Traceroute</strong>操作。</p>
<ul>
<li>类型11，代码0表示TTL超时，代码1表示分片重组超时。</li>
</ul>
<p><strong>重定向（Redirect）</strong>：当路由器发现通过另一条路径传输数据更有效时，通知主机更改其路由。</p>
<ul>
<li>类型5，不同的代码值表示不同的重定向原因。</li>
</ul>
<p><strong>Traceroute 原理</strong></p>
<ul>
<li>想要获得距离本机第 n 跳的路由器信息，则发送一个 TTL 为 n 的 IP 数据报 （数据报中包含具有不可达 UDP 端口号的 UDP 报文段），到达路由器之后，因为 TTL 为 0 ，路由器向请求端发送超时 ICMP 报文。</li>
<li>当到达目的主机，会返回端口不可达 ICMP 报文，终止探测过程</li>
</ul>
<h2 id="4-4-IP-Internet-Protocol-conti"><a class="header-anchor" href="#4-4-IP-Internet-Protocol-conti"></a>4.4 IP: Internet Protocol (conti-)</h2>
<h3 id="IPv6-datagram-format"><a class="header-anchor" href="#IPv6-datagram-format"></a>IPv6 datagram format</h3>
<h4 id="地址："><a class="header-anchor" href="#地址："></a>地址：</h4>
<ul>
<li>IPv6地址长度为128位，通常使用八组16进制数表示，每组由冒号分隔。例如：AD80:0000:0000:0000:ABAA:0000:00C2:0002。</li>
<li><strong>零压缩方法</strong>：零压缩用于缩短连续零的表示，但每个地址只能压缩一次。示例如下：
<ul>
<li>原地址：AD80:0000:0000:0000:ABAA:0000:00C2:0002</li>
<li>压缩后：AD80::ABAA:0000:00C2:0002</li>
</ul>
</li>
</ul>
<h3 id="IPv6相对于IPv4的变化（IPv6的优势）"><a class="header-anchor" href="#IPv6相对于IPv4的变化（IPv6的优势）"></a>IPv6相对于IPv4的变化（IPv6的优势）</h3>
<ol>
<li><strong>更大的地址空间</strong>：IPv6使用128位地址，支持大约3.4×10^38个唯一地址，解决了IPv4地址耗尽的问题。</li>
<li><strong>简化的报头</strong>：IPv6报头结构更简洁，<strong>固定为40字节</strong>，减少了路由器处理开销。</li>
<li><strong>自动配置</strong>：支持无状态地址自动配置（SLAAC），设备可以自动生成IPv6地址。</li>
<li><strong>内置的安全性</strong>：IPv6强制支持IPsec协议，提高了网络通信的安全性。</li>
<li><strong>改进的多播和任播</strong>：增强了多播和任播功能，提高了组播通信的效率。</li>
<li><strong>扩展头部机制</strong>：通过可选的扩展头部，增加了灵活性和功能扩展能力。</li>
<li><strong>消除了网络地址转换（NAT）</strong>：每个设备可以有一个唯一的公共IP地址，简化了网络架构。</li>
</ol>
<h2 id="4-5-Routing-algorithms"><a class="header-anchor" href="#4-5-Routing-algorithms"></a>4.5 Routing algorithms</h2>
<p>路由算法决定了网络层端到端的path</p>
<p>路由器中有一个本地转发表，决定了数据报在该router里的转发方向</p>
<h3 id="两种路由器算法"><a class="header-anchor" href="#两种路由器算法"></a>两种路由器算法</h3>
<ol>
<li>全局式：所有路由器知道完整的拓扑图以及相关的连接信息：<strong>Link State 链路状态算法</strong></li>
<li>分散式：路由器仅知道主机相连的邻居已经到达邻居的costs，以迭代、分布式的方式计算从最优路径：<strong>距离向量 Distance Vector 算法——DV算法</strong></li>
<li>根据路由器中路由的变化快慢有：
<ol>
<li>静态 static：一段时间内路由变化较慢</li>
<li>动态 dynamic：一段时间内路由变化快</li>
</ol>
</li>
<li>根据算法是负载敏感还是迟钝划分：
<ol>
<li>负载敏感算法 load-sensitive algorithm：链路费用动态地变化以反映底层链路当前的拥塞水平。</li>
<li>负载迟钝：某条链路的费用不显式反映出当前的拥塞水平，常见算法有：RIP、OSPF、BGP</li>
</ol>
</li>
</ol>
<p><strong>距离向量（Distance Vector）</strong>：例如 <strong>RIP（Routing Information Protocol）和 BGP （Border Gateway Protocol）</strong>。每个路由器根据收到的距离向量更新来计算到目的地的最佳路径，并将这些信息传播给相邻的路由器。</p>
<p><strong>路径向量（Path Vector）</strong>：例如 <strong>BGP（Border Gateway Protocol）</strong>。路径向量算法类似于距离向量，但是在路由选择时考虑了更多的因素，如 AS 路由策略和路径属性。</p>
<p><strong>拓扑图（Link State）</strong>：如 <strong>OSPF</strong>。每个路由器都维护一个拓扑图，并根据该图计算最短路径。</p>
<p><strong>洪泛（Flooding）</strong>：每个收到的路由器更新都被转发到所有邻居，直到达到目的地。</p>
<h3 id="LS-Link-State算法"><a class="header-anchor" href="#LS-Link-State算法"></a>LS Link State算法</h3>
<p>向所有路由器广播整个网络拓扑的信息，让每个路由器计算到其他路由器的汇聚树。</p>
<p>使用Dijkstra算法算出当前路由器到其他每一个路由器的最短路径 OSPF使用的就是这种算法</p>
<h3 id="层次路由"><a class="header-anchor" href="#层次路由"></a>层次路由</h3>
<p><strong>规模 scale</strong></p>
<p><strong>管理自知 administrative autonomy</strong></p>
<p>将router组织成一种regions，形成<strong>自治系统AS autonomous systems</strong></p>
<p>AS 通过 Gateway Router 网关路由器进行连接与相互访问，基于这种 AS 与 AS 间的路由设计出了BGP border gateway protocol</p>
<p>同一个系统中的路由运行同一种路由算法(LS或者DV的一种)</p>
<h3 id="内部网关算法-AS内部算法"><a class="header-anchor" href="#内部网关算法-AS内部算法"></a>内部网关算法 AS内部算法</h3>
<h4 id="RIP-Routing-Information-Protocol"><a class="header-anchor" href="#RIP-Routing-Information-Protocol"></a>RIP: Routing Information Protocol</h4>
<p>RIP advertisements RIP广播</p>
<p>原理是 DV算法，交换相邻节点的路由信息</p>
<p>使用UDP协议进行传输，重复传输</p>
<h4 id="OSPF-Open-Shortest-Path-First"><a class="header-anchor" href="#OSPF-Open-Shortest-Path-First"></a>OSPF: Open Shortest Path First</h4>
<p>原理是：Link State，因为知道了局部网络中所有的路由信息，因此可以采用该算法</p>
<h4 id="BGP"><a class="header-anchor" href="#BGP"></a>BGP</h4>
<p>应用了DV算法 进而推测出最佳路径</p>
<ul>
<li>
<p>eBGP 外部网关协议：AS 与 AS 间的可达性由eBGP获得</p>
</li>
<li>
<p>iBGP 内部网关协议：AS 内部的路由器的可达性信息，由iBGP进行传播</p>
</li>
</ul>
<p>BGP允许子网向其余的internet宣布自己的存在</p>
<p>一对路由器(BGP对等方)在TCP协议的基础上进行 routing info 的交换:</p>
<p>这就叫做 BGP session(BGP会话)</p>
<h5 id="两个重要的路径属性"><a class="header-anchor" href="#两个重要的路径属性"></a>两个重要的路径属性</h5>
<ul>
<li>AS-PATH: contains ASs through which prefix advertisement has passed: e.g, AS 67, AS 17</li>
<li>NEXT-HOP: indicates specific internal-AS router to next-hop AS. (may be multiple links from current AS to next-hop-AS)<br>
指定到下一跳自治系统的特定AS内部路由器。(可能是从当前自治系统到下一跳自治系统的多条链路)
<ul>
<li>标识了应该用于到达目的网络的下一个最近的路由器（通常在同一个AS内部）。</li>
</ul>
</li>
</ul>
<h3 id="BGP路径选择依据"><a class="header-anchor" href="#BGP路径选择依据"></a>BGP路径选择依据</h3>
<p>selects route based on:<br>
local preference value attribute: policy decision<br>
shortest AS-PATH<br>
closest NEXT-HOP router: hot potato routing<br>
additional criteria</p>
<ul>
<li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary)</li>
</ul>
<p>Why there are different routing algorithms?</p>
<p>Link state</p>
<ul>
<li>principle of algorithm</li>
<li>how to use Dijkstra’s algorithms to calculate the shortest path—<br>
examples table of ppt<br>
r Distance Vector algorithm</li>
<li>Principle of algorithm &amp; how to calculating route by DV</li>
</ul>
<p>4.6 Routing in the Internet<br>
r Two levels of routing in Internet and why<br>
r Inter-AS routing - policy<br>
r Intra-AS routing- performance (costs)<br>
r Interior Gateway Protocols/intra-domain: RIP, OSPF<br>
r Principles of them<br>
r Border Gateway Protocol/inter-domain: BGP<br>
r “hot potato routing”<br>
r based on Path vector</p>
<h1 id="链路层"><a class="header-anchor" href="#链路层"></a>链路层</h1>
<h2 id="5-1-data-transmission-services"><a class="header-anchor" href="#5-1-data-transmission-services"></a>5.1 data transmission services</h2>
<h3 id="链路层的实现"><a class="header-anchor" href="#链路层的实现"></a>链路层的实现</h3>
<p>在每一个 router 和 host 的适配器 adaptor(Network Interface Card 网络接口卡，网卡) 当中去实现：以太网适配器实现了链路层和物理层</p>
<h3 id="Link-Layer-Services"><a class="header-anchor" href="#Link-Layer-Services"></a>Link Layer Services</h3>
<p>负责将datagram从一个node移动到另一个node</p>
<ol>
<li>flow control.
<ul>
<li>相邻发送和接收节点之间的速度<br>
pacing between adjacent sending and receiving nodes</li>
</ul>
</li>
<li>framing：对来自网络层的datagram进行封装，要加header和trailer
<ul>
<li>在封装过程中，发送方在frame中加入checking bits，rdt，flow control</li>
<li>接收方查看frame中添加的带有那些功能的位</li>
</ul>
</li>
<li>error detection and correction bits EDC：
<ul>
<li>Error detection not 100% reliable!</li>
<li>接收器检测到错误的存在:<br>
receiver detects presence of errors</li>
<li>接收器识别并纠正比特错误，而不需要重传<br>
receiver identifies and corrects bit error(s) without resorting to retransmission</li>
<li>使用的 EDC 方法为：Checksumming：Cyclic redundancy Check 循环校冗余检测</li>
</ul>
</li>
<li>half-duplex and full-duplex 半双工和全双工
<ul>
<li>对于半双工，链路两端的节点可以传输，但不能同时传输<br>
with half duplex, nodes at both ends of link can transmit, but not at same time</li>
</ul>
</li>
<li>reliable delivery<br>
6. link access：</li>
</ol>
<h2 id="CRC计算"><a class="header-anchor" href="#CRC计算"></a>CRC计算</h2>
<h3 id="CRC的基本原理"><a class="header-anchor" href="#CRC的基本原理"></a>CRC的基本原理</h3>
<ol>
<li><strong>多项式表示</strong>：
<ul>
<li>数据被视为一个二进制序列，并用一个多项式表示。例如，数据1101可以表示为多项式x³ + x² + 1。</li>
<li>生成多项式（Generator Polynomial）也是一个固定的二进制序列，如常用的CRC-32的生成多项式为x³² + x²⁶ + x²³ + … + 1。</li>
</ul>
</li>
<li><strong>附加零位</strong>：
<ul>
<li>在数据后面附加与生成多项式长度相同的零位。</li>
<li>例如，假设生成多项式为G(x)二进制数字长度为 n 位，</li>
<li>对于数据D(x)，在其后面附加 n-1 个零位，形成D’(x)。</li>
</ul>
</li>
<li><strong>二进制除法</strong>：一个异或操作
<ul>
<li>对D’(x)进行二进制除法，除数为生成多项式G(x)，得到余数R(x)。</li>
</ul>
</li>
<li><strong>生成校验码</strong>：
<ul>
<li>余数R(x)就是校验码，将其附加在原始数据后面形成传输数据。</li>
</ul>
</li>
</ol>
<h3 id="CRC校验过程"><a class="header-anchor" href="#CRC校验过程"></a>CRC校验过程</h3>
<ol>
<li><strong>接收数据</strong>：
<ul>
<li>接收方接收到数据D(x)和附加的校验码R(x)。</li>
</ul>
</li>
<li><strong>二进制除法校验</strong>：
<ul>
<li>接收方对包含校验码的接收数据进行与生成步骤相同的二进制除法，检查是否余数为零。</li>
<li>如果余数为零，说明数据没有错误；否则，数据存在错误。</li>
</ul>
</li>
</ol>
<h3 id="CRC示例（CRC-4）"><a class="header-anchor" href="#CRC示例（CRC-4）"></a>CRC示例（CRC-4）</h3>
<p>假设我们要发送的数据是1101，生成多项式为x⁴ + x + 1（对应的二进制为10011），步骤如下：</p>
<ol>
<li><strong>附加零位</strong>：
<ul>
<li>数据：1101</li>
<li>生成多项式长度为5位，所以附加4个零位：1101 0000</li>
</ul>
</li>
<li><strong>二进制除法</strong>：
<ul>
<li>1101 0000 ÷ 1001 1</li>
<li>二进制除法的过程类似于十进制的长除法，得到的余数R(x)为0100</li>
</ul>
</li>
<li><strong>生成校验码</strong>：
<ul>
<li>校验码为1000</li>
<li>发送的数据为1101 0100</li>
</ul>
</li>
</ol>
<h3 id="接收方校验"><a class="header-anchor" href="#接收方校验"></a>接收方校验</h3>
<ol>
<li><strong>接收数据</strong>：
<ul>
<li>接收数据为1101 0100</li>
</ul>
</li>
<li><strong>二进制除法</strong>：
<ul>
<li>1101 0100 ÷ 10011</li>
<li>如果余数为0，说明数据无误；如果余数非0，说明数据出错。</li>
</ul>
</li>
</ol>
<h2 id="5-3-Multiple-access-protocols"><a class="header-anchor" href="#5-3-Multiple-access-protocols"></a>5.3 Multiple access protocols</h2>
<h3 id="两种多连接链路"><a class="header-anchor" href="#两种多连接链路"></a>两种多连接链路</h3>
<ol>
<li>点对点式：point to point</li>
<li>广播式：  broadcast</li>
</ol>
<h3 id="多道访问协议-Multiple-Access-protocols"><a class="header-anchor" href="#多道访问协议-Multiple-Access-protocols"></a>多道访问协议 Multiple Access protocols</h3>
<h3 id="碰撞-Collision"><a class="header-anchor" href="#碰撞-Collision"></a>碰撞 Collision</h3>
<p>Collision(碰撞) of broadcast channel when two or more nodes send data at the same time<br>
当两个及以上个节点<strong>同时</strong>在信道内发送数据，则会导致 “碰撞” 的发生</p>
<h3 id="three-broad-classes（MAC-协议）"><a class="header-anchor" href="#three-broad-classes（MAC-协议）"></a>three broad classes（MAC 协议）</h3>
<h4 id="Channel-Partitioning-Multiplexing"><a class="header-anchor" href="#Channel-Partitioning-Multiplexing"></a>Channel Partitioning/Multiplexing:</h4>
<p>将信道分层小的“pieces”（时间隙）</p>
<ol>
<li>TDMA time division multiple access
<ul>
<li>时分 time slots 将一段固定的周期分成小的时间间隙，每个节点使用一个固定序号的间隙</li>
</ul>
</li>
<li>FDMA frequency division multiple access
<ul>
<li>频分 frequency</li>
</ul>
</li>
<li>CDMA 码分 code</li>
</ol>
<h4 id="Random-Access"><a class="header-anchor" href="#Random-Access"></a>Random Access:</h4>
<ol>
<li>ALOHA<br>
1.</li>
<li>slotted ALOHA</li>
<li>CSMA carrier sense multiple access
<ol>
<li>传输之前先监听信道：如果信道空闲，发送frame；如果信道忙碌，延迟发送</li>
<li></li>
</ol>
</li>
<li>CSMA\CD (Collision Detection) 载波监听多道访问（碰撞检测版）
<ol>
<li>先听再讲–载波监听</li>
<li>边讲边听—进行检测检测</li>
<li>冲突处理–发送站检测到冲突后立即停止帧的发送,并且发一个简短的堵塞信号(称强化冲突信号，Jamming signal),通知网上各站已经发生冲突,本站及网上所有站都等待一段随机分布的时间,然后再按CSMA/CD方式重发该帧。</li>
</ol>
</li>
<li>CSMA/CD 遇到冲突时进行重传的算法：Binary backoff
<ol>
<li>随机选择的时隙数 $ n \in (0,2^{重传次数}−1)$ 内选择。</li>
<li>这意味着 n 可以是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mtext>重传次数</mtext></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{重传次数}−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">重传次数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 中的任意值。</li>
<li>After 16 collisions, abandon the transmission.</li>
</ol>
</li>
</ol>
<h4 id="CSMA-CD算法也用在以太网中"><a class="header-anchor" href="#CSMA-CD算法也用在以太网中"></a>CSMA/CD算法也用在以太网中</h4>
<p>NIC network interface card</p>
<h4 id="“Taking-turns”-Tokening-Ring"><a class="header-anchor" href="#“Taking-turns”-Tokening-Ring"></a>“Taking turns”:Tokening Ring</h4>
<ol>
<li><strong>令牌传递机制</strong>：
<ul>
<li>使用一个特殊的数据包，称为“令牌”（token），在网络节点之间传递。</li>
<li>持有令牌的节点获得发送数据的权限。</li>
<li>令牌在节点之间按照特定顺序传递（通常是环形网络）。</li>
<li>当节点完成数据传输后，将令牌传递给下一个节点</li>
<li>如果节点没有数据要传输，它会简单地将令牌传递给环路中的下一个节点，而不作修改。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>网络带宽高效利用：只有需要传输数据的节点才使用网络，减少碰撞，提高效率。</li>
<li>**公平性：**每个节点根据令牌传递顺序有平等的机会传输数据。</li>
<li>**可靠性：**由于一次只能有一个节点传输，碰撞减少，提高了网络的可靠性。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>网络管理复杂：令牌管理需要额外的开销，并且实现和故障排除可能较为复杂。</li>
<li>**单点故障：**如果令牌帧丢失或损坏，或者拿到令牌的主机，可能会导致网络通信中断，直到问题解决为止。</li>
<li><strong>有效利用率不高</strong>：当网络中仅有一台主机活跃需要令牌时，它必须等待令牌的到来才可以进行数据的传输</li>
</ul>
</li>
</ol>
<h2 id="5-4-LAN-Local-Area-Network"><a class="header-anchor" href="#5-4-LAN-Local-Area-Network"></a>5.4 LAN Local Area Network</h2>
<h3 id="MAC-address"><a class="header-anchor" href="#MAC-address"></a>MAC address</h3>
<p>MAC(Media Access Control)媒体访问控制(or LAN or physical or Ethernet) address ：</p>
<p>在NIC出厂前就烧制在NIC当中，</p>
<p>48bits 的 MAC地址(对于大部分LANs)通常存储在网卡的ROM当中,也可以通过软件设置<br>
e.g.: 1A-2F-BB-76-09-AD</p>
<p>MAC address 由IEEE统一管理和分配；</p>
<p>MAC地址就像身份证号码一样；IP地址就像邮政编码一样：</p>
<p>人可以改变地址，进而修改邮政编码，但是除非重生，负责身份证号码不可以改变</p>
<h3 id="ARP（Address-Resolution-Protocol）"><a class="header-anchor" href="#ARP（Address-Resolution-Protocol）"></a>ARP（Address Resolution Protocol）</h3>
<p>将一个IP地址转换成一个MAC地址</p>
<p>有一个广播地址：FF-FF-FF-FF-FF-FF</p>
<p>每一个适配器在 Local Area Network 中有独一无二的LAN地址，那就是 MAC地址</p>
<h4 id="ARP-Table"><a class="header-anchor" href="#ARP-Table"></a>ARP Table</h4>
<p>有一个字段 TTL time to leave：用于记录 IP和MAC 的映射关系存在于ARP表中的时间，到时间则进行清除。</p>
<h4 id="ARP的工作过程"><a class="header-anchor" href="#ARP的工作过程"></a>ARP的工作过程</h4>
<ol>
<li><strong>ARP请求</strong>：
<ul>
<li>当一台主机（例如，主机A）想要和另一台主机（例如，主机B）通信时，它需要知道主机B的MAC地址。</li>
<li>如果主机A只有主机B的IP地址，它会发送一个ARP请求广播到网络中。ARP请求中包含了主机A的IP地址和MAC地址，以及主机B的IP地址（请求的目标）。</li>
</ul>
</li>
<li><strong>ARP响应</strong>：
<ul>
<li>网络中所有接收到ARP请求的设备都会检查请求中的目标IP地址是否与自身的IP地址匹配。</li>
<li>如果某台设备（即主机B）的IP地址与请求中的目标IP地址匹配，它会发送一个ARP响应，其中包含自己的MAC地址。</li>
<li>这个ARP响应是单播的，直接发送给请求者（主机A）。</li>
</ul>
</li>
<li><strong>更新ARP缓存</strong>：
<ul>
<li>主机A收到ARP响应后，会将主机B的IP地址和对应的MAC地址记录在自己的ARP缓存中，以后再次与主机B通信时，可以直接从ARP缓存中获取MAC地址，而不需要再次发送ARP请求。</li>
</ul>
</li>
<li><strong>通信</strong>：
<ul>
<li>有了主机B的MAC地址后，主机A可以通过以太网帧的目的MAC地址字段将数据包发送给主机B。</li>
</ul>
</li>
</ol>
<h4 id="ARP缓存"><a class="header-anchor" href="#ARP缓存"></a>ARP缓存</h4>
<p>为了提高效率，主机通常会维护一个ARP缓存（ARP table），其中记录了最近解析过的IP地址和MAC地址的对应关系。缓存条目有一定的生存时间（TTL），过期后会被删除。</p>
<h4 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h4>
<ul>
<li>动态解析：ARP能动态解析IP地址为MAC地址，适用于动态变化的网络环境。</li>
<li>广播请求：通过广播请求，可以确保网络中任何节点的MAC地址都能被发现。</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>安全问题：ARP协议容易受到ARP欺骗（ARP spoofing）攻击，攻击者可以发送伪造的ARP响应，导致网络中的流量被重定向或中断。</li>
<li>广播开销：ARP请求是广播的，在大型网络中频繁的ARP请求会产生一定的广播开销。</li>
</ul>
<h3 id="以太网"><a class="header-anchor" href="#以太网"></a>以太网</h3>
<p>以太网:其实就是物理拓扑图</p>
<ol>
<li>总线型：所有节点node都在一个冲突域内，如果多个node同时发生数据，这会发生冲突</li>
<li>星型：</li>
</ol>
<h4 id="Ethernet-Frame"><a class="header-anchor" href="#Ethernet-Frame"></a>Ethernet Frame</h4>
<p>将IP数据报封装到Ethernet Frame中</p>
<h4 id="不可靠、无连接"><a class="header-anchor" href="#不可靠、无连接"></a>不可靠、无连接</h4>
<ol>
<li>
<p>不可靠的：发送和接收 NIC网卡 间不发送ack；</p>
</li>
<li>
<p>无连接的：在发送和接收网卡间没有握手</p>
</li>
</ol>
<p>采取 带有二进制退避算法的无时隙的CSMA/CD 的 MAC 协议 carrier sense multiple access/collision detection</p>
<h2 id="Switch"><a class="header-anchor" href="#Switch"></a>Switch</h2>
<h3 id="Hubs-集线器"><a class="header-anchor" href="#Hubs-集线器"></a>Hubs 集线器</h3>
<h1 id="RTP"><a class="header-anchor" href="#RTP"></a>RTP</h1>
<p><em>Real-time Transport Protocol</em>（实时传输协议）</p>
<p>为<em>IP</em>网上的语音、图像、传真等多种需要实时传输的多媒体数据提供端到端的实时传输服务</p>
<p><em>RTP</em>为<em>Internet</em>上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由<em>RTCP</em>来提供。</p>
<p>单播或多播网络中传送实时数据。</p>
<h1 id="VLAN"><a class="header-anchor" href="#VLAN"></a>VLAN</h1>
<h1 id="IPv6"><a class="header-anchor" href="#IPv6"></a>IPv6</h1>
<h1 id="零散知识"><a class="header-anchor" href="#零散知识"></a>零散知识</h1>
<p>接入网/enterprise：以太网和wifi的特点：</p>
<h2 id="一些指定的端口port"><a class="header-anchor" href="#一些指定的端口port"></a>一些指定的端口port</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919169.png" alt="image-20240612205125464"></p>
<h2 id="带宽是什么"><a class="header-anchor" href="#带宽是什么"></a>带宽是什么</h2>
<p>带宽是所有链路中传输速度最小的那个值</p>
<h2 id="各种应用对于数据丢失、宽带和时间敏感的要求"><a class="header-anchor" href="#各种应用对于数据丢失、宽带和时间敏感的要求"></a>各种应用对于数据丢失、宽带和时间敏感的要求</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919421.png" alt="image-20240611195201263"></p>
<h2 id="MAC地址相关"><a class="header-anchor" href="#MAC地址相关"></a>MAC地址相关</h2>
<p>Ethernet interface addresses以太网接口地址</p>
<ul>
<li>
<p>也称为MAC地址</p>
</li>
<li>
<p>也称为硬件地址（Hardware Address）</p>
</li>
</ul>
<p><strong>IEEE注册管理机构</strong>：</p>
<ul>
<li>IEEE（电气电子工程师学会）管理MAC地址的分配。</li>
<li>网络设备制造商必须向IEEE注册，并被分配一个唯一的组织唯一标识符（OUI）。</li>
<li>确保了每个以太网接口都有一个唯一的MAC地址。</li>
</ul>
<p><strong>组织唯一标识符（OUI）</strong>：</p>
<ul>
<li>OUI是一个24位（3字节）的数字，用于唯一标识制造商或组织。</li>
<li>OUI构成MAC地址的前三个字节（24位）。</li>
</ul>
<p><strong>设备特定标识符</strong>：</p>
<ul>
<li>MAC地址的剩余24位由制造商分配。这些位用于唯一标识制造商生产的每个网络接口卡。</li>
<li>这意味着每个制造商可以为每个OUI生成多达 2242^{24}224 个唯一的MAC地址。</li>
</ul>
<h2 id="数据链路层某些协议的分类："><a class="header-anchor" href="#数据链路层某些协议的分类："></a>数据链路层某些协议的分类：</h2>
<p><strong>基于竞争的协议</strong>：</p>
<ul>
<li>CSMA/CD</li>
<li>CSMA</li>
<li>ALOHA</li>
</ul>
<p><strong>基于时分多址的协议</strong>：</p>
<ul>
<li>TDMA</li>
</ul>
<h2 id="各层协议的头部："><a class="header-anchor" href="#各层协议的头部："></a>各层协议的头部：</h2>
<p><strong>应用层（Application Layer）</strong>：</p>
<ul>
<li>应用层数据报不会添加额外的头部。例如，HTTP请求和响应的头部信息已经包含在应用层数据中。</li>
</ul>
<p><strong>传输层（Transport Layer）</strong>：</p>
<ul>
<li>TCP头部大小通常是20字节，但在某些情况下可能会有额外的选项字段，最大可达60字节。</li>
<li>UDP头部大小固定为8字节。</li>
</ul>
<p><strong>网络层（Network Layer）</strong>：</p>
<ul>
<li>IPv4头部大小通常是20字节，但也可能因选项字段而有所增加，最大可达60字节。</li>
<li>IPv6头部大小固定为40字节。</li>
</ul>
<p><strong>数据链路层（Data Link Layer）</strong>：</p>
<ul>
<li>数据链路层的头部大小取决于使用的协议，例如以太网帧的头部大小通常为14字节。不过，需要注意的是，这个头部大小不是在所有情况下都一样，它可能会因为使用的协议和网络设备而有所变化。</li>
</ul>
<h2 id="复用和解复用"><a class="header-anchor" href="#复用和解复用"></a>复用和解复用</h2>
<p><strong>复用 multiplexing</strong>：发送端将将应用层的每一个socket的数据合并交付给传输层</p>
<p><strong>解复用 demultiplexing</strong>：传输层将收到的数据交付给正确的socket</p>
<h2 id="电路交换和分组交换、数据报交换和虚电路交换的特点"><a class="header-anchor" href="#电路交换和分组交换、数据报交换和虚电路交换的特点"></a>电路交换和分组交换、数据报交换和虚电路交换的特点</h2>
<ol>
<li>电路交换：最经典的电路交换网是电话网络。
<ol>
<li>数据传输方式：
<ol>
<li>在通信之前需要先建立电路，连接两个通信端点</li>
<li>通信中的数据都跳过这条电路进行传输</li>
</ol>
</li>
<li>资源使用：
<ol>
<li>主要特点是可以独占资源</li>
</ol>
</li>
<li>连接建立：
<ol>
<li>三个阶段：1. 建立连接  2. 通信  3. 释放连接</li>
</ol>
</li>
</ol>
</li>
<li>分组交换：
<ol>
<li>数据传输方式：
<ol>
<li>大的报文被分割成小的packet，每个packet独立传输</li>
<li>pkt选择最佳路径进行传输，可能经过不同的网络节点和链路</li>
</ol>
</li>
<li>资源使用：
<ol>
<li>传输时，网络资源动态分配和共享</li>
</ol>
</li>
<li>通信连接：在进行通信之前不建立连接</li>
</ol>
</li>
</ol>
<h3 id="分组交换和电路交换的区别"><a class="header-anchor" href="#分组交换和电路交换的区别"></a>分组交换和电路交换的区别</h3>
<p><strong>资源使用</strong>：</p>
<ul>
<li>分组交换：动态分配和共享网络资源。</li>
<li>电路交换：建立专用的连接，独占网络资源。</li>
</ul>
<p><strong>连接建立</strong>：</p>
<ul>
<li>分组交换：不需要事先建立连接，每个数据包独立传输。</li>
<li>电路交换：需要事先建立连接，通信双方独占建立的电路。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>分组交换：Internet中的IP网络。</li>
<li>电路交换：传统的电话网络。</li>
</ul>
<h2 id="互联网分层的两个重要原因"><a class="header-anchor" href="#互联网分层的两个重要原因"></a>互联网分层的两个重要原因</h2>
<p><strong>Scale and administrative autonomy</strong></p>
<h2 id="分组交换网络性能评估指标：延迟、丢包和吞吐量"><a class="header-anchor" href="#分组交换网络性能评估指标：延迟、丢包和吞吐量"></a>分组交换网络性能评估指标：延迟、丢包和吞吐量</h2>
<p><strong>丢包</strong>：</p>
<ul>
<li><strong>数据包丢失</strong>：在到达目的地之前丢弃或丢失的数据包。可能由于拥塞、错误或缓冲区溢出等原因造成。</li>
<li><strong>比特错误率（BER）</strong>：接收到的错误比特数与发送的总比特数的比率。反映了传输媒介的可靠性。</li>
</ul>
<p><strong>吞吐量</strong>：</p>
<ul>
<li><strong>有效吞吐量</strong>：单位时间内传输的实际有用数据量，不包括协议开销和重传。反映了数据传输的有效速率。</li>
<li><strong>链路利用率</strong>：链路被使用来传输数据的时间百分比。反映了链路容量的有效利用程度。</li>
</ul>
<h3 id="对网络性能的影响-v2"><a class="header-anchor" href="#对网络性能的影响-v2"></a>对网络性能的影响</h3>
<ul>
<li><strong>延迟</strong>：高延迟会导致响应时间增加和实时通信性能下降。</li>
<li><strong>丢包</strong>：数据包丢失会降低数据传输的质量，影响网络的可靠性。</li>
<li><strong>吞吐量</strong>：较高的吞吐量表示网络容量和性能更好，允许在给定时间内传输更多的数据。</li>
</ul>
<h2 id="DHCP"><a class="header-anchor" href="#DHCP"></a>DHCP</h2>
<p>用于在计算机网络中自动分配IP地址和其他网络配置参数的协议。</p>
<p>主要目的是简化网络管理，提高网络的可扩展性和灵活性。</p>
<h2 id="填空题"><a class="header-anchor" href="#填空题"></a>填空题</h2>
<p>Data link layer in IEEE802.3 is divided to two function sub-layers. They are (MAC) and (LLC).</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/./img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件架构设计复习笔记"><img class="cover" src="/./img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">软件架构设计复习笔记</div></div><div class="info-2"><div class="info-item-1">软件架构设计期末复习 CH1 软件架构 Software Architecture 软件&amp;架构 什么是软件体系结构：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系 以及两者的属性。 架构即即是一种软件结构 一系列的元素由某种关系串联起来构成一个结构 structure 一个软件系统由许多的structure构成（单一个结构无法称之为架构） Architecture 架构 三个重要特征：  Module 模块   一些结构将系统划分为实现单元，我们称之为模块。 模块被分配具体的计算责任，并且是编程团队工作任务的基础。 在大型项目中，这些元素（模块）会被进一步划分，以便分配给子团队。   Component and Connector 组件和连接器    其他结构关注于元素在运行时相互交互的方式，以执行系统的功能。这种运行时结构称之为Component and Connector (C&amp;C)结构 组件和连接器。   实际应用中，组件基本上都是运行时实体    Allocation...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="编译原理复习笔记"><img class="cover" src="/./img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">编译原理复习笔记</div></div><div class="info-2"><div class="info-item-1">编译原理复习笔记 为什么要编译 电脑只能执行机器语言 但高级编程语言易于给人类进行编辑与开发 因而需要将人类易于阅读的高级编程语言转换成机器语言 这个转换的过程就是编译 什么是编译器 一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言 解释器 interpreter 另一种常见的语言处理器，不通过翻译的方式生成目标程序 编译器和解释器的异同 相同： 都是语言实现系统 不同：  编译器先翻译后执行，编译器做拓展性的预处理，大部分都是考编译器实现的 解释器边翻译边执行，解释器执行程序很少或没有预处理  JVM的原理：  语言处理系统全过程  编译器全过程  各板块及其功能  词法分析：识别描述逻辑块 语法分析：识别逻辑之间如何相互有关系 语义分析：识别整个结构的意义 中间代码生成：设计一个可能符合的结构 中间代码优化：简化生成的目的结构 代码生成：产生目的结构 机器相关代码优化：优化最终结构  编译器中间的四大流程又与  Literal table 语法表； Symbol table 符号表； Error handler 错误处理器  词法分析 Lexical...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Network-edge"><span class="toc-number">2.1.</span> <span class="toc-text">1.2 Network edge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-network-core"><span class="toc-number">2.2.</span> <span class="toc-text">1.3 network core</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Performance"><span class="toc-number">2.3.</span> <span class="toc-text">1.4 Performance:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%97%B6%E5%BB%B6%EF%BC%9A%E6%97%B6%E5%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E6%95%B0%EF%BC%8C%E8%80%8C%E6%98%AF%E5%92%8C%E6%8B%A5%E5%A1%9E%E7%A8%8B%E5%BA%A6%E6%9C%89%E5%85%B3"><span class="toc-number">2.3.1.</span> <span class="toc-text">四种时延：时延的大小不是一个常数，而是和拥塞程度有关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">丢包：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">吞吐量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.3.4.</span> <span class="toc-text">对网络性能的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Protocol-layers-service-models"><span class="toc-number">2.4.</span> <span class="toc-text">1.5 Protocol layers, service models</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocols-in-each-layer-of-TCP-IP"><span class="toc-number">2.4.1.</span> <span class="toc-text">Protocols in each layer of TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protocol-stacks-in-Internet"><span class="toc-number">2.4.2.</span> <span class="toc-text">protocol stacks in Internet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Principles-of-network-applications"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Principles of network applications</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Web-and-HTTP"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 Web and HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-FTP"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 FTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Electronic-Mail"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 Electronic Mail</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-DNS-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 DNS 域名系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Funcation-of-DNS"><span class="toc-number">3.5.1.</span> <span class="toc-text">Funcation of DNS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Peer-to-Peer-Applications"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 Peer-to-Peer Applications</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">3.7.</span> <span class="toc-text">socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-SOCKET%EF%BC%9A"><span class="toc-number">3.7.1.</span> <span class="toc-text">TCP-SOCKET：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-Socket"><span class="toc-number">3.7.2.</span> <span class="toc-text">UDP-Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Transport-layer-services"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 Transport-layer services</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Differences-on-providing-data-transmission-services"><span class="toc-number">4.1.1.</span> <span class="toc-text">Differences on providing data transmission services</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Features-of-TCP"><span class="toc-number">4.1.2.</span> <span class="toc-text">Features of TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Differences-of-TCP-UDP"><span class="toc-number">4.1.3.</span> <span class="toc-text">Differences of TCP &amp; UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Multiplexing-and-demultiplexing"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 Multiplexing and demultiplexing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions-of-multiplexing-and-demultiplexing"><span class="toc-number">4.2.1.</span> <span class="toc-text">Functions of multiplexing and demultiplexing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Port-number-length-16-bits"><span class="toc-number">4.2.2.</span> <span class="toc-text">Port number (length-16 bits)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86-TCP-UDP-%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">使用了 TCP&#x2F;UDP 作为传输协议的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Connectionless-transport-UDP"><span class="toc-number">4.4.</span> <span class="toc-text">3.3 Connectionless transport: UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-format"><span class="toc-number">4.4.1.</span> <span class="toc-text">UDP format</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">4.4.2.</span> <span class="toc-text">UDP存在的原因：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Principles-of-reliable-data-transfer"><span class="toc-number">4.5.</span> <span class="toc-text">3.4 Principles of reliable data transfer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Principles-of-different-version-of-rdt-reliable-data-transfer-1-0%E3%80%812-0%E3%80%812-1%E3%80%812-2%E3%80%813-0"><span class="toc-number">4.5.1.</span> <span class="toc-text">Principles of different version of rdt reliable data transfer(1.0、2.0、2.1、2.2、3.0)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt1-0-reliable-transfer-over-a-reliable-channel"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">rdt1.0 reliable transfer over a reliable channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-0-channel-with-bit-errors"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">rdt2.0 channel with bit errors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1-%E5%A4%84%E7%90%86%E5%87%BA%E9%94%99%E7%9A%84ack%E5%92%8Cnak"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">rdt2.1 处理出错的ack和nak</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-2"><span class="toc-number">4.5.1.4.</span> <span class="toc-text">rdt2.2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0"><span class="toc-number">4.5.1.5.</span> <span class="toc-text">rdt3.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparisons-of-sliding-window-protocols-GBN-SR"><span class="toc-number">4.5.2.</span> <span class="toc-text">Comparisons of sliding window protocols (GBN &amp; SR)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-SlideWindow-%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">滑动窗口(SlideWindow)协议：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">4.6.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%9A"><span class="toc-number">4.6.1.</span> <span class="toc-text">TCP的标志位：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0"><span class="toc-number">4.6.2.</span> <span class="toc-text">重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.6.3.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%88%E5%B0%B1%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="toc-number">4.6.4.</span> <span class="toc-text">连接管理（就是三次握手）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-Congestion-Control"><span class="toc-number">4.7.</span> <span class="toc-text">TCP拥塞控制 Congestion Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Difference-between-flow-control-congestion-control"><span class="toc-number">4.7.1.</span> <span class="toc-text">Difference between flow control &amp; congestion control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%8B%A5%E5%A1%9E%EF%BC%9A"><span class="toc-number">4.7.2.</span> <span class="toc-text">如何判断是否拥塞：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%91%E9%80%81%E9%80%9F%E7%8E%87"><span class="toc-number">4.7.3.</span> <span class="toc-text">如何控制发送方发送速率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%EF%BC%9A"><span class="toc-number">4.7.4.</span> <span class="toc-text">联合控制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">4.7.5.</span> <span class="toc-text">控制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%90%84%E9%98%B6%E6%AE%B5%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">4.7.6.</span> <span class="toc-text">拥塞控制各阶段转换图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Slow-Start-%E2%80%93figure-3-53-transmission-round-CongWin"><span class="toc-number">4.7.7.</span> <span class="toc-text">TCP Slow Start –figure 3.53- transmission round&#x2F;CongWin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Services-of-Network-Layer"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 Services of Network-Layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Virtual-circuit-and-datagram-networks"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 Virtual circuit and datagram networks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-What%E2%80%99s-Inside-a-Router"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 What’s Inside a Router?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-IP-Internet-Protocol"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 IP: Internet Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Format-of-IPv4-datagram-header"><span class="toc-number">5.4.1.</span> <span class="toc-text">Format of IPv4 datagram (header)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CIDR-Classless-InterDomain-Routing-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%EF%BC%88%E4%B8%80%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">5.4.2.</span> <span class="toc-text">CIDR Classless InterDomain Routing 子网掩码（一种寻址方式）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP-Dynamic-Host-Configuration-Protocol"><span class="toc-number">5.4.3.</span> <span class="toc-text">DHCP Dynamic Host Configuration Protocol</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAT"><span class="toc-number">5.5.</span> <span class="toc-text">NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8NAT%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">5.5.1.</span> <span class="toc-text">使用NAT的原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">5.5.2.</span> <span class="toc-text">如何实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Outgoing-Datagram"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">Outgoing Datagram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Incoming-Datagram"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">Incoming Datagram</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP"><span class="toc-number">5.5.3.</span> <span class="toc-text">ICMP:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81ICMP"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">常见ICMP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-IP-Internet-Protocol-conti"><span class="toc-number">5.6.</span> <span class="toc-text">4.4 IP: Internet Protocol (conti-)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6-datagram-format"><span class="toc-number">5.6.1.</span> <span class="toc-text">IPv6 datagram format</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">地址：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6%E7%9B%B8%E5%AF%B9%E4%BA%8EIPv4%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%88IPv6%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="toc-number">5.6.2.</span> <span class="toc-text">IPv6相对于IPv4的变化（IPv6的优势）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Routing-algorithms"><span class="toc-number">5.7.</span> <span class="toc-text">4.5 Routing algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.1.</span> <span class="toc-text">两种路由器算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LS-Link-State%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.2.</span> <span class="toc-text">LS Link State算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1"><span class="toc-number">5.7.3.</span> <span class="toc-text">层次路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E7%AE%97%E6%B3%95-AS%E5%86%85%E9%83%A8%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.4.</span> <span class="toc-text">内部网关算法 AS内部算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP-Routing-Information-Protocol"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">RIP: Routing Information Protocol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF-Open-Shortest-Path-First"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">OSPF: Open Shortest Path First</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP"><span class="toc-number">5.7.4.3.</span> <span class="toc-text">BGP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.7.4.3.1.</span> <span class="toc-text">两个重要的路径属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%E4%BE%9D%E6%8D%AE"><span class="toc-number">5.7.5.</span> <span class="toc-text">BGP路径选择依据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-data-transmission-services"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 data transmission services</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">链路层的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Link-Layer-Services"><span class="toc-number">6.1.2.</span> <span class="toc-text">Link Layer Services</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CRC%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.</span> <span class="toc-text">CRC计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRC%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.1.</span> <span class="toc-text">CRC的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRC%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">CRC校验过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRC%E7%A4%BA%E4%BE%8B%EF%BC%88CRC-4%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">CRC示例（CRC-4）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.2.4.</span> <span class="toc-text">接收方校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Multiple-access-protocols"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 Multiple access protocols</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%A4%9A%E8%BF%9E%E6%8E%A5%E9%93%BE%E8%B7%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">两种多连接链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE-Multiple-Access-protocols"><span class="toc-number">6.3.2.</span> <span class="toc-text">多道访问协议 Multiple Access protocols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E-Collision"><span class="toc-number">6.3.3.</span> <span class="toc-text">碰撞 Collision</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#three-broad-classes%EF%BC%88MAC-%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">three broad classes（MAC 协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel-Partitioning-Multiplexing"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">Channel Partitioning&#x2F;Multiplexing:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random-Access"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">Random Access:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CD%E7%AE%97%E6%B3%95%E4%B9%9F%E7%94%A8%E5%9C%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%AD"><span class="toc-number">6.3.4.3.</span> <span class="toc-text">CSMA&#x2F;CD算法也用在以太网中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9CTaking-turns%E2%80%9D-Tokening-Ring"><span class="toc-number">6.3.4.4.</span> <span class="toc-text">“Taking turns”:Tokening Ring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-LAN-Local-Area-Network"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 LAN Local Area Network</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC-address"><span class="toc-number">6.4.1.</span> <span class="toc-text">MAC address</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%EF%BC%88Address-Resolution-Protocol%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">ARP（Address Resolution Protocol）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-Table"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">ARP Table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">ARP的工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E7%BC%93%E5%AD%98"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">ARP缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">6.4.2.4.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">6.4.2.5.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">6.4.3.</span> <span class="toc-text">以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ethernet-Frame"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">Ethernet Frame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0%E3%80%81%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">不可靠、无连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Switch"><span class="toc-number">6.5.</span> <span class="toc-text">Switch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hubs-%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="toc-number">6.5.1.</span> <span class="toc-text">Hubs 集线器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTP"><span class="toc-number">7.</span> <span class="toc-text">RTP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VLAN"><span class="toc-number">8.</span> <span class="toc-text">VLAN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IPv6"><span class="toc-number">9.</span> <span class="toc-text">IPv6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86"><span class="toc-number">10.</span> <span class="toc-text">零散知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3port"><span class="toc-number">10.1.</span> <span class="toc-text">一些指定的端口port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.2.</span> <span class="toc-text">带宽是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%BA%94%E7%94%A8%E5%AF%B9%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%81%E5%AE%BD%E5%B8%A6%E5%92%8C%E6%97%B6%E9%97%B4%E6%95%8F%E6%84%9F%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">10.3.</span> <span class="toc-text">各种应用对于数据丢失、宽带和时间敏感的要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="toc-number">10.4.</span> <span class="toc-text">MAC地址相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9F%90%E4%BA%9B%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">数据链路层某些协议的分类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%9A"><span class="toc-number">10.6.</span> <span class="toc-text">各层协议的头部：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">10.7.</span> <span class="toc-text">复用和解复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">10.8.</span> <span class="toc-text">电路交换和分组交换、数据报交换和虚电路交换的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E5%92%8C%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.8.1.</span> <span class="toc-text">分组交换和电路交换的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.9.</span> <span class="toc-text">互联网分层的两个重要原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87%EF%BC%9A%E5%BB%B6%E8%BF%9F%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">10.10.</span> <span class="toc-text">分组交换网络性能评估指标：延迟、丢包和吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D-v2"><span class="toc-number">10.10.1.</span> <span class="toc-text">对网络性能的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DHCP"><span class="toc-number">10.11.</span> <span class="toc-text">DHCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E7%A9%BA%E9%A2%98"><span class="toc-number">10.12.</span> <span class="toc-text">填空题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/" title="无标题"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/markdown%E8%AF%AD%E6%B3%95/" title="无标题">无标题</a><time datetime="2025-03-01T11:28:00.000Z" title="发表于 2025-03-01 19:28:00">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="力扣刷题"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣刷题"/></a><div class="content"><a class="title" href="/2025/03/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="力扣刷题">力扣刷题</a><time datetime="2025-03-01T03:35:47.301Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络学习笔记"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络学习笔记">计算机网络学习笔记</a><time datetime="2025-03-01T03:35:47.296Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="计算机组成原理学习笔记"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="计算机组成原理学习笔记">计算机组成原理学习笔记</a><time datetime="2025-03-01T03:35:47.295Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理学习笔记"><img src="/./img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译原理学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理学习笔记">编译原理学习笔记</a><time datetime="2025-03-01T03:35:47.294Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>