<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理复习笔记 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编译原理复习笔记 为什么要编译 电脑只能执行机器语言 但高级编程语言易于给人类进行编辑与开发 因而需要将人类易于阅读的高级编程语言转换成机器语言 这个转换的过程就是编译 什么是编译器 一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言 解释器 interpreter 另一种常见的语言处理器，不通过翻译的方式生成目标程序 编译器和解释器的异同 相同： 都是语言实现系统 不同：  编译">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理复习笔记">
<meta property="og:url" content="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="编译原理复习笔记 为什么要编译 电脑只能执行机器语言 但高级编程语言易于给人类进行编辑与开发 因而需要将人类易于阅读的高级编程语言转换成机器语言 这个转换的过程就是编译 什么是编译器 一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言 解释器 interpreter 另一种常见的语言处理器，不通过翻译的方式生成目标程序 编译器和解释器的异同 相同： 都是语言实现系统 不同：  编译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1.jpg">
<meta property="article:published_time" content="2025-03-01T03:35:47.263Z">
<meta property="article:modified_time" content="2025-03-18T13:06:34.079Z">
<meta property="article:author" content="moru">
<meta property="article:tag" content="期末复习">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "编译原理复习笔记",
  "url": "http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "http://example.com/img/1.jpg",
  "datePublished": "2025-03-01T03:35:47.263Z",
  "dateModified": "2025-03-18T13:06:34.079Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理复习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(./img/1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">编译原理复习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">编译原理复习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T03:35:47.263Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T13:06:34.079Z" title="更新于 2025-03-18 21:06:34">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="编译原理复习笔记"><a class="header-anchor" href="#编译原理复习笔记"></a>编译原理复习笔记</h1>
<h2 id="为什么要编译"><a class="header-anchor" href="#为什么要编译"></a>为什么要编译</h2>
<p>电脑只能执行机器语言</p>
<p>但高级编程语言易于给人类进行编辑与开发</p>
<p>因而需要将人类易于阅读的高级编程语言转换成机器语言</p>
<p>这个转换的过程就是编译</p>
<h2 id="什么是编译器"><a class="header-anchor" href="#什么是编译器"></a>什么是编译器</h2>
<p>一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言</p>
<h2 id="解释器-interpreter"><a class="header-anchor" href="#解释器-interpreter"></a>解释器 interpreter</h2>
<p>另一种常见的语言处理器，不通过翻译的方式生成目标程序</p>
<h2 id="编译器和解释器的异同"><a class="header-anchor" href="#编译器和解释器的异同"></a>编译器和解释器的异同</h2>
<h3 id="相同："><a class="header-anchor" href="#相同："></a>相同：</h3>
<p>都是语言实现系统</p>
<h3 id="不同："><a class="header-anchor" href="#不同："></a>不同：</h3>
<ol>
<li>编译器先翻译后执行，编译器做拓展性的预处理，大部分都是考编译器实现的</li>
<li>解释器边翻译边执行，解释器执行程序很少或没有预处理</li>
</ol>
<h3 id="JVM的原理："><a class="header-anchor" href="#JVM的原理："></a>JVM的原理：</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913059.png" alt="image-20240621080928578"></p>
<h2 id="语言处理系统全过程"><a class="header-anchor" href="#语言处理系统全过程"></a>语言处理系统全过程</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913271.png" alt="image-20240621075846648"></p>
<h2 id="编译器全过程"><a class="header-anchor" href="#编译器全过程"></a>编译器全过程</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913424.png" alt="image-20240621080342776"></p>
<h3 id="各板块及其功能"><a class="header-anchor" href="#各板块及其功能"></a>各板块及其功能</h3>
<ol>
<li>词法分析：识别描述逻辑块</li>
<li>语法分析：识别逻辑之间如何相互有关系</li>
<li>语义分析：识别整个结构的意义</li>
<li>中间代码生成：设计一个可能符合的结构</li>
<li>中间代码优化：简化生成的目的结构</li>
<li>代码生成：产生目的结构</li>
<li>机器相关代码优化：优化最终结构</li>
</ol>
<p>编译器中间的四大流程又与</p>
<ol>
<li>Literal table 语法表；</li>
<li>Symbol table 符号表；</li>
<li>Error handler 错误处理器</li>
</ol>
<h1 id="词法分析-Lexical-analysis"><a class="header-anchor" href="#词法分析-Lexical-analysis"></a>词法分析 Lexical analysis</h1>
<h2 id="词素"><a class="header-anchor" href="#词素"></a>词素</h2>
<p>我们从原始程序中创建token的那一部分称为词 lexeme 词素</p>
<h2 id="Token"><a class="header-anchor" href="#Token"></a>Token</h2>
<p>是从源代码中读取出来的逻辑条目</p>
<p>Token可以复制，即存储一些特殊信息</p>
<h2 id="词法分析器任务"><a class="header-anchor" href="#词法分析器任务"></a>词法分析器任务</h2>
<ol>
<li>读入的源代码的输入字符，将其组成词素，生成并输出一个token序列，每一个token对应着一个词素</li>
<li>一个token由：token名和可选的属性值组成</li>
</ol>
<p>每一个字符都经过扫描转换成一个token 词法单元，如一个标识符 int a ，会被记录为：&lt;id,entry&gt; id是identify的抽象符号，entry指的是 标识符a 对应的条目号码。</p>
<h2 id="正则表达式-Regular-Expression"><a class="header-anchor" href="#正则表达式-Regular-Expression"></a>正则表达式 Regular Expression</h2>
<p>用来捕获一类描述</p>
<p>具有可读性</p>
<h3 id="串的术语"><a class="header-anchor" href="#串的术语"></a>串的术语</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914870.png" alt="image-20240621101823881"></p>
<h3 id="复合正则表达式"><a class="header-anchor" href="#复合正则表达式"></a>复合正则表达式</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914915.png" alt="image-20240621101905529"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914177.png" alt="image-20240621102021241"></p>
<p>还有正闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">R^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>​，即至少有一个R</p>
<p>一个正则表达式的例子：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914276.png" alt="image-20240621102049198"></p>
<p>alphabet 字母表</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914663.png" alt="image-20240621103430822"></p>
<h2 id="有限状态机"><a class="header-anchor" href="#有限状态机"></a>有限状态机</h2>
<h3 id="实现正则表达式RE"><a class="header-anchor" href="#实现正则表达式RE"></a>实现正则表达式RE</h3>
<p>RE可以使用有限状态机FA进行表示</p>
<h3 id="NFA-非确定的有限状态机"><a class="header-anchor" href="#NFA-非确定的有限状态机"></a>NFA 非确定的有限状态机</h3>
<p>非确定性有限状态机中,每个输入符号可以有多个状态转换,这意味着在任何给定时间,NFA可以处以多种状态之一</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914236.png" alt="image-20240621110132100"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914509.png" alt="image-20240621110104122"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914403.png" alt="image-20240621110124293"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914377.png" alt="image-20240621110118970"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914552.png" alt="image-20240621110150891"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914204.png" alt="image-20240621110201703"></p>
<h3 id="扫描的二义性"><a class="header-anchor" href="#扫描的二义性"></a>扫描的二义性</h3>
<p>最长匹配的词素来解决二义性问题</p>
<ol>
<li>Convert expressions to NFAs. 将正则表达式转换为NFA</li>
<li>Run all NFAs in parallel, keeping track of the last match.<br>
所有的NFA都并行运行,保持最后match的轨迹</li>
<li>When all automata get stuck, report the last match and restart the<br>
search at that point.<br>
所以的自动机都发生堵塞,报告最后的match,然后从这一点重新开始</li>
</ol>
<p>有多条可以匹配上的规则：设置优先级。通过选择优先级更高的匹配来打破平局</p>
<p>没有可以匹配上的规则：设置一台用于报错的状态机，但是优先级设置为最低，有一个通用规则来处理错误。</p>
<ol>
<li>如何将词素和标记关联起来
<ol>
<li>标记定义</li>
<li>扫描输入</li>
</ol>
</li>
<li>有多条扫描路径，如何选择
<ol>
<li>最长匹配优先</li>
<li>设置优先级</li>
</ol>
</li>
</ol>
<h3 id="DFA-确定的有限状态机"><a class="header-anchor" href="#DFA-确定的有限状态机"></a>DFA 确定的有限状态机</h3>
<p>在确定性有限状态机中,每个输入符号都只有唯一的状态转换,这样就意味着DFA只能处于一种状态;</p>
<p>每个状态对于一个确定的输入只能转换到一个新的状态，不可能存在多个状态或多种转换transition</p>
<p>在DFA的存在周期当中只能有一个state存在。</p>
<p>空集转换是不合法的</p>
<p>DFA仅需要线性时间即可匹配一个长度为 m 的字符串 O(m)的复杂度</p>
<h3 id="子集构造法"><a class="header-anchor" href="#子集构造法"></a>子集构造法</h3>
<p>将NFA中一类状态对应成DFA中的一个状态</p>
<p>将NFA中一类状态到另一类状态的转换对应到DFA中两个转换间的转换——</p>
<p>用DFA的一个状态来表示通过单个字符输入从某个状态可以到达的其他状态的集合</p>
<p>一个DFA的状态代表NFA的一个状态集合,DFA的转化就是NFA的状态集合之间的转化</p>
<ol>
<li>通过空转换可到达的所有状态组成的集合为同一个DFA中的一个状态 ε-closure</li>
<li>通过一步从空状态 非空转换可到达的所有状态组成的集合为一个状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">xxx</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​</li>
</ol>
<h3 id="最小化算法"><a class="header-anchor" href="#最小化算法"></a>最小化算法</h3>
<ol>
<li>消除多余状态</li>
<li>合并等价状态</li>
</ol>
<h1 id="语法分析-Syntax-analysis-Parsing"><a class="header-anchor" href="#语法分析-Syntax-analysis-Parsing"></a>语法分析 Syntax analysis(Parsing)</h1>
<p>语法分析后，得到一系列token，需要解释这些token的含义</p>
<p>恢复token原本描述的句子结构——即语法；token无法组成符合语法的顺序结构时，报错</p>
<h2 id="Context-free-Grammar-CFG（上下文无关文法）"><a class="header-anchor" href="#Context-free-Grammar-CFG（上下文无关文法）"></a>Context-free Grammar CFG（上下文无关文法）</h2>
<p>将文法规则转换成可以用来解析代码的方法</p>
<p>分为两种分析方法：Top-down parsing 和 Bottom-up parsing</p>
<blockquote>
<p>正则表达式对于词法的分析是线性的；使用ParsingTree对语法进行分析是递归的</p>
</blockquote>
<p><strong>CF展示信息和进行结构构造的能力强于RE，同时RE表达能力较弱，无法进行记忆与回溯，因而无法对语法进行分析</strong></p>
<p>语法分析最终的输出是一颗语法树，语法分析的目的也是构造一颗显式或隐式的语法树，语法树中每个节点都包含编译过程中reminder需要的对象</p>
<p>树的递归式结构符合语法递归式的定义结构</p>
<p>一个文法在编译原理当中即可视为一系列产生式的结合</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914566.png" alt="image-20240622152759993"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914973.png" alt="image-20240622152814903"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914576.png" alt="image-20240622152928330"></p>
<h3 id="RE-和-CFG的对比"><a class="header-anchor" href="#RE-和-CFG的对比"></a>RE 和 CFG的对比</h3>
<p>CFG使用递归语句来实现RE中的闭包操作，即：<br>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915352.png" alt="image-20240622153128171"> 可以转换成右图： <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915897.png" alt="image-20240622153134704" style="zoom:50%;" /></p>
<p>CFG具有更广泛的表示形式</p>
<p>通过使用CFG进行推导即可知道token组成的句子符合文法，是否正确</p>
<p>句型 sentential form：既包含终结符又包含非终结符，即从开始符号 S 开始的</p>
<p>句子 sentence ：只包含终结符</p>
<ol>
<li>
<p>The root node is labeled with the start symbol S<br>
树的每一片叶子由空或者terminal进行标记</p>
</li>
<li>
<p>Each leaf node is labeled with a terminal or with ε<br>
每一个非叶子节点都代表一个非终结符</p>
</li>
<li>
<p>Each nonleaf node is labeled with a nonterminal</p>
</li>
<li>
<p>If a node with label A ∈ VN has n children with labels X1,X2,…,Xn<br>
(which may be terminals or nonterminals), then A → X1X2…Xn∈P</p>
</li>
</ol>
<p>一条推理derivation是由一系列产生式所得的句型 sentential forms：S ⇒ … ⇒ …</p>
<h3 id="最左推导-Leftmost-derivation"><a class="header-anchor" href="#最左推导-Leftmost-derivation"></a>最左推导 Leftmost derivation</h3>
<p>每一步中，最左的非终结符被置换推导，并进入到下一步中</p>
<p>分析树的先序遍历</p>
<h3 id="AST-Abstract-Syntax-Tree"><a class="header-anchor" href="#AST-Abstract-Syntax-Tree"></a>AST Abstract Syntax Tree</h3>
<p>将生成的Parsing Tree转换成AST</p>
<p>将分析树简化成抽象语法树，最终也只是将抽象语法树作为输入传递到下一个阶段当中</p>
<h2 id="二义性问题-Ambiguity"><a class="header-anchor" href="#二义性问题-Ambiguity"></a>二义性问题 Ambiguity</h2>
<p>同一个串出现了两颗语法树，即存在两种可匹配该句子的语法</p>
<p>正常来说，不同的推导过程最后会得到相同的语法树和抽象语法树</p>
<p>但是有些语法：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915767.png" alt="image-20240623010419663"> 会导致因为推导顺序的不同而出现不同的语法树</p>
<p>STring=“i-i*i”</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915421.png" alt="image-20240623010445883"></p>
<p>int - int - int</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915310.png" alt="image-20240623010914178"></p>
<h3 id="两种处理二义性的方法"><a class="header-anchor" href="#两种处理二义性的方法"></a>两种处理二义性的方法</h3>
<h4 id="添加规则Rule"><a class="header-anchor" href="#添加规则Rule"></a>添加规则Rule</h4>
<ol>
<li>添加优先级</li>
<li>左联系</li>
</ol>
<h4 id="重写文法"><a class="header-anchor" href="#重写文法"></a>重写文法</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915804.png" alt="image-20240623011243650"></p>
<p>左结合和右结合</p>
<ol>
<li>左结合</li>
</ol>
<h2 id="什么是预测性分析"><a class="header-anchor" href="#什么是预测性分析"></a>什么是预测性分析</h2>
<p>基于剩余的input，预测可能被使用的产生式</p>
<h3 id="两种预测性分析的方法"><a class="header-anchor" href="#两种预测性分析的方法"></a>两种预测性分析的方法</h3>
<p>一种递归向下分析</p>
<p>一种向前看一步 Look-ahead one token</p>
<h1 id="自顶向下"><a class="header-anchor" href="#自顶向下"></a>自顶向下</h1>
<h2 id="LL-1-文法-First和Follow-set"><a class="header-anchor" href="#LL-1-文法-First和Follow-set"></a>LL(1)文法 First和Follow set</h2>
<h3 id="First-set"><a class="header-anchor" href="#First-set"></a>First set</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915539.png" alt="image-20240623015518332"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915340.png" alt="image-20240623100137169"></p>
<h3 id="Follow-Set"><a class="header-anchor" href="#Follow-Set"></a>Follow Set</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915059.png" alt="image-20240623015531401"></p>
<h3 id="判断一个文法是否符合LL-1-文法"><a class="header-anchor" href="#判断一个文法是否符合LL-1-文法"></a>判断一个文法是否符合LL(1)文法</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915102.png" alt="image-20240623101056096"></p>
<p>有左公因子或左递归一定不是</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915482.png" alt="image-20240623105054041"></p>
<h2 id="递归向下分析"><a class="header-anchor" href="#递归向下分析"></a>递归向下分析</h2>
<h2 id="LL-1-分析（非递归分析）"><a class="header-anchor" href="#LL-1-分析（非递归分析）"></a>LL(1)分析（非递归分析）</h2>
<h2 id="分析表"><a class="header-anchor" href="#分析表"></a>分析表</h2>
<h1 id="自底向上"><a class="header-anchor" href="#自底向上"></a>自底向上</h1>
<p>规约/化简都是从左侧区域的最右边开始的</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915752.png" alt="image-20240623160909316"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915154.png" alt="image-20240623160948167"></p>
<p>所有的规约动作都只发生在左区域的最右部分</p>
<p>将分析栈中部分符号弹出匹配，并重新压入正确的非终结符，即将右部倒推回左部</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915305.png" alt="image-20240623161416454"></p>
<p>大多数时候查看栈顶无法满足规约需求，可能pop出更深的位置去进行规约</p>
<h2 id="LR分析器"><a class="header-anchor" href="#LR分析器"></a>LR分析器</h2>
<h3 id="寻找handle"><a class="header-anchor" href="#寻找handle"></a>寻找handle</h3>
<p>LR解析器维护状态（Sm）来跟踪我们在解析中的位置。状态总结了下面堆栈中包含的信息</p>
<p>存储“$S0X1S1……XmSm”，其中Xi是一个语法符号，而Si是一个状态。在每次推送一个符号后，新的状态号都会被推到解析堆栈中</p>
<h3 id="LR功能较弱的原因"><a class="header-anchor" href="#LR功能较弱的原因"></a>LR功能较弱的原因</h3>
<ol>
<li>LR (0)只接受没有正确上下文的语言</li>
<li>我们的移位/减少解析器只看句柄的左边，而不是向右边</li>
<li></li>
</ol>
<h2 id="SLR-1"><a class="header-anchor" href="#SLR-1"></a>SLR(1)</h2>
<h1 id="语义分析-Semantic-analysis"><a class="header-anchor" href="#语义分析-Semantic-analysis"></a>语义分析 Semantic analysis</h1>
<p>静态语义</p>
<p>动态语义</p>
<p>属性文法</p>
<p>语法自导翻译 SDD Syntax Directed Definitions</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915068.png" alt="image-20240623200808980"></p>
<h2 id="综合属性和继承属性"><a class="header-anchor" href="#综合属性和继承属性"></a>综合属性和继承属性</h2>
<h3 id="综合属性的判断："><a class="header-anchor" href="#综合属性的判断："></a>综合属性的判断：</h3>
<p>非终结符可以有综合属性和继承属性，</p>
<p>文法开始符S没有继承属性</p>
<p>终结符只有综合属性，由词法程序提供</p>
<p>S属性文法是只含有综合属性的属性文法</p>
<p>一个属性文法称之为、L-属性文法，</p>
<p>如果属性来自于产生式的左部的，</p>
<p>且该属性的值是由右部的属性或其它属性的确定的，就是综合属性</p>
<h3 id="继承属性的判断"><a class="header-anchor" href="#继承属性的判断"></a>继承属性的判断</h3>
<p>如果属性来自于产生式的右部的</p>
<p>且由左边属性或右边属性任意文法符号确定（包括自己）</p>
<h2 id="综合属性和继承属性的计算：向上综合，向下继承"><a class="header-anchor" href="#综合属性和继承属性的计算：向上综合，向下继承"></a>综合属性和继承属性的计算：向上综合，向下继承</h2>
<h3 id="计算顺序："><a class="header-anchor" href="#计算顺序："></a>计算顺序：</h3>
<ol>
<li>先放上终结符的数值</li>
<li>综合：再自底向上地传递综合属性的值</li>
<li>继承：兄弟和父亲节点的继承属性一步步向下传递值</li>
</ol>
<h3 id="阐述语义功能"><a class="header-anchor" href="#阐述语义功能"></a>阐述语义功能</h3>
<p>观察每一个属性文法的公式，看看其把什么转化成了什么，最终是否有输出</p>
<h1 id="中间代码生成-Intermediate-code-generation"><a class="header-anchor" href="#中间代码生成-Intermediate-code-generation"></a>中间代码生成 Intermediate code generation</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></div><div class="post-share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络复习笔记"><img class="cover" src="/./img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机网络复习笔记</div></div><div class="info-2"><div class="info-item-1">计算机网络 引言 1.2 Network edge several type of access networks  residential access nets 住宅接入网 institutional access networks (school, company) 机构接入网 wireless access networks 无线接入网 bandwidth bit per second 带宽 bps  Physical media: twisted pair  Twisted copper wire / Twisted pair 双绞铜线 coax/coaxial cable 同轴电缆 fiber optic 光纤 radio 无线电  1.3 network core Difference of performance between Packet-switching &amp; circuit switching  分组交换不适合实时服务，端到端的时延是可变和不可预测的 分组交换有着比电路交换更好的网络共享； 比电路交换更简单、有效，实现成本更低；  1.4...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="离散数学复习笔记"><img class="cover" src="/./img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">离散数学复习笔记</div></div><div class="info-2"><div class="info-item-1">离散数学 逻辑和证明 1. 命题逻辑 proposition 命题 prop 逻辑关系: 1.否定、合取、析取、条件、双条件（同或）、异或、条件否定、与非、或非 条件语句 implication 蕴含 implies $P \rightarrow Q \Leftrightarrow \neg P \or Q $ 2. 命题的等价 2.1 Tautology and Contradiction 2.2 常见的等价语句 Identity：$p \and T \Leftrightarrow p $ Domination： 9.Relations 自反性：关系矩阵的主对角线上元素全部为1 反自反：关系矩阵的主对角线上元素全部为0 对称性：关系矩阵关于主对角线对称 反对称：关系矩阵关于主对角线不对称或者非主对角线上元素全部为0 传递性：这个得用矩阵的乘法，很难直接看出来   9.3 Representing Relations 集合 A = { a , b , c , d } 关系 R = { &lt; a , b &gt; , &lt; b , a &gt; , &lt; b , c...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/UML%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="uml复习笔记"><img class="cover" src="/./img/3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">uml复习笔记</div></div><div class="info-2"><div class="info-item-1">UML期末复习 复习重点： 考试题型：   ·选择题 十个题目 一个三分 总共三十分      名词解释 五题，一题两分，总共十分 建议英文作答  OOD OOP    简答题 两题 共十五分   建模题 两个题目 十五分   定义一些类，画一个类图   定义一个用例，写出用例文本   例子 重点了解：  ATM机 银行业务 火车订票    用例图的基本元素有4种：用例、参与者、关系和系统边界。   用例描述：          综合分析设计题 四个小题目 总共三十分   例子：  智能家居 汽车租赁 dd车    第一题：用例模型，用例文本；领域模型（不写方法）   第二题：   第三题：   第四题：采用某一种模式，对状态图或类图做一个设计的修正     考点： 名词解释和简答 设计模式 patern：是一套被已命名的、多数人知晓的、经过验证的经验总结而出的软件开发模式。设计模式提供了一种通用的设计方案，帮助开发者在面对常见的设计问题时，能够快速找到合适的解决办法。视频7.39 什么是uml：UML（Unified Modeling...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="离散数学复习笔记"><img class="cover" src="/./img/4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">离散数学复习笔记</div></div><div class="info-2"><div class="info-item-1">离散数学 逻辑和证明 1. 命题逻辑 proposition 命题 prop 逻辑关系: 1.否定、合取、析取、条件、双条件（同或）、异或、条件否定、与非、或非 条件语句 implication 蕴含 implies $P \rightarrow Q \Leftrightarrow \neg P \or Q $ 2. 命题的等价 2.1 Tautology and Contradiction 2.2 常见的等价语句 Identity：$p \and T \Leftrightarrow p $ Domination： 9.Relations 自反性：关系矩阵的主对角线上元素全部为1 反自反：关系矩阵的主对角线上元素全部为0 对称性：关系矩阵关于主对角线对称 反对称：关系矩阵关于主对角线不对称或者非主对角线上元素全部为0 传递性：这个得用矩阵的乘法，很难直接看出来   9.3 Representing Relations 集合 A = { a , b , c , d } 关系 R = { &lt; a , b &gt; , &lt; b , a &gt; , &lt; b , c...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="操作系统复习笔记"><img class="cover" src="/./img/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">操作系统复习笔记</div></div><div class="info-2"><div class="info-item-1">操作系统突击复习 Introduction 早期引入批处理系统通过减少人工操作的时间，以提高处理效率 进程 Process Definition 进程的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次活动 当进程被创建时，会给予进程一个不重复的独一无二的PID。 与进程相关的信息使用一种数据结构PCB(Process Control Block)当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的PCB，当进程结束时再回收其PCB。 Process 和 Program 的不同 程序 (Program):  是一系列集合指令，是一个静态概念； 永久存在，直到被删除； 一个程序可以被多个进程执行。  进程 (Process):   描述并发、动态的概念；   进程包括程序、数据和进程控制块 (PCB)；   是暂时的，会随进程的终止而消失；   进程可以创建其他进程；   进程可以调用多个程序。   进程是CPU调度的基本单位   Process States  三种基本状态：  运行 running state 就绪 ready state 阻塞...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title=""><img class="cover" src="/./img/5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">数据库期末复习 CH1 DBMS 相关数据的集合 访问数据的程序集 方便高效的使用环境 文件系统来存储数据的缺点：  数据冗余和不一致性  多种文件格式：即同一个文件夹内存在多种存储数据的文件格式，其中存储的数据信息可能都相同只是因为文件格式不同导致了冗余 复制不同文件中的信息：不同文件之间进行数据查拷贝时，容易出现数据不一致的现象   访问数据困难  需要编写一个新的程序来执行每一个新的任务：文件系统对于用户来说缺乏一个统一的接口来进行数据的访问和操作。   数据隔离————多种文件和格式 完整性问题  完整性约束（例如，帐户余额&gt; 0）被“隐藏”在程序代码中，而不是被显式地声明 很难添加新的约束条件或更改现有的约束条件   更新的原子性  失败可能会使数据库处于不一致的状态，并执行了部分更新   由多个用户的并发访问  执行性能所需的并发访问权限 不受控制的并发访问可能会导致不一致   安全问题  难以限制用户对数据的访问范围    抽象层级 Abstraction Levels  Physical...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">编译原理复习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.</span> <span class="toc-text">为什么要编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">什么是编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8-interpreter"><span class="toc-number">1.3.</span> <span class="toc-text">解释器 interpreter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.4.</span> <span class="toc-text">编译器和解释器的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">相同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">不同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">JVM的原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">语言处理系统全过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">编译器全过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E6%9D%BF%E5%9D%97%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">各板块及其功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-Lexical-analysis"><span class="toc-number">2.</span> <span class="toc-text">词法分析 Lexical analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">词素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Token"><span class="toc-number">2.2.</span> <span class="toc-text">Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">词法分析器任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-Regular-Expression"><span class="toc-number">2.4.</span> <span class="toc-text">正则表达式 Regular Expression</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.4.1.</span> <span class="toc-text">串的术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">复合正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRE"><span class="toc-number">2.5.1.</span> <span class="toc-text">实现正则表达式RE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFA-%E9%9D%9E%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.5.2.</span> <span class="toc-text">NFA 非确定的有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">2.5.3.</span> <span class="toc-text">扫描的二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFA-%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.5.4.</span> <span class="toc-text">DFA 确定的有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E6%9E%84%E9%80%A0%E6%B3%95"><span class="toc-number">2.5.5.</span> <span class="toc-text">子集构造法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.6.</span> <span class="toc-text">最小化算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-analysis-Parsing"><span class="toc-number">3.</span> <span class="toc-text">语法分析 Syntax analysis(Parsing)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-free-Grammar-CFG%EF%BC%88%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">Context-free Grammar CFG（上下文无关文法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RE-%E5%92%8C-CFG%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.1.</span> <span class="toc-text">RE 和 CFG的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BC-Leftmost-derivation"><span class="toc-number">3.1.2.</span> <span class="toc-text">最左推导 Leftmost derivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AST-Abstract-Syntax-Tree"><span class="toc-number">3.1.3.</span> <span class="toc-text">AST Abstract Syntax Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98-Ambiguity"><span class="toc-number">3.2.</span> <span class="toc-text">二义性问题 Ambiguity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">两种处理二义性的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%A7%84%E5%88%99Rule"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">添加规则Rule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%96%87%E6%B3%95"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">重写文法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E6%B5%8B%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">什么是预测性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%A2%84%E6%B5%8B%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">两种预测性分析的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="toc-number">4.</span> <span class="toc-text">自顶向下</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95-First%E5%92%8CFollow-set"><span class="toc-number">4.1.</span> <span class="toc-text">LL(1)文法 First和Follow set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-set"><span class="toc-number">4.1.1.</span> <span class="toc-text">First set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Follow-Set"><span class="toc-number">4.1.2.</span> <span class="toc-text">Follow Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%96%87%E6%B3%95%E6%98%AF%E5%90%A6%E7%AC%A6%E5%90%88LL-1-%E6%96%87%E6%B3%95"><span class="toc-number">4.1.3.</span> <span class="toc-text">判断一个文法是否符合LL(1)文法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">递归向下分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">LL(1)分析（非递归分析）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">分析表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">5.</span> <span class="toc-text">自底向上</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">LR分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEhandle"><span class="toc-number">5.1.1.</span> <span class="toc-text">寻找handle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E5%8A%9F%E8%83%BD%E8%BE%83%E5%BC%B1%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.2.</span> <span class="toc-text">LR功能较弱的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLR-1"><span class="toc-number">5.2.</span> <span class="toc-text">SLR(1)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-Semantic-analysis"><span class="toc-number">6.</span> <span class="toc-text">语义分析 Semantic analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">综合属性和继承属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">综合属性的判断：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">6.1.2.</span> <span class="toc-text">继承属性的判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%9A%E5%90%91%E4%B8%8A%E7%BB%BC%E5%90%88%EF%BC%8C%E5%90%91%E4%B8%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">综合属性和继承属性的计算：向上综合，向下继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">6.2.1.</span> <span class="toc-text">计算顺序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%90%E8%BF%B0%E8%AF%AD%E4%B9%89%E5%8A%9F%E8%83%BD"><span class="toc-number">6.2.2.</span> <span class="toc-text">阐述语义功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Intermediate-code-generation"><span class="toc-number">7.</span> <span class="toc-text">中间代码生成 Intermediate code generation</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/24/%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" title="面试鸭项目开发手册"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试鸭项目开发手册"/></a><div class="content"><a class="title" href="/2025/03/24/%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" title="面试鸭项目开发手册">面试鸭项目开发手册</a><time datetime="2025-03-24T08:04:27.000Z" title="发表于 2025-03-24 16:04:27">2025-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/23/Java%E5%9F%BA%E7%A1%80/javaweb/" title="javaweb"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaweb"/></a><div class="content"><a class="title" href="/2025/03/23/Java%E5%9F%BA%E7%A1%80/javaweb/" title="javaweb">javaweb</a><time datetime="2025-03-23T13:31:31.000Z" title="发表于 2025-03-23 21:31:31">2025-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/23/Spring/SpringMVC/" title="SpringMVC"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"/></a><div class="content"><a class="title" href="/2025/03/23/Spring/SpringMVC/" title="SpringMVC">SpringMVC</a><time datetime="2025-03-23T12:13:56.000Z" title="发表于 2025-03-23 20:13:56">2025-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/23/%E6%8F%92%E4%BB%B6/hutool%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/" title="hutool使用经验"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hutool使用经验"/></a><div class="content"><a class="title" href="/2025/03/23/%E6%8F%92%E4%BB%B6/hutool%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/" title="hutool使用经验">hutool使用经验</a><time datetime="2025-03-23T07:31:59.000Z" title="发表于 2025-03-23 15:31:59">2025-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/Sa-token/" title="Sa-token"><img src="/./img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Sa-token"/></a><div class="content"><a class="title" href="/2025/03/23/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/Sa-token/" title="Sa-token">Sa-token</a><time datetime="2025-03-23T04:38:16.000Z" title="发表于 2025-03-23 12:38:16">2025-03-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>