<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络学习笔记 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络 计算机网络与因特网  ——本章task：  介绍基本术语和概念  构成网络的基本硬件和软件组成：  从网络边缘——网络中运行的端系统和网络应用； 再到网络核心——传输数据的链路和交换机以及将端系统与网络核心相连接的接入网和物理媒体。     计算机网络中数据的时延、丢包和吞吐量 端到端吞吐量和时延的定量模型：  模型兼顾了传输、传播和排队时延等因素   体系结构原则：  协议分层和服务">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络学习笔记">
<meta property="og:url" content="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="计算机网络 计算机网络与因特网  ——本章task：  介绍基本术语和概念  构成网络的基本硬件和软件组成：  从网络边缘——网络中运行的端系统和网络应用； 再到网络核心——传输数据的链路和交换机以及将端系统与网络核心相连接的接入网和物理媒体。     计算机网络中数据的时延、丢包和吞吐量 端到端吞吐量和时延的定量模型：  模型兼顾了传输、传播和排队时延等因素   体系结构原则：  协议分层和服务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/4.jpg">
<meta property="article:published_time" content="2025-03-01T03:35:47.296Z">
<meta property="article:modified_time" content="2025-03-18T13:06:04.665Z">
<meta property="article:author" content="moru">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/4.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络学习笔记",
  "url": "http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
  "image": "http://example.com/img/4.jpg",
  "datePublished": "2025-03-01T03:35:47.296Z",
  "dateModified": "2025-03-18T13:06:04.665Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(./img/4.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T03:35:47.296Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T13:06:04.665Z" title="更新于 2025-03-18 21:06:04">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">19k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h1>
<h2 id="计算机网络与因特网"><a class="header-anchor" href="#计算机网络与因特网"></a>计算机网络与因特网</h2>
<blockquote>
<p>——本章<strong>task</strong>：</p>
<ol>
<li>介绍基本术语和概念
<ul>
<li>构成网络的基本硬件和软件组成：
<ul>
<li>从网络边缘——网络中运行的端系统和网络应用；</li>
<li>再到网络核心——传输数据的链路和交换机以及将端系统与网络核心相连接的接入网和物理媒体。</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络中数据的时延、丢包和吞吐量</li>
<li>端到端吞吐量和时延的定量模型：
<ul>
<li>模型兼顾了传输、传播和排队时延等因素</li>
</ul>
</li>
<li>体系结构原则：
<ul>
<li>协议分层和服务模型</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="计网概念简述"><a class="header-anchor" href="#计网概念简述"></a>计网概念简述</h3>
<h4 id="概念"><a class="header-anchor" href="#概念"></a>概念</h4>
<blockquote>
<ol>
<li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过<strong>通信设备和线路</strong>连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li>
<li>本质即是由若干个节点和连接这些节点的链路组成的一张网</li>
</ol>
</blockquote>
<h3 id="计网的结构组成"><a class="header-anchor" href="#计网的结构组成"></a>计网的结构组成</h3>
<blockquote>
<p>——由三大要素组成：<strong>硬件</strong>、<strong>软件</strong> 、<strong>协议</strong>&lt;一系列规则和约定的集合&gt;</p>
</blockquote>
<h4 id="物理硬件进度来看结构："><a class="header-anchor" href="#物理硬件进度来看结构："></a>物理硬件进度来看结构：</h4>
<ul>
<li>
<p>节点分为两类节点</p>
<ol>
<li><strong>主机节点</strong></li>
<li><strong>数据交换节点</strong>（数据传输过程中间过渡连接两个端的节点）：
<ol>
<li>例如：路由器（工作在网络层）Router；交换机（工作在链路层）Switch</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>端系统/端系统</strong>：与因特网相连的计算机或其他联网的设备</p>
<ul>
<li>端系统通过**通信链路(communication link)<strong>和</strong>分组交换机(packet switch)**进行链接；</li>
<li>host == end system</li>
</ul>
</li>
<li>
<p><strong>分组交换机 packet switches：</strong> 转发数据报</p>
<ul>
<li><strong>分组</strong>：当一台端系统向另一条端系统发送数据时，发送端会将数据分段，并未每一段加上首部字节，由此形成的<strong>信息包</strong>称之为<strong>分组</strong>；</li>
<li>路由器 router 作用于网络 通常用于网络核心中进行数据的转发</li>
<li>交换机 switch 作用于链路层 通常用于接入网将主机的数据转发到路由器</li>
<li><strong>路径 route&amp;path</strong>：从发送端到接收端，一个分组所走过的一系列通信链路和分组交换机</li>
</ul>
</li>
<li>
<p><strong>通信链路 links：</strong></p>
<ul>
<li>光纤 fiber，铜缆 copper，无线电 radio，卫星 satellite</li>
<li>trabsmission rate bandwidth 传输速率：带宽</li>
</ul>
</li>
<li>
<p><strong>网络 network</strong></p>
<ul>
<li>以上设备相互组合的集合</li>
</ul>
</li>
</ul>
<h4 id="功能角度来看结构："><a class="header-anchor" href="#功能角度来看结构："></a>功能角度来看结构：</h4>
<ul>
<li>
<p><strong>网络边缘 Network Edge：</strong></p>
<ul>
<li>主机和主机当中的应用</li>
<li>端系统与网络间的接口</li>
</ul>
</li>
<li>
<p><strong>接入网 Access Network：</strong></p>
<blockquote>
<p>将端系统物理连接到 <strong>边缘路由器 edge router</strong>的网络</p>
</blockquote>
<ul>
<li><strong>因特网服务提供商 Internet Service Provider,ISP</strong>：端系统通过ISP接入因特网
<ul>
<li>ISP包括：本地电缆、电话公司提供的住宅区ISP、公司ISP、大学ISP……</li>
</ul>
</li>
<li><strong>Residential access nets(家庭接入网)</strong> 基于电缆接入</li>
<li><strong>mobile access networks (WiFi, 4G/5G)(移动接入网络)</strong>
<ul>
<li>无线局域网</li>
<li>广域蜂窝接入网</li>
</ul>
</li>
<li><strong>institutional access networks(机构介入网络)</strong>
<ul>
<li>混合使用有线、无线链路技术，连接混合的交换机和路由器</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络核心 NetWork Core：</strong></p>
<ul>
<li>由高速路由器和交换机组成。</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="网络协议"><a class="header-anchor" href="#网络协议"></a>网络协议</h4>
<blockquote>
<p>——掌握计算机网络领域知识的过程就是理解网络协议的构成 、原理和工 作方式的过程 。</p>
</blockquote>
<ul>
<li>
<p><strong>网络协议</strong>：端系统、分组交换机和其他可接入因特网的部件都遵循一系列预先<strong>规定好的规则</strong>，这些规则被称之为协议。协议控制因特网当中信息的接收和发送。</p>
<ul>
<li>**TCP(Transmission Control Protocol，传输控制协议)<strong>和</strong>IP(Internel Protocol，网络协议)**是因特网中最为重要的两个协议。
<ul>
<li><strong>IP协议</strong>定义了在路由器和端系统之间发送和接收的<strong>分组格式</strong>。</li>
</ul>
</li>
<li><strong>功能</strong>：
<ul>
<li>定义了在两个或多个通信实体间交换的报文的格式和顺序，以及报文发送&amp;接收一条报文或其他事件所采取的动作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应用TCP的app：</p>
<ul>
<li>HTTP Web 网页数据报文传输</li>
<li>FTP file transfer 文件传输</li>
<li>Telnet——remote login 远程登录,</li>
<li>SMTP—— email</li>
</ul>
</li>
<li>
<p>应用UDP的app：流媒体 streaming media，teleconferencing 电话会议，DNS，Internet telephony 网络电话。</p>
</li>
</ul>
<h4 id="网络实体"><a class="header-anchor" href="#网络实体"></a>网络实体</h4>
<h5 id="定义："><a class="header-anchor" href="#定义："></a>定义：</h5>
<ul>
<li>参与网络通信的任何设备或程序。这可以包括服务器、客户端、路由器、交换机、防火墙等硬件设备，也可以包括浏览器、邮件客户端、FTP客户端等软件程序。每个网络实体都有一个或多个网络接口，用于发送和接收数据。</li>
</ul>
<h5 id="对等层次的实体"><a class="header-anchor" href="#对等层次的实体"></a>对等层次的实体</h5>
<ul>
<li>在网络模型的同一层次中，执行相同功能的两个网络实体。这些实体可以在不同的计算机上，通过网络进行通信。</li>
<li>&quot;对等&quot;只是指这两个实体在网络模型中处于同一层次，并执行相同的功能。</li>
</ul>
<h3 id="网络边缘"><a class="header-anchor" href="#网络边缘"></a>网络边缘</h3>
<blockquote>
<p>更深入了解计算机网络的部件</p>
</blockquote>
<p>通过ISP接入互联网，</p>
<h4 id="边缘部分"><a class="header-anchor" href="#边缘部分"></a>边缘部分</h4>
<blockquote>
<p>主机host和端系统————一个概念<br>
边缘部分包括：端系统和接入网<br>
在C/S体系中，主机进一步划分为<strong>client</strong>和<strong>server</strong>。</p>
</blockquote>
<ul>
<li>
<p><strong>边缘部分</strong>：用户直接使用</p>
<blockquote>
<p>端系统之间的通信强调的是两个端系统当着正在执行的进程之间的通信</p>
</blockquote>
<ul>
<li><strong>C/S方式（Client/Server）&amp; B/S方式（Browser/Server）</strong></li>
<li>**P2P方式（peer To peer）**主机数量越多，下载速度越快（一份资源拥有的人越多，则下载速度越快，因为可以同时从多个主机处下载同一份资源，多线程下载？）</li>
</ul>
</li>
<li>
<p><strong>接入网</strong>：将端系统物理连接到<strong>边缘路由器 edge router</strong>的网络</p>
<ul>
<li>
<p>Residential accsee 家庭接入：点对点接入</p>
<p>家庭利用分配器将数据信号和电话信号分开</p>
<p>电话公司利用DSLAM把数据和电话信号分开，并将数据送往因特网</p>
<ul>
<li>DSL 数字用户线 常用：</li>
<li>Dialup via modem 通过调解器进行拨号</li>
<li>电缆 常用</li>
<li>HFC hybrid Fiber coax 混合光纤同轴</li>
<li>FTTH</li>
<li>拨号和卫星</li>
</ul>
</li>
<li>
<p>企业&amp;家庭接入：以太网&amp;WIFI</p>
</li>
<li>
<p>广域无线接入：3G和LTE</p>
</li>
</ul>
</li>
<li>
<p><strong>物理媒体</strong>：</p>
<blockquote>
<p>所有无线网的根基都是有线网</p>
</blockquote>
<ul>
<li>导引型：光缆/光纤、双绞铜线、同轴电缆</li>
<li>非导引型：电波、陆地无线电信道、卫星无线电信道</li>
</ul>
</li>
</ul>
<h3 id="网络核心"><a class="header-anchor" href="#网络核心"></a>网络核心</h3>
<p>核心部分为边缘部分服务</p>
<h4 id="分组交换"><a class="header-anchor" href="#分组交换"></a>分组交换</h4>
<ul>
<li>
<p><strong>分组 packet</strong>：源主机将长报文划分为小的数据块</p>
</li>
<li>
<p>端系统彼此交换<strong>报文 message</strong>，分组 packet在源和目的地之间通过<strong>通信链路</strong>和<strong>分组交换机 packet-switch</strong>传输和转发报文。</p>
<ul>
<li>解释：在应用层，端和端之间交流的信息单位是报文message，但是具体进入到下面层次时，需要将报文（太长了，无法一次传输完）依照预先设定好的格式划分若干的小报文，这种小报文的名称就是分组，将这种分组向下层结构传递再经过一系列链路和交换机传输到目的主机，以达成信息交互的目的。</li>
</ul>
</li>
<li>
<p><strong>存储转发传输 store-and-forward transmission</strong>：多数分组交换机在链路输入端使用。指的是在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p>
<p>假设有一个简单网络：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241804.png" alt="image-20240605162345495"></p>
<p>源主机通过链路传输分组到路由器，假设发送方发送一个大小我 L bits 的分组，链路传输速率为 R bits/s，则传输该分组的时间为：传输时延 L/R s</p>
<ul>
<li>假设分组1的前沿先到达路由器，路由器采用存储转发机制</li>
<li>此时路由器会先缓存分组1的前沿比特</li>
<li>等待分组1的所有比特都达到路由器时，才会开始向出链路传输分组1</li>
</ul>
</li>
</ul>
<h4 id="功能组成："><a class="header-anchor" href="#功能组成："></a>功能组成：</h4>
<ul>
<li>
<p>通信子网：实现<strong>数据通信</strong>。</p>
</li>
<li>
<p>资源子网：实现<strong>资源共享</strong>/数据处理。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	subgraph 子网</span><br><span class="line">	direction TB</span><br><span class="line">	str1[&quot;资源子网\n(实现资源共享功能的设备和软件的集合)&quot;]</span><br><span class="line">	str6[&quot;通信子网\n(各种传输介质,通信设备,相应的网络协议组成)&quot;]</span><br><span class="line">	end</span><br><span class="line">	subgraph OSI七层结构</span><br><span class="line">	str2[&quot;应用层&quot;]</span><br><span class="line">	str3[&quot;表示层&quot;]</span><br><span class="line">	str4[&quot;会话层&quot;]</span><br><span class="line">	str5[&quot;传输层&quot;]</span><br><span class="line">	str7[&quot;网络层\n如:路由器&quot;]</span><br><span class="line">	str8[&quot;数据链路层\n(如:交换机,网桥)&quot;]</span><br><span class="line">	str9[&quot;物理层\n(如:集线器,中继器)&quot;]</span><br><span class="line">	end</span><br><span class="line">	str1 --&gt; str2 &amp; str3 &amp; str4 </span><br><span class="line">	str6 --&gt; str7 &amp; str8 &amp; str9</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="功能"><a class="header-anchor" href="#功能"></a>功能</h4>
<ul>
<li><strong>数据通信</strong></li>
<li><strong>资源共享</strong></li>
<li><strong>分布式处理</strong>：
<ul>
<li>多台设备各自承担同一任务的不同部分</li>
<li>使用备用机来顶替出故障的设备，提高安全性和可靠性</li>
</ul>
</li>
</ul>
<h4 id="分类"><a class="header-anchor" href="#分类"></a>分类</h4>
<ul>
<li>
<p><strong>分布范围</strong>：是按照使用技术进行区分而不是按照实际物理距离进行区分</p>
<ul>
<li><strong>广域网(WAN)</strong>;</li>
<li>城域网(MAN);</li>
<li><strong>局域网(LAN)</strong>;</li>
<li>个人区域网(PAN)</li>
</ul>
</li>
<li>
<p><strong>使用者</strong>：</p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li>
<p><strong>交换技术</strong>：</p>
<ul>
<li>电路交换，如：打电话</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li>
<p>拓扑结构：</p>
<ul>
<li>
<p>总线型</p>
</li>
<li>
<p>星型</p>
</li>
<li>
<p>环形</p>
</li>
<li>
<p>网状型</p>
</li>
</ul>
</li>
<li>
<p><strong>传输技术</strong>：</p>
<ul>
<li>广播式网络：共享公共通信通道</li>
<li>点对点网络：使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li>
</ul>
</li>
</ul>
<h4 id="标准化工作"><a class="header-anchor" href="#标准化工作"></a>标准化工作</h4>
<ul>
<li><strong>法定标准</strong>：OSI</li>
<li><strong>事实标准</strong>：TCP/IP</li>
</ul>
<h3 id="分组交换网络中的时延、丢包和吞吐量"><a class="header-anchor" href="#分组交换网络中的时延、丢包和吞吐量"></a>分组交换网络中的时延、丢包和吞吐量</h3>
<h4 id="性能指标"><a class="header-anchor" href="#性能指标"></a>性能指标</h4>
<ul>
<li>
<p><strong>速率</strong>：数据率&amp;数据传输率&amp;比特率</p>
<ul>
<li>数据在传输单位是bit 0/1 位</li>
<li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>3</mn></msup><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>6</mn></msup><mi>K</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>9</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Gb/s = 10^{3}Mb/s = 10^{6}Kb/s = 10^{9}b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></li>
</ul>
<blockquote>
<p>存储容量： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>G</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup><mi>M</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>30</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>40</mn></msup><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>43</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">1TB = 2^{10}GB = 2^{20}MB = 2^{30}KB = 2^{40}B = 2^{43}bite</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">TB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">43</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mtext>字节</mtext><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mtext>比特</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1Byte(字节) = 2^{3}bit(比特)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord cjk_fallback">字节</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord cjk_fallback">比特</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
</li>
<li>
<p><strong>带宽</strong>：网络通信线路传输数据的能力，通常指单位时间内从网络中的某一节点到另一节点所能通过的“最高数据率” ，单位“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bite/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>”</p>
</li>
<li>
<p><strong>吞吐量</strong>：单位时间内通过某个网络（或信道、接口）的数据量，单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>、</mtext><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>、</mtext><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">b/s、kb/s、Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></p>
</li>
</ul>
<h4 id="时延"><a class="header-anchor" href="#时延"></a>时延</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241713.png" alt="image-20240605170015617"></p>
<ul>
<li>
<p><strong>nodal processing 节点处理时延</strong>：</p>
<ul>
<li>
<p>检查：检查分组首部所需要的时间；检查比特级别的错误；</p>
</li>
<li>
<p>找出口：决定将该分组导向何处所需要的时间；</p>
</li>
<li>
<p>高速路由器的处理时延通常是微秒或更低的数量级</p>
</li>
</ul>
</li>
<li>
<p><strong>queueing 排队时延（最复杂）</strong>：</p>
<p>分组到达路由的速率超过了出路由的能力，因而存入一个缓存队列中，等待发出</p>
<p>等待输出/入链路可用</p>
<ul>
<li>
<p>取决于拥塞程度</p>
</li>
<li>
<p>取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<ul>
<li>该队列是空的，则排队时延为0</li>
<li>如果许多其他分组等待传输，排在等待缓存队列当中，则等待时延很长</li>
</ul>
</li>
<li>
<p>实际的排队时延可以是毫秒到微秒量级。</p>
</li>
<li>
<p>R 为链路带宽 bps</p>
</li>
<li>
<p>L 为分组长度 bits</p>
</li>
<li>
<p>a = 平均分组到达速率</p>
</li>
<li>
<p>交通强度 traffic intersity = L*a / R</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241232.png" alt="image-20240605201914573" style="zoom:50%;" /> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241233.png" alt="image-20240605202000063" style="zoom: 80%;" /></p>
</li>
<li>
<p><strong>transmission传输时延</strong>：将分组的所有比特推向链路(即传输,或者说发送)所需要的时间</p>
<ul>
<li>L 比特表示该分组的长度，</li>
<li>用 R bps(即 b/s) 表示从路由器 A 到路由器 B 的链路传输速率。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>传输时延</mtext><mo>=</mo><mfrac><mi>L</mi><mi>R</mi></mfrac></mrow><annotation encoding="application/x-tex">传输时延 = \frac{L}{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传输时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>
<p><strong>propagation 传播时延</strong>：信道路上消耗的时间，取决于<strong>电磁波传播速度</strong>和<strong>链路长度</strong></p>
<ul>
<li>d 为物理链路长度</li>
<li>s 为在物理介质中的传播速率</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>传播时延</mtext><mo>=</mo><mfrac><mi>d</mi><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">传播时延=\frac{d}{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​</li>
</ul>
</li>
<li>
<p><strong>节点时延：</strong></p>
<ul>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242712.png" alt="image-20240605201719133" style="zoom:50%;" /> 
</li>
</ul>
</li>
<li>
<p><strong>时延带宽积</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>时延带宽积</mtext><mo>=</mo><mtext>传播时延</mtext><mo>×</mo><mtext>带宽</mtext></mrow><annotation encoding="application/x-tex">时延带宽积 = 传播时延\times带宽</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">时延带宽积</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带宽</span></span></span></span> ，又称为 <strong>以比特为单位的链路长度</strong></p>
</li>
<li>
<p><strong>往返时延RTT</strong>：从<strong>发送方</strong>发送数据开始；到<strong>发送方</strong>收到<strong>接收方</strong>的确认结束。</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mtext>包括</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>往返传播时延</mtext><mo>=</mo><mtext>传播时延</mtext><mo>×</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>末端处理时间</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">RTT包括\begin{cases}往返传播时延 = 传播时延\times2 \\ 末端处理时间 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mord cjk_fallback">包括</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">往返传播时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">末端处理时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p><strong>利用率</strong>：</p>
<ul>
<li>信道利用率： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext>有数据通过时间</mtext><mrow><mo stretchy="false">(</mo><mtext>有</mtext><mo>+</mo><mtext>无</mtext><mo stretchy="false">)</mo><mtext>数据通过时间</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{有数据通过时间}{(有+无)数据通过时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3923em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">有</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">无</span><span class="mclose mtight">)</span><span class="mord cjk_fallback mtight">数据通过时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">有数据通过时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>网络利用率：信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h4 id="丢包-loss"><a class="header-anchor" href="#丢包-loss"></a>丢包 loss</h4>
<p><strong>丢包</strong>：</p>
<ul>
<li>因为排队容量有限，当新到达的分组没有地方存放时，路由器将<strong>丢弃 drop</strong>该分组，则该分组<strong>丢失 lost</strong>。</li>
<li>丢弃的分组需要进行重传</li>
</ul>
<h4 id="吞吐量"><a class="header-anchor" href="#吞吐量"></a>吞吐量</h4>
<p><strong>throughput 吞吐量：</strong> 单位时间内成功传输的数据量。</p>
<ul>
<li>瞬时吞吐量 instantaneous throughput：在特定时刻网络传输的数据速率。</li>
<li>平均吞吐量 average throughput：在较长时间内网络传输的数据的平均速率。平均吞吐量可以反映网络在一段时间内的整体传输能力。</li>
<li></li>
</ul>
<h3 id="协议层次及服务模型"><a class="header-anchor" href="#协议层次及服务模型"></a>协议层次及服务模型</h3>
<h4 id="分层的体系结构"><a class="header-anchor" href="#分层的体系结构"></a>分层的体系结构</h4>
<h5 id="协议分层-层次结构"><a class="header-anchor" href="#协议分层-层次结构"></a>协议分层&amp;层次结构</h5>
<blockquote>
<p>为什么分层？</p>
<p>因为计算机网络的数据传输是一个较大且复杂的问题。因而将一个大问题拆分为无数个小问题进行解决，而每一个小问题就对应着一个层次。</p>
<p>怎样分层？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>实体</mtext><mo>→</mo><mtext>协议</mtext><mo stretchy="false">(</mo><mtext>对等的实体间才有协议</mtext><mo stretchy="false">)</mo><mo>→</mo><mtext>接口</mtext><mo>→</mo><mtext>服务</mtext><mo stretchy="false">(</mo><mtext>下级为上级提供服务</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">实体 \rightarrow 协议(对等的实体间才有协议) \rightarrow 接口 \rightarrow 服务(下级为上级提供服务)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">实体</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">协议</span><span class="mopen">(</span><span class="mord cjk_fallback">对等的实体间才有协议</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">接口</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">服务</span><span class="mopen">(</span><span class="mord cjk_fallback">下级为上级提供服务</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<blockquote>
<p>计算机网络体系结构，简称“网络体系结构”：是计算机网络的各层及其协议的集合。</p>
<p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</p>
</blockquote>
<ul>
<li><strong>分层基本原则</strong>
<ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li>
<li>结构上可分割。每层采用最合适技术实现</li>
<li>保持下层对上层的独立性，上层单向使用下次提供的服务</li>
</ol>
</li>
<li><strong>实体</strong>：第n层中的活动元素称为<strong>n层实体</strong>。同一层实体叫<strong>对等实体</strong>。</li>
<li><strong>协议</strong>：为进行网络中的<strong>对等实体</strong>数据交换建立的规则、标准或约定。称为网络协议。
<ul>
<li>协议只在对等层次间进行使用。【协议是水平的】</li>
<li>语法：规定了传输数据的格式。</li>
<li>语义：规定所要完成的功能。</li>
<li>同步：规定各种操作的顺序。</li>
</ul>
</li>
<li><strong>接口（访问服务点SAP）</strong>：上层使用下层服务的入口。</li>
<li><strong>服务</strong>：下层为相邻上层提供的功能调用。【服务是垂直的】</li>
<li><strong>SDU服务数据单元</strong>：为完成用户所要求的功能而传送的数据。</li>
<li><strong>PCI协议控制信息</strong>：控制协议操作的信息</li>
<li><strong>PDU协议数据单元</strong>：对等层次之间传递的数据单元</li>
</ul>
<h4 id="TCP-IP模型-实例-事实标准-5层"><a class="header-anchor" href="#TCP-IP模型-实例-事实标准-5层"></a>TCP/IP模型(实例)事实标准 5层</h4>
<ul>
<li><strong>应用层</strong>：网络应用程序及它们的应用层协议存留的地方。
<ul>
<li>位于应用层的信息分组称为<strong>报文</strong>。</li>
</ul>
</li>
<li><strong>运输层</strong>：因特网的传输层在应用程序端点间传送应用层报文。
<ul>
<li>位于运输层的信息分组称为<strong>报文段 segment</strong></li>
<li>有两种运输协议：<strong>TCP和UDP</strong>，利用其中任一个 都可以运输应用层报文。</li>
<li><strong>TCP</strong>向应用程序提供面向连接服务————包括：
<ul>
<li>应用层报文向目的地的确保传递和流量控制(即发送方/接收方速率匹配）</li>
<li>将长报文划分为短报文,并提供拥塞控制机制,因此当网络拥塞时,源抑制其传输速率。</li>
</ul>
</li>
<li><strong>UDP</strong>向应用程序提供无连接服务，这种服务不提供不必要服务，没有可靠性、流量控制、拥塞控制。</li>
</ul>
</li>
<li><strong>网络层</strong>：
<ul>
<li>位于网络层的信息分组称为<strong>数据报 datagram</strong></li>
<li>负责将数据报从一台主机移动到另一台主机。</li>
<li>源端中的运输层协议向网络层递交运输层报文段 segment和目的地址</li>
</ul>
</li>
<li><strong>链路层</strong>：端之间的网络层通过一系列路由器、路由数据报。
<ul>
<li>位于链路层的信息分组称为<strong>帧 frame</strong></li>
<li>链路层接收由网络层传递来的数据报，沿着路径 path将数据报传递给下一个节点。</li>
<li>链路层提供的服务取决于应用于该链路的特定链路层协议。</li>
</ul>
</li>
<li><strong>物理层</strong>：
<ul>
<li>物理层的任务是将链路层的帧的一个个比特从一个节点传输到下一个节点。</li>
<li>这一层的协议仍旧和链路相关，且进一步与链路的实际及输出媒体有关。</li>
</ul>
</li>
</ul>
<h4 id="ISO-OSI模型-实例-法定标准-7层"><a class="header-anchor" href="#ISO-OSI模型-实例-法定标准-7层"></a>ISO/OSI模型(实例)法定标准 7层</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>应用层</mtext><mo>→</mo><mtext>表示层</mtext><mo>→</mo><mtext>会话层</mtext><mo>→</mo><mtext>传输层</mtext><mo>→</mo><mtext>网络层</mtext><mo>→</mo><mtext>数据链路层</mtext><mo>→</mo><mtext>物理层</mtext></mrow><annotation encoding="application/x-tex">应用层 \rightarrow 表示层\rightarrow会话层\rightarrow传输层\rightarrow网络层\rightarrow数据链路层\rightarrow物理层</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">应用层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">表示层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">会话层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传输层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">网络层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">数据链路层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">物理层</span></span></span></span></p>
<ul>
<li>
<p>其他六个层次都只加一个头部<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">H~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span></span></span></span> 只有在数据链路层会加上头部和尾部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mn>2</mn><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>T</mi><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">H~2~~and~~T~2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>数据传输是端对端/点对点的，需要考虑下一个端，且需要知道终点。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242324.png" alt="image-20240311100615910" /> 
</li>
<li>
<p><strong>应用层</strong>：网络应用程序和它们的应用层协议存留的地方。所有能和用户交互产生网络流量的程序。</p>
<ul>
<li>把位于应用层的信息分组称为<strong>报文(message)</strong>。</li>
</ul>
</li>
<li>
<p><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<ul>
<li>数据格式的交换</li>
<li>数据加密解密</li>
<li>数据压缩和恢复</li>
</ul>
</li>
<li>
<p><strong>会话层</strong>：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据</p>
<ul>
<li>会话的同时<strong>建立同步(SYN)</strong>。</li>
<li>和不同实体建立的会话是相对独立的，不会相互影响</li>
<li>建立、管理、终止会话</li>
<li>使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。例如：大文件的传输。</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：负责不同的主机中两个相同进程的通信，即端到端的通信。传输单位时报文段or用户数据报。</p>
<ul>
<li>可靠传输：基于确认机制的一种传输方式</li>
<li>不可靠传输：基于</li>
<li>差错控制：</li>
<li>流量控制：</li>
<li>复用分用：</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>：</p>
</li>
<li>
<p><strong>数据链路层</strong>：</p>
</li>
</ul>
<h4 id="封装"><a class="header-anchor" href="#封装"></a>封装</h4>
<ol>
<li>
<p>端与端之间的通信过程：数据经由发送端的协议栈向下、沿着中间链路层分组交换机的协议栈上上下下，而后向上到达接收端的协议栈。</p>
</li>
<li>
<p>一个应用层报文message传输到运输层，会为其增加一个首部信息，该首部信息将被接收端的运输层使用，应用层的message和添加的首部信息构成了运输层的segment，则运输层封装了应用层传递过来的报文信息；</p>
<ol>
<li>其他层次都只加一个头部<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">H~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span></span></span></span></li>
<li>只有在数据链路层会加上头部和尾部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mn>2</mn><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>T</mi><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">H~2~and~T~2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mord">2</span></span></span></span></li>
</ol>
</li>
<li>
<p>同理，在经过源端的协议栈的过程中，数据形成的信息分组会不断添加附加信息以供目的端使用。</p>
<ol>
<li>应用层向运输层传递message，运输层添加运输层首部信息构成了运输层的segment;</li>
<li>运输层向网络层传递segment，网络层增加源和目的端系统地址等网络层首部信息、构成网络层datagram</li>
<li>网络层向链路层传递datagram，链路层增加其首部信息并生成链路层frame</li>
</ol>
</li>
<li>
<p>图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242940.png" alt="image-20240316230731784" style="zoom:50%;" /> 
</li>
</ol>
<h2 id="应用层"><a class="header-anchor" href="#应用层"></a>应用层</h2>
<blockquote>
<p>研发网络应用程序核心是写出能够运行在不同端系统和通过网络彼此通信的程序。</p>
</blockquote>
<h3 id="应用层协议"><a class="header-anchor" href="#应用层协议"></a>应用层协议</h3>
<h4 id="应用层协议是什么"><a class="header-anchor" href="#应用层协议是什么"></a>应用层协议是什么</h4>
<ul>
<li>定义了运行在不同端系统上的应用进程如何进行进行报文的交换
<ul>
<li>
<p>交换的类型</p>
</li>
<li>
<p>报文的语法</p>
</li>
<li>
<p>根据语法建立的字段的语义</p>
</li>
<li>
<p>进程进行报文发送的时序和次序——何时发、如何发、响应规则</p>
</li>
</ul>
</li>
</ul>
<h4 id="公开协议"><a class="header-anchor" href="#公开协议"></a>公开协议</h4>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>E.g：HTTP，SMTP</li>
</ul>
<h4 id="专用协议"><a class="header-anchor" href="#专用协议"></a>专用协议</h4>
<ul>
<li>不公开</li>
<li>E.g：Skype</li>
</ul>
<h3 id="网络应用程序体系结构"><a class="header-anchor" href="#网络应用程序体系结构"></a>网络应用程序体系结构</h3>
<h4 id="两种主流的应用程序体系结构"><a class="header-anchor" href="#两种主流的应用程序体系结构"></a>两种主流的应用程序体系结构</h4>
<ol>
<li>
<p><strong>客户-服务器体系（C/S——client-server）</strong></p>
<ul>
<li>
<p>有一个总是打开的主机称为<strong>服务器</strong>，服务来自其他的被称为<strong>客户</strong>的主机的请求。</p>
</li>
<li>
<p>以Web应用程序为例：其中总是打开的Web服务器服务于来自浏览器（运行在client主机上）的请求。当Web服务器接受到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。（相当于多了一个卖家和买家之间的中间商，其中每个client即可以是卖家、也可以是买家。</p>
</li>
<li>
<p>主要应用：Web、FTP、Telnet和电子邮件</p>
</li>
<li>
<p>该模型中客户的服务与服务器有高度的依赖</p>
</li>
</ul>
</li>
<li>
<p><strong>对等服务体系（P2P——Peer-to-Peer）</strong></p>
<ul>
<li>
<p>该模型中对服务器的依赖最小（或没有）</p>
</li>
<li>
<p>应用程序在间断连接的主机对之间直接通信，这些主机称为<strong>Peer</strong>，</p>
</li>
<li>
<p>P2P具有<strong>自扩展性</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="进程通信"><a class="header-anchor" href="#进程通信"></a>进程通信</h4>
<blockquote>
<p>进行通信的实际上是两个端系统当中创建出的同一种<strong>进程 process</strong>而非程序。</p>
<p>关注点在于——运行在不同端系统（可能具有不同的操作系统）上的进程间的通信</p>
</blockquote>
<p>在两个不同端系统当中创建的同一种进程，通过计算机网络交换**报文(message)**从而相互通信。发送进程生成并向网络发送message，接收进程接收这些message并可能通过回送message进行响应。</p>
<h5 id="客户和服务器进程"><a class="header-anchor" href="#客户和服务器进程"></a>客户和服务器进程</h5>
<ul>
<li><strong>客户&amp;客户端</strong>：在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程标识为客户；</li>
<li><strong>服务器&amp;服务器端</strong>：在会话开始时等待联系的进程是服务器；</li>
</ul>
<h5 id="进程和计算机网络之间的接口"><a class="header-anchor" href="#进程和计算机网络之间的接口"></a>进程和计算机网络之间的接口</h5>
<ul>
<li>
<p>进程通过一个称为**套接字(socket)**的软件接口向网络发送/接受报文。</p>
<p>host–socket–server工作图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242898.png" alt="image-20240317085036165" style="zoom:50%;" /> 
</li>
<li>
<p><strong>socket</strong>称为应用程序和网络之间的<strong>应用程序编程接口(Application Programming Interface API)</strong>。开发者可以控制socket在应用层端的一切。</p>
</li>
<li>
<p>开发者在socket的运输层只有有限的控制权：</p>
<ul>
<li>选择运输层协议；</li>
<li>可能可以设定几个运输层参数</li>
</ul>
</li>
</ul>
<h5 id="进程寻址"><a class="header-anchor" href="#进程寻址"></a>进程寻址</h5>
<blockquote>
<p>就像发邮件需要有一个收件人地址，发送message数据也需要一个目的端接收进程的地址。</p>
</blockquote>
<ul>
<li>
<p>标识一个进程需要两种信息：</p>
<ul>
<li>
<p>主机地址：主机由其<strong>IP address</strong>唯一标识。</p>
<p>IP address是一个32bite的量且能够唯一标识某一台主机。</p>
</li>
<li>
<p>在目的主机中指定接收进程的标识符：<strong>目的地/客户端</strong>-端口号 <strong>port number</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="可供应用程序使用的运输服务"><a class="header-anchor" href="#可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4>
<h5 id="分类："><a class="header-anchor" href="#分类："></a>分类：</h5>
<ul>
<li><strong>可靠数据传输</strong>：一个运输层协议实现了<strong>确保数据交付服务</strong>，则认为是可靠数据传输 reliable-data-transfer。</li>
<li><strong>吞吐量</strong>：<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。
<ul>
<li>可用吞吐量可能存在波动————因为存在其他共享当前网络path的还会，随着这些会话的进入和离开导致可用吞吐量的波动。</li>
<li>需求：运输层协议能够以某种特定的速率提供确保的可用吞吐量————<strong>确保吞吐量</strong>。</li>
<li><strong>带宽敏感的应用(bandwidth-sensitive application)</strong>：具有吞吐量要求的应用程序，在吞吐量达不到协议要求时————如只有规定所需吞吐量的一半————会放弃发送给，因为对于这类应用程序，接收一半的吞吐量没有意义。</li>
<li><strong>弹性应用</strong>：课根据当前带宽或多或少利用可供使用的吞吐量。如电子邮件、文件传输以及web传送。</li>
</ul>
</li>
<li><strong>定时</strong>：</li>
<li><strong>安全性</strong>：对发送的报文信息进行加密。</li>
</ul>
<h4 id="常见的运输服务"><a class="header-anchor" href="#常见的运输服务"></a>常见的运输服务</h4>
<h5 id="TCP服务"><a class="header-anchor" href="#TCP服务"></a>TCP服务</h5>
<ul>
<li><strong>面向连接服务</strong>：
<ul>
<li><strong>handshaking</strong>：在应用层数据message开始流动前，TCP让客户和服务器互相交换运输层控制信息。提醒客户和服务器做好准备应对接下来大量的信息分组。</li>
<li>握手阶段后：一个TCP connection在两个进程的socket间建立。该connection是全双工的————即连接双方的进程可以在此连接上同时进行message的收发；在message发送结束后必须拆除该连接。</li>
</ul>
</li>
<li><strong>可靠数据传输服务</strong>：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进socket时，它能够依靠TCP将相同的字节流交付给接收方的socket，而没有字节的丢失和冗余。</li>
<li>TCP还也有<strong>拥塞控制机制</strong>，该服务不一定可以为通信进程带来好处，但能为因特网整体带来好处————当发生端和接收端之间的网络出现拥塞，TCP拥塞控制机制会抑制发送端。</li>
</ul>
<h5 id="UDP服务"><a class="header-anchor" href="#UDP服务"></a>UDP服务</h5>
<ul>
<li>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连<br>
接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</li>
</ul>
<h3 id="Web-HTTP"><a class="header-anchor" href="#Web-HTTP"></a>Web &amp; HTTP</h3>
<h4 id="HTTP概况"><a class="header-anchor" href="#HTTP概况"></a>HTTP概况</h4>
<ul>
<li>
<p>Web的应用层协议是<strong>超文本传输协议 HyperText Transfer Protocol,HTTP</strong>————是Web的核心。</p>
</li>
<li>
<p>HTTP由两个程序实现：客户程序喝服务器程序运行在不同的端系统中，通过HTTP报文进行会话。</p>
<blockquote>
<p>HTTP定义了message的结构、客户和服务器进行报文交换的方式</p>
</blockquote>
<ul>
<li>一个客户端程序</li>
<li>一个服务器程序</li>
</ul>
</li>
</ul>
<h5 id="Web页面-Web-page是由对象组成的"><a class="header-anchor" href="#Web页面-Web-page是由对象组成的"></a><strong>Web页面 Web page</strong>是由对象组成的</h5>
<ul>
<li>
<p>一个<strong>object</strong>只是一个文件，如一个HTML文件、一个JPEG图像…且它们可以通过一个URL地址寻址。</p>
</li>
<li>
<p>多数page包含有一个HTML基本文件(base HTML file)以及几个引用对象。</p>
</li>
<li>
<p>HTML基本文件通过对象的URL地址引用页面中的其他对象。</p>
</li>
<li>
<p>URL由两部分组成：存放对象的服务器主机名和对象的路径名。</p>
<p>如：URL 地址 http: // www.someSchool. edu/someDepartment/picture.gif,其中的www. someSchool.edu就是主机名, /someDepartment/picture.gif就是路径名。</p>
</li>
<li>
<p>Web browser实现HTTP的客户端，Web服务器实现HTTP的服务器端，用于存储Web对象，每个对象由URL进行寻址。</p>
</li>
</ul>
<h5 id="HTTP的工作方式："><a class="header-anchor" href="#HTTP的工作方式："></a>HTTP的工作方式：</h5>
<ul>
<li><strong>基本思想为</strong>：用户请求一个Web页面，浏览器向服务器发送该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。</li>
<li>HTTP以TCP作为支持运输的协议</li>
<li>分层体系结构最大的优点,即HTTP协议不用担心数据丢失,也不关注 TCP从网络的数据丢失和乱序故障中恢复的细节。</li>
<li><strong>HTTP是一个无状态协议 stateless protocol</strong>：HTTP并不保存任何客户状态信息，假如短时间内客户发送了两次<strong>请求同一个对象</strong>，服务器并不会因为刚刚为客户提供了该对象而不再响应，而是<strong>重新发送该对象</strong>。</li>
</ul>
<h4 id="非持续连接和持续连接"><a class="header-anchor" href="#非持续连接和持续连接"></a>非持续连接和持续连接</h4>
<p><strong>非持续连接 non-persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求/响应对是经过单独的一个TCP进行</p>
<p><strong>持续连接 persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求/响应对是经相同的TCP连续发送</p>
<h5 id="非持续连接的HTTP"><a class="header-anchor" href="#非持续连接的HTTP"></a>非持续连接的HTTP</h5>
<p>每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他对象而持续下来。每个TCP连接只传输一个请求报文&amp;一个响应报文。</p>
<p><strong>往返时间 Round-Trip Time RTT</strong>：是指一个短分组从客户到服务器然后再返回客户所花费的时间 。</p>
<ul>
<li>
<p><em>RTT</em>包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
</li>
<li>
<p>非持续连接中一次超链接点击：设计一次“三次握手”过程。</p>
<p>客户向服务器发送一个小 TCP 报文段；</p>
<p>服务器用一个小 TCP 报文段做出确认和响应；</p>
<p>客户向服务器返回确认</p>
<p>前两个部分占用一个RTT，客户结合握手的第三部分向TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。</p>
</li>
<li>
<p>HTTP请求/响应也需要用去一个RTT，因此粗略计算：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>总的响应时间</mtext><mo>=</mo><mtext>两个</mtext><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mtext>服务器传输</mtext><mi>H</mi><mi>T</mi><mi>M</mi><mi>L</mi><mtext>文件的时间</mtext></mrow><annotation encoding="application/x-tex">总的响应时间=两个RTT+服务器传输HTML文件的时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">总的响应时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">两个</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">服务器传输</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mord cjk_fallback">文件的时间</span></span></span></span>。</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ol>
<li>
<p>必须为每一个请求的对象建立和维护一个全新的连接，加重了服务器负担。</p>
</li>
<li>
<p>每个对象经受双倍<em>RTT</em>的交付时延————一个<em>RTT</em>创建TCP，另一个用于请求和接收对象</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242436.png" alt="image-20240318101113130" style="zoom:50%;" /> 
</li>
<li></li>
</ol>
<p><strong>工作全流程</strong>：</p>
<ul>
<li>HTTP客户进程在端口号xx发起一个到服务器www.xxx的TCP连接，在客户端和服务器上分别有一个socket与该连接相关联。</li>
<li>HTTP客户经过它的socket向该服务发送一个HTTP请求报文。请求报文中包含有路径名</li>
<li>HTTP服务器进程经它的socket接收请求报文，从其存储器中检索出对象www.xxx/xxx，在一个 HTTP响应报文中封装对象，并通过其socket向客户端发送响应报文。</li>
<li>HTTP服务器进程通知断开该TCP连接。（但是直到 TCP 确认客户已经完整地收到响应报文为止,它才会实际中断连接。）</li>
<li>HTTP客户接收响应报文，TCP连接关闭。</li>
<li>重复前四个步骤；</li>
</ul>
<h5 id="采用持续连接的HTTP"><a class="header-anchor" href="#采用持续连接的HTTP"></a>采用持续连接的HTTP</h5>
<h2 id="运输层"><a class="header-anchor" href="#运输层"></a>运输层</h2>
<h3 id="概述和运输层服务"><a class="header-anchor" href="#概述和运输层服务"></a>概述和运输层服务</h3>
<p>运输层为两个主机当中的两个应用进程提供<strong>逻辑通信</strong>。</p>
<p>运输层协议在端系统中实现</p>
<ul>
<li>将发送进程接收到的报文封装成运输层分组——报文段 segment。
<ul>
<li>将应用报文分为较小的块，为每个块分别加上首部就可以生成运输层的报文段 segment</li>
<li>网络层再将segment封装成网络分组——数据报 datagram</li>
</ul>
</li>
</ul>
<h4 id="运输层和网络层的关系"><a class="header-anchor" href="#运输层和网络层的关系"></a>运输层和网络层的关系</h4>
<blockquote>
<p>网络层提供了主机间的逻辑通信</p>
</blockquote>
<p>运输层只工作在端系统上，通过运输层协议将报文段通过接入网载入网络层。</p>
<p>每一层的向上都可以使用下层提供的服务，同时进行服务的拓展，再提供给上层。</p>
<p>由于网络协议的不可靠——可能造成分组丢失、篡改和冗余；运输层解决这些问题，为进程提供可靠的数据传输服务。同时运输协议还可以通过加密手段来增强网络传输的安全性。</p>
<h4 id="运输层概述"><a class="header-anchor" href="#运输层概述"></a>运输层概述</h4>
<ul>
<li>
<p>IP 网际协议（网络层协议）</p>
<ul>
<li>服务模型为：尽力而为交付服务，best-effort delivery service。IP不确保报文段的交付、不保证报文段的有序交付，不保证报文段数据的完整性。</li>
<li>综上可知，IP是不可靠服务，ubreliable service</li>
<li>每台主机至少有一个网络层地址，即为俗称的IP地址。</li>
</ul>
</li>
<li>
<p>两种可用的运输层协议：</p>
<ul>
<li>UDP 无连接、不可靠的服务</li>
<li>TCP 面向连接的、可靠的服务</li>
<li>两种模型的基本职责是：将端系统间IP的交付服务拓展为端系统上正在运行的进程间的交付服务。这种将主机间交付拓展为进程间交付的行为称之为：<strong>运输层的多路复用 transport-layer multiplexing</strong>和<strong>多路分解 demultiplexing</strong>。</li>
<li>同时，协议还可以根据报文段首部当中的字段进行包括检错等服务的拓展</li>
</ul>
</li>
<li>
<p>TCP提供的附加服务：</p>
<ul>
<li>可靠数据传输 reliable data transfer：通过流量控制、序号、确认和定时器，TCP可以正确地、按序地将数据从发送进程交付给接收进程。</li>
<li>拥塞机制 congestion control：</li>
</ul>
</li>
</ul>
<h3 id="多路复用与多路分解"><a class="header-anchor" href="#多路复用与多路分解"></a>多路复用与多路分解</h3>
<p>一个进程有一个或多个<strong>套接字socket</strong>——网络和进程相互传递数据的门户。</p>
<h4 id="多路分解"><a class="header-anchor" href="#多路分解"></a>多路分解</h4>
<p>在接收端，运输层检查字段，标识接收socket，将segment定向到特定的socket。将运输层segment交付到正确的socket的这个过程称之为多路分解。</p>
<h4 id="多路复用"><a class="header-anchor" href="#多路复用"></a>多路复用</h4>
<p>在源host从不同socket收集数据，并将每个数据块加上首部信息封装成报文段，然后将报文段传递到网络层，该过程称之为多路复用。</p>
<p>多路复用的实现需要什么要求：</p>
<ul>
<li>socket有唯一标识</li>
<li>每个报文段有特殊的字符用于定位到对应的socket
<ul>
<li>即源端口字段 source port number field和目的端口字段 destination port number field</li>
<li>端口号：16bit的数，0~1023为周知端口号 well-known port number，是被保留的</li>
</ul>
</li>
</ul>
<blockquote>
<p>将数据分发给每一个socket是分解</p>
<p>将从不同socket收集到一起，再将其统一传递是复用</p>
</blockquote>
<h4 id="UDP的多路复用"><a class="header-anchor" href="#UDP的多路复用"></a>UDP的多路复用</h4>
<p>主机为每一个socket分配一个port，当segment到达主机时，检查segment当中的destination port，用这个d port定位到对应的socket，而后将data通过socket进入到相应的进程当中。</p>
<p>一个udp socket是由一个二元组进行标识</p>
<ul>
<li>二元组：一个目的IP地址和一个目的端口号</li>
<li>如果两个 UDP 报文段有不同的源 IP 地址和源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</li>
<li>源端口号和源IP地址的用途：
<ul>
<li>用于数据的返回发送，当A到B的数据传输完，B需要给A传时，则使用到A传输过来的数据当中的源port和IP地址。当B传A时，源和目的发生了改变。</li>
</ul>
</li>
</ul>
<h4 id="TCP的多路复用与多路分解"><a class="header-anchor" href="#TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h4>
<p>TCP socket是一个四元组（源IP地址，源port，目的IP地址，目的port）来标识。</p>
<p>TCP建立连接示例：</p>
<ul>
<li>client创建一个socket，并发送连接建立请求</li>
<li>当运行 server 进程的主机收到报文段，定位到进程，在该服务器进程创建一个新的socket</li>
<li>根据连接请求报文段当中的四个值：1.源port，2.源IP地址，3.目的port，4.目的IP地址，进行socket的创建，之后再有与这四个值匹配的首部则会将报文段传给创建好的socket。</li>
<li>当TCP报文段达到主机，根据四个字段将报文段定向（分解）到对应socket。</li>
</ul>
<h4 id="Web服务器和TCP"><a class="header-anchor" href="#Web服务器和TCP"></a>Web服务器和TCP</h4>
<p>当今的高性能 Web 服务器边常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程（单个进程里可以同时有多个线程）。</p>
<h3 id="UDP：无连接传输"><a class="header-anchor" href="#UDP：无连接传输"></a>UDP：无连接传输</h3>
<p>运输层需要最低限度地提供一种复用/分解服务，以便在网络层和正确的应用层进程间进行数据的传递。</p>
<h4 id="UDP功能"><a class="header-anchor" href="#UDP功能"></a>UDP功能</h4>
<ol>
<li>复用/解复用</li>
<li>少量的差错检测</li>
</ol>
<blockquote>
<p>因为基本没有在IP基础上进行更多功能的拓展，仅是完成了传输层的本职工作，因此采用UDP的应用程序，相当于直接应用IP协议。</p>
</blockquote>
<h4 id="使用UDP的过程解析："><a class="header-anchor" href="#使用UDP的过程解析："></a>使用UDP的过程解析：</h4>
<ol>
<li>UDP 从应用进程得到数据，附加上用于多路复用/分解服务的<strong>源和目的port</strong>字段以及两个其他的小字段，然后将形成的报文段segment交给网络层。</li>
<li>网络层将该运输层报文段封装到一个IP数据报datagram中,然后尽力而为地尝试将此报文段交付给接收主机。</li>
<li>如果该报文段到达接收主机，UDP使用<strong>目的port</strong>将报文段中的数据交付给port对应的应用进程。</li>
</ol>
<blockquote>
<p>在发送报文段之前，sender和receiver的运输层实体间未建立连接，因而称之为无连接</p>
</blockquote>
<p>DNS是使用UDP的典例：</p>
<p>进行一次DNS查询，将查询报文交给UDP，无需建立连接，主机的UDP为查询报文添加首部字段，而后交给网络层，网络层将报文段封装成数据报，发送给dns服务器进行查询，查询主机中的DNS应用这等待响应；若未收到响应，这试图向其他的dns服务器发送查询请求or报错未得到响应。</p>
<h5 id="UDP报文段结构"><a class="header-anchor" href="#UDP报文段结构"></a>UDP报文段结构</h5>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242311.png" alt="image-20240523175429387" style="zoom:50%;" /> 
<ol>
<li>
<p>首部四个字段，每个字段有2两个字节组成</p>
</li>
<li>
<p>源端口号：用于后续可能的数据回传</p>
</li>
<li>
<p>目的端口号：初始化socket</p>
</li>
<li>
<p>长度：指示UDP报文段的字节数（head（花销）+data（载荷））</p>
</li>
<li>
<p>检验和：用于校验数据是否出现错误 EDC 差错检测编码</p>
</li>
</ol>
<p>检验和</p>
<ul>
<li>
<p>作用</p>
<p>用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变</p>
</li>
<li>
<p>发送方校验和的计算方法</p>
<p>对发送方的 UDP 报文段的所有 16 比特字的和进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E7%A0%81&amp;spm=1001.2101.3001.7020">反码</a>运算，当求和遇见溢出的时候，进行回卷（回卷的补充在下面），得到的结果放在 UDP 报文段中的检验和字段</p>
</li>
<li>
<p>什么是回卷</p>
<p>所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第 17 位和后 16 位进行加法和运算。</p>
</li>
</ul>
<h3 id="可靠传输原理"><a class="header-anchor" href="#可靠传输原理"></a>可靠传输原理</h3>
<h4 id="可靠传输服务的概念："><a class="header-anchor" href="#可靠传输服务的概念："></a>可靠传输服务的概念：</h4>
<p>就可靠传输这一服务而言，位于较低的层次为上层实体提供的服务可以抽象为一种抽象服务：数据可以通过一条可靠的信道进行传输。借助该信道，数据比特可以无损、无丢失地按照发送顺序进行交付，恰好就是TCP提供的服务模型</p>
<p>实现这种抽象服务即为可靠数据传输协议 reliable data transfer protocol RDT的任务。</p>
<h4 id="传输过程："><a class="header-anchor" href="#传输过程："></a>传输过程：</h4>
<p>rdt_send()被最上层调用，将data交付给下层的发送实体</p>
<p>-&gt;udt_send()被rdt调用，用于将分组放在不可靠的信道上传输给接收方</p>
<p>-&gt;rdt_rev()当分组到达接收方时调用</p>
<p>-&gt;deliver_data()被rdt调用，将pkt当中的data传输给应用层</p>
<h4 id="rdt1-0"><a class="header-anchor" href="#rdt1-0"></a>rdt1.0</h4>
<blockquote>
<p>假设数据在信道中不丢失、不出错</p>
</blockquote>
<p>使用有限状态机 FSM 进行状态的表示，使用带箭头的edge表示状态的变迁，edge上带有便标注：</p>
<ul>
<li>分子表示变迁条件——即A状态做出了什么动作导致了跳转到B状态</li>
<li>分母表示：状态变迁状态过程中A状态做出的动作。</li>
</ul>
<h4 id="rdt2-0-StopAndWait"><a class="header-anchor" href="#rdt2-0-StopAndWait"></a>rdt2.0(StopAndWait)</h4>
<blockquote>
<p>假设数据会出错但不会丢失</p>
</blockquote>
<p>使用肯定确认 positive ackonwledgment ACK和否定确认negative ackonwledgment NCK——自动重传请求（Automatic Repeat reQuest,ARQ）协议</p>
<ul>
<li>差错检测</li>
<li>接收方反馈：通过接收方发送回来的回馈信息为：ACK or NCK来了解接收方的接收情况</li>
<li>重传：接收方接收到有差错的分组时，发送方重新发送数据给接收方</li>
</ul>
<p>rdt3.0：经具有比特差错的丢包信道的可靠数据传输</p>
<h4 id="rdt2-1"><a class="header-anchor" href="#rdt2-1"></a>rdt2.1</h4>
<p>接收方处理出错的ACK/NCK</p>
<p>假设接收方接受了P0，当接收方发送的返回的ACK_0/NCK_0发生错误，导致发送方重复发送了P0，则接收方不接收这个重复的P0但重新发送ACK_0以处理ACK出错的情况，使得发送方和接收方重新回到同步状态</p>
<p>发送方：</p>
<ul>
<li>在每一个pkt里加入序列号：两个序列号（0,1）</li>
<li>一次只发送一个未经确认的分组</li>
<li>需要检测ACK/NCK是否出错</li>
</ul>
<p>接收方：</p>
<ul>
<li>需要检测出收到的分组是否重复
<ul>
<li>状态会指示出希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="rdt2-2-NAK-free"><a class="header-anchor" href="#rdt2-2-NAK-free"></a>rdt2.2 NAK-free</h4>
<p>对ACK进行编号，通过对前一个分组的ACK来代替这一个NAK，即期待得到NAK_0，当得到ACK_1时相当于实现了同样的效果</p>
<h4 id="rdt3-0"><a class="header-anchor" href="#rdt3-0"></a>rdt3.0</h4>
<blockquote>
<p>数据会丢失、会出错</p>
</blockquote>
<p>超时重传机制：</p>
<p>启动一个计时器，比一个RTT多一点的时间，当超时则重新发送pkt</p>
<p>不担心重复，因为分组有序，重复问题在rdt2.2解决了</p>
<p>动态设置计时器</p>
<p>迭代到rdt3.0，则停等协议已经满足了抗丢失、可检错的需求，较为完备，但该协议在信道容量较大时，效率较低。因为信道的利用率很低</p>
<h4 id="流水线可靠数据传输协议-Pipeline-："><a class="header-anchor" href="#流水线可靠数据传输协议-Pipeline-："></a>流水线可靠数据传输协议(Pipeline)：</h4>
<blockquote>
<p>在rdt3.0的基础上，由一次发一个未经确认的分组改成一次发多个未经确认的分组</p>
</blockquote>
<h5 id="滑动窗口-SlideWindow-协议："><a class="header-anchor" href="#滑动窗口-SlideWindow-协议："></a>滑动窗口(SlideWindow)协议：</h5>
<p>缓冲区：暂时存放已发送的分组，以备检错重发和超时重发；但是存放在发送缓冲区的分组不一定都是已发送的。缓冲区的大小决定了一次可以发送多少个未经确认的分组。</p>
<table>
<thead>
<tr>
<th>发送方窗口大小</th>
<th>接收方窗口大小</th>
<th>协议</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>stop-wait</td>
<td></td>
</tr>
<tr>
<td>&gt;1</td>
<td>1</td>
<td>GBN</td>
<td>累计确认</td>
</tr>
<tr>
<td>&gt;1</td>
<td>&gt;1</td>
<td>SR select_repeat</td>
<td>非累计确认</td>
</tr>
</tbody>
</table>
<p>发送窗口：发送缓冲区的一个范围，发送缓冲区的一个子集；发送窗口内的分组都是已发送待确认的，每确认一个分组则窗口向前滑动一个分组；窗口的大小小于或等于缓冲区大小。</p>
<p>回退N步 GBN (Go_Back_N_Steps)</p>
<ul>
<li>基序号：将基序号定义为最早未确认分组的序号</li>
<li>下一个序号：定义为最小的未使用序号</li>
<li>则可将序号范围分成了四个部分：
<ul>
<li>已发送已确认的分组</li>
<li>已发送未确认的分组</li>
<li>即将被发送的分组</li>
<li>尚未能使用</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242093.png" alt="image-20240527162540507"></p>
<p>在发送方有一个N大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为1的接收窗口，</p>
<p>假设当前接收窗口指向为pkt_1，但到来的是pkt_2，首先抛弃掉pkt_2，在迟迟等不到pkt_1，接收方无法发送ACK_1，则发送方计时器超时，发送窗口和发送缓冲区不会向前移动，需要重新发送整个发送窗口内的分组，因为可能有一些分组比pkt_1先到达（例如pkt_2）当被舍弃了，则需要重新发送。</p>
<h5 id="Select-repeat-选择重传"><a class="header-anchor" href="#Select-repeat-选择重传"></a>Select repeat 选择重传</h5>
<p>在发送方有一个SN大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为RN的接收窗口</p>
<p>在发送方每发送一个pkt就会开启一个timepiece 计时器记录该分组是否超时，每收到一个对应分组的ACK则会关闭对应的tp，哪个分组的计时器超时则重新发送哪个分组，从而达到选择重传的效果</p>
<p>假设当前RW内包含分组：pkt_1、2、3、4；则每来一个RW内的分组都可以被接收并发送一个ACK信号给发送方，但是当且仅当到达的是，RW最前面的那个分组，到达，才可以将接收窗口前移：</p>
<p>假设先来的是pkt_2、和3，则接收方返回ACK_2、3，但是窗口不移动，当接收到pkt_1时，将pkt_1、2、3解码读取出data上传给应用层并将窗口前移3格，更新RW为：pkt_4、5、6、7</p>
<h3 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h3>
<ul>
<li>点对点</li>
<li>可靠、按顺序</li>
<li>管道化</li>
<li>发送和接收缓存</li>
<li>全双工</li>
<li>面向连接：数据交换之前需要建立连接</li>
<li>有流量控制</li>
</ul>
<p><strong>报文段结构：</strong></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242029.png" alt="img"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242460.png" alt="img"></p>
<blockquote>
<p>MSS：每个TCP报文段中数据字段的最大长度，仅为数据部分的字段，不包括TCP的head</p>
</blockquote>
<ul>
<li>
<p>HEAD：</p>
<ul>
<li>
<p>头部长度为：长20字节：</p>
</li>
<li>
<p>序号seq：报文段的第一个字节+N个偏移量（MSS*N）</p>
<p>第一个字节，假设seq = m，则传过去的数据序号就是m</p>
</li>
<li>
<p>确认号ack:第二个字节，假设ack = n，相当于告诉对方n-1号以前的序号已经确认完毕，需要从第n号开始传</p>
</li>
<li>
<p>标志位：</p>
<ul>
<li>
<p>URG：紧急指针，为1时表示紧急指针有效</p>
</li>
<li>
<p>SYN：同步序号，用于建立连接，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p>
</li>
<li>
<p>FIN：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li>
<p>RST：重置连接标志，</p>
</li>
<li>
<p>ACK：确认序号标志，为1时表示确认号ack有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
</ul>
</li>
<li>
<p>receive window：窗口大小，可以用于流量控制</p>
</li>
</ul>
</li>
<li>
<p>DATA：</p>
</li>
</ul>
<p>cumulative ack 累计确认</p>
<p>一条TCP连接的双方均可随机地选择初始序号。</p>
<h4 id="TCP的RTT估计和超时"><a class="header-anchor" href="#TCP的RTT估计和超时"></a>TCP的RTT估计和超时</h4>
<p>样本RTT：从某报文段被发出到对该报文段的确认被收到之间的时间量。</p>
<p>获得新的一段时间内的某一时刻的样本RTT时，需要重新计算 预估的RTT</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mi>α</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_s = (1-\alpha)*RTT_s +  \alpha * RTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></p>
<p>一般<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>取0.125，则上面的式子改写成：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0.875</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mn>0.125</mn><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_s = (0.875)*RTT_s +  0.125 * RTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0.875</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.125</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></p>
<p>DevRTT = (1-β) · DevRTT + β·|RTT - RTT_s| β一般取0.25</p>
<p>重传RTT设置为：RTT_s + 4*DevRTT</p>
<p>初始 Timeoutlnterval 值为 1 秒，出现超时后将 timeoutinterval的值加倍，以免即将确认的后继报文过早超时。</p>
<h4 id="TCP-超时重传时间设置"><a class="header-anchor" href="#TCP-超时重传时间设置"></a>TCP 超时重传时间设置</h4>
<h4 id="重传"><a class="header-anchor" href="#重传"></a>重传</h4>
<ul>
<li>
<p>一直顺序到达：</p>
<p>暂缓发送ack，设置一个定时器，在定时器超时之前如果又来了一个新的顺序分组，则重启定时器，再次暂缓发送ack，直到超时；因为累计确认，则在超时发送的那个ack之前的那些分组都是确认过的了</p>
</li>
<li>
<p>乱序到达：</p>
<p>赶紧将需要的顺序最小的期待收到的发一个ack通知发送方重新发送</p>
</li>
<li>
<p>前面顺序，中间有一个乱序：</p>
<p>有一部分gap未到达：缺那部分发哪部分的ack通知重传</p>
</li>
<li>
<p>快速重传：三个冗余ack触发的重传，无须等待发送方的计时器超时</p>
<p>例如：[30,39] [40,44] [45,50] [51,60] [60,70]</p>
<p>其中除了[40,44]其他几个都已到达</p>
<p>[30,39] 发送第一个正常的ack_40；后面三个分组则会发送三个冗余的ack_40给发送方，从而触发快速重传机制</p>
</li>
</ul>
<h4 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h4>
<p>接收方使用捎带技术(Piggybacking)，将本地空闲缓冲区的大小反馈发送方，告知其接下来可以发送数据的大小规模，则不会因为发送方发送过多，接收方处理能力无法跟上导致的数据被大量舍弃。</p>
<h4 id="连接控制"><a class="header-anchor" href="#连接控制"></a>连接控制</h4>
<blockquote>
<ol>
<li>双方知道要建立通信</li>
<li>为从此通信准备好缓冲区</li>
<li>为要发送的数据和控制变量做一些制位操作，告诉彼此初始序号、窗口大小等一些必要信息</li>
</ol>
</blockquote>
<p>需要三次握手</p>
<ol>
<li>申请连接</li>
<li>同意申请连接</li>
<li>告知已知道对方同意</li>
</ol>
<ul>
<li>
<h2 id="SYN位："><a class="header-anchor" href="#SYN位："></a>SYN位：</h2>
</li>
<li>FIN位</li>
<li>RST位</li>
</ul>
<h5 id="建立连接"><a class="header-anchor" href="#建立连接"></a>建立连接</h5>
<h5 id="释放连接"><a class="header-anchor" href="#释放连接"></a>释放连接</h5>
<p>一个完整的TCP连接可以视为两个 半连接 ，即 C-&gt;S 和 S-&gt;C ，因此如果要进行释放则是释放两个 半连接。首先 C 向 S 发送释放请求，S 同意后C不再向S发送数据，但是此时S仍然可以向C发送数据——一种对称式的拆除。在第二个 半连接释放多一步细节，在发送ACK后，启动一个定时器，在超时之前没有数据再传过来，则彻底关闭连接</p>
<h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3>
<p>网络有太多数据，超过了网络的处理能力</p>
<p>两种控制方法：</p>
<ol>
<li>端到端拥塞控制：
<ol>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件判断是否有拥塞</li>
<li>TCP采用的方式</li>
</ol>
</li>
<li>网络辅助的拥塞控制<br>
1.</li>
</ol>
<p>ATM ABR拥塞控制</p>
<h3 id="TCP的拥塞控制"><a class="header-anchor" href="#TCP的拥塞控制"></a>TCP的拥塞控制</h3>
<p>采用端对端的拥塞控制</p>
<p>自我感知：</p>
<p>将复杂的放在边缘部分，core部分提供简单服务与功能</p>
<h4 id="是否发生拥塞"><a class="header-anchor" href="#是否发生拥塞"></a>是否发生拥塞</h4>
<ol>
<li>
<p><strong>超时</strong>：</p>
</li>
<li>
<p><strong>三个冗余ACK</strong>：</p>
</li>
</ol>
<h4 id="如何控制发送方发送速率"><a class="header-anchor" href="#如何控制发送方发送速率"></a>如何控制发送方发送速率</h4>
<ul>
<li>
<p>维持一个拥塞窗口：CongWin</p>
</li>
<li>
<p>发送方限制已发送但未确认的数据量（的上限）</p>
</li>
<li>
<p>从而粗略控制发送方往网络中注入的速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">rate = \frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>SS阶段：加倍增加（每个RTT）</p>
</li>
<li>
<p>CA阶段：线性增加（每个RTT）</p>
</li>
<li>
<p>CongWin是动态的，可以感知到网络拥塞程度的函数</p>
<ul>
<li>超时：CongWin降为 1 MSS，进入SS阶段然后再倍增到 CongWin/2(每个RTT)，从而进入CA阶段</li>
<li>冗余ACK：CongWin降为CongWin/2，CA阶段</li>
<li>否则（即正常收到ACK）：CongWin跃跃欲试</li>
</ul>
</li>
</ul>
<h4 id="联合控制："><a class="header-anchor" href="#联合控制："></a>联合控制：</h4>
<ul>
<li>
<p>发送方已发送但未确认的数据量不超过接收窗口的空闲尺寸、也不超过拥塞窗口</p>
</li>
<li>
<p>可以同时满足拥塞控制和流量控制</p>
</li>
<li>
<p>$SendWin = min { CongWin,RecvWin } $</p>
</li>
</ul>
<h4 id="控制策略"><a class="header-anchor" href="#控制策略"></a>控制策略</h4>
<ul>
<li>慢启动
<ul>
<li>连接刚建立：CongWin = 1 MSS</li>
<li>每收到一个确认，CongWin加倍增长，指数级增长——必然导致拥塞</li>
<li>超时后：重置为 1 MSS，而后加倍达到标记处(CongWin/2)，而后进行线性增长(一个个MSS增加)</li>
<li>冗余ACK后：重置为 CongWin/2</li>
</ul>
</li>
<li>AIMD：线性增长、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242079.png" alt="image-20240529221931664"></p>
<h4 id="TCP吞吐量"><a class="header-anchor" href="#TCP吞吐量"></a>TCP吞吐量</h4>
<p>$ (\frac{CongWin}{2},CongWin)$</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>吞吐量为：</mtext><mfrac><mrow><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mn>2</mn><mo>×</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">吞吐量为：\frac{ \frac{CongWin}{2} + CongWin}{2 \times RTT} = \frac{3}{4}\frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6195em;vertical-align:-0.4033em;"></span><span class="mord cjk_fallback">吞吐量为：</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2161em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9505em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4624em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​</p>
<h2 id="网络层：概述"><a class="header-anchor" href="#网络层：概述"></a>网络层：概述</h2>
<blockquote>
<p>网络层重要的两个功能：转发和路由</p>
<p>转发：数据平面</p>
<p>路由：控制平面——是全局的，在整个网络层面寻找源和目标post</p>
</blockquote>
<p>网络层的功能：</p>
<ol>
<li>在post之间传送 segment/datagram</li>
<li>在发送段将段封装到数据报中</li>
<li>在接收端将段上报给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ol>
<h3 id="转发功能"><a class="header-anchor" href="#转发功能"></a>转发功能</h3>
<ul>
<li>传统方式：基于目标地址和转发表</li>
<li>SDN方式：基于多个字段+流表</li>
</ul>
<h3 id="控制平面方法："><a class="header-anchor" href="#控制平面方法："></a>控制平面方法：</h3>
<ul>
<li>传统的路由器算法：在路由器中实现
<ul>
<li>每一个路由器中的单独路由器算法元件，在控制平面进行交互</li>
<li>一个路由器实现了数据和控制平面的功能</li>
<li>路由实体和其他路由器实体交互路由器信息，分布式地计算流表</li>
<li>算出的流表交给IP协议实体，IP实体根据到来的分组的目标IP地址进行匹配，进而完成分组的转发动作</li>
<li>数据和控制平面紧耦合</li>
</ul>
</li>
<li>software-defined networking（SDN）：在远程的服务器中实现
<ul>
<li>一个不同的（通常是远程的）控制器（网络操作系统）和本地控制代理（CAs）交互</li>
<li>CAs上报当前本地状况</li>
<li>控制器根据CAs给出的状态数据算出相对应的流表</li>
<li>而后通过南向接口将流表交给每一个分组交换设备</li>
<li>分组交互设备将流表装载好，而后对每一个到来的分组进行多个字段的匹配，同时流表内已经设置好了分组动作，当一个分组匹配到哪个流表，则会相对应的执行该流表内的分组动作（转发、阻塞、）</li>
<li>由分布式修改为了集中式</li>
</ul>
</li>
</ul>
<h3 id="网络服务模型"><a class="header-anchor" href="#网络服务模型"></a>网络服务模型</h3>
<h4 id="指标："><a class="header-anchor" href="#指标："></a>指标：</h4>
<ul>
<li>对于单个数据报而言：
<ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
</li>
<li>对于数据报流：
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组间的延迟差 jitter</li>
</ul>
</li>
<li>建立连接
<ul>
<li>某些架构内是重要的功能</li>
<li>网络层的连接和传输层不一样（在传输层的TCP指的是面向连接，即源post的某个进程和目标post的某个进程之间的连接，与中间的交换设备无关，体现在端系统之间的逻辑连接）而网络层是两个主机之间的连接，涉及到路径上的路由器</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242143.png" alt="image-20240530120240222"></p>
<p>一类指标组成的服务称之为服务模型，而基于这种服务模型建立起来的协议的模型可以用这类服务模型来代指</p>
<h3 id="路由器的组成"><a class="header-anchor" href="#路由器的组成"></a>路由器的组成</h3>
<p>路由：运行路由选择算法/协议(RIP,OSPF,BGP)——生成流表</p>
<p>转发：从输入到输出链路交互数据报——根据流表进行分组<strong>转发</strong></p>
<p>具有输入输出端口，输入到输出端口存在queue，输出端口到链路层也有queue，因为传输延迟做不到百分之百为0，因而需要把一些frame暂时放在缓存queue当中，而后这些frame的发送也需要一定的调度schedule方法。</p>
<h4 id="调度规则："><a class="header-anchor" href="#调度规则："></a>调度规则：</h4>
<ul>
<li>FIFO 先到先服务
<ul>
<li>按照分组到来次序</li>
<li>丢弃策略也是FIFO</li>
</ul>
</li>
<li>优先级
<ul>
<li>多类，不同分类有不同级别</li>
</ul>
</li>
<li>RoundRobin RR 调度
<ul>
<li>轮换法</li>
</ul>
</li>
<li>Weighted Fair Queuing WFQ 加权公平队列
<ul>
<li>服务时间可以根据权重计算得出</li>
</ul>
</li>
</ul>
<h3 id="IP协议"><a class="header-anchor" href="#IP协议"></a>IP协议</h3>
<h3 id="IP数据报"><a class="header-anchor" href="#IP数据报"></a>IP数据报</h3>
<p>20 byte的TCP 20 byte的IP = 40 bytes + app layer overhead</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242655.png" alt="image-20240530144524045"></p>
<p>TTL(time to live)生存时间：每经过一个三层设备TTL-1，当TTL==0时，数据包丢弃（向源主机发一个ICMP的错误信息报文通知源post）</p>
<p>option，一般没有，可以有</p>
<h4 id="IP的分片和重组"><a class="header-anchor" href="#IP的分片和重组"></a>IP的分片和重组</h4>
<p>FDDI</p>
<p>对于每个frame：head+body 组成，body的最大长度即为MTU</p>
<p>对于一个较大的segment，将其进行分片，分片原理：</p>
<ul>
<li>首先复制首部，因此分片出来的每一个frame具有相同的源id，因而可以标识为同一个分组分片出来的片段，其次使用offset进行每个分组的序号依据，最后在目标主机根据offset进行重组。</li>
</ul>
<h4 id="IP编址"><a class="header-anchor" href="#IP编址"></a>IP编址</h4>
<p><strong>IP地址</strong>：32位标示，对主机或路由器的接口编址</p>
<ul>
<li>使用IP地址用来标识设备</li>
</ul>
<p><strong>接口</strong>：主机/路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也可能拥有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
<p>一个IP地址和一个接口相关联</p>
<h4 id="子网-Subnets"><a class="header-anchor" href="#子网-Subnets"></a>子网 Subnets</h4>
<p>IP地址：</p>
<ul>
<li>子网部分（高位）</li>
<li>主机部分（低位）</li>
</ul>
<p>一个子网内的节点，它们的IP地址高位部分相同，这些节点构成的网络称之为子网</p>
<p>无需路由器介入，子网内各个主机可以在物理上相互直接到达，可以借助于交换机</p>
<p>纯子网两个特点：</p>
<ul>
<li>前缀相同（高位相同）</li>
<li>他们之间的分组转发在ip层面一跳可达，无须借助路由器</li>
</ul>
<p>互联网：点到点</p>
<p>局域网：多点连接——通过交换机相连，</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242162.png" alt="img"></p>
<p>每个ip地址包含两个标识码ID：网络ID和主机ID</p>
<ul>
<li>
<p>A类地址：网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0， 共126个网络地址，全零和全1的地址不使用，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{7}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>B类地址：网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{14}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>C类地址：网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{30}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>​</p>
</li>
<li>
<p>D类地址：IP地址第一个字节以“1110”开始，它是一个专门保留的地址。224.0.0.0到239.255.255.255用于多点广播。</p>
<ul>
<li>每个网络地址容纳254个主机</li>
<li>多点广播（Multicast）中</li>
</ul>
</li>
</ul>
<p>A、B、C类称为单播地址</p>
<p>D类称之为主播地址——发送给属于主播组的成员</p>
<p>广播一般是局域网内部的广播，一般不会是全球范围的广播</p>
<p>互联网的路由以网络为单位，做路由信息的发布和路由信息的计算：每一个网络是一个流表</p>
<p>特殊IP地址：</p>
<ul>
<li>子网部分：全为0——本网络</li>
<li>主机部分：全为0——本主机</li>
<li>主机部分：全为1——广播地址，这个网络的舍友主机</li>
</ul>
<p>回路地址：127.x.x.x，该地址为目标ip，则tcp\udp将分组传输到ip层时会回传，又称为测试地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242150.png" alt="image-20240602222253233"></p>
<p>IP编制：CIDR Classless InterDomaiin Routing</p>
<p>无类域间路由</p>
<ul>
<li>子网部分可以在任意位置</li>
<li>地址格式为：a.b.c.d/x，x是地址中子网号的长度</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243270.png" alt="image-20240602222546094"></li>
</ul>
<h3 id="子网掩码"><a class="header-anchor" href="#子网掩码"></a>子网掩码</h3>
<p>使用32位bit标识网络id和主机id</p>
<p>两种标书方法：</p>
<ul>
<li>直接32位 1标识网络号，0标识主机号</li>
<li>/xx，标识前xx位为网络号</li>
</ul>
<h3 id="DHCP服务"><a class="header-anchor" href="#DHCP服务"></a>DHCP服务</h3>
<h4 id="动态分配的过程："><a class="header-anchor" href="#动态分配的过程："></a>动态分配的过程：</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243726.png" alt="image-20240602224024681"></p>
<h3 id="SDN"><a class="header-anchor" href="#SDN"></a>SDN</h3>
<p>集中化网络控制器</p>
<p>匹配目标ip、源IP、目标端口、源端口</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243300.png" alt="image-20240603092539337"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243987.png" alt="image-20240603092754178"></p>
<h2 id="网络层：控制平面"><a class="header-anchor" href="#网络层：控制平面"></a>网络层：控制平面</h2>
<blockquote>
<p>决定数据如何走，传输过程</p>
</blockquote>
<h3 id="路由选择算法"><a class="header-anchor" href="#路由选择算法"></a>路由选择算法</h3>
<blockquote>
<p>选择一条合适的路径从源主机到目标主机</p>
<p>网络层的路由是由子网到子网的路由，而非主机到主机</p>
<p>子网聚集下，可以先当作子网到子网，减少工作量，到了子网后再在子网内找主机，提高效率，分治思想，一步步解决一个复杂的大问题，分成一个个子问题</p>
<p>一个路由器代表着一个子网，则由子网到子网的路由相当于从路由器到路由器的路由</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243422.png" alt="image-20240603093907802"></p>
<h4 id="最优化原则-optimality-principle"><a class="header-anchor" href="#最优化原则-optimality-principle"></a>最优化原则 optimality principle</h4>
<ul>
<li>汇集树 sink tree
<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243521.png" alt="image-20240603101328110"></li>
<li>找到的最优路径是一棵树而不是一个图，因为不可能存在环</li>
</ul>
</li>
</ul>
<h4 id="Link-State-LS"><a class="header-anchor" href="#Link-State-LS"></a>Link State LS</h4>
<ul>
<li>迪杰斯特拉算法——核心
<ul>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243409.png" alt="image-20240603112241395"></li>
</ul>
</li>
<li>LS应用情况：
<ul>
<li>OSPF协议是一种LS协议，用于Internet上</li>
<li>IS-IS(intermediate system-intermediate system)：用于Internet主干上，NetWare</li>
</ul>
</li>
</ul>
<h4 id="Distance-Vectos-DV"><a class="header-anchor" href="#Distance-Vectos-DV"></a>Distance Vectos DV</h4>
<h3 id="自治系统内部的路由选择"><a class="header-anchor" href="#自治系统内部的路由选择"></a>自治系统内部的路由选择</h3>
<h4 id="RIP"><a class="header-anchor" href="#RIP"></a>RIP</h4>
<p>RIP算法，相邻路由器之间互相传递路由表信息，信息包括：目标主机和到相邻的节点的距离。通过每一次交互进行路由表的迭代，最终可以完成收敛，进而得出每个节点到其他所有节点的最短路径。</p>
<p>好消息传递快，坏消息传递慢</p>
<h4 id="OSPF"><a class="header-anchor" href="#OSPF"></a>OSPF</h4>
<p>SPF，最短路径优先</p>
<p>洪泛法——广播</p>
<p>发送信息：本路由器相邻的室友路由器的链路状态</p>
<p>当链路状态发生变化时，进行一次洪泛发送</p>
<ul>
<li>
<p>重要的分组：</p>
<ul>
<li>
<p>HELLO分组，问候分组</p>
</li>
<li>
<p>DD分组，数据库描述分组</p>
</li>
<li>
<p>LSR分组，链路状态请求分组</p>
</li>
<li>
<p>LSU分组，链路状态更新分组</p>
</li>
<li>
<p>LSAck分组，链路状态确认分组</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243391.png" alt="image-20240603210211955"></p>
<p>网络较大，将网络分成多个区域——自治系统AS，本区域的洪泛不会影响到其他区域area，而后是区域间进行分组传递交由area0去路由到目标主机的area，再到与目标相邻的路由器。</p>
<h3 id="ISP之间路由选择：BGP"><a class="header-anchor" href="#ISP之间路由选择：BGP"></a>ISP之间路由选择：BGP</h3>
<p>自治区AS之间的选择协议</p>
<p>每个AS有一个BGP发言人，相邻的AS通过BGP发言人交换信息</p>
<p>BGP发言人交换的信息：到达某个网络所需要经过的一系列AS，根据收到的信息选择较好的路由。</p>
<p>BGP路由器既需要管理外部AS间路由的选择，同时也需要执行自治系统内部的路由的选择</p>
<p>BGP路由表包括：网络前缀，下一跳，到达目的网络所要经过的各个自治系统系列（路径）</p>
<blockquote>
<p>三种路由协议：</p>
<ul>
<li>RIP，用于自治系统，内部网关。采用UDP报文来交互路由信息</li>
<li>OSPF，用于自治系统，内部网关。采用IP报文</li>
<li>BGP，用于自治系统之间，外部网关，因网络环境复杂，需要可靠传输，采用TCP报文</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243667.png" alt="image-20240603222249253"></p>
</blockquote>
<h3 id="SDN控制平面"><a class="header-anchor" href="#SDN控制平面"></a>SDN控制平面</h3>
<h3 id="ICMP：因特网控制报文协议"><a class="header-anchor" href="#ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243042.png" alt="image-20240603222345159"></p>
<p>支持主机或路由器：</p>
<ul>
<li>差错/异常报告</li>
<li>网络探询</li>
</ul>
<p>报文结构：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243232.png" alt="image-20240603222515556"></p>
<ul>
<li>
<p>差错报文：</p>
<ul>
<li>
<p>终点不可达：无法交付，向源主机发送终点不可大报文</p>
</li>
<li>
<p>（取消了）源点抑制：当由于拥塞而丢弃数据报时，向源主机发送抑制报文，让源主机放慢数据报发送速率（一种反馈）</p>
</li>
<li>
<p>时间超过：当TTL=0时，丢弃报文，同时向源主机发送时间超过报文。当终点在预定时间内未收到一个数据报的完整数据片，就把已收到的数据片丢弃并发送时间超过报文</p>
</li>
<li>
<p>参数问题：首部字段出问题</p>
</li>
<li>
<p>改变路由（重定向）：修改发送数据报去往的路由器到更好的路由器。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243582.png" alt="image-20240603223206089"></p>
</li>
<li>
<p>不发生ICMP差错报文的情况：</p>
<ul>
<li>对ICMP差错报文不发送</li>
<li>只对第一个数据片发送ICMP差错</li>
<li>对具有组播地址的数据报都不发送</li>
<li>对具有特殊地址的数据报不发送</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ICMP询问报文</p>
<ul>
<li>回送请求和回答报文：</li>
</ul>
</li>
</ul>
<p>ICMP应用：</p>
<ul>
<li>PING</li>
<li>Traceroute</li>
</ul>
<h2 id="链路层和局域网"><a class="header-anchor" href="#链路层和局域网"></a>链路层和局域网</h2>
<p>网卡实现了链路层和物理层的功能</p>
<ul>
<li>
<p>数据链路层的原理：</p>
<ul>
<li>检错和纠错</li>
<li>共享广播信道：多点接入</li>
<li>链路层寻址</li>
<li>LAN：以太网、VLANS</li>
<li>可靠数据传输，流控制：donel</li>
</ul>
</li>
<li>
<p>点到点的链路</p>
</li>
<li>
<p>多点连接的链路</p>
<ul>
<li>同轴电缆</li>
<li>网络通信设备都接入交换机，通过交换机进行信息的传递</li>
</ul>
</li>
<li>
<p>节点：</p>
<ul>
<li>主机和路由器都是节点 nodes，网桥和交换机也是节点</li>
</ul>
</li>
<li>
<p>链路：</p>
<ul>
<li>将节点连接在一起的边</li>
</ul>
</li>
<li>
<p>帧 frame：</p>
<ul>
<li>链路层的pdu protocol data unit，</li>
</ul>
</li>
</ul>
<h3 id="检错和纠错"><a class="header-anchor" href="#检错和纠错"></a>检错和纠错</h3>
<p>EDC = 差错检测和纠正位（冗余位）</p>
<p>D = 数据由差错检测保护，可以包含头部字段</p>
<ul>
<li>奇偶校验
<ul>
<li>单bit奇偶校验</li>
<li>2维奇偶校验</li>
</ul>
</li>
</ul>
<h4 id="CRC-循环冗余检错"><a class="header-anchor" href="#CRC-循环冗余检错"></a>CRC 循环冗余检错</h4>
<ol>
<li>模2运算（每一位进行异或）</li>
</ol>
<blockquote>
<p>加法不进位</p>
<p>减法不借位</p>
</blockquote>
<ol start="2">
<li>
<p>比特序列的两种表示：</p>
<ul>
<li>
<p>位串：1011</p>
</li>
<li>
<p>多项式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>生成多项式</p>
<ul>
<li>
<p>r次方 有r+1位</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G = x^3+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 3次方，有3+1==4位</p>
</li>
</ul>
</li>
<li>
<h2 id="冗余位："><a class="header-anchor" href="#冗余位："></a>冗余位：</h2>
</li>
<li>
<p>性能：</p>
<ul>
<li>可检测出所有1bit错误、2bits错误</li>
<li>检查出所有长度为r或小于r的错误</li>
<li>出现长度为r+1的突发错误，，检查不出的概率为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^{r-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>出现长度大于r+1的突发错误，，检查不出的概率为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msup><mn>2</mn><mi>r</mi></msup><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^r-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ol>
<h3 id="多点访问协议-MAP"><a class="header-anchor" href="#多点访问协议-MAP"></a>多点访问协议 MAP</h3>
<blockquote>
<p>有两种类型的网络链路：</p>
<ul>
<li>点对点链路
<ul>
<li>链路协议：PPP，point2point link和high-level data link control HDLC</li>
</ul>
</li>
<li>广播链路 broadcast link
<ul>
<li>让多个发送节点和接收节点都连接到相同、单一、共享的广播信道上。</li>
<li>每有一个节点传输一个frame，其他所有的节点都可以通过信道收到这个frame的副本，以太网和无线局域网</li>
</ul>
</li>
</ul>
<p>局域网使用</p>
</blockquote>
<h4 id="多路访问协议-multiple-access-protocol"><a class="header-anchor" href="#多路访问协议-multiple-access-protocol"></a>多路访问协议 multiple access protocol</h4>
<p><strong>为什么要有多路访问协议：</strong></p>
<p>在广播链路当中，每个节点都可以传输frame，则会导致，多个节点同时发送frame，所有的节点同时接收到多个frame，传输的frame在所有接收方发生了<strong>碰撞  collide</strong>。</p>
<p>以上情况可以通过使用一个多路访问协议来进行协调，协调活跃节点的对frame的传输。</p>
<p><strong>多路访问协议希望做到的特性：</strong></p>
<blockquote>
<p>理想情况下，对于速率为 R bps的广播信道</p>
</blockquote>
<ol>
<li>当仅有一个节点发送数据，该节点具有 R bps 的吞吐量</li>
<li>当有M个节点发送数据，，每个节点具有 R/M bps的吞吐量——在一段时间内的平均速率达到即可</li>
<li>协议是分散的，不会因为某个主节点故障而全局奔溃</li>
<li>协议简单、便宜</li>
</ol>
<h4 id="信道划分协议："><a class="header-anchor" href="#信道划分协议："></a>信道划分协议：</h4>
<p>时分多路复用TDM和频分多路复用FDM两种用于划分广播信道带宽的技术</p>
<ul>
<li>TDM：将时间划分为时间帧time frame，进一步将每个时间帧划分为N个时隙slot
<ul>
<li>将N个slot不重复的平均分配给N个节点，每个节点只在每个时间帧的指定的第N个slot出书分组，一个slot可以传输单个分组。</li>
<li>缺点：
<ul>
<li>节点限制在R/N bps的平均速率，上限设死了</li>
<li>节点必须等待到他的轮次，即当出现情况：xx节点是唯一需要发送的节点，也必须被迫等待到第N个slot才能进行发送。</li>
</ul>
</li>
</ul>
</li>
<li>FDM：
<ul>
<li>将R bps的信道划分为不同的频段，将每个判断分配给N个节点中的一个。</li>
</ul>
</li>
<li>码分多址 CDMA Code Division Multiple Access：
<ul>
<li>对每个节点分配一种不同编码，每个节点用其唯一编码来对发送的数据进行编码</li>
<li>不同的节点可以同时传输，且接收方可以正确接收，不受干扰</li>
</ul>
</li>
</ul>
<h4 id="随机接入协议"><a class="header-anchor" href="#随机接入协议"></a>随机接入协议</h4>
<p>一个传输节点总是以信道的全部速率（即 R bps）进行发送。</p>
<p>有碰撞时，涉及的每个节点反复重发分组，知道分组无碰撞通过为止。</p>
<p>但不是立即重发，而是在等待一个随机时延后进行重发。则每一个参与碰撞的节点都会独立地选择一个随机时延，则可能有出现一种情况：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>
<ul>
<li>最常见的几个：ALOHA协议，Abramson 和 载波侦听多路访问 CSMA 协议——以太网使用的及时CSMA</li>
</ul>
<ol>
<li><strong>时隙 ALOHA：</strong>
<ul>
<li>所有frame由L比特组成</li>
<li>时间被划分位长度为 L/R 的时隙，一个时隙对于传输一帧的时间</li>
<li>节点在时隙起点开始传输帧</li>
<li>节点同步，每个节点都知道时隙何时开始</li>
<li>如果一个时隙内发生碰撞，所有节点在该时隙结束之前检测到碰撞时间</li>
</ul>
</li>
</ol>
<p>取一个概率 <em>p</em> ，每个节点的操作为：</p>
<ul>
<li>当节点有一个待发送的帧，等到下一个时隙开始时传输整个帧</li>
<li>如果没有碰撞，该节点成功传输，无需重发</li>
<li>如果发生碰撞，在时隙结束前检测到，并以 <em>p</em> 的概率在后续的时隙中重发这一帧，知道无碰撞无须重发为止</li>
</ul>
<ol start="2">
<li>
<h2 id="ALOHA："><a class="header-anchor" href="#ALOHA："></a><strong>ALOHA</strong>：</h2>
</li>
<li><strong>载波侦听多路访问 CSMA：</strong>
<ul>
<li>设定规则：
<ul>
<li>传输节点之前先听信道是否有人在传输，载波侦听过程：一直到检测到一段时间无人传输，才开始传输</li>
<li>传输时，一直侦听信道，如果与其他节点正在传输干扰帧，停止吃成熟，在重复上一个过程“侦听 —— 当信道空闲时传输”之前需要等待一段随机时间。</li>
<li>等待时间随机的必要性：加入两个节点同时传输，然后碰撞后又等待相同的时间，则会一直碰撞下去。</li>
<li>当碰撞节点数量较少，时间间隔较短；数量较大，时间间隔较长</li>
</ul>
</li>
<li>二进制指数回退算法：
<ul>
<li>当传输一个给定帧时，该帧发生n次碰撞，节点随机在 [0,1,2,… <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>] 中选择一个K值，碰撞越多，K选择的间隔越大。一个节点实际等待时间为：K*512bit时间，n小于10</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="轮流协议"><a class="header-anchor" href="#轮流协议"></a>轮流协议</h4>
<ol>
<li>轮询协议 taking-turns protocol：N个节点之中要有一个指定为主节点。主节点以循环方式轮询poll每一个节点。
<ol>
<li>主节点首先向节点1发送一个报文，告诉它能够传输的帧的最多数量；在节点1传输了某些帧后,主节点告诉节点2它能够传输的帧的最大数量</li>
<li>主节点可以观察到信道上是否缺乏信号来决定一个节点何时完成帧的发送。</li>
<li>缺点：
<ol>
<li>轮询时延，即每个活跃节点必须等待主节点轮询非活跃节点的时间</li>
<li>主节点故障，全局系统瘫痪</li>
</ol>
</li>
</ol>
</li>
<li>令牌传递协议 token-passing protocol：
<ol>
<li>无主节点，有一个令牌token的小的特殊帧在节点间以设定好的固定次序进行交互</li>
<li>当一个节点拿到token时，仅当其需要发送帧时才继续持有，否则立刻将token发送给下一个节点。</li>
</ol>
</li>
</ol>
<h4 id="DOCSIS：用于电缆因特网接入的链路层协议"><a class="header-anchor" href="#DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h4>
<ol>
<li>使用FDM将上下行信道进行分离</li>
<li>使用TDM将上行信道划分为时间间隔，每个时间间隔包含一个微时隙序列，每个电缆调制解调器分配到序列为N的时隙向CMTS传输数据，CMTS在下行信道发送控制报文——MAP报文——指定哪个电缆调制解调器能够在时间间隔中的哪个微时隙中传输数据。</li>
<li>电缆调制解调器在一组特殊的微时隙间隔内向CMTS发送请求帧来告诉CMTS有数据要发送。请求帧以随机接入方式传输，可能发生碰撞，当电缆没有在下一个下行控制报文收到响应，则推断请求帧发生了碰撞，采取二进制指数回退将其微时隙请求帧延缓到以后的时隙重新发送。</li>
</ol>
<h3 id="LANS"><a class="header-anchor" href="#LANS"></a>LANS</h3>
<h4 id="MAC地址"><a class="header-anchor" href="#MAC地址"></a>MAC地址</h4>
<p>MAC地址具有扁平化结构，不像IP地址一样需要划分出网络部分和主机部分，且MAC地址不会因为地点的改变而改变，不像IP地址一样，随着主机设备的移动，IP地址也需要动态做出改变</p>
<p>适配器向其他适配器发送一个frame，发送适配器将目的适配器的MAC地址插入到帧中，并将帧发送到局域网，交换机广播这一个帧，一个适配器可以接收到一个并非向它寻址的帧，当接收到一个帧时会去匹配MAC地址，若匹配得上，则提取出封装的数据，否则丢弃该数据。</p>
<h4 id="ARP协议-地址解析协议"><a class="header-anchor" href="#ARP协议-地址解析协议"></a>ARP协议 地址解析协议</h4>
<p>ARP：输入进来一个子网IP，将其转换成对应的MAC地址并返回。</p>
<p>ARP只作用于同一个子网上的主机和路由器接口解析IP地址</p>
<p>每台主机或路由器存有一张ARP表，该表包含IP地址到MAC地址的映射关系，表项中含有一个TTL，指示从表中删除某对映射关系的时间</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243579.png" alt="image-20240604164237575"></p>
<p>该表不必为子网中每台主机和路由器都包含一个表项，某些可能从未进入，某些可能过期了。</p>
<p>一个通讯过程中：</p>
<ul>
<li>
<p>发送方构造一个称为ARP分组 ARP pkt 的特殊分组，分组含有字段：</p>
<ul>
<li>发送和接收IP地址及MAC地址</li>
</ul>
<p>ARP查询分组和响应分组具有相同格式，查询分组目的是查询子网上所有其他主机和路由器以缺点对应于要解析的IP地址的那个MAC地址</p>
</li>
<li>
<p>发送查询分组，使用MAC广播地址来发送这个分组，每一个接收到广播而来的分组的适配器去匹配IP地址，如果匹配成功，则发送一个带有IP和MAC地址映射关系的响应ARP分组，而后查询主机更新ARP表，并发送IP数据报，该数据报封装在一个链路层帧中，并且该帧目的MAC与之前发送响应报文的主机或路由器的MAC地址相同。</p>
</li>
</ul>
<h4 id="以太网"><a class="header-anchor" href="#以太网"></a>以太网</h4>
<ol>
<li><strong>帧结构：</strong>
<ul>
<li>前同步码+目的地址+源地址+类型+数据部分+…+CRC检验和</li>
<li>数据字段：承载IP数据报，MTU位1500字节。</li>
<li>目的地址（6字节）：包含目的适配器的MAC地址</li>
<li>源地址（6字节）：包含发送适配器的MAC地址</li>
<li>类型字段（2字节）：允许以太网复用多种网络层协议</li>
<li>CRC（4字节）：校验和</li>
<li>前同步码（8字节）：前七个字节值都为10101010，最后一个为10101011。前七个用于唤醒接收适配器，且将它们的时钟和发送方的时钟同步。</li>
</ul>
</li>
</ol>
<h4 id="链路层交换机"><a class="header-anchor" href="#链路层交换机"></a>链路层交换机</h4>
<p>交换机本身对于子网中的主机和路由器是透明的，即不需要理会的。</p>
<ol>
<li>
<p><strong>过滤：</strong></p>
<ul>
<li>决定进行转发or丢弃的功能</li>
</ul>
</li>
<li>
<p><strong>转发：</strong></p>
<ul>
<li>决定一个帧应该被导向哪个接口，并把帧移动到接口的功能</li>
</ul>
</li>
<li>
<p><strong>交换机表 switch table：</strong></p>
<ul>
<li>过滤和转发功能借助于交换机表实现。</li>
<li>包含某局域网上某些主机和路由器的表项，不必时是全部的</li>
<li>表项包含：
<ul>
<li>一个MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项放置在表中的时间</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243777.png" alt="image-20240604195935508"></li>
<li>查表的三种情况：</li>
<li>假设有一个包含目的地址为dd-dd-dd-dd-dd-dd的帧，从接口x到达交换机：
<ul>
<li>表中无记录dd-dd-dd-dd-dd-dd的表项。这种情况下，对除了接口x以外的所有接口进行洪泛。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="链路虚拟化"><a class="header-anchor" href="#链路虚拟化"></a>链路虚拟化</h3>
<h3 id="数据中心网络"><a class="header-anchor" href="#数据中心网络"></a>数据中心网络</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://example.com/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post-share"><div class="social-share" data-image="/./img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/%E7%AE%97%E6%B3%95/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="力扣刷题"><img class="cover" src="/./img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">力扣刷题</div></div><div class="info-2"><div class="info-item-1">LeetCode刷题记录 [2549] 统计桌面上的不同数字 题目 给你一个正整数 n ，开始时，它放在桌面上。在 109 天内，每天都要执行下述步骤：  对于出现在桌面上的每个数字 x ，找出符合 1 &lt;= i &lt;= n 且满足 x % i == 1 的所有数字 i 。 然后，将这些数字放在桌面上。  返回在 109 天之后，出现在桌面上的 不同 整数的数目。 注意：  一旦数字放在桌面上，则会一直保留直到结束。 % 表示取余运算。例如，14 % 3 等于 2 。  示例 1： 123456输入：n = 5输出：4解释：最开始，5 在桌面上。 第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。 示例 2： 12345输入：n = 3 输出：2解释： 因为 3 % 2 == 1 ，2 也出现在桌面上。 在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="计算机组成原理学习笔记"><img class="cover" src="/./img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">计算机组成原理学习笔记</div></div><div class="info-2"><div class="info-item-1"> 计算机组成原理  CH1 计算机基本知识 计算机类型：  嵌入式计算机 个人计算机 服务器和企业系统 超级计算机和网络计算机  计算机五大部件：  输入单元——Input Unit 输出单元——Output Unit 存储设——Memory 运算逻辑单元——ALU Arithmetic and Logic Unit 控制单元——Control Unit  3、程序运行 4、计算机发展 CH9 Arithmetic 数的表示 数据   数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。   硬件实现的数据类型——数据表示   软件实现的数据类型——数据结构   整数的表示  有符号整数，符号位为0表示为正；符号位为1表示为负  出于各种原因，针对二进制数，设计出了以下几种二进制编码   原码   反码   补码   移码   原码：   一个数的绝对值的二进制表示   特点：    含有+0（0000 0000）和-0（1111...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络复习笔记"><img class="cover" src="/./img/5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">计算机网络复习笔记</div></div><div class="info-2"><div class="info-item-1">计算机网络 引言 1.2 Network edge several type of access networks  residential access nets 住宅接入网 institutional access networks (school, company) 机构接入网 wireless access networks 无线接入网 bandwidth bit per second 带宽 bps  Physical media: twisted pair  Twisted copper wire / Twisted pair 双绞铜线 coax/coaxial cable 同轴电缆 fiber optic 光纤 radio 无线电  1.3 network core Difference of performance between Packet-switching &amp; circuit switching  分组交换不适合实时服务，端到端的时延是可变和不可预测的 分组交换有着比电路交换更好的网络共享； 比电路交换更简单、有效，实现成本更低；  1.4...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统学习笔记"><img class="cover" src="/./img/4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">操作系统学习笔记</div></div><div class="info-2"><div class="info-item-1">操作系统 CH1—基本概念概述 操作系统：  是一台将复杂的执行细节隐藏， 向用户提供虚拟的易于使用的功能的一种机器。 一种资源管理机器  进程：  正在执行的一个程序就是一个进程 为了描述和控制进程的运行    一个称为command interpret或shell的进程从终端读取命令。   一个进程可以创建一个或多个子进程，从而构成进程树。   UNIX有一个共同的父进程：root   进程块 PCB 为了便于描述和控制进程的运行，OS为进程定义了一种数据结构“进程块 PCB（Process Control Block）”，每创建一个进程，即是为某个程序设置了一个PCB，用于对该进程进行控制和管理。进程任务完成则收回PCB，代表进程消亡。 至此，PCB是进程存在的唯一标志。 进程的状态   running   blocked(阻塞，不可抢占CPU资源)   ready(可抢占CPU资源状态)   不同种类的ID   UID：Each person authorized to use a system is assigned a User...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理学习笔记"><img class="cover" src="/./img/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">编译原理学习笔记</div></div><div class="info-2"><div class="info-item-1">编译原理 CH1: 编译器介绍 编译器概述  为什么需要编译器？ 因为计算机只能执行机器语言，而为了便于项目开发，人们需要使用高级程序语言提高效率。此时需要编译器将人能看懂但机器看不懂的高级程序语言转换为机器可以看得懂的机器码(machine code) 什么是编译器？   编译器也是一种程序或软件   其核心功能是将输入的源代码翻译为目标代码进行输出。 即将代码由一种语言转换为另一种语言的翻译软件    解释器  一种常见的语言处理器。 它并不通过翻译的方式生成目标程序；解释器直接利用用户提供的输入执行源程序中指定对的操作。   编译器和解释器对比 相同点：都是一种语言实现系统 不同点：   解释器边解释边执行。    编译器对源代码总的进行编译并产生可直接使用的对象代码。   解释器运行程序基本没有预处理。   编译器做了许多拓展性的预处理，大部分都是靠编译器实现。   编译器和解释器配合使用，法力无边（参考JAVA）   编译器结构   Lexical analysis(Scanning)词法分析：识别description逻辑块。   Syntax...</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="计算机组成原理学习笔记"><img class="cover" src="/./img/3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">计算机组成原理学习笔记</div></div><div class="info-2"><div class="info-item-1"> 计算机组成原理  CH1 计算机基本知识 计算机类型：  嵌入式计算机 个人计算机 服务器和企业系统 超级计算机和网络计算机  计算机五大部件：  输入单元——Input Unit 输出单元——Output Unit 存储设——Memory 运算逻辑单元——ALU Arithmetic and Logic Unit 控制单元——Control Unit  3、程序运行 4、计算机发展 CH9 Arithmetic 数的表示 数据   数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。   硬件实现的数据类型——数据表示   软件实现的数据类型——数据结构   整数的表示  有符号整数，符号位为0表示为正；符号位为1表示为负  出于各种原因，针对二进制数，设计出了以下几种二进制编码   原码   反码   补码   移码   原码：   一个数的绝对值的二进制表示   特点：    含有+0（0000 0000）和-0（1111...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="toc-number">1.1.</span> <span class="toc-text">计算机网络与因特网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">计网概念简述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91%E7%9A%84%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">计网的结构组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A1%AC%E4%BB%B6%E8%BF%9B%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">物理硬件进度来看结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">功能角度来看结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">网络协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%9E%E4%BD%93"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">网络实体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%9E%E4%BD%93"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">对等层次的实体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">网络边缘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">边缘部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="toc-number">1.1.4.</span> <span class="toc-text">网络核心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">分组交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">功能组成：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">标准化工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.1.5.</span> <span class="toc-text">分组交换网络中的时延、丢包和吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">时延</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85-loss"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">丢包 loss</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">吞吐量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">协议层次及服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">分层的体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">协议分层&amp;层次结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B-%E5%AE%9E%E4%BE%8B-%E4%BA%8B%E5%AE%9E%E6%A0%87%E5%87%86-5%E5%B1%82"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">TCP&#x2F;IP模型(实例)事实标准 5层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ISO-OSI%E6%A8%A1%E5%9E%8B-%E5%AE%9E%E4%BE%8B-%E6%B3%95%E5%AE%9A%E6%A0%87%E5%87%86-7%E5%B1%82"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">ISO&#x2F;OSI模型(实例)法定标准 7层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">封装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">应用层协议是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%BC%80%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">公开协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">专用协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">网络应用程序体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">两种主流的应用程序体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">客户和服务器进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">进程和计算机网络之间的接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AF%BB%E5%9D%80"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">进程寻址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">可供应用程序使用的运输服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">分类：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">常见的运输服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">TCP服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">UDP服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-HTTP"><span class="toc-number">1.2.3.</span> <span class="toc-text">Web &amp; HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%A6%82%E5%86%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">HTTP概况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Web%E9%A1%B5%E9%9D%A2-Web-page%E6%98%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E7%BB%84%E6%88%90%E7%9A%84"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">Web页面 Web page是由对象组成的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">HTTP的工作方式：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">非持续连接和持续连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5%E7%9A%84HTTP"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">非持续连接的HTTP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5%E7%9A%84HTTP"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">采用持续连接的HTTP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">1.3.</span> <span class="toc-text">运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E8%BF%90%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述和运输层服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">运输层和网络层的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">运输层概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">多路复用与多路分解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">多路分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">UDP的多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">TCP的多路复用与多路分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CTCP"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">Web服务器和TCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%EF%BC%9A%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93"><span class="toc-number">1.3.3.</span> <span class="toc-text">UDP：无连接传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">UDP功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8UDP%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">使用UDP的过程解析：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">UDP报文段结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">可靠传输原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">可靠传输服务的概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">传输过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt1-0"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">rdt1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-0-StopAndWait"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">rdt2.0(StopAndWait)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">rdt2.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-2-NAK-free"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">rdt2.2 NAK-free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">rdt3.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-Pipeline-%EF%BC%9A"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">流水线可靠数据传输协议(Pipeline)：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-SlideWindow-%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.3.4.8.1.</span> <span class="toc-text">滑动窗口(SlideWindow)协议：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Select-repeat-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0"><span class="toc-number">1.3.4.8.2.</span> <span class="toc-text">Select repeat 选择重传</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">1.3.5.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84RTT%E4%BC%B0%E8%AE%A1%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">TCP的RTT估计和超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">TCP 超时重传时间设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">连接控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SYN%E4%BD%8D%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">SYN位：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.0.0.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.0.0.2.</span> <span class="toc-text">释放连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E6%8B%A5%E5%A1%9E"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">是否发生拥塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%91%E9%80%81%E9%80%9F%E7%8E%87"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">如何控制发送方发送速率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%EF%BC%9A"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">联合控制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">控制策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">TCP吞吐量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.</span> <span class="toc-text">网络层：概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.1.</span> <span class="toc-text">转发功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">控制平面方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">网络服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%A0%87%EF%BC%9A"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">指标：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">路由器的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">调度规则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.5.</span> <span class="toc-text">IP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">1.5.6.</span> <span class="toc-text">IP数据报</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E7%9A%84%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">IP的分片和重组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E7%BC%96%E5%9D%80"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">IP编址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91-Subnets"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">子网 Subnets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">1.5.7.</span> <span class="toc-text">子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.8.</span> <span class="toc-text">DHCP服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">动态分配的过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDN"><span class="toc-number">1.5.9.</span> <span class="toc-text">SDN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">网络层：控制平面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">路由选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99-optimality-principle"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">最优化原则 optimality principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Link-State-LS"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">Link State LS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distance-Vectos-DV"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">Distance Vectos DV</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.2.</span> <span class="toc-text">自治系统内部的路由选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">RIP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">OSPF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISP%E4%B9%8B%E9%97%B4%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ABGP"><span class="toc-number">1.6.3.</span> <span class="toc-text">ISP之间路由选择：BGP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDN%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.6.4.</span> <span class="toc-text">SDN控制平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%EF%BC%9A%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.5.</span> <span class="toc-text">ICMP：因特网控制报文协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">1.7.</span> <span class="toc-text">链路层和局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E5%92%8C%E7%BA%A0%E9%94%99"><span class="toc-number">1.7.1.</span> <span class="toc-text">检错和纠错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CRC-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%94%99"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">CRC 循环冗余检错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E4%BD%8D%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">冗余位：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE-MAP"><span class="toc-number">1.8.1.</span> <span class="toc-text">多点访问协议 MAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE-multiple-access-protocol"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">多路访问协议 multiple access protocol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">信道划分协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%A5%E5%85%A5%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">随机接入协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALOHA%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">ALOHA：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">轮流协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOCSIS%EF%BC%9A%E7%94%A8%E4%BA%8E%E7%94%B5%E7%BC%86%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A5%E5%85%A5%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">DOCSIS：用于电缆因特网接入的链路层协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LANS"><span class="toc-number">1.9.1.</span> <span class="toc-text">LANS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">ARP协议 地址解析协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">链路层交换机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.9.2.</span> <span class="toc-text">链路虚拟化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">数据中心网络</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法"><img src="/./img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/2025/03/18/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-03-18T12:43:53.000Z" title="发表于 2025-03-18 20:43:53">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/14/MySQL/MySql%E8%BF%9B%E9%98%B6/" title="MySql进阶"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql进阶"/></a><div class="content"><a class="title" href="/2025/03/14/MySQL/MySql%E8%BF%9B%E9%98%B6/" title="MySql进阶">MySql进阶</a><time datetime="2025-03-14T06:08:13.000Z" title="发表于 2025-03-14 14:08:13">2025-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" title="IO流"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO流"/></a><div class="content"><a class="title" href="/2025/03/07/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" title="IO流">IO流</a><time datetime="2025-03-07T08:13:04.000Z" title="发表于 2025-03-07 16:13:04">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/%E6%8F%92%E4%BB%B6/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="mybatis-plus插件使用"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis-plus插件使用"/></a><div class="content"><a class="title" href="/2025/03/07/%E6%8F%92%E4%BB%B6/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="mybatis-plus插件使用">mybatis-plus插件使用</a><time datetime="2025-03-07T01:55:42.000Z" title="发表于 2025-03-07 09:55:42">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/%E6%8F%92%E4%BB%B6/lombok%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="lombok插件使用"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lombok插件使用"/></a><div class="content"><a class="title" href="/2025/03/07/%E6%8F%92%E4%BB%B6/lombok%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="lombok插件使用">lombok插件使用</a><time datetime="2025-03-07T01:51:11.000Z" title="发表于 2025-03-07 09:51:11">2025-03-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>