<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>jvm 学习笔记 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM  本文参考资料： 黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili  认识 JVM jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。 jvms三大核心功能：  解释与运行：对字节码文件中的指令实时解释为机器码">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm 学习笔记">
<meta property="og:url" content="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="JVM  本文参考资料： 黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili  认识 JVM jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。 jvms三大核心功能：  解释与运行：对字节码文件中的指令实时解释为机器码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041400507.png">
<meta property="article:published_time" content="2025-03-01T03:35:47.081Z">
<meta property="article:modified_time" content="2025-03-18T13:11:46.824Z">
<meta property="article:author" content="moru">
<meta property="article:tag" content="java 底层">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041400507.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "jvm 学习笔记",
  "url": "http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/",
  "image": "https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041400507.png",
  "datePublished": "2025-03-01T03:35:47.081Z",
  "dateModified": "2025-03-18T13:11:46.824Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jvm 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041400507.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">jvm 学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">jvm 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T03:35:47.081Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T13:11:46.824Z" title="更新于 2025-03-18 21:11:46">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM"><a class="header-anchor" href="#JVM"></a>JVM</h1>
<blockquote>
<p>本文参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="认识-JVM"><a class="header-anchor" href="#认识-JVM"></a>认识 JVM</h2>
<p>jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。</p>
<h3 id="jvms三大核心功能："><a class="header-anchor" href="#jvms三大核心功能："></a>jvms三大核心功能：</h3>
<ol>
<li>解释与运行：对字节码文件中的指令实时解释为机器码，交由计算机执行</li>
<li>内存管理：自动为对象、方法分配内存；垃圾回收机制，自动监测和回收不再使用的对象</li>
<li>即时编译：将热点代码翻译为机器码后会将这段机器码存储到内存中，避免重复翻译导致的时耗</li>
</ol>
<p>常见的 jvm：Hotspot、GraalVM、OpenJ9等，另外 DragonWell 龙井 JDK 也提供了一款功能增强版的 JVM。我们平时默认使用的虚拟机是 Oracle 官方的 HotSpot。</p>
<h2 id="JVM-的组成"><a class="header-anchor" href="#JVM-的组成"></a>JVM 的组成</h2>
<ul>
<li>
<p>类加载器：ClassLoader，作用是把从外界（磁盘或网络）读取的字节码文件加载到内存中</p>
</li>
<li>
<p>运行时数据区域：负责管理 jvm 使用到的内存（方法区、堆区）</p>
<p>如：字节码文件通过类加载器加载后会存放在该区域</p>
</li>
<li>
<p>执行引擎：包括即时编译器、解释器、垃圾回收器等。负责将字节码文件中的指令解释成机器码，同时调用即时编译器优化性能。</p>
</li>
<li>
<p>本地接口：调用本地已经编译的方法，如虚拟机中提供的 c/c++方法。（HotSpot 虚拟机本身由 c++ 编写，一些底层接口需要调用相关方法）</p>
</li>
</ul>
<p>示意图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031514092.png" alt="img"></p>
<h2 id="字节码"><a class="header-anchor" href="#字节码"></a>字节码</h2>
<p>本文学习过程中使用  <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib">jclasslib</a>  工具查看字节码文件。使用 <a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">Arthas</a> 进行线上监控诊断。</p>
<h3 id="字节码文件的组成"><a class="header-anchor" href="#字节码文件的组成"></a>字节码文件的组成</h3>
<p>字节码文件以二进制组成，保存的是源代码编译后的信息</p>
<h4 id="基础信息"><a class="header-anchor" href="#基础信息"></a>基础信息</h4>
<blockquote>
<p>魔数、字节码文件对应的 Java 版本号、访问标识、父类和接口</p>
</blockquote>
<ul>
<li>
<p>魔数 Magic：java 字节码文件的文件头（文件的起始的几个固定字节 <code>ca fe ba be</code>）称之为 魔数</p>
<ul>
<li>
<p>文件无法通过文件拓展名来确定文件类型，文件拓展名可以随意修改，不影响文件的内容</p>
</li>
<li>
<p>软件通过文件的文件头去校验文件的类型，如果软件不支持该类型就会报错</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031451968.png" alt="魔数"></p>
<ul>
<li>
<p>版本号：</p>
<ul>
<li>
<p><strong>主版本号</strong>：java 的主版本号 - 44 即可知道当前 jdk 版本</p>
</li>
<li>
<p><strong>副版本号</strong>：主版本号相同时，内部进行区分，一般只关心主版本号</p>
</li>
</ul>
<p>低版本无法运行高版本</p>
<p><strong>当主版本不兼容时，解决措施</strong>：</p>
<ul>
<li>
<p>升级 JDK（升级版本，容易引发其他兼容问题，且需要大量测试）</p>
</li>
<li>
<p>讲第三方依赖的版本号降低或更换依赖，以满足 JDK 版本要求（推荐）</p>
</li>
</ul>
</li>
<li>
<p>访问标识：</p>
</li>
<li>
<p>类、父类、接口索引：</p>
</li>
</ul>
<h4 id="常量池"><a class="header-anchor" href="#常量池"></a>常量池</h4>
<blockquote>
<p>保存了字符串常量、类或接口、字段名，主要在字节码指令中使用</p>
</blockquote>
<p>常量池的作用：</p>
<ul>
<li>避免相同内容的重复定义，节省内存（以 String 为例，当有两个 String 变量的字面量相同时，则让这两个字符串变量指向同一块内存空间）</li>
<li>字节码在设计时，会根据字段的属性信息先去找常量池中的 <code>String_info</code>，再根据索引去找常量池中的 <code>info</code>（<code>info</code> 字面量的存在是为了当变量名和字符串文本名一致的时候，可以复用，节省空间），此时才是真正存储字符串文本内容的地方。</li>
<li>此处可以借鉴c++当中的指针思想，a 和 b 两个变量的字面量相同时，同时指向地址变量 c，而地址变量 c 会指向最终的字面量 “val”</li>
</ul>
<h4 id="字段"><a class="header-anchor" href="#字段"></a>字段</h4>
<p>当前类或接口声明的字段信息</p>
<h4 id="方法"><a class="header-anchor" href="#方法"></a>方法</h4>
<p>当前类或接口声明的方法信息字节码指令，由编译器编译生成字节码</p>
<ul>
<li>
<p>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的 Code 属性中。其中，操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。</p>
<p>指令可见 官方 jvm 规范</p>
<ul>
<li>iconst_x</li>
<li>istore_x</li>
<li>iload_i</li>
<li>iadd</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="属性"><a class="header-anchor" href="#属性"></a>属性</h4>
<p>类的属性，如源码的文件名，内部类列表等</p>
<h3 id="常见的字节码工具"><a class="header-anchor" href="#常见的字节码工具"></a>常见的字节码工具</h3>
<p><code>javap</code> 命令：适合在服务器上查看字节码文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -<span class="built_in">cp</span> &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>
<p><code>Arthas</code></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031622612.png" alt="image-20250303162231430" style="zoom:50%;" />
<h2 id="类的生命周期"><a class="header-anchor" href="#类的生命周期"></a>类的生命周期</h2>
<p>类的生命周期描述了一个类加载、使用、卸载的整个过程。类的生命周期主要有五个阶段，分别是：加载、连接(连接里包括验证、准备和解析)、初始化、使用、卸载</p>
<h3 id="应用场景"><a class="header-anchor" href="#应用场景"></a>应用场景</h3>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031631773.png" alt="image-20250303163156675" style="zoom: 50%;" /> 
<h3 id="加载-loading："><a class="header-anchor" href="#加载-loading："></a>加载 loading：</h3>
<ol>
<li>类加载器根据类的全限定名通过不同的渠道以二进制流方式获取字节码信息，开发者可以使用 Java 代码扩展不同的渠道。</li>
<li>类加载完后，jvm 会将字节码中的信息保存到方法区中（方法区是虚拟概念，具体实现有不同），</li>
<li>同时，生成一个 <code>InstanceKlass</code> 对象，保存类的所有信息，里面还包括实现特定功能，如：多态的信息。</li>
<li>除此之外 ，jvm 还会在堆中生成一份和方法区中数据类似的 <code>java.lang.Class</code> 对象，作用是在使用反射时可以在 Java 代码中去获取类的信息以及<strong>存储静态字段的数据</strong>。<code>InstanceKlass</code> 和 <code>java.lang.Class</code> 可以通过一个引用相互关联，<code>InstanceKlass</code> 中信息更丰富，但是有些需要对开发者闭源，并且 <code>InstanceKlass</code> 可以被 C/C++ 操作，是给 JVM 使用的；而 <code>java.lang.Class</code> 是给 Java 开发者使用的。</li>
</ol>
<h3 id="连接-Linking："><a class="header-anchor" href="#连接-Linking："></a>连接 Linking：</h3>
<ul>
<li>
<p><strong>验证</strong>：验证内容是否满足《Java 虚拟机规范》，一般无需开发者参与（参照编译原理的词法、语法检测）</p>
</li>
<li>
<p><strong>准备</strong>：给静态变量分配内存并设置初始值（默认值）</p>
<p>注：如果有 final 关键字，则直接赋值进行初始化。</p>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031735435.png" alt="image-20250303173545369"></p>
<ul>
<li>
<p><strong>解析</strong>：将常量池中的符号引用替换成指向内存的直接引用</p>
<p>直接引用不在使用编号，而是使用内存中地址来访问具体数据</p>
</li>
</ul>
<h3 id="初始化-initialing："><a class="header-anchor" href="#初始化-initialing："></a>初始化 initialing：</h3>
<ul>
<li>
<p>执行<strong>静态代码块</strong>中的代码，并为静态变量赋值,此处的赋值是程序中定义的值，而非准备阶段的默认值</p>
</li>
<li>
<p>执行字节码文件中 clinit 部分的字节码指令</p>
</li>
<li>
<p>以下几种方式会触发类的初始化：</p>
<ol>
<li>访问一个类的静态变量或者静态方法，注意变量是 <code>final</code> 修饰的并且等号右边是常量不会触发初始化（这种在连接阶段就已经赋好值了）。</li>
<li>调用 <code>Class.forName(String className)</code> 时。</li>
<li><code>new</code> 一个该类的对象时。</li>
<li>执行 <code>Main</code> 方法的当前类。</li>
<li>final 修饰的变量如果赋值的内容需要指令才能得出结果，会执行 clinit 方法进行初始化</li>
</ol>
<p>根据上面的内容可以推导最后结果为 D A C B C B</p>
<ul>
<li>首先是静态代码块，在类初始化时最先打印 “D”</li>
<li>而后 main 方法内的 “A”</li>
<li>之后是创建 Main 对象时：因为初始代码块的优先级高于构造函数
<ul>
<li>先执行初始代码块，打印 “C”</li>
<li>再执行构造函数，打印 “B”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 输出结果: DACBCB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.启动main方法，初始化Main类，先走Main的clinit，执行static代码块，打印D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.打印A</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建Main对象，调用构造方法，先走构造代码块，再走无参构造，打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="comment">// 4.重复创建，再次打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>clinit</code> 指令在特定情况下不会出现，比如：</p>
<ol>
<li>无静态代码块且无静态变量赋值语句。</li>
<li>有静态变量的声明，但是没有赋值语句。</li>
<li>静态变量的定义使用 <code>final</code> 关键字，这类变量会在准备阶段直接进行初始化。</li>
<li>数组的创建不会导致数组中<strong>元素的类</strong>进行初始化。</li>
</ol>
</li>
<li>
<p>如果出现继承，则：</p>
<ol>
<li>直接访问父类的静态变量，不会触发子类的初始化</li>
<li>子类的初始化 <code>clinit</code> 调用前，会先调用父类的 <code>clinit</code> 初始化方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出结果为1</span></span><br><span class="line">        <span class="comment">// 因为是直接使用B02的静态变量，这个时候是只走父类的初始化的</span></span><br><span class="line">        <span class="comment">// 如果在前面加上 new B02();   那么就会打印2</span></span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类加载器"><a class="header-anchor" href="#类加载器"></a>类加载器</h2>
<p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术，只参与<strong>加载过程中的字节码获取并加载到内存</strong>这一部分。通过加载字节码数据放入内存转换成 <code>byte[]</code>，接下来调用虚拟机底层方法将 <code>byte[]</code> 转换成方法区和堆中的数据。</p>
<h3 id="类加载器的分类"><a class="header-anchor" href="#类加载器的分类"></a>类加载器的分类</h3>
<ul>
<li>
<p>虚拟机底层实现：源代码位于 Java 虚拟机的源码中，实现语言与虚拟机底层语言一致，如 hotspot 使用 c++</p>
<p>加载程序运行时的基础类被正确加载，如 java.lang.String，确保其可靠性</p>
</li>
<li>
<p>JDK 中默认提供或自定义：jdk 中默认提供了多种处理不同渠道的类加载器，开发者也可以根据需求定制</p>
<p>继承自抽象类 <code>ClassLoader</code> 的所有类加载器</p>
</li>
</ul>
<p>类加载器的设计 JDK 8 和 8 之后的版本差别较大，JDK 8 及之前的版本中默认的类加载器有如下几种：</p>
<ul>
<li>虚拟机底层实现 c++：启动类加载器 Bootstrap，加载 Java 中最核心的类</li>
<li>Java：扩展类加载器 Extension，允许扩展 Java 中比较通用的类；应用程序加载器 Application，加载应用使用的类</li>
</ul>
<h4 id="启动类加载器"><a class="header-anchor" href="#启动类加载器"></a>启动类加载器</h4>
<p>启动类加载器（Bootstrap ClassLoader）是由 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器。</p>
<p>会默认加载 Java 安装目录下 /jre/lib 的类文件，如 rt.jar、tools.jar、resource.jar等</p>
<p>由启动类加载器加载的<strong>基础类</strong>，无法通过 <code>.class.getClassLoader()</code> 来获取类加载器，因为这种方法获取的类加载器是 Java 的类加载器，而并非虚拟机底层的类加载器。</p>
<p>如果要对核心类进行扩展，可以通过启动类加载器去加载用户 jar 包。可用的方法是使用参数进行扩展，在 IDEA 的运行调试配置中添加 <code>-Xbootclasspath/a:jar包目录/jar包名</code> 来进行扩展。</p>
<h4 id="扩展类加载器"><a class="header-anchor" href="#扩展类加载器"></a>扩展类加载器</h4>
<p>ExtClassLoader</p>
<p>扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器。它们的源码都位于 <code>sun.misc.Launcher</code> 中，是一个静态内部类。继承自 <code>URLClassLoader</code>。具备通过目录或者指定 jar 包将字节码文件加载到内存中。在 JDK 8 中主要用来加载 java 安装目录下 <code>/jre/lib/ext</code> 下的扩展类文件。</p>
<p>扩展类加载器主要加载扩展功能（有些功能我们平时并不常用）。如果我们需要编写一些通用但是不常用的 jar 包，可以通过扩展类加载器来进行加载。在 JDK 8 中可以使用 <code>-Djava.ext.dirs=&quot;原始jar包目录;新增jar包目录&quot;</code> 进行扩展。</p>
<h4 id="应用程序加载器"><a class="header-anchor" href="#应用程序加载器"></a>应用程序加载器</h4>
<p>AppClassLoader</p>
<p>应用程序类加载器主要用来加载 <code>classpath</code> 下的类文件，包括了我们自己编写的 java 文件以及第三方库中的类文件。</p>
<h3 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制"></a>双亲委派机制</h3>
<p>功能：</p>
<ul>
<li><strong>保证类加载的安全性</strong>：通过双亲委派机制避免恶意代码替换 JDK 中的核心类库，如：java.lang.String，确保核心类库的完整性和安全性</li>
<li><strong>避免重复加载</strong>：双亲委派机制可以避免同一个类被多次加载</li>
</ul>
<p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下进行加载</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032118133.png" alt="image-20250303211859044"></p>
<p>每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，避免重复加载。否则会将加载请求委派给父类加载器。如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p>
<ul>
<li>向上查找：如果已经加载过，就直接返回 Class 对象，加载过程结束，就能避免类重复加载</li>
<li>向下尝试加载：起到了加载优先级的作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行类声明周期中的连接阶段</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<p>记住 load 和 find</p>
<p><code>loadClass</code> 方法在实现时有进行加锁操作，目的是为了防止多线程环境下被重复加载，调用 <code>findClass</code> 方法查找类是否已经加载了，如果有则直接返回对象，如果没有则会继续向上查找，直到 <code>parent</code> 为空再去查找启动类加载器；如果都为空，则需要一直委派到自己实现的加载器类</p>
<p><strong>双亲委派的核心逻辑</strong>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032159666.png" alt="image-20250303215959586"></p>
<h3 id="打破双亲委派机制"><a class="header-anchor" href="#打破双亲委派机制"></a>打破双亲委派机制</h3>
<p>打破双亲委派机制的方法有三种：</p>
<h4 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器"></a>自定义类加载器</h4>
<p>自定义类加载器并重写 <code>loadClass</code> 方法，就可以将双亲委派机制的代码去除。Tomcat 通过这种方式实现应用之间的类隔离。</p>
<p>一个 Tomcat 程序中是可以运行多个 Web 应用的，如果这两个应用中出现了相同限定名的类，比如 Servlet 类，Tomcat 要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载 Web 应用 1 中的 <code>MyServlet</code> 之后，Web 应用 2 中相同限定名的 <code>MyServlet</code> 类就无法被加载了。所以，Tomcat 使用了自定义类加载器来实现应用之间类的隔离，每一个应用会有一个独立的类加载器加载对应的类。</p>
<p>正确实现一个<strong>自定义类加载器</strong>的方式是重写 <code>findClass</code> 方法，不会破坏双亲委派机制。</p>
<h4 id="线程上下文类加载器"><a class="header-anchor" href="#线程上下文类加载器"></a>线程上下文类加载器</h4>
<p>利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。</p>
<p>JDBC 中使用了 <code>DriverManager</code> 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。<code>DriverManager</code> 类位于 <code>rt.jar</code> 包中，由<strong>启动类加载器</strong>来加载。而我们自己引入的数据库驱动是由<strong>应用程序类加载器</strong>来加载，这违反了双亲委派机制（按照双亲委派机制的正常逻辑，<code>DriverManager</code> 类无法直接访问由应用程序类加载器加载的 JDBC 驱动类，因为类加载器通常只会访问自己或祖先加载器加载的类。但在 JDBC 场景中，<code>DriverManager</code> 却可以访问这些由应用程序类加载器加载的驱动类）。</p>
<p>JDBC 是如何实现这种 “违反” 双亲委派机制的操作呢？</p>
<p>首先，我们先来解决一个问题，就是：<code>DriverManager</code> 是如何知道 <code>jar</code> 包中要加载的驱动在哪儿的？</p>
<p>实际上，JDBC 采用了 JDK 内置的 SPI（Service Provider Interface）机制：</p>
<blockquote>
<p>SPI机制：</p>
<ol>
<li>
<p>JDBC 定义了一个核心接口 <code>java.sql.Driver</code>，所有数据库驱动都需要实现这个接口。例如：</p>
<ul>
<li>MySQL 的驱动实现类是 <code>com.mysql.cj.jdbc.Driver</code>。</li>
<li>PostgreSQL 的驱动实现类是 <code>org.postgresql.Driver</code>。</li>
</ul>
</li>
<li>
<p>每个数据库驱动的 JAR 包中，都会包含一个 SPI 配置文件来主动暴露自己的实现类类名，路径为： <code>META-INF/services/java.sql.Driver</code></p>
<p>配置文件的内容是实现类的全限定名。例如，MySQL 的配置文件中内容为：<code>com.mysql.cj.jdbc.Driver</code></p>
</li>
<li>
<p><code>ServiceLoader</code> 扫描 <code>META-INF/services/java.sql.Driver</code>  文件，找到所有实现了 <code>java.sql.Driver</code> 接口的类、使用类加载器加载驱动类、而后注册驱动到 <code>DriverManager</code>、最后根据 URL 选择合适的驱动创建连接</p>
</li>
</ol>
</blockquote>
<p>观察加载过程我们发现，<strong>驱动文件确实是由应用程序类加载器来加载的</strong>，那么，SPI 中是又是如何获取到应用程序类加载器的呢？实际上，SPI 中使用了线程上下文中保存的类加载器进行类加载（<code>Thread.currentThread().getContextClassLoader()</code>），而被保存的这个类加载器一般是应用程序类加载器（通过该线程上下文可以在程序任何地方获取到类加载器）。</p>
<p>不过，JDBC 只是在 <code>DriverManager</code> 加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依旧遵循双亲委派机制，所以，从这个角度上看，JDBC 的驱动加载并不会真正打破双亲委派机制。</p>
<h4 id="Osgi-框架的类加载器"><a class="header-anchor" href="#Osgi-框架的类加载器"></a>Osgi 框架的类加载器</h4>
<p>历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载。Osgi 还是用类加载器实现了热部署（指在服务不停止的情况下，动态更新字节码文件到内存中）的功能。</p>
<p>不过，现如今我们可以使用 Arthas 来帮助我们进行热部署，基本步骤如下：</p>
<ol>
<li>在服务器上部署 arthas，并启动。</li>
<li><code>jad --source-only 类全限定名 &gt; 目录/文件名.java</code>，利用 <code>jad</code> 命令反编译，然后可以用其他编译器，比如 vim 来修改源码。</li>
<li><code>sc -d 类全限定名</code>，利用 <code>sc</code> 命令查看类对应的类加载器 hashcode。</li>
<li><code>mc -c 类加载器的hashcode 目录/文件名.java -d 输出目录</code>，使用 <code>mc</code> 命令来编译修改过的代码。</li>
<li><code>retransform class文件所在目录/xxx.class</code>，用 <code>retransform</code> 命令加载新的字节码。</li>
<li><strong>注意事项</strong>：程序重启之后，字节码文件会恢复（因为 <code>retransform</code> 是做内存上的更新），除非将 class 文件放入 jar 包中进行更新。并且，<code>retransform</code> 也不能添加方法或者字段，也不能更新正在执行中的方法。（只能当做一种应急手段）</li>
</ol>
<h3 id="JDK-9-之后的类加载器"><a class="header-anchor" href="#JDK-9-之后的类加载器"></a>JDK 9 之后的类加载器</h3>
<p>JDK 9 引入了 module 的概念，类加载器设计上有了很多变化</p>
<ol>
<li>
<p>启动类加载器使用 Java 编写，位于 <code>jdk.internal.loader.ClassLoader</code> 类中。Java 中的 <code>BootClassLoader</code> 继承自 <code>BuiltinClassLoader</code>，实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过 java 代码获取到，返回的仍然是 null，保持了统一。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936205.png" alt="image-20250304093613115"></p>
</li>
<li>
<p>扩展类加载器被替换成了平台类加载器（Platform Class Loader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，<strong>自身没有特殊逻辑</strong>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936512.png" alt="image-20250304093642439"></p>
</li>
<li>
<p>应用程序类加载器的继承关系发生了改变，从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，其余没有特殊变化。</p>
</li>
</ol>
<h2 id="JMM运行时数据区"><a class="header-anchor" href="#JMM运行时数据区"></a>JMM运行时数据区</h2>
<h3 id="什么是运行时数据区"><a class="header-anchor" href="#什么是运行时数据区"></a>什么是运行时数据区</h3>
<p>运行时数据区指的是：jvm 在运行 Java 程序过程中管理的内存区域</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040942498.png" alt="image-20250304094232418" style="zoom:67%;" />
<blockquote>
<p>线程不共享：每当创建一个线程，每一个线程都有一份独立的<strong>程序计数器、Java 虚拟机栈、本地方法栈</strong>，数据不共享，但安全性高</p>
<p>线程共享：数据共享，每个线程都可以获取与使用，线程不安全</p>
</blockquote>
<h3 id="程序计数器"><a class="header-anchor" href="#程序计数器"></a>程序计数器</h3>
<p>程序计数器（Program Counter Register），也叫 PC 寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令地址。</p>
<p>加载阶段，jvm 讲字节码文件中的指令读取到内存后，会将原文件中的偏移量转换成内存地址。每一天字节码指令都会有一个内存地址。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040953897.png" alt="image-20250304095304805" style="zoom:67%;" />
<p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p>
<p>在多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到的那一句指令并继续执行</p>
<blockquote>
<p><strong>内存溢出</strong>是指程序在使用某一刻区域时，存放的数据需要占用的内存大小超出了虚拟机可以提供的内存上限</p>
<p>每个线程只存储固定长度的内存地址，因此程序计数器不会发生内存溢出</p>
</blockquote>
<h3 id="栈"><a class="header-anchor" href="#栈"></a>栈</h3>
<h4 id="Java-虚拟机栈"><a class="header-anchor" href="#Java-虚拟机栈"></a>Java 虚拟机栈</h4>
<p>Java 虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，FILO，每个方法的调用使用一个栈帧（Stack Frame）来保存</p>
<p>Java 代码在遇到异常，报错的时候，会把异常时的栈帧信息打印出来。也就是说，发生异常时，控制台上打印出来的，是栈帧信息。</p>
<p>Java 虚拟机栈随线程创建而创建，而回收则会在线程的销毁时进行。</p>
<h4 id="栈帧的组成"><a class="header-anchor" href="#栈帧的组成"></a>栈帧的组成</h4>
<ul>
<li>
<p>局部变量表：主要作用是方法执行过程中存放所有的局部变量。编译成字节码文件时就可以确定局部变量表的内容。栈帧中的局部变量表本质上是一个数组，数组中每个位置称之为槽（slot），long 和 double 类型占用两个槽，其他类型占用一个槽</p>
<p>在字节码文件记录的局部变量表信息中，<code>Nr.</code> 表示局部变量的编号，<code>起始PC</code> 和 <code>长度</code> 划定了局部变量生效的范围，<code>序号</code> 表示变量在栈帧中槽的起始编号。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041017338.png" alt="image-20250304101742258" style="zoom: 80%;" />
<p>实例方法中的序号为 0 的位置存放的是 this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041018955.png" alt="image-20250304101808880"></p>
<p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致</p>
<p>局部变量表会保存的内容有：实例方法的 <code>this</code> 对象，方法的参数，方法体中声明的局部变量</p>
<p>为了节省空间，局部变量表中的槽可以复用，一旦某个局部变量不再失效，当前槽可以再次被使用。当某个变量已经不再被使用，则可以将变量丢弃后把槽给新的变量使用。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041023902.png" alt="image-20250304102312810" style="zoom:80%;" />
</li>
<li>
<p>操作数栈：是在虚拟机执行指令过程中存放临时数据或中间数据的，也是一种栈式结构，在编译期就可以确定操作数栈的最大深度，进而在执行时正确分配内存大小</p>
</li>
<li>
<p>帧数据：主要包含动态链接、方法出口、异常表的引用。</p>
<p><strong>动态链接</strong>：当前类的字节码指令引用了其他类的属性或方法时，需要将符合引用（编号）转换成对应的运行时常量池中的内存地址，动态链接（类似于一个map表）就保存了编号到运行时常量池的内存地址的映射关系。</p>
<p><strong>方法出口</strong>：方法在正确或异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址，所以当前栈帧中，需要存储此方法出口的地址</p>
<p><strong>异常表</strong>：存放代码异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p>
</li>
</ul>
<p>每个栈的空间是有限的，如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出，出现 <code>StackOverflowError</code> 的错误（系统级错误，程序无法运行）。虚拟机设置中，可以使用 <code>-Xss栈大小</code> 来设置栈帧最大大小，不过必须是 <em>1024</em> 的倍数。Win（64位）下的 JDK 8 测试最小值位 180 K，最大为 1024 M。一般来说，工作中即使使用了递归操作，栈的深度最多也只能到几百，不会出现栈溢出。所以可以手动指定参数为 <code>-Xss256k</code> 来节省内存。</p>
<h4 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"></a>本地方法栈</h4>
<p>除了 Java 虚拟机，栈区还包括本地方法栈。Java 虚拟机栈存储了 Java 方法调用时的栈帧，而本地方法栈存储的是 native 本地方法的栈帧。在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存中生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。(了解即可)</p>
<h3 id="堆"><a class="header-anchor" href="#堆"></a>堆</h3>
<ul>
<li>
<p>一般 Java 程序中堆内存是空间<strong>最大的一块内存</strong>区域。创建出来的对象都存在堆上。</p>
<p>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<p>堆内存大小是有上限的，当对象一直向堆中放入对象达到上限后，就会抛出 <code>OutOfMemory</code> 错误。</p>
</li>
<li>
<p>堆空间有三个需要关注的值：used、total、max。</p>
<ul>
<li>used 指的是当前已经使用的堆内存，</li>
<li>total 指的是 Java 虚拟机已经分配的可用堆内存</li>
<li>max 是 Java 虚拟机可以分配的最大堆内存</li>
</ul>
<p>随着堆中的对象增多，当 total 可以使用的内存即将不足时，jvm 会继续分配内存给堆。【注：并不是当 used = max = total】时，堆内存才溢出，堆内存溢出的判断条件比较复杂，在垃圾回收章节再详细介绍。</p>
</li>
<li>
<p>如果不设置任何的虚拟机参数，max 默认是系统内存的四分之一，total 默认是系统内存的六十四分之一。在实际应用中一般都需要 total 和 max 的值。使用 <code>-Xmx</code> 修改 max 值（必须大于 2 M），<code>-Xms</code> 修改 total 值（必须大于 1 M）。在服务端程序开发时，建议将 max 值和 total 值设置为相同的值，这样程序启动后可使用的总内存就是最大内存，无需向 JVM 申请，减少申请空间的额外开销</p>
</li>
<li>
<p>需要注意的是，如果使用 Arthas 显示 heap 堆大小，会发现其和设置的值并不相同。这是因为 Arthas 使用的是 JMX 技术中的内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。</p>
</li>
</ul>
<h3 id="方法区"><a class="header-anchor" href="#方法区"></a>方法区</h3>
<p>方法区是《Java 虚拟机规范》中设计的虚拟概念，每款虚拟机设计各不相同。Hotspot 的设计如下：</p>
<ul>
<li>JDK 7 及之前的版本将方法存放在<strong>堆区域</strong>中的永久代空间里，堆的大小由虚拟机参数 <code>-XX:MaxPermSize=值</code> 控制。</li>
<li>JDK 8 及之后的版本将方法去存放在<strong>元空间</strong>中，元空间位于操作系统维护的<strong>直接内存</strong>中，默认情况下只要不超过系统承受的上限，可以一直分配。可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大大小进行限制。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041446781.png" alt="方法区不同JDK版本中实现对比图"></p>
<p>方法区是存放基础信息的位置，线程共享，主要包含三个内容：</p>
<p><strong>类的元信息</strong>：保存所有类的基本信息</p>
<ul>
<li>存储每个类的基本信息（元信息），一般称之为 InstanceKlass 对象。在类<strong>加载阶段</strong>完成。</li>
</ul>
<p><strong>运行时常量池</strong>：保存字节码文件中的常量池内容</p>
<ul>
<li>字节码文件中是通过编号查表的方式找到常量的，这种常量池称之为静态常量池。</li>
<li>当常量池加载到内存中后，可以通过内存地址快速的定位常量池中的内容，这种常量池称之为动态常量池</li>
<li>核心：将原本由编号查询常量的方式替换成用内存地址的方式去查询</li>
</ul>
<p><strong>字符串常量池</strong>：（字节码文件中有一部分区域时字符串常量池）字符串常量池存储在代码中定义的常量字符串内容</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041529238.png" alt="image-20250304152918152"></p>
<p>与运行时常量池作用接近：早期设计中，字符串常量池是属于运行时常量池的一部分，存储的位置也一致。后续做出了调整，进行了拆分</p>
<ul>
<li>JDK 7 之前：运行时常量池包含了字符串常量池，都位于永久代中</li>
<li>JDK 7 ：字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li>
<li>JDK 8 ：永久代修改为元空间，字符串常量池还在堆中</li>
</ul>
<p>可以使用 <code>intern</code> 方法主动把字符串放到字符串常量池中，JDK 6 版本的 <code>intern</code> 方法会把第一次遇到的字符串实例复制一份到字符串常量池中；而 JDK 7 及以后因为字符串常量池就在堆上，故是在堆上复制一个引用到字符串常量池中。并且，因为载入基础包等原因，JVM 在加载后，字符串常量池中会默认加载完毕 <code>java</code> 等字符串。</p>
<p>【注：在不同版本的 JDK 当中，静态变量的存放也是不同的，在 JDK 6 及其之前版本，静态变量存放在方法区也就是永久代中，JDK 7 之后的版本中，静态变量是存放在堆区的 Class 对象中，脱离了永久代】</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041449067.png" alt="JDK6 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451007.png" alt="JDK7 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451165.png" alt="JDK8 的 运行时数据区结构"></p>
<h3 id="直接内存"><a class="header-anchor" href="#直接内存"></a>直接内存</h3>
<p>直接内存（Direct Memory）并不在《Java 虚拟机规范》中存在，所以<strong>并不属于 Java 运行时的内存区域</strong>，而是由操作系统本地分配的内存区域。虽然直接内存不是虚拟机运行时数据区的一部分，但是使用也被频繁使用，也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>在 JDK 1.4 中引入了 NIO（Non-Blocking I/O，也被称为 New I/O） 机制，使用了直接内存，主要为了解决两个问题：</p>
<ol>
<li>Java 堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li>
<li>IO 操作，如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到 Java 堆中，现在直接放入直接内存即可，同时 Java 堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路</li>
</ol>
<p>要创建直接内存上的数据，可以使用 <code>ByteBuffer</code>，语法（Arthas 的 <code>memory</code> 命令可以直接查看直接内存的大小，属性名 <code>direct</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(size);</span><br></pre></td></tr></table></figure>
<p>如果要手动调整直接内存的大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code>，来为 JVM 的直接内存分配大小。</p>
<h2 id="自动垃圾回收"><a class="header-anchor" href="#自动垃圾回收"></a>自动垃圾回收</h2>
<p>在 C/C++ 这类没有自动垃圾回收机制的语言中，一个对象如果不在使用需要手动释放，否则会造成<strong>内存泄漏</strong>的问题（内存泄漏的累计会导致内存溢出）。释放对象的过程称之为垃圾回收，而程序员需要手动编码进行回收的方式称之手动回收。</p>
<p>Java 中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection 简称 GC）机制。通过垃圾回收器来对不在使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言，如 C#、Python、Go 都有自己的垃圾回收器。如果想要查看垃圾回收的信息，可以通过 <code>verbose:gc</code> 参数。</p>
<p>线程不共享的部分（程序计数器、Java 虚拟机栈、本地方法栈），都是随着线程的创建而创建、线程的销毁而销毁。方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。</p>
<h3 id="方法区的回收"><a class="header-anchor" href="#方法区的回收"></a>方法区的回收</h3>
<p>方法区中能回收的内容主要是不在使用的类。判定一个类是否可以被<strong>卸载</strong>（类的生命周期当中最后一个），需要同时满足三个条件：</p>
<ol>
<li>
<p>此类所有实例对象都已经被回收，在堆中已经不存在任何该类的实例对象以及子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加载该类的类加载器已经被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:D:\\lib\\&quot;</span>)&#125;</span><br><span class="line">);</span><br><span class="line">loader = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该类对应的 java.lang.Class 对象没有在任何地方被引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果需要手动触发垃圾回收，可以调用 System.gc 方法。调用该方法并不一定会立即触发垃圾回收，仅仅是发送一个请求，具体是否执行回收操作由 Java 虚拟机自行判断</p>
<p>开发中此类场景一般很少出现，主要是在 OSGI、JSP 的热部署等应用场景中，每个 jsp 文件对应一个唯一的类加载器，当一个 jsp 文件修改了，就直接卸载这个 jsp 类加载器。重新创建类加载器，重新加载 jsp 文件。</p>
<h3 id="堆回收"><a class="header-anchor" href="#堆回收"></a>堆回收</h3>
<p>Java 中的对象是否能够被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许回收。</p>
<p>判断堆上的对象是否被引用的判断方法：引用计数法和可达性分析法。</p>
<h4 id="引用计数法"><a class="header-anchor" href="#引用计数法"></a>引用计数法</h4>
<p>引用计数法会为每个对象维护一个引用计数器，当对象被引用时加 1，取消引用时减 1。</p>
<p>优点：实现简单，C++ 中的智能指针就是采用了引用计数法</p>
<p>缺点：</p>
<ol>
<li>每次引用和取消引用都需要维护计数器，影响性能</li>
<li>存在循环引用的问题，当 A 中有 B，B 中有 A 的情况下，会出现 AB 都无法回收的问题。</li>
</ol>
<h4 id="可达性分析"><a class="header-anchor" href="#可达性分析"></a>可达性分析</h4>
<p>Java 使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。</p>
<p>所有普通对象都会和根对象形成引用关系，如果某个对象是从 GC Root 沿着引用链达的，那么对象就不会回收。</p>
<p>GC Root 对象主要有：</p>
<ul>
<li>线程 Thread 对象，引用线程栈帧中的方法参数、局部变量等。</li>
<li>系统类加载器加载的 java.lang.Class 对象，引用类中的静态变量</li>
<li>监视器对象，用来保存同步锁 synchronized 关键字持有的对象。</li>
<li>本地方法调用时使用的全局对象。</li>
</ul>
<h3 id="五种对象引用"><a class="header-anchor" href="#五种对象引用"></a>五种对象引用</h3>
<p>可达性算法中描述的对象引用，一般指的是强引用，即 GC Root 对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/">http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E5%BA%95%E5%B1%82/">java 底层</a><a class="post-meta__tags" href="/tags/jvm/">jvm</a></div><div class="post-share"><div class="social-share" data-image="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041400507.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题解决方案"><img class="cover" src="/./img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">跨域问题解决方案</div></div><div class="info-2"><div class="info-item-1">收录常见的跨域问题解决方案</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/elasticsearch%E5%9F%BA%E7%A1%80%E7%AF%87/" title="es 基础篇"><img class="cover" src="/./img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">es 基础篇</div></div><div class="info-2"><div class="info-item-1">Elasticsearch学习  官方文档，学习过程中遇到任何问题首先是尝试从官方文档中查找解决方法，同时也可以加深自己对技术特性的了解  Elasticsearch 生态丰富 elasticsearch 生态丰富，包含一系列工具和功能，帮助用户处理、分析和可视化数据， 核心组成为：  Elasticsearch：核心搜索引擎，负责存储、索引和搜索数据 Kibana：可视化平台、用于查询、分析和展示 Elasticsearch 中的数据 Logstash：数据处理管道，负责数据收集、过滤、增强和传输到 Elasticsearch。 Beats：轻量级的数据传输工具，收集和发生数据到 Logstash 或 Elasticsearch  核心概念  索引 index：类似于关系型数据库中的表，索引是数据存储和搜索的 基本单位，每个索引可以存储多条文档数据 文档 document：索引中的每条记录，类似于数据库中的行。以 json 格式存储 字段 field：文档中的每个键值对，类似于数据库中的列。 映射 mapping：（类似于 sql 建表语句）用于定义...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-JVM"><span class="toc-number">1.1.</span> <span class="toc-text">认识 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvms%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">jvms三大核心功能：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">JVM 的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">字节码文件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">基础信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">常见的字节码工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-loading%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">加载 loading：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-Linking%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">连接 Linking：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-initialing%EF%BC%9A"><span class="toc-number">1.4.4.</span> <span class="toc-text">初始化 initialing：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">应用程序加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">自定义类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Osgi-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Osgi 框架的类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-9-%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">JDK 9 之后的类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">JMM运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">Java 虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">栈帧的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.6.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.6.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.7.</span> <span class="toc-text">自动垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">方法区的回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9B%9E%E6%94%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">堆回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">可达性分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">五种对象引用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法"><img src="/./img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/2025/03/18/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-03-18T12:43:53.000Z" title="发表于 2025-03-18 20:43:53">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/14/MySQL/MySql%E8%BF%9B%E9%98%B6/" title="MySql进阶"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql进阶"/></a><div class="content"><a class="title" href="/2025/03/14/MySQL/MySql%E8%BF%9B%E9%98%B6/" title="MySql进阶">MySql进阶</a><time datetime="2025-03-14T06:08:13.000Z" title="发表于 2025-03-14 14:08:13">2025-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" title="IO流"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO流"/></a><div class="content"><a class="title" href="/2025/03/07/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" title="IO流">IO流</a><time datetime="2025-03-07T08:13:04.000Z" title="发表于 2025-03-07 16:13:04">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/%E6%8F%92%E4%BB%B6/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="mybatis-plus插件使用"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis-plus插件使用"/></a><div class="content"><a class="title" href="/2025/03/07/%E6%8F%92%E4%BB%B6/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="mybatis-plus插件使用">mybatis-plus插件使用</a><time datetime="2025-03-07T01:55:42.000Z" title="发表于 2025-03-07 09:55:42">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/%E6%8F%92%E4%BB%B6/lombok%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="lombok插件使用"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lombok插件使用"/></a><div class="content"><a class="title" href="/2025/03/07/%E6%8F%92%E4%BB%B6/lombok%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" title="lombok插件使用">lombok插件使用</a><time datetime="2025-03-07T01:51:11.000Z" title="发表于 2025-03-07 09:51:11">2025-03-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>