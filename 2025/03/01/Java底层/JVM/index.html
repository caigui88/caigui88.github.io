<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>jvm 学习笔记 | Moru</title><meta name="author" content="moru"><meta name="copyright" content="moru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM  本文参考资料： 黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili  认识 JVM jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。 jvms三大核心功能：  解释与运行：对字节码文件中的指令实时解释为机器码">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm 学习笔记">
<meta property="og:url" content="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/index.html">
<meta property="og:site_name" content="Moru">
<meta property="og:description" content="JVM  本文参考资料： 黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili  认识 JVM jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。 jvms三大核心功能：  解释与运行：对字节码文件中的指令实时解释为机器码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503200026081.png">
<meta property="article:published_time" content="2025-03-01T03:35:47.081Z">
<meta property="article:modified_time" content="2025-03-31T07:04:52.119Z">
<meta property="article:author" content="moru">
<meta property="article:tag" content="java 底层">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503200026081.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "jvm 学习笔记",
  "url": "http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/",
  "image": "https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503200026081.png",
  "datePublished": "2025-03-01T03:35:47.081Z",
  "dateModified": "2025-03-31T07:04:52.119Z",
  "author": [
    {
      "@type": "Person",
      "name": "墨儒",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/butterfly-icon.png"><link rel="canonical" href="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jvm 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(./img/sky.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503200026081.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011730967.png" alt="Logo"><span class="site-name">Moru</span></a><a class="nav-page-title" href="/"><span class="site-name">jvm 学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">jvm 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T03:35:47.081Z" title="发表于 2025-03-01 11:35:47">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-31T07:04:52.119Z" title="更新于 2025-03-31 15:04:52">2025-03-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM"><a class="header-anchor" href="#JVM"></a>JVM</h1>
<blockquote>
<p>本文参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="认识-JVM"><a class="header-anchor" href="#认识-JVM"></a>认识 JVM</h2>
<p>jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。</p>
<h3 id="jvms三大核心功能："><a class="header-anchor" href="#jvms三大核心功能："></a>jvms三大核心功能：</h3>
<ol>
<li>解释与运行：对字节码文件中的指令实时解释为机器码，交由计算机执行</li>
<li>内存管理：自动为对象、方法分配内存；垃圾回收机制，自动监测和回收不再使用的对象</li>
<li>即时编译：将热点代码翻译为机器码后会将这段机器码存储到内存中，避免重复翻译导致的时耗</li>
</ol>
<p>常见的 jvm：Hotspot、GraalVM、OpenJ9等，另外 DragonWell 龙井 JDK 也提供了一款功能增强版的 JVM。我们平时默认使用的虚拟机是 Oracle 官方的 HotSpot。</p>
<h2 id="JVM-的组成"><a class="header-anchor" href="#JVM-的组成"></a>JVM 的组成</h2>
<ul>
<li>
<p><strong>类加载器</strong>：ClassLoader，作用是把从外界（磁盘或网络）读取的字节码文件加载到内存中</p>
</li>
<li>
<p><strong>运行时数据区域</strong>：负责管理 jvm 使用到的内存（方法区、堆区）</p>
<p>如：字节码文件通过类加载器加载后会存放在该区域。</p>
</li>
<li>
<p><strong>执行引擎</strong>：包括<strong>即时编译器、解释器、垃圾回收器</strong>等。负责将字节码文件中的指令解释成机器码，同时调用即时编译器优化性能。</p>
</li>
<li>
<p><strong>本地接口</strong>：调用本地已经编译的方法，如虚拟机中提供的 c/c++方法。（HotSpot 虚拟机本身由 c++ 编写，一些底层接口需要调用相关方法）</p>
</li>
</ul>
<p>示意图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031514092.png" alt="img"></p>
<h2 id="字节码"><a class="header-anchor" href="#字节码"></a>字节码</h2>
<p>本文学习过程中使用  <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib">jclasslib</a>  工具查看字节码文件。使用 <a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">Arthas</a> 进行线上监控诊断。</p>
<h3 id="字节码文件的组成"><a class="header-anchor" href="#字节码文件的组成"></a>字节码文件的组成</h3>
<p>字节码文件以二进制组成，保存的是源代码编译后的信息，主要组成部分有：基础信息、常量池、字段、方法（字节码指令）、属性（类的属性信息：源码的文件名，内部类列表等）</p>
<h4 id="基础信息"><a class="header-anchor" href="#基础信息"></a>基础信息</h4>
<blockquote>
<ul>
<li>魔数</li>
<li>字节码文件对应的 Java 版本号</li>
<li>访问标识</li>
<li>父类和接口</li>
</ul>
</blockquote>
<ul>
<li>
<p>魔数 Magic：java 字节码文件的文件头（文件的起始的几个固定字节 <code>ca fe ba be</code>）称之为 魔数</p>
<ul>
<li>
<p>文件无法通过文件拓展名来确定文件类型，文件拓展名可以随意修改，不影响文件的内容</p>
</li>
<li>
<p>软件通过文件的文件头去校验文件的类型，如果软件不支持该类型就会报错</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031451968.png" alt="魔数"></p>
<ul>
<li>
<p>版本号：</p>
<ul>
<li>
<p><strong>主版本号</strong>：java 的主版本号 - 44 即可知道当前 jdk 版本</p>
</li>
<li>
<p><strong>副版本号</strong>：主版本号相同时，内部进行区分，一般只关心主版本号</p>
</li>
</ul>
<p>低版本无法运行高版本</p>
<p><strong>当主版本不兼容时，解决措施</strong>：</p>
<ul>
<li>
<p>升级 JDK（升级版本，容易引发其他兼容问题，且需要大量测试）</p>
</li>
<li>
<p>讲第三方依赖的版本号降低或更换依赖，以满足 JDK 版本要求（推荐）</p>
</li>
</ul>
</li>
<li>
<p>访问标识：</p>
</li>
<li>
<p>类、父类、接口索引：</p>
</li>
</ul>
<h4 id="常量池"><a class="header-anchor" href="#常量池"></a>常量池</h4>
<blockquote>
<p>保存了字符串常量、类或接口、字段名，主要在字节码指令中使用</p>
</blockquote>
<p><strong>常量池的作用</strong>：</p>
<ul>
<li><strong>避免相同内容的重复定义</strong>，节省内存（以 String 为例，当有两个 String 变量的字面量相同时，则让这两个字符串变量指向同一块内存空间）</li>
<li>字节码在设计时，会根据字段的属性信息先去找常量池中的 <code>String_info</code>，再根据索引去找常量池中的 <code>info</code>（<code>info</code> 字面量的存在是为了当变量名和字符串文本名一致的时候，可以复用，节省空间），此时才是真正存储字符串文本内容的地方。</li>
<li>此处可以借鉴c++当中的指针思想，a 和 b 两个变量的字面量相同时，同时指向地址变量 c，而地址变量 c 会指向最终的字面量 “val”</li>
</ul>
<h4 id="字段"><a class="header-anchor" href="#字段"></a>字段</h4>
<p>当前类或接口声明的字段信息</p>
<h4 id="方法"><a class="header-anchor" href="#方法"></a>方法</h4>
<p>当前类或接口声明的方法信息字节码指令，由编译器编译生成字节码</p>
<ul>
<li>
<p>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的 Code 属性中。其中，操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。</p>
<p>指令可见 官方 jvm 规范</p>
<ul>
<li>iconst_x</li>
<li>istore_x</li>
<li>iload_i</li>
<li>iadd</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="属性"><a class="header-anchor" href="#属性"></a>属性</h4>
<p>类的属性，如源码的文件名，内部类列表等</p>
<h3 id="常见的字节码工具"><a class="header-anchor" href="#常见的字节码工具"></a>常见的字节码工具</h3>
<p><code>javap</code> 命令：适合在服务器上查看字节码文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -<span class="built_in">cp</span> &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>
<p><code>Arthas</code></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031622612.png" alt="image-20250303162231430" style="zoom:50%;" />
<h2 id="类的生命周期"><a class="header-anchor" href="#类的生命周期"></a>类的生命周期</h2>
<p>类的生命周期描述了一个类加载、使用、卸载的整个过程。类的生命周期主要有五个阶段，分别是：<strong>加载</strong>、<strong>连接</strong>(连接里包括<strong>验证、准备和解析</strong>)、<strong>初始化</strong>、<strong>使用</strong>、<strong>卸载</strong></p>
<h3 id="应用场景"><a class="header-anchor" href="#应用场景"></a>应用场景</h3>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031631773.png" alt="image-20250303163156675" style="zoom: 50%;" /> 
<h3 id="加载-loading："><a class="header-anchor" href="#加载-loading："></a>加载 loading：</h3>
<ol>
<li>类加载器根据类的全限定名通过不同的渠道（因为可以是本地文件加载或者网络传输加载）以<strong>二进制流方式</strong>获取字节码信息，开发者可以使用 Java 代码扩展不同的渠道。</li>
<li>类加载完后，jvm 会将字节码中的信息保存到方法区中（方法区是虚拟概念，具体实现有不同）。</li>
<li>同时，在方法区生成一个 <code>InstanceKlass</code> 对象，保存类的所有信息，里面还包括实现特定功能，如：多态的信息。</li>
<li>除此之外 ，jvm 还会在堆中生成一份和方法区中数据类似的 <code>java.lang.Class</code> 对象，作用是在使用反射时可以在 Java 代码中去获取类的信息以及<strong>存储静态字段的数据</strong>。<code>InstanceKlass</code> 和 <code>java.lang.Class</code> 可以通过一个<strong>引用相互关联</strong>，<code>InstanceKlass</code> 中信息更丰富，但是有些需要对开发者闭源，并且 <code>InstanceKlass</code> 可以被 C/C++ 操作，是给 JVM 使用的；而 <code>java.lang.Class</code> 是给 Java 开发者使用的。</li>
</ol>
<h3 id="连接-Linking："><a class="header-anchor" href="#连接-Linking："></a>连接 Linking：</h3>
<ul>
<li>
<p><strong>验证</strong>：验证内容是否满足《Java 虚拟机规范》，一般无需开发者参与（参照编译原理的词法、语法检测）</p>
</li>
<li>
<p><strong>准备</strong>：给静态变量分配内存并设置初始值（默认值）</p>
<p>注：如果有 final 关键字，则直接赋值进行初始化。</p>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031735435.png" alt="image-20250303173545369"></p>
<ul>
<li>
<p><strong>解析</strong>：将常量池中的符号引用替换成指向内存的直接引用</p>
<p>直接引用不在使用编号，而是使用内存中地址来访问具体数据</p>
</li>
</ul>
<h3 id="初始化-initialing："><a class="header-anchor" href="#初始化-initialing："></a>初始化 initialing：</h3>
<ul>
<li>
<p>执行<strong>静态代码块</strong>中的代码，并为静态变量赋值,此处的赋值是程序中定义的值，而非准备阶段的默认值</p>
</li>
<li>
<p>执行字节码文件中 clinit 部分的字节码指令</p>
</li>
<li>
<p>以下几种方式会触发类的初始化：</p>
<ol>
<li>访问一个类的静态变量或者静态方法，【注意变量是 <code>final</code> 修饰的并且等号右边是<strong>常量不会触发初始化</strong>（这种在连接阶段就已经赋好值了）。】</li>
<li>调用 <code>Class.forName(String className)</code> 时。反射调用时</li>
<li><code>new</code> 一个该类的对象时。最常见的手动创建</li>
<li>执行 <code>Main</code> 方法的当前类。开启了一个线程</li>
<li>final 修饰的变量如果赋值的内容并非常量，会执行 clinit 方法进行初始化</li>
</ol>
<p>推测下面的打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 输出结果: DACBCB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.启动main方法，初始化Main类，先走Main的clinit，执行static代码块，打印D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.打印A</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建Main对象，调用构造方法，先走构造代码块，再走无参构造，打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="comment">// 4.重复创建，再次打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 初始化代码块，比构造方法先执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据上面的内容可以推导最后结果为 D A C B C B</p>
<ul>
<li>首先是静态代码块，在类初始化时最先打印 “D”</li>
<li>而后 main 方法内的 “A”</li>
<li>之后是创建 Main 对象时：因为初始代码块的优先级高于构造函数
<ul>
<li>先执行初始代码块，打印 “C”</li>
<li>再执行构造函数，打印 “B”</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>clinit</code> 指令在特定情况下不会出现，比如：</p>
<ol>
<li>无静态代码块且无静态变量赋值语句。</li>
<li>有静态变量的声明，但是没有赋值语句。</li>
<li>静态变量的定义使用 <code>final</code> 关键字，这类变量会在准备阶段直接进行初始化。</li>
<li>数组的创建不会导致数组中<strong>元素的类</strong>进行初始化。</li>
</ol>
</li>
<li>
<p>如果出现继承，则：</p>
<ol>
<li>直接访问父类的静态变量，不会触发子类的初始化</li>
<li>子类的初始化 <code>clinit</code> 调用前，会先调用父类的 <code>clinit</code> 初始化方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出结果为1</span></span><br><span class="line">        <span class="comment">// 因为是直接使用B02的静态变量，这个时候是只走父类的初始化的</span></span><br><span class="line">        <span class="comment">// 如果在前面加上 new B02();   那么就会打印2</span></span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类加载器"><a class="header-anchor" href="#类加载器"></a>类加载器</h2>
<p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术，只参与<strong>加载过程中的字节码获取并加载到内存</strong>这一部分。通过加载字节码数据放入内存转换成 <code>byte[]</code>，接下来调用虚拟机底层方法将 <code>byte[]</code> 转换成方法区和堆中的数据。</p>
<h3 id="类加载器的分类"><a class="header-anchor" href="#类加载器的分类"></a>类加载器的分类</h3>
<ul>
<li>
<p>虚拟机底层实现：源代码位于 Java 虚拟机的源码中，实现语言与虚拟机底层语言一致，如 hotspot 使用 c++</p>
<p>加载程序运行时的基础类被正确加载，如 java.lang.String，确保其可靠性</p>
</li>
<li>
<p>JDK 中默认提供或自定义：jdk 中默认提供了多种处理不同渠道的类加载器，开发者也可以根据需求定制（通过继承自抽象类 <code>ClassLoader</code> 的所有类加载器）</p>
</li>
</ul>
<p>类加载器的设计 JDK 8 和 8 之后的版本差别较大，JDK 8 及之前的版本中默认的类加载器有如下几种：</p>
<ul>
<li>虚拟机底层实现 c++：启动类加载器 Bootstrap，加载 Java 中最核心的类</li>
<li>Java：扩展类加载器 Extension，允许扩展 Java 中比较通用的类；应用程序加载器 Application，加载应用使用的类</li>
</ul>
<h4 id="启动类加载器"><a class="header-anchor" href="#启动类加载器"></a>启动类加载器</h4>
<p>启动类加载器（Bootstrap ClassLoader）是由 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器。</p>
<p>会默认加载 Java 安装目录下 /jre/lib 的类文件，如 rt.jar、tools.jar、resource.jar等</p>
<p>由启动类加载器加载的<strong>基础类</strong>，无法通过 <code>.class.getClassLoader()</code> 来获取类加载器，因为这种方法只能获取 Java 的类加载器，而并非虚拟机底层的类加载器。</p>
<p>如果要对核心类进行扩展，可以通过启动类加载器去加载用户 jar 包。可用的方法是使用参数进行扩展，在 IDEA 的运行调试配置中添加 <code>-Xbootclasspath/a:jar包目录/jar包名</code> 来进行扩展。</p>
<h4 id="扩展类加载器"><a class="header-anchor" href="#扩展类加载器"></a>扩展类加载器</h4>
<p>ExtClassLoader</p>
<p>扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器。它们的源码都位于 <code>sun.misc.Launcher</code> 中，是一个静态内部类。继承自 <code>URLClassLoader</code>。可以通过目录或者指定 jar 包将字节码文件加载到内存中。在 JDK 8 中主要用来加载 java 安装目录下 <code>/jre/lib/ext</code> 下的扩展类文件。</p>
<p>扩展类加载器主要加载扩展功能（有些功能我们平时并不常用）。如果我们需要编写一些通用但是不常用的 jar 包，可以通过扩展类加载器来进行加载。在 JDK 8 中可以使用 <code>-Djava.ext.dirs=&quot;原始jar包目录;新增jar包目录&quot;</code> 进行扩展。</p>
<h4 id="应用程序加载器"><a class="header-anchor" href="#应用程序加载器"></a>应用程序加载器</h4>
<p>AppClassLoader</p>
<p>应用程序类加载器主要用来加载 <code>classpath</code> 下的类文件，包括了我们自己编写的 java 文件以及第三方库中的类文件。</p>
<h3 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制"></a>双亲委派机制</h3>
<p>功能：</p>
<ul>
<li><strong>保证类加载的安全性</strong>：通过双亲委派机制避免恶意代码替换 JDK 中的核心类库，如：java.lang.String，确保核心类库的完整性和安全性</li>
<li><strong>避免重复加载</strong>：双亲委派机制可以避免同一个类被多次加载</li>
</ul>
<p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下进行加载</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032118133.png" alt="image-20250303211859044"></p>
<p>每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，避免重复加载。否则会将加载请求委派给父类加载器。如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p>
<ul>
<li>向上查找：如果已经加载过，就直接返回 Class 对象，加载过程结束，就能避免类重复加载</li>
<li>向下尝试加载：起到了加载优先级的作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行类声明周期中的连接阶段</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<p>记住 load 和 find</p>
<p><code>loadClass</code> 方法在实现时有进行加锁操作，目的是为了防止多线程环境下被重复加载，调用 <code>findClass</code> 方法查找类是否已经加载了，如果有则直接返回对象，如果没有则会继续向上查找，直到 <code>parent</code> 为空再去查找启动类加载器；如果都为空，则需要一直委派到自己实现的加载器类</p>
<p><strong>双亲委派的核心逻辑</strong>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032159666.png" alt="image-20250303215959586"></p>
<h3 id="打破双亲委派机制"><a class="header-anchor" href="#打破双亲委派机制"></a>打破双亲委派机制</h3>
<p>打破双亲委派机制的方法有三种：</p>
<h4 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器"></a>自定义类加载器</h4>
<p>自定义类加载器并重写 <code>loadClass</code> 方法，就可以将双亲委派机制的代码去除。Tomcat 通过这种方式实现应用之间的类隔离。</p>
<p>一个 Tomcat 程序中是可以运行多个 Web 应用的，如果这两个应用中出现了相同限定名的类，比如 Servlet 类，Tomcat 要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载 Web 应用 1 中的 <code>MyServlet</code> 之后，Web 应用 2 中相同限定名的 <code>MyServlet</code> 类就无法被加载了。所以，Tomcat 使用了自定义类加载器来实现应用之间类的隔离，每一个应用会有一个独立的类加载器加载对应的类。</p>
<p>正确实现一个<strong>自定义类加载器</strong>的方式是重写 <code>findClass</code> 方法，不会破坏双亲委派机制。</p>
<h4 id="线程上下文类加载器"><a class="header-anchor" href="#线程上下文类加载器"></a>线程上下文类加载器</h4>
<p>利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。spi？</p>
<p>JDBC 中使用了 <code>DriverManager</code> 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。<code>DriverManager</code> 类位于 <code>rt.jar</code> 包中，由<strong>启动类加载器</strong>来加载。而我们自己引入的数据库驱动是由<strong>应用程序类加载器</strong>来加载，这违反了双亲委派机制（按照双亲委派机制的正常逻辑，<code>DriverManager</code> 类无法直接访问由应用程序类加载器加载的 JDBC 驱动类，因为类加载器通常只会访问自己或祖先加载器加载的类。但在 JDBC 场景中，<code>DriverManager</code> 却可以访问这些由应用程序类加载器加载的驱动类）。</p>
<p>JDBC 是如何实现这种 “违反” 双亲委派机制的操作呢？</p>
<p>首先，我们先来解决一个问题，就是：<code>DriverManager</code> 是如何知道 <code>jar</code> 包中要加载的驱动在哪儿的？</p>
<p>实际上，JDBC 采用了 JDK 内置的 SPI（Service Provider Interface）机制：</p>
<blockquote>
<p>SPI机制：</p>
<ol>
<li>
<p>JDBC 定义了一个核心接口 <code>java.sql.Driver</code>，所有数据库驱动都需要实现这个接口。例如：</p>
<ul>
<li>MySQL 的驱动实现类是 <code>com.mysql.cj.jdbc.Driver</code>。</li>
<li>PostgreSQL 的驱动实现类是 <code>org.postgresql.Driver</code>。</li>
</ul>
</li>
<li>
<p>每个数据库驱动的 JAR 包中，都会包含一个 SPI <strong>配置文件</strong>来主动暴露自己的<strong>实现类的全限定类名</strong>，路径为： <code>META-INF/services/java.sql.Driver</code></p>
<p>配置文件的内容是实现类的全限定名。例如，MySQL 的配置文件中内容为：<code>com.mysql.cj.jdbc.Driver</code></p>
</li>
<li>
<p><code>ServiceLoader</code> 扫描 <code>META-INF/services/java.sql.Driver</code>  文件，找到所有实现了 <code>java.sql.Driver</code> 接口的类、使用类加载器加载驱动类、而后注册驱动到 <code>DriverManager</code>、最后根据 URL 选择合适的驱动创建连接</p>
</li>
</ol>
</blockquote>
<p>观察加载过程我们发现，<strong>驱动文件确实是由应用程序类加载器来加载的</strong>，那么，SPI 中是又是如何获取到应用程序类加载器的呢？实际上，SPI 中使用了线程上下文中保存的类加载器进行类加载（<code>Thread.currentThread().getContextClassLoader()</code>），而被保存的这个类加载器一般是应用程序类加载器（通过该线程上下文可以在程序任何地方获取到类加载器）。</p>
<p>不过，JDBC 只是在 <code>DriverManager</code> 加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依旧遵循双亲委派机制，所以，从这个角度上看，JDBC 的驱动加载并不会真正打破双亲委派机制。从类加载器之间的隔离性来说确实是打破了双亲委派的，因为在启动类加载器当中调用了应用程序类加载器，但是类本身的加载流程上来看，向上查找、向下尝试加载的这个流程仍然是生效的，只不过是在应用程序类加载器查找到了这个类。</p>
<h4 id="Osgi-框架的类加载器"><a class="header-anchor" href="#Osgi-框架的类加载器"></a>Osgi 框架的类加载器</h4>
<p>历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载。Osgi 还是用类加载器实现了热部署（指在服务不停止的情况下，动态更新字节码文件到内存中）的功能。</p>
<p>不过，现如今我们可以使用 Arthas 来帮助我们进行热部署，基本步骤如下：</p>
<ol>
<li>在服务器上部署 arthas，并启动。</li>
<li><code>jad --source-only 类全限定名 &gt; 目录/文件名.java</code>，利用 <code>jad</code> 命令反编译，然后可以用其他编译器，比如 vim 来修改源码。</li>
<li><code>sc -d 类全限定名</code>，利用 <code>sc</code> 命令查看类对应的类加载器 hashcode。</li>
<li><code>mc -c 类加载器的hashcode 目录/文件名.java -d 输出目录</code>，使用 <code>mc</code> 命令来编译修改过的代码。</li>
<li><code>retransform class文件所在目录/xxx.class</code>，用 <code>retransform</code> 命令加载新的字节码。</li>
<li><strong>注意事项</strong>：程序重启之后，字节码文件会恢复（因为 <code>retransform</code> 是做内存上的更新），除非将 class 文件放入 jar 包中进行更新。并且，<code>retransform</code> 也不能添加方法或者字段，也不能更新正在执行中的方法。（只能当做一种应急手段）</li>
</ol>
<h3 id="JDK-9-之后的类加载器"><a class="header-anchor" href="#JDK-9-之后的类加载器"></a>JDK 9 之后的类加载器</h3>
<p>JDK 9 引入了 module 的概念，类加载器设计上有了很多变化</p>
<ol>
<li>
<p>启动类加载器使用 Java 编写，位于 <code>jdk.internal.loader.ClassLoader</code> 类中。Java 中的 <code>BootClassLoader</code> 继承自 <code>BuiltinClassLoader</code>，实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过 java 代码获取到，返回的仍然是 null，保持了统一。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936205.png" alt="image-20250304093613115"></p>
</li>
<li>
<p>扩展类加载器被替换成了平台类加载器（Platform Class Loader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，<strong>自身没有特殊逻辑</strong>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936512.png" alt="image-20250304093642439"></p>
</li>
<li>
<p>应用程序类加载器的继承关系发生了改变，从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，其余没有特殊变化。</p>
</li>
</ol>
<h2 id="JMM运行时数据区"><a class="header-anchor" href="#JMM运行时数据区"></a>JMM运行时数据区</h2>
<h3 id="什么是运行时数据区"><a class="header-anchor" href="#什么是运行时数据区"></a>什么是运行时数据区</h3>
<p>运行时数据区指的是：jvm 在运行 Java 程序过程中管理的内存区域</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040942498.png" alt="image-20250304094232418" style="zoom:67%;" />
<blockquote>
<p>线程不共享：每当创建一个线程，每一个线程都有一份独立的<strong>程序计数器、Java 虚拟机栈、本地方法栈</strong>，数据不共享，但安全性高</p>
<p>线程共享：数据共享，每个线程都可以获取与使用，线程不安全</p>
</blockquote>
<h3 id="程序计数器（私有）"><a class="header-anchor" href="#程序计数器（私有）"></a>程序计数器（私有）</h3>
<p>程序计数器（Program Counter Register），也叫 PC 寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令地址。</p>
<p>加载阶段（解析），jvm 讲字节码文件中的指令读取到内存后，会将原文件中的偏移量转换成内存地址。每一天字节码指令都会有一个内存地址。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040953897.png" alt="image-20250304095304805" style="zoom:67%;" />
<p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p>
<p>在多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到的那一句指令并继续执行</p>
<blockquote>
<p><strong>内存溢出</strong>是指程序在使用某一刻区域时，存放的数据需要占用的内存大小超出了虚拟机可以提供的内存上限</p>
<p>每个线程只存储固定长度的内存地址，因此程序计数器不会发生内存溢出</p>
</blockquote>
<h3 id="栈（私有）"><a class="header-anchor" href="#栈（私有）"></a>栈（私有）</h3>
<h4 id="Java-虚拟机栈"><a class="header-anchor" href="#Java-虚拟机栈"></a>Java 虚拟机栈</h4>
<p>Java 虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，FILO，每个方法的调用使用一个栈帧（Stack Frame）来保存</p>
<p>Java 代码在遇到异常，报错的时候，会把异常时的栈帧信息打印出来。也就是说，发生异常时，控制台上打印出来的，是栈帧信息。</p>
<p>Java 虚拟机栈随线程创建而创建，而回收则会在线程的销毁时进行。</p>
<h4 id="栈帧的组成"><a class="header-anchor" href="#栈帧的组成"></a>栈帧的组成</h4>
<ul>
<li>
<p>局部变量表：主要作用是方法执行过程中存放所有的局部变量。编译成字节码文件时就可以确定局部变量表的内容。栈帧中的局部变量表本质上是一个数组，数组中每个位置称之为槽（slot），long 和 double 类型占用两个槽，其他类型占用一个槽</p>
<p>在字节码文件记录的局部变量表信息中，<code>Nr.</code> 表示局部变量的编号，<code>起始PC</code> 和 <code>长度</code> 划定了局部变量生效的范围，<code>序号</code> 表示变量在栈帧中槽的起始编号。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041017338.png" alt="image-20250304101742258" style="zoom: 80%;" />
<p>实例方法中的序号为 0 的位置存放的是 this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041018955.png" alt="image-20250304101808880"></p>
<p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致</p>
<p>局部变量表会保存的内容有：<strong>实例方法的 <code>this</code> 对象</strong>，<strong>方法的参数列表</strong>，方法体中声明的<strong>局部变量</strong>。</p>
<p>为了节省空间，局部变量表中的槽可以复用，一旦某个局部变量不再失效，当前槽可以再次被使用。当某个变量已经不再被使用，则可以将变量丢弃后把槽给新的变量使用。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041023902.png" alt="image-20250304102312810" style="zoom:80%;" />
</li>
<li>
<p>操作数栈：是在虚拟机执行指令过程中存放临时数据或中间数据的，也是一种栈式结构，在编译期就可以确定操作数栈的最大深度，进而在执行时正确分配内存大小</p>
</li>
<li>
<p>帧数据：主要包含动态链接、方法出口、异常表的引用。</p>
<p><strong>动态链接</strong>：当前类的字节码指令引用了其他类的属性或方法时，需要将符合引用（编号）转换成对应的运行时常量池中的内存地址，动态链接（类似于一个map表）就保存了编号到运行时常量池的内存地址的映射关系。</p>
<p><strong>方法出口</strong>：方法在正确或异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址，所以当前栈帧中，需要存储此方法出口的地址</p>
<p><strong>异常表</strong>：存放代码异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p>
</li>
</ul>
<p>每个栈的空间是有限的，如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出，出现 <code>StackOverflowError</code> 的错误（系统级错误，程序无法运行）。虚拟机设置中，可以使用 <code>-Xss栈大小</code> 来设置栈帧最大大小，不过必须是 <em>1024</em> 的倍数。Win（64位）下的 JDK 8 测试最小值位 180 K，最大为 1024 M。一般来说，工作中即使使用了递归操作，栈的深度最多也只能到几百，不会出现栈溢出。所以可以手动指定参数为 <code>-Xss256k</code> 来节省内存。</p>
<h4 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"></a>本地方法栈</h4>
<p>除了 Java 虚拟机，栈区还包括本地方法栈。Java 虚拟机栈存储了 Java 方法调用时的栈帧，而本地方法栈存储的是 native 本地方法的栈帧。在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存中生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。(了解即可)</p>
<h3 id="堆"><a class="header-anchor" href="#堆"></a>堆</h3>
<ul>
<li>
<p>一般 Java 程序中堆内存是空间<strong>最大的一块内存</strong>区域。创建出来的<strong>对象实例</strong>都存在堆上。</p>
<p>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<p>堆内存大小是有上限的，当对象一直向堆中放入对象达到上限后，就会抛出 <code>OutOfMemory</code> 错误。</p>
</li>
<li>
<p>堆空间有三个需要关注的值：used、total、max。</p>
<ul>
<li>used 指的是当前已经使用的堆内存，</li>
<li>total 指的是 Java 虚拟机已经分配的可用堆内存</li>
<li>max 是 Java 虚拟机可以分配的最大堆内存</li>
</ul>
<p>随着堆中的对象增多，当 total 可以使用的内存即将不足时，jvm 会继续分配内存给堆。【注：并不是当 used = max = total】时，堆内存才溢出，堆内存溢出的判断条件比较复杂，在垃圾回收章节再详细介绍。</p>
</li>
<li>
<p>如果不设置任何的虚拟机参数，max 默认是系统内存的四分之一，total 默认是系统内存的六十四分之一。在实际应用中一般都需要 total 和 max 的值。使用 <code>-Xmx</code> 修改 max 值（必须大于 2 M），<code>-Xms</code> 修改 total 值（必须大于 1 M）。在服务端程序开发时，建议将 max 值和 total 值设置为相同的值，这样程序启动后可使用的总内存就是最大内存，<strong>无需向 JVM 申请，减少申请空间的额外开销</strong>。</p>
</li>
<li>
<p>需要注意的是，如果使用 Arthas 显示 heap 堆大小，会发现其和设置的值并不相同。这是因为 Arthas 使用的是 JMX 技术中的内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。</p>
</li>
</ul>
<p><strong>字符串常量池</strong>：（字节码文件中有一部分区域时字符串常量池）字符串常量池存储在代码中定义的常量字符串内容</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041529238.png" alt="image-20250304152918152"></p>
<p>与运行时常量池作用接近：早期设计中，字符串常量池是属于运行时常量池的一部分，存储的位置也一致。后续做出了调整，进行了拆分</p>
<ul>
<li>JDK 7 之前：运行时常量池包含了字符串常量池，都位于永久代中</li>
<li>JDK 7 ：字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li>
<li>JDK 8 ：永久代修改为元空间，字符串常量池还在堆中</li>
</ul>
<p>可以使用 <code>intern</code> 方法主动把字符串放到字符串常量池中，JDK 6 版本的 <code>intern</code> 方法会把第一次遇到的字符串实例复制一份到字符串常量池中；而 JDK 7 及以后因为字符串常量池就在堆上，故是在堆上复制一个引用到字符串常量池中。并且，因为载入基础包等原因，JVM 在加载后，字符串常量池中会默认加载完毕 <code>java</code> 等字符串。</p>
<p>【注：在不同版本的 JDK 当中，静态变量的存放也是不同的，在 JDK 6 及其之前版本，静态变量存放在方法区也就是永久代中，JDK 7 之后的版本中，静态变量是存放在堆区的 Class 对象中，脱离了永久代】</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041449067.png" alt="JDK6 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451007.png" alt="JDK7 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451165.png" alt="JDK8 的 运行时数据区结构"></p>
<h3 id="方法区"><a class="header-anchor" href="#方法区"></a>方法区</h3>
<p>方法区是《Java 虚拟机规范》中设计的虚拟概念，每款虚拟机设计各不相同。Hotspot 的设计如下：</p>
<ul>
<li>JDK 7 及之前的版本将方法存放在<strong>堆区域</strong>中的永久代空间里，堆的大小由虚拟机参数 <code>-XX:MaxPermSize=值</code> 控制。</li>
<li>JDK 8 及之后的版本将方法去存放在<strong>元空间</strong>中，元空间位于操作系统维护的<strong>直接内存</strong>中，默认情况下只要不超过系统承受的上限，可以一直分配。可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大大小进行限制。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041446781.png" alt="方法区不同JDK版本中实现对比图"></p>
<p>方法区是存放基础信息的位置，线程共享，主要包含三个内容：</p>
<p><strong>类的元信息</strong>：保存所有类的基本信息</p>
<ul>
<li>存储每个类的基本信息（元信息），一般称之为 InstanceKlass 对象，在类<strong>加载阶段</strong>创建并加载。</li>
</ul>
<p><strong>运行时常量池</strong>：保存字节码文件中的常量池内容</p>
<ul>
<li>字节码文件中是通过编号查表的方式找到常量的，这种常量池称之为静态常量池。</li>
<li>当常量池加载到内存中后，可以通过内存地址快速的定位常量池中的内容，这种常量池称之为动态常量池</li>
<li>核心：将原本由编号查询常量的方式替换成用内存地址的方式去查询</li>
</ul>
<h2 id="直接内存"><a class="header-anchor" href="#直接内存"></a>直接内存</h2>
<p>直接内存（Direct Memory）并不在《Java 虚拟机规范》中存在，所以<strong>并不属于 Java 运行时的内存区域</strong>，而是由操作系统本地分配的内存区域。虽然直接内存不是虚拟机运行时数据区的一部分，但是使用也被频繁使用，也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>在 JDK 1.4 中引入了 NIO（Non-Blocking I/O，也被称为 New I/O） 机制，使用了直接内存，主要为了解决两个问题：</p>
<ol>
<li>Java 堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li>
<li>IO 操作，如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到 Java 堆中，现在直接放入直接内存即可，同时 Java 堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路</li>
</ol>
<p>要创建直接内存上的数据，可以使用 <code>ByteBuffer</code>，语法（Arthas 的 <code>memory</code> 命令可以直接查看直接内存的大小，属性名 <code>direct</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(size);</span><br></pre></td></tr></table></figure>
<p>如果要手动调整直接内存的大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code>，来为 JVM 的直接内存分配大小。</p>
<h2 id="自动垃圾回收"><a class="header-anchor" href="#自动垃圾回收"></a>自动垃圾回收</h2>
<p>在 C/C++ 这类没有自动垃圾回收机制的语言中，一个对象如果不在使用需要手动释放，否则会造成<strong>内存泄漏</strong>的问题（内存泄漏的累计会导致内存溢出）。释放对象的过程称之为垃圾回收，而程序员需要手动编码进行回收的方式称之<strong>手动回收</strong>。</p>
<p>Java 中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection 简称 GC）机制。通过垃圾回收器来对不在使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言，如 C#、Python、Go 都有自己的垃圾回收器。如果想要查看垃圾回收的信息，可以通过 <code>verbose:gc</code> 参数。</p>
<p>线程不共享部分的内存（程序计数器、Java 虚拟机栈、本地方法栈），都是随着线程的创建而创建、线程的销毁而销毁。方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。</p>
<h3 id="方法区的回收（正常开发中一般不触及）"><a class="header-anchor" href="#方法区的回收（正常开发中一般不触及）"></a>方法区的回收（正常开发中一般不触及）</h3>
<p>方法区中能回收的内容主要是不在使用的类。判定一个类是否可以被<strong>卸载</strong>（类的生命周期当中最后一个），需要同时满足三个条件：</p>
<ol>
<li>
<p>（没有可以使用的东西了）此类所有<strong>实例对象都已经被回收</strong>，在堆中已经不存在任何该类的实例对象以及子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（连加载它的都没了）加载该类的<strong>类加载器已经被回收</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:D:\\lib\\&quot;</span>)&#125;</span><br><span class="line">);</span><br><span class="line">loader = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（没有任何地方用到）该类对应的 java.lang.Class 对象（类对象）没有在任何地方被引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果需要手动触发垃圾回收，可以调用 <code>System.gc</code> 方法。调用该方法并不一定会立即触发垃圾回收，仅仅是发送一个请求，具体是否执行回收操作由 Java 虚拟机自行判断</p>
<p>开发中此类场景一般很少出现，主要是在 OSGI、JSP 的热部署等应用场景中，每个 jsp 文件对应一个唯一的类加载器，当一个 jsp 文件修改了，就直接卸载这个 jsp 类加载器。重新创建类加载器，重新加载 jsp 文件。</p>
<h3 id="堆回收"><a class="header-anchor" href="#堆回收"></a>堆回收</h3>
<p>Java 中的<strong>对象</strong>是否能够被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许回收。</p>
<p>判断堆上的对象是否被引用的判断方法：引用计数法和可达性分析法。</p>
<h3 id="两种回收机制"><a class="header-anchor" href="#两种回收机制"></a>两种回收机制</h3>
<h4 id="引用计数法"><a class="header-anchor" href="#引用计数法"></a>引用计数法</h4>
<p>引用计数法会为每个对象维护一个引用计数器（初始值为 0），当对象被引用时加 1，取消引用时减 1。</p>
<p>优点：实现简单，C++ 中的智能指针就是采用了引用计数法</p>
<p>缺点：</p>
<ol>
<li>每次引用和取消引用都需要维护计数器，影响性能</li>
<li>存在循环引用的问题，当 A 中有 B，B 中有 A 的情况下，会出现 AB 都无法回收的问题。</li>
</ol>
<h4 id="可达性分析-强引用"><a class="header-anchor" href="#可达性分析-强引用"></a>可达性分析&amp;强引用</h4>
<p>【这种通过 GC Root 对象与普通对象之间产生的引用关系称之为<strong>强引用</strong>】</p>
<p>Java 使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。</p>
<p>可达性算法基础：所有普通对象都会和<strong>根对象形成引用关系</strong>。</p>
<p>可达性算法：如果某个对象是从 GC Root 可以沿着引用链到达，那么该对象就不会回收。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503190907192.png" alt="可达性算法演示图"></p>
<p>GC Root 对象主要有（预先规定好）：</p>
<ul>
<li>线程 Thread 对象，引用线程栈帧中的<strong>方法参数、局部变量</strong>等。</li>
<li>系统类加载器加载的 java.lang.Class 对象，引用类中的静态变量</li>
<li>监视器对象，用来保存同步锁 synchronized 关键字持有的对象。</li>
<li>本地方法调用时使用的全局对象。</li>
</ul>
<h4 id="五种对象引用"><a class="header-anchor" href="#五种对象引用"></a>五种对象引用</h4>
<p>可达性算法中描述的对象引用，一般指的是<strong>强引用</strong>，即 GC Root 对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外还有其他 4 种对象引用</p>
<h5 id="软引用"><a class="header-anchor" href="#软引用"></a>软引用</h5>
<p>弱于强引用，如果一个对象只有软引用关系，那么当<strong>程序内存不足时，就会将软引用中的数据回收</strong>，释放内存，在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用，<strong>软引用常用于缓存中</strong>。使用的时候，通过要让 GC Root 来关联 <code>SoftReference</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据放入软引用中</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(bytes);</span><br></pre></td></tr></table></figure>
<p>软引用的对象会在内存不足时被回收，但 SoftReference 对象本身也需要被回收，如何知道 SoftReference 对象需要回收？SoftReference 提供了一套队列机制：</p>
<ol>
<li>软引用创建时，通过构造器传入引用队列</li>
<li>在软引用中包含的对象被回收时，该软引用对象会被放入<strong>引用队列</strong></li>
<li>通过代码遍历引用队列，将 SoftReference 的强引用删除</li>
</ol>
<h5 id="弱引用"><a class="header-anchor" href="#弱引用"></a>弱引用</h5>
<p>整体机制和软引用几乎一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收，jdk 1.2 版本之后提供了 WeakReference 类来实现弱引用，弱引用主要是 <strong>ThreadLocal</strong> 中使用。弱引用对象本身也可以使用队列进行回收。（平时开发使用概率不大）</p>
<h5 id="虚引用和终结器引用"><a class="header-anchor" href="#虚引用和终结器引用"></a>虚引用和终结器引用</h5>
<p>在常规开发中不会使用的</p>
<p><strong>虚引用也叫幽灵引用/幻影引用</strong>，不能通过虚引用对象获取包含的对象。虚引用唯一的作用是：当对象被垃圾回收器回收时，可以接收到对应的通知。java 中使用 PhantomReference 实现虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</p>
<p><strong>终结器引用</strong>：在对象需要回收时，对象将会放置在 Finalize 类中的引用队列中，并在稍后由一条由 FinalizerThread 线程从队列中获取对象，然后执行对象的 finalize 方法。在这个过程中可以在 finalize 中再将自身对象使用强引用关联上，但不建议，如果耗时太长会影响其他对象的回收。</p>
<h2 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法"></a>垃圾回收算法</h2>
<p>简单来说，垃圾回收需要做的就是两件事：</p>
<ol>
<li>找到内存中存活的对象</li>
<li>释放不再存活对象的内存，让这部分空间可以再次被利用</li>
</ol>
<h3 id="垃圾回收算法的评价标准"><a class="header-anchor" href="#垃圾回收算法的评价标准"></a>垃圾回收算法的评价标准</h3>
<p>java 垃圾回收过程会通过单独的 GC 线程来完成，不管哪一种 GC 算法，都会有部分阶段需要停止所有用户线程。这个过程称之为 Stop The World 简称 STW，如果 STW 时间过长则会影响用户的使用。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191417580.png" alt="程序运行过程中 STW 的发生"></p>
<p>三个评价标准：</p>
<p><strong>吞吐量</strong>：（核心是用户可以用来执行的时间要多）指的是 CPU 用于执行用户代码的时间和 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 / (执行用户代码时间 + GC 时间)。吞吐量越高，垃圾回收效率也高</p>
<p><strong>最大暂停时间</strong>：指的是所有在垃圾回收过程中的 STW 时间最大值</p>
<p><strong>堆使用效率</strong>：不同算法，对堆内存的使用方式不同，如标记清除算法、使用的是完整的堆内存；复制算法则会将堆一分为二，每次只使用一半内存。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191423557.png" alt="标记清除算法和复制算法对比图"></p>
<p>三个指标是类似于 CAP 的不可能三角问题，不可兼得：堆内存越大，STW 越长；而 STW 减少，势必导致吞吐量降低。根据合适的场景选择算法</p>
<h3 id="标记清除算法"><a class="header-anchor" href="#标记清除算法"></a>标记清除算法</h3>
<p>核心思想：将垃圾回收分为两个阶段，标记阶段和清除阶段</p>
<p><strong>标记阶段</strong>：将所有存活的对象进行标记，java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有<strong>存活对象</strong>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191431447.png" alt="标记阶段"></p>
<p><strong>清除阶段</strong>：从内存中删除没有被标记（也就是非存活）的对象。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191431052.png" alt="清除阶段"></p>
<p>优点：实现简单，只需要在第一阶段给每个对象维护一个标记位，第二个阶段根据标记位进行删除即可</p>
<p>缺点：</p>
<ul>
<li>碎片化问题：如图所示，会有大量的不连续空间，导致看似有很多空闲空间，但是实际去申请时很多碎片无法被利用（当申请空间较大时）</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191432814.png" alt="碎片化问题图示"></p>
<ul>
<li>分配速度慢：由于碎片的存在，需要额外维护一个空闲链表，最坏情况可能需要 o(n) 才能找到合适的空闲空间分配内存。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191434891.png" alt="空闲链表分配内存"></p>
<h3 id="复制算法"><a class="header-anchor" href="#复制算法"></a>复制算法</h3>
<p>核心是：将内存一分为二：</p>
<ol>
<li>From 空间和 To 空间，每次对象分配阶段，只能使用 From 空间。</li>
<li>垃圾回收时，将 From 中存活的对象复制到 To 空间，本质就是把 GC Root 对象搬运到 To 空间后再把 GC Root 关联的对象也搬运到 To 空间。</li>
<li>而后清理掉 From 中没有被复制的（也就是非存活的）对象。</li>
<li>最后将两块空间的 From 和 To 名字互换。</li>
</ol>
<p>优点：</p>
<ol>
<li>吞吐量高：只需要遍历一次存活对象而后复制到 To 空间即可，比标记清除算法少一次遍历</li>
<li>不会发生碎片化：按对象顺序复制到 To 空间，剩余的都是连续可用的内存空间</li>
</ol>
<p>缺点：堆内存使用效率低，只有一般都内存可以使用</p>
<h3 id="标记整理算法"><a class="header-anchor" href="#标记整理算法"></a>标记整理算法</h3>
<p>也叫<strong>标记压缩算法</strong>，针对标记清理算法碎片化问题的一种优化</p>
<p>分为两个阶段：</p>
<ol>
<li>标记阶段：将所有存活对象进行标记，java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象
<ol>
<li>整理（➕ 清理）阶段：将存活对象移动到堆的一端，清理掉其他的非存活对象的内存空间</li>
</ol>
</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191443452.png" alt="标记和整理阶段"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191444164.png" alt="整理和清理阶段"></p>
<h3 id="分代-GC-算法"><a class="header-anchor" href="#分代-GC-算法"></a>分代 GC 算法</h3>
<p>如今使用最广的算法：</p>
<p>将内存整体划分为：</p>
<p>Young 区（年轻代/新生代）：存活时间比较短的对象，使用的是<strong>复制算法</strong>。</p>
<ul>
<li>伊甸园区 eden_space：对象刚刚创建出来存放的地方</li>
<li>幸存区(survivor_space)分为 S0 和 S1：用于实现复试算法</li>
</ul>
<p>Old 区(tenured_gen)（老年代）：存活时间比较长的对象，使用的是<strong>标记-清除和标记-整理</strong>算法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191452521.png" alt="分代 gc 算法的内存划分"></p>
<p>在 JDK 8 中，添加 <code>-XX:+UserSerialGC</code> 参数使用分代回收的垃圾回收器，运行程序。在 Arthas 中使用 <code>memory</code> 命令查看内存，显示出上述几个区域的使用情况。</p>
<h4 id="算法流程"><a class="header-anchor" href="#算法流程"></a>算法流程</h4>
<ol>
<li>分代回收算法中，创建出来的对象会先放入 Eden 区</li>
<li>直到 Eden 区填满，新创建对象无法放入,触发年轻代的 GC 机制，称之为 Minor GC 或 Young GC：Minor GC 会根据可达性分析算法将 eden 和 from 这两个区中需要回收的对象进行回收，把没有回收的对象放入 to 区</li>
<li>而后将 from 区和 to 区名字互换，重复第 2 阶段</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191505388.png" alt="Minor GC 完成前" style="zoom: 80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191505614.png" alt="Minor GC 完成后" style="zoom: 80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191508837.png" alt="image-20250319150812753"  />
<ol start="4">
<li>每次 Minor GC 都会为对象记录他的年龄，初始值为 0，每进行一次 GC 会加一，当对象年龄到达 15（最大值，具体的默认值与连接回收器有关），对象会从<strong>新生代晋升到老年代</strong>；</li>
<li>当老年代空间不足（如图），无法放入新的对象时，先尝试 Minor GC （此时有一种特殊情况：新生代满了会进行 Minor GC，如果 Minor GC 之后如果新生代还是不足，一些年龄未达标的对象也会有“要存入”老年代的操作，但是事实上无法存入，就会触发 Full GC），如果还是不足，则会触发 Full GC，对整个堆进行垃圾回收（之所以先进行 Minor GC，是因为，如果新生代在清理完之后还能先继续承担一部分对象，且这部分对象并不一定会移入老年代）</li>
<li>如果 Full GC 依然无法回收老年代的对象，那么当对象继续放入老年代时，就会报错 “out of memory”。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191515616.png" alt="老年代已满"></p>
<p>思考：</p>
<p>为什么划分老年代和新生代，这种设计的原理依据是什么：因为系统中创建的大部分对象都是临时使用，使用完以后就可以被释放了；老年代中存放的是长期存活的对象，比如 Spring 的 bean 对象，在程序启动后不会被回收，所以新生代的大小默认小于老年代。接近于 3:7 的比例</p>
<h2 id="垃圾回收器"><a class="header-anchor" href="#垃圾回收器"></a>垃圾回收器</h2>
<p>垃圾回收器是垃圾回收算法的具体实现。</p>
<p>jvm 的垃圾回收器都是根据分代 GC 算法实现的，根据这一算法可以将垃圾回收器分为年轻代垃圾回收器和老年代垃圾回收器，除了 G1 之外其他垃圾回收器必须成对组合进行使用。具体关系图如下：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191600287.png" alt="不同垃圾回收器的组合关系"></p>
<h3 id="组合一"><a class="header-anchor" href="#组合一"></a>组合一</h3>
<h4 id="Serial-垃圾回收器"><a class="header-anchor" href="#Serial-垃圾回收器"></a>Serial 垃圾回收器</h4>
<p>Serial 是一种<strong>单线程串行回收</strong>年轻代的垃圾回收器，使用<strong>复制算法</strong>回收年轻代，进行垃圾回收操作时，会阻塞用户线程，对 Eden 区和 From 区进行回收。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191616733.png" alt="串行回收"></p>
<p>优点：单 CPU 处理器下吞吐量较高</p>
<p>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程被阻塞太长时间</p>
<p>可用场景比较少。</p>
<h4 id="SerialOld-垃圾回收器"><a class="header-anchor" href="#SerialOld-垃圾回收器"></a>SerialOld 垃圾回收器</h4>
<p>SerialOld 垃圾回收器是 Serial 回收器的老年代版本，也是采用<strong>单线程进行回收</strong>。针对老年代区使用的算法是<strong>标记-整理算法</strong>，使用 <code>-XX:+UseSerialGC</code> 可以让新生代、老年代都是用串行回收器。</p>
<ul>
<li>优点：单 CPU 处理器下吞吐量非常出色。</li>
<li>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待。</li>
<li>使用场景：与 Serial 垃圾回收器搭配使用，或者在 CMS 特殊情况下使用。</li>
</ul>
<h3 id="组合二"><a class="header-anchor" href="#组合二"></a>组合二</h3>
<h4 id="ParNew-垃圾回收器"><a class="header-anchor" href="#ParNew-垃圾回收器"></a>ParNew 垃圾回收器</h4>
<p>parNew 年轻代垃圾回收器本质上是对 Serial 在多 CPU 下的优化，使用<strong>多线程</strong>进行垃圾回收。使用 <code>-XX:+UseParNewGC</code> 可以让新生代使用 ParNew 回收器，老年代使用串行回收器。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191623637.png" alt="parNew 多线程进行垃圾回收"></p>
<ul>
<li>优点：多 CPU 处理器下停顿时间较短。</li>
<li>缺点：吞吐量和停顿时间不如 G1，所以在 JDK 9 之后不建议使用。</li>
<li>使用场景：JDK 8 及之前的版本中，与 CMS 老年代回收器搭配使用。</li>
</ul>
<h4 id="CMS-Concurrent-Mark-Sweep-垃圾回收器"><a class="header-anchor" href="#CMS-Concurrent-Mark-Sweep-垃圾回收器"></a>CMS(Concurrent Mark Sweep)垃圾回收器</h4>
<p>CMS 垃圾回收器关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少用户线程的等待时间，参数：<code>-XX:+UseConcMarkSweepGC</code>。使用标记清除（整理）算法回收老年代</p>
<ul>
<li>优点：系统由于垃圾回收出现的停顿时间较短，用户体验好</li>
<li>缺点：内存碎片化问题、退化问题、浮动垃圾问题</li>
<li>适用场景：大型的互联网系统中用户请求数据量大、频率高的场景，如订单接口、商品接口等</li>
</ul>
<p>CMS 执行步骤：</p>
<ol>
<li>初始标记：用极短的时间标记出 GC Roots 可达的对象</li>
<li>并发标记：标记所有对象，用户线程不需要暂停</li>
<li>重新标记：由于并发标记阶段有些对戏发生了变化，存在错标、漏标等问题，需要重新标记。</li>
<li>并发清理：清理死亡对象，用户线程不需要暂停</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191631079.png" alt="cms 执行步骤"></p>
<p>CMS 存在的问题：</p>
<ul>
<li>使用了标记-清除算法，垃圾清理完之后会产生大量的内存碎片，会在 full gc 时进行碎片的整理，这个操作会导致用户线程暂停，可以使用 <code>-XX：CMSFullGCsBeforeCompaction=N</code> 参数（默认为 0）调整 N 次 Full GC 之后再整理，但是最终还是得整理</li>
<li>无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。</li>
<li>如果老年代内存不足无法分配对象，CMS 会退化成 Serial Old 单线程回收老年代</li>
</ul>
<h3 id="组合三"><a class="header-anchor" href="#组合三"></a>组合三</h3>
<h4 id="Parallel-Scavenge-垃圾回收器"><a class="header-anchor" href="#Parallel-Scavenge-垃圾回收器"></a>Parallel Scavenge 垃圾回收器</h4>
<p>JDK 8 默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备<strong>自动调整堆内存大小</strong>的特点，使用<strong>复制算法</strong>对年轻代进行回收，参数：<code>-XX:+UseParallelGC</code>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191641532.png" alt="ps 垃圾回收过程"></p>
<ul>
<li>优点：吞吐量高，且手动可控，为了提高吞吐量，jvm 会动态调整堆的参数</li>
<li>缺点：不能保证单次的停顿时间</li>
<li>适用场景：后台任务，不需要与用户交互，并且容易产生大量对象，如大数据的处理、大文件导出</li>
</ul>
<p>Oracle 官方建议在使用 Parallel Scavenge 和 Parallel Old 这个组合的时候，<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整堆内存大小。</p>
<ul>
<li>最大暂停时间：<code>-XX:MaxGCPauseMillis=n</code>，设置每次垃圾回收时的最大停顿毫秒数。</li>
<li>吞吐量：<code>-XX:GCTimeRatio=n</code>，设置吞吐量为 n（<code>用户线程执行时间 = n / n + 1</code>）。</li>
<li>自动调整内存大小：<code>-XX:+UseAdaptiveSizePolicy</code> 设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小。</li>
</ul>
<h4 id="Parallel-Old-垃圾回收器"><a class="header-anchor" href="#Parallel-Old-垃圾回收器"></a>Parallel Old 垃圾回收器</h4>
<p>Parallel Old 是为 Parallel Scavenge 设计的老年代版本，利用<strong>多线程并发</strong>回收。对老年代区域使用<strong>标记-整理算法</strong>。参数：<code>-XX:+UseParallelOldGC</code>。</p>
<ul>
<li>优点：并发执行，在多核 CPU 下效率较高。</li>
<li>缺点：暂停时间会比较长。</li>
<li>使用场景：与 Parallel Scavenge 配套使用。</li>
</ul>
<h3 id="G1-垃圾回收器"><a class="header-anchor" href="#G1-垃圾回收器"></a>G1 垃圾回收器</h3>
<p>JDK 9 之后默认的垃圾回收器是 G1 垃圾回收器（jdk 9 之后建议使用 G1 垃圾回收器）</p>
<blockquote>
<p>由 Serial 组合的单线程串行（复制算法、标记整理算法）到 ParNew 和 CMS 组合，通过引入并发操作来完成垃圾回收以及 Parallel 组合也采用并发，只不过年轻代根据需求的吞吐量大小动态调整可用空间。</p>
</blockquote>
<p>Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小</p>
<p>CMS 关注暂停时间，但是吞吐量会下降</p>
<p>G1 垃圾回收器综合了以上两种垃圾回收器的优点：</p>
<ul>
<li>支持巨大的堆空间回收，并有较高的吞吐量</li>
<li>支持多 CPU 并行垃圾回收</li>
<li>允许用户设置最大暂停时间</li>
</ul>
<p>G1 的整个堆被划分成多个大小相等的区域，称之为区 region，区域不要求是连续的。</p>
<p>分为 eden、survior、old 区。region 的大小通过堆空间大小 / 2048（分为 2048 块） 计算得到，也可以通过参数 -XX:G1HeapRegionSize = 32m 指定（其中 32m 指定 region 大小为 32m），region size 必须是 2 的指数幂，范围是 1~32 M。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191703529.png" alt="堆空间划分示意图"></p>
<p>G1 垃圾回收器两种方式：</p>
<h4 id="年轻代回收-Young-GC"><a class="header-anchor" href="#年轻代回收-Young-GC"></a>年轻代回收 Young GC</h4>
<p>回收 eden 区和 survivor 区中不可用的对象。会导致 STW，G1 中可以通过参数 -XX:MaxGCPauseMillis=n（默认 200）设置每次垃圾回收时的最大暂停时间（毫秒级），G1  垃圾回收器会尽可能保证暂停时间。</p>
<p><strong>执行流程</strong>：</p>
<ol>
<li>新创建的对象会存放在 eden 区，当 G1 判断年轻代区不足（max 默认 60%），无法分配对象，需要回收时会执行 Young GC</li>
<li>标记出 eden 和 survivor 区域中的存活对象</li>
<li>根据配置的最大暂停时间<strong>选择某些区域</strong>将存活对象复制到一个新的 survivor 区（年龄➕1），清空原来的区域。</li>
</ol>
<p>G1 在进行 Young GC 的过程中会去记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个 Region 区域了。<br>
比如 <code>-XX:MaxGCPauseMillis=n</code>（默认200），每个 Region 回收耗时 40 ms，那么这次回收最多只能回收 4 个 Region。</p>
<ol start="4">
<li>后续 Young GC 时与之前差不多，只不过 survivor 区中存活对象会被搬运到另一个 survivor 区</li>
<li>当某个存活对象年龄达到阈值（默认 15），将会放入老年代当中。</li>
<li>部分对象大小超过 region 的一半，会直接放入老年代，这些老年代被成为 humongous 区。例如：堆内存是 4G，每个 region 2m，只要一个大对象超过了 1m 就会被放入 humongous 区，如果对象过大会横跨多个 region。</li>
<li>多次回收后，old 区会积累，直到达到一定的阈值（<code>-XX:initiatingHeapOccupancyPercent</code> 默认为 45%）会触发混合回收 MixedGC，回收<strong>所有年轻代和部分老年代的对象以及大对象区</strong>，采用复制算法来实现。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191715558.png" alt="触发混合回收"></p>
<h4 id="混合回收-Mixed-GC"><a class="header-anchor" href="#混合回收-Mixed-GC"></a>混合回收 Mixed GC</h4>
<p>混合回收分为：初始标记（initial mark）、并发标记（Concurrent mark）、最终标记（remark/finalize marking）、并发清理（cleanup）【初始标记会和年轻代回收一起执行】</p>
<p>G1 对老年代的清理会选择存活度最低的区域进行，这样子可以保证回收效率最高，也是 Garbage first 名字的由来。如果清理过程中发现没有足够的空 Region 存放转移的对象，会出现 Full GC。<strong>单线程</strong>执行标记-整理算法，<strong>此时会导致用户线程的暂停</strong>。所以尽量保证应该用的堆内存有一定多余的空间。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191719630.png" alt="混合回收工作流程"></p>
<p>混合回收执行效果：</p>
<p>eden 区和 survivor 区的存活对象会放进一个新的 survivor 区，而 old 区会选一个空的 region 区复制存活的对象。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191722608.png" alt="混合回收执行效果"></p>
<ul>
<li>优点：对比较大的堆，如超过 6G 的堆回收时，延迟可控、不会产生内存碎片、并发标记的 SATB 算法效率高</li>
<li>缺点：jdk 8 之前不够成熟，需要提高 jdk 版本</li>
<li>适用场景：jdk 8 最新版本，jdk 9 之后默认使用</li>
</ul>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<p>主要记忆两种组合和 G1 这四种组合来记忆</p>
<p>按照性能来讲解：jdk 8 及之前</p>
<ul>
<li>关注暂停时间：parNew + CMS</li>
<li>关注吞吐量：Parallel Scavenge + Parallel Old</li>
<li>G1 综合能力最好，但是该版本下还不是很成熟，建议升级版本。</li>
</ul>
<p>jdk 9 之后，尽量使用 G1 垃圾回收器</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">墨儒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/">http://example.com/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E5%BA%95%E5%B1%82/">java 底层</a><a class="post-meta__tags" href="/tags/jvm/">jvm</a></div><div class="post-share"><div class="social-share" data-image="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503200026081.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/%E4%BC%98%E5%8C%96%E6%93%8D%E4%BD%9C/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题解决方案"><img class="cover" src="/./img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">跨域问题解决方案</div></div><div class="info-2"><div class="info-item-1">收录常见的跨域问题解决方案</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/elasticsearch%E5%9F%BA%E7%A1%80%E7%AF%87/" title="es 基础篇"><img class="cover" src="/./img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">es 基础篇</div></div><div class="info-2"><div class="info-item-1">Elasticsearch学习  官方文档，学习过程中遇到任何问题首先是尝试从官方文档中查找解决方法，同时也可以加深自己对技术特性的了解  Elasticsearch 生态丰富 elasticsearch 生态丰富，包含一系列工具和功能，帮助用户处理、分析和可视化数据， 核心组成为：  Elasticsearch：核心搜索引擎，负责存储、索引和搜索数据 Kibana：可视化平台、用于查询、分析和展示 Elasticsearch 中的数据 Logstash：数据处理管道，负责数据收集、过滤、增强和传输到 Elasticsearch。 Beats：轻量级的数据传输工具，收集和发生数据到 Logstash 或 Elasticsearch  核心概念  索引 index：类似于关系型数据库中的表，索引是数据存储和搜索的 基本单位，每个索引可以存储多条文档数据 文档 document：索引中的每条记录，类似于数据库中的行。以 json 格式存储 字段 field：文档中的每个键值对，类似于数据库中的列。 映射 mapping：（类似于 sql 建表语句）用于定义...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">moru</div><div class="author-info-description">道虽迩，不行不至</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caigui88"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/caigui88" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/1468664118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-JVM"><span class="toc-number">1.1.</span> <span class="toc-text">认识 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvms%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">jvms三大核心功能：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">JVM 的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">字节码文件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">基础信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">常见的字节码工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-loading%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">加载 loading：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-Linking%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">连接 Linking：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-initialing%EF%BC%9A"><span class="toc-number">1.4.4.</span> <span class="toc-text">初始化 initialing：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">应用程序加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">自定义类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Osgi-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Osgi 框架的类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-9-%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">JDK 9 之后的类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">JMM运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">程序计数器（私有）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">栈（私有）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">Java 虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">栈帧的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.6.5.</span> <span class="toc-text">方法区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.7.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.8.</span> <span class="toc-text">自动垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6%EF%BC%88%E6%AD%A3%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E8%88%AC%E4%B8%8D%E8%A7%A6%E5%8F%8A%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">方法区的回收（正常开发中一般不触及）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9B%9E%E6%94%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">堆回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.3.</span> <span class="toc-text">两种回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">可达性分析&amp;强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">五种对象引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.3.3.1.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.3.3.2.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E5%92%8C%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.3.3.3.</span> <span class="toc-text">虚引用和终结器引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-number">1.9.1.</span> <span class="toc-text">垃圾回收算法的评价标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.4.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3-GC-%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.5.</span> <span class="toc-text">分代 GC 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">算法流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">组合一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">Serial 垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SerialOld-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">SerialOld 垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BA%8C"><span class="toc-number">1.10.2.</span> <span class="toc-text">组合二</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">ParNew 垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-Concurrent-Mark-Sweep-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">CMS(Concurrent Mark Sweep)垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">组合三</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">Parallel Scavenge 垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">Parallel Old 垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text">G1 垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9B%9E%E6%94%B6-Young-GC"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">年轻代回收 Young GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6-Mixed-GC"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">混合回收 Mixed GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件测试"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件测试"/></a><div class="content"><a class="title" href="/2025/04/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件测试">软件测试</a><time datetime="2025-04-21T13:28:31.000Z" title="发表于 2025-04-21 21:28:31">2025-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组"><img src="/./img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树状数组"/></a><div class="content"><a class="title" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组">树状数组</a><time datetime="2025-04-15T04:47:39.000Z" title="发表于 2025-04-15 12:47:39">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树"><img src="/./img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线段树"/></a><div class="content"><a class="title" href="/2025/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树">线段树</a><time datetime="2025-04-15T04:40:24.000Z" title="发表于 2025-04-15 12:40:24">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202504281520603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2025/04/03/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2025-04-03T05:08:18.000Z" title="发表于 2025-04-03 13:08:18">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/Java/FreeMarker/" title="FreeMarker"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FreeMarker"/></a><div class="content"><a class="title" href="/2025/04/01/Java/FreeMarker/" title="FreeMarker">FreeMarker</a><time datetime="2025-04-01T08:37:43.000Z" title="发表于 2025-04-01 16:37:43">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By moru</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://caigui88.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>