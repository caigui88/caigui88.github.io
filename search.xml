<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>跨域问题解决方案</title>
    <url>/2025/03/01/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id=""><a class="header-anchor" href="#"></a></h1>
<h1 id="跨域"><a class="header-anchor" href="#跨域"></a>跨域</h1>
<h2 id="什么是跨域"><a class="header-anchor" href="#什么是跨域"></a>什么是跨域</h2>
<p>在了解跨域之前需要先知道引起跨域的原因是浏览器安全策略中的同源策略</p>
<h3 id="什么是同源策略"><a class="header-anchor" href="#什么是同源策略"></a>什么是同源策略</h3>
<p>一种浏览器自带的安全策略，主要是指<strong>协议、域名、端口</strong>三者都相同才能互相访问，浏览器禁止页面加载或执行与自身不同域的脚本</p>
]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>25年日记</title>
    <url>/2025/03/01/%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<ol>
<li>时间总是不够用的
<ul>
<li>一小时的学习可以让我过 12 页的 PDF ➕ 笔记，但这才抖音里不过是短短的几个视频，收获更是天差地别的。如此想来过去浪费的时间何其之多。</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2025/03/07/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO-流"><a class="header-anchor" href="#IO-流"></a>IO 流</h1>
<p>本文参考资料：</p>
<p><a href="https://javaguide.cn/java/io/io-basis.html#io-%E6%B5%81%E7%AE%80%E4%BB%8B">Java IO 基础知识总结 | JavaGuide</a></p>
<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2>
<p>IO 即 Input/Output ，输入与输出。数据输入到计算机内存的过程称为<strong>输入</strong>，反之输出到外部存储（数据库、文件、远程主机）的过程统称为<strong>输出</strong>。数据传输过程类似于水流，因此称之为 IO 流。</p>
<p>Java IO 有 40 多种，但是都是从 4 个最基本的抽象类派生出来的：</p>
<ul>
<li>InputStream/Reader：所有的输入流的基类，InputStream 是字节输入流，Reader 是字符输入流</li>
<li>OutputStream/Writer：所有的输出流的基类，OutputStream 是字节输出流，Writer 是字符输出流</li>
<li>字节流可以操作所有文件；字符流只能操作纯文本文件</li>
</ul>
<h2 id="字节流"><a class="header-anchor" href="#字节流"></a>字节流</h2>
<h3 id="InputStream-字节输入流"><a class="header-anchor" href="#InputStream-字节输入流"></a>InputStream 字节输入流</h3>
<p>从外部文件读取数据（字节信息）到内存当中，java.io.InputStream 抽象类是所有字节输入流的父类。</p>
<p>InputStream 常用方法：</p>
<ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<p><code>FileInputStream</code> 代码示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (InputStream fis = new FileInputStream(&quot;input.txt&quot;)) &#123;</span><br><span class="line">    System.out.println(&quot;Number of remaining bytes:&quot;</span><br><span class="line">            + fis.available());</span><br><span class="line">    int content;</span><br><span class="line">    long skip = fis.skip(2);</span><br><span class="line">    System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);</span><br><span class="line">    System.out.print(&quot;The content read from file:&quot;);</span><br><span class="line">    while ((content = fis.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>input.txt</code> 文件内容：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503071639642.png" alt="image-20250307163922583"></p>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Number of remaining bytes：6</span><br><span class="line">The actual number of bytes skipped：2</span><br><span class="line">The content read from file：moru</span><br></pre></td></tr></table></figure>
<p>不过一般不会直接单独使用 <code>FileInputStream</code>，通常配合 <code>BufferedInputStream</code> （字节缓冲输入流）一起使用。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>除此之外还有用 <code>ObjectOutputStream</code> 将对象写入输出流（序列化）和 <code>ObjectInputStream</code> 从输入流读取 Java 对象（反序列化）的【注：序列化和反序列化的类必须实现 <code>Serializable</code> 接口】</p>
<h3 id="OutputStream-字节输出流"><a class="header-anchor" href="#OutputStream-字节输出流"></a>OutputStream 字节输出流</h3>
<p>OutputStream 用于将数据（字节信息）写入目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<p><code>OutputStream</code> 常用方法：</p>
<ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组 <code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在 <code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p><code>FileOutputStream</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream)</span><br></pre></td></tr></table></figure>
<h2 id="字符流"><a class="header-anchor" href="#字符流"></a>字符流</h2>
<h3 id="为什么要有字符流"><a class="header-anchor" href="#为什么要有字符流"></a>为什么要有字符流</h3>
<p>回答这个问题之前首先要回顾一下字节流和字符流各自的特点：</p>
<p>字节流</p>
<ul>
<li>直接存储内存或文件中的二进制数据，不考虑数据的类型或结构</li>
<li>无格式字节流</li>
</ul>
<p>在计算机中，最小的存储单位就是字节，那么传输的时候以<strong>字节流</strong>的形式传输，可以保证数据不会出现错误，顶多就是编码出现问题。即，字节流可以传输所有文件而不出错；</p>
<p>但是字节流转换成字符流十分耗时，</p>
]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>io 流</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC学习</title>
    <url>/2025/03/01/Java%E5%9F%BA%E7%A1%80/JUC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="JUC学习"><a class="header-anchor" href="#JUC学习"></a>JUC学习</h1>
<blockquote>
<p>java.util.concurrent java并发编程，简称 JUC 包，Java 1.5 引入的。涵盖了多线程、同步、锁、并发容器、线程池等相关组件</p>
</blockquote>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2>
<h3 id="线程与进程"><a class="header-anchor" href="#线程与进程"></a>线程与进程</h3>
<h4 id="什么是进程"><a class="header-anchor" href="#什么是进程"></a>什么是进程</h4>
<p>存储在静态资源当中的程序（数据与指令集合）运行起来时的一种状态，即运行的程序就是进程</p>
<p>是系统<strong>进行资源分配和调度的基本单位</strong>。</p>
<h4 id="什么是线程"><a class="header-anchor" href="#什么是线程"></a>什么是线程</h4>
<p>一个进程中可以分配多个线程！！</p>
<p>线程是一个指令流，将指令流中的一条条指令交给 cpu 运行。</p>
<p>线程是<strong>是操作系统能够进行运算调度的最小单位</strong>。</p>
<blockquote>
<p>首先由系统分配资源给一个进程，而后在进程内部再由线程来调度资源的使用</p>
</blockquote>
<h4 id="对比"><a class="header-anchor" href="#对比"></a>对比</h4>
<ul>
<li>每一个进程间是独立的，但线程都存在于同一个进程中</li>
<li>同一天计算机的进程通信称为 IPC(inter-process communication)；不同计算机之间的进程通信则需要通过网络与协议，例如常见的 http 等等</li>
<li>线程通信相对简单，因为共享进程内的内存，多个线程可以访问同一个共享变量，上下文切换成本低于进程</li>
</ul>
<h3 id="并发与并行"><a class="header-anchor" href="#并发与并行"></a>并发与并行</h3>
<h4 id="并发"><a class="header-anchor" href="#并发"></a>并发</h4>
<p>同一时间，多个指令在单个 CPU 上交替执行</p>
<p>单核 cpu 下，线程本质上都是串行执行的，由操作系统的任务调度器组件，将 cpu 的执行时间切成时间片（win 时间片最小为 15ms）分给不同的程序使用，<strong>微观串行，宏观并行</strong>。</p>
<p>一个核心轮流执行各个线程，线程轮流使用 CPU 的行为称为并发，concurrent</p>
<h4 id="并行"><a class="header-anchor" href="#并行"></a>并行</h4>
<p>同一时间，多个指令在多个 CPU 上同时执行</p>
<p>多个核心同一时间执行不同的线程</p>
<h3 id="同步与异步"><a class="header-anchor" href="#同步与异步"></a>同步与异步</h3>
<h4 id="同步"><a class="header-anchor" href="#同步"></a>同步</h4>
<p>需要等待结果返回，才能运行即为同步</p>
<h4 id="异步"><a class="header-anchor" href="#异步"></a>异步</h4>
<p>无需等待结果返回，也能运行即为异步</p>
<h3 id="线程生命周期"><a class="header-anchor" href="#线程生命周期"></a>线程生命周期</h3>
<ul>
<li>
<p>新建状态**(NEW)**</p>
<ul>
<li>使用new关键字和Thread类或子类建立一个线程对象A后，则线程对象A处于新建状态。一直到进程<code>start()</code>这个线程。</li>
</ul>
</li>
<li>
<p>就绪状态**(RUNNABLE)**</p>
<ul>
<li>有执行资格，没有执行权</li>
<li>当线程对象A调用<code>start()</code>方法后，线程进入就绪状态、参与到等待队列中，等待JVM中线程调度器的调度的调度。</li>
</ul>
</li>
<li>
<p>运行状态</p>
<ul>
<li>有执行资格也有执行权</li>
<li>如果处于就绪状态的线程获取到了CPU资源，则执行<code>run()</code>方法，此时线程处于运行状态。处于运行状态的线程较为复杂，它有三种变化情况：阻塞、就绪与死亡状态。</li>
</ul>
</li>
<li>
<p>阻塞状态**(BLOCKED)**</p>
<ul>
<li>无执行资格也无执行权</li>
<li>一个线程执行了<code>sleep()</code> （睡眠）、<code>suspend()</code>（挂起）等方法后，失去了当前抢占的资源，进入阻塞状态，当睡眠时间或阻塞条件结束后，重新进入就绪状态，再次参与CPU资源的抢夺，在抢夺成功后才可以继续执行阻塞方法下面的其他代码。</li>
<li>阻塞分为：
<ul>
<li>等待阻塞**(WAITING)**：运行状态中的线程执行了<code>wait()</code>方法；</li>
<li>同步阻塞：线程在获取<code>synchronized</code>同步锁失败（因同步锁被其他线程占用；</li>
<li>其他阻塞：通过调用线程的<code>sleep()</code> **(TIMED_WAITING)**或 <code>join()</code>发出了<code>I/O</code>请求时，线程进入阻塞状态。当<code>sleep()</code>状态超时，<code>join()</code>等待下次终止或超时，或者<code>I/O</code>处理完毕，线程重新进入就绪状态。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>死亡状态**(TERMINATED)**</p>
<ul>
<li>线程死亡，变成垃圾，被垃圾回收机回收</li>
<li>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到死亡 状态。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834677.png" alt="image-20250223113515244"></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834067.png" alt="image-20250223113544705" style="zoom:80%;" />
<h3 id="线程安全问题"><a class="header-anchor" href="#线程安全问题"></a>线程安全问题</h3>
<ul>
<li>竞态条件（Race Condition）</li>
<li>内存可见性问题（Memory Visibility）</li>
<li>指令重排序（Reordering）</li>
</ul>
<h3 id="Java-内存模型（JMM）"><a class="header-anchor" href="#Java-内存模型（JMM）"></a>Java 内存模型（JMM）</h3>
<h4 id="主内存与工作内存"><a class="header-anchor" href="#主内存与工作内存"></a>主内存与工作内存</h4>
<h4 id="volatile-关键字"><a class="header-anchor" href="#volatile-关键字"></a>volatile 关键字</h4>
<p><strong>内存可见性 memory visibility</strong>：是指当某个线程正在使用 对象A 的状态而另一个线程也在同一时间修改 对象A 的状态。需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<p><strong>可见性错误</strong>：当 read 和 write 在不同线程中执行时，无法确保执行 read 的线程能及时看到其他线程 write 的值。</p>
<p>Java提供的一个同步机制，volatile 变量，用来确保将变量的更新操作通知到其他线程，相当于一个轻量级当不互斥的锁，无法保证变量状态的原子性操作。</p>
<h4 id="何为原子性"><a class="header-anchor" href="#何为原子性"></a>何为原子性</h4>
<p>即操作不可再分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，这个类的操作就不具有原子性，主要是 <code>serialNumber++</code> 操作，其本质分为：</p>
<ul>
<li>读取 serialNumber 当前值</li>
<li>serialNumber 的值加 1</li>
<li>将新值写会 serialNumber 的内存块中。</li>
</ul>
<p>由于这三个步骤不是原子的，因此在多线程环境下，可能会出现以下问题：</p>
<ul>
<li>
<p>竞态条件（Race Condition）</p>
<ul>
<li>
<p><strong>线程 A</strong> 读取 <code>serialNumber</code> 的值为 <code>0</code>。</p>
</li>
<li>
<p><strong>线程 B</strong> 也读取 <code>serialNumber</code> 的值为 <code>0</code>。</p>
</li>
<li>
<p><strong>线程 A</strong> 将 <code>serialNumber</code> 的值加 1，并写回 <code>1</code>。</p>
</li>
<li>
<p><strong>线程 B</strong> 也将 <code>serialNumber</code> 的值加 1，并写回 <code>1</code>。</p>
</li>
<li>
<p>最终，<code>serialNumber</code> 的值是 <code>1</code>，而不是预期的 <code>2</code></p>
</li>
</ul>
</li>
<li>
<p>数据不一致</p>
<ul>
<li>由于多个线程同时修改 <code>serialNumber</code>，可能导致 <code>serialNumber</code> 的值不符合预期。</li>
</ul>
</li>
</ul>
<h4 id="Happens-Before-规则"><a class="header-anchor" href="#Happens-Before-规则"></a>Happens-Before 规则</h4>
<h2 id="线程管理"><a class="header-anchor" href="#线程管理"></a>线程管理</h2>
<h3 id="线程创建"><a class="header-anchor" href="#线程创建"></a>线程创建</h3>
<h4 id="Thread-类"><a class="header-anchor" href="#Thread-类"></a>Thread 类</h4>
<p>Thread 创建线程方式：</p>
<p>创建线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li>
<li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li>
<li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li>
</ul>
<p>Thread 构造器：</p>
<ul>
<li><code>public Thread()</code></li>
<li><code>public Thread(String name)</code></li>
</ul>
<p>继承 Thread 类的优缺点：</p>
<ul>
<li>优点：编码简单</li>
<li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li>
</ul>
<p>Thread 类本身也是实现了 Runnable 接口，具有 Runnable 的属性，执行线程 run 方法底层也是调用的 Runnable 实例的 run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Runnable-接口"><a class="header-anchor" href="#Runnable-接口"></a>Runnable 接口</h4>
<p>Runnable 创建线程方式</p>
<p>创建线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">				t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>匿名内部类方式</p>
<p>Thread 的构造器：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
<li><code>public Thread(Runnable target, String name)</code></li>
</ul>
<h5 id="Runnable-方式的优缺点"><a class="header-anchor" href="#Runnable-方式的优缺点"></a>Runnable 方式的优缺点</h5>
<p>缺点：代码复杂一点。</p>
<p>优点</p>
<ol>
<li>
<p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p>
</li>
<li>
<p>同一个线程任务对象可以被包装成多个线程对象</p>
<ul>
<li>
<p><strong>任务与线程分离</strong>：<code>Runnable</code> 对象代表任务逻辑，可以被多个 <code>Thread</code> 对象共享。</p>
</li>
<li>
<p><strong>资源复用</strong>：同一个 <code>Runnable</code> 实例可以被多个线程执行，减少对象创建开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(); <span class="comment">// 任务对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task); <span class="comment">// 线程1</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task); <span class="comment">// 线程2</span></span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>适合多个线程去共享同一个资源</p>
<ul>
<li>
<p><strong>共享资源</strong>：多个线程可以共享同一个 <code>Runnable</code> 实例，从而共享实例中的资源（如变量、状态等）。</p>
</li>
<li>
<p><strong>线程安全</strong>：需要额外注意共享资源的线程安全问题（如使用同步机制）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SharedTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedTask</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p>
<p>即第 2 点，将任务对象与线程对象解耦，任务可以被多个线程共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务可以被多个线程共享</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务到线程池</span></span><br><span class="line">executor.submit(task);</span><br><span class="line">executor.submit(task);</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Callable-接口和-Future"><a class="header-anchor" href="#Callable-接口和-Future"></a>Callable 接口和 Future</h4>
<p>实现 Callable 接口：</p>
<ol>
<li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li>
<li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li>
<li>创建一个 Callable 的线程任务对象</li>
<li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li>
<li>把未来任务对象包装成线程对象</li>
<li>调用线程的 start() 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">      	<span class="type">Callable</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(callableDemo);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        t1.start();</span><br><span class="line">      	<span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> task.get();</span><br><span class="line">          System.out.println(i.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写线程任务类方法</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p>
<ul>
<li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li>
<li>线程池部分详解了 FutureTask 的源码</li>
</ul>
<p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>
<ul>
<li>get() 线程会阻塞等待任务执行完成</li>
<li>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：同 Runnable，并且能得到线程执行的结果</li>
<li>缺点：编码复杂</li>
</ul>
<h4 id="线程方法"><a class="header-anchor" href="#线程方法"></a>线程方法</h4>
<p>Thread 类 API：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public void start()</code></td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td style="text-align:left"><code>public void run()</code></td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td style="text-align:left"><code>public void setName(String name)</code></td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td style="text-align:left"><code>public void getName()</code></td>
<td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td style="text-align:left"><code>public static Thread currentThread()</code></td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void sleep(long time)</code></td>
<td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td style="text-align:left"><code>public static native void yield()</code></td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td style="text-align:left"><code>public final int getPriority()</code></td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td style="text-align:left"><code>public final void setPriority(int priority)</code></td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td style="text-align:left"><code>public void interrupt()</code></td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean interrupted()</code></td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean isInterrupted()</code></td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td style="text-align:left"><code>public final void join()</code></td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td style="text-align:left"><code>public final void join(long millis)</code></td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td style="text-align:left"><code>public final native boolean isAlive()</code></td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td style="text-align:left"><code>public final void setDaemon(boolean on)</code></td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody>
</table>
<h4 id="run-和-start"><a class="header-anchor" href="#run-和-start"></a>run 和 start</h4>
<p>run：称为<strong>线程体</strong>，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p>
<p>start：使用 start 是<strong>启动新的线程</strong>，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p>
<p>说明：<strong>线程控制资源类</strong></p>
<p>run() 方法中的异常不能抛出，只能 try/catch 捕获</p>
<ul>
<li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li>
<li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li>
</ul>
<h4 id="sleep-和-yield"><a class="header-anchor" href="#sleep-和-yield"></a>sleep 和 yield</h4>
<p>sleep：</p>
<ul>
<li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>
<li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行，<strong>需要抢占 CPU</strong></li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
<p>yield：</p>
<ul>
<li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
<li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li>
</ul>
<h4 id="join"><a class="header-anchor" href="#join"></a>join</h4>
<p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果目标线程仍在运行</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(millis); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></li>
<li>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</li>
<li>调用了 A线程 的 join 方法的 main线程 会进入阻塞，直到 A线程 执行完之后释放后才会执行 main线程 里的其他代码。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834783.jpg" alt="img"></p>
<p>等待线程结束</p>
<p>线程同步</p>
<ul>
<li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行
<ul>
<li>需要外部共享变量，不符合面向对象封装的思想</li>
<li>必须等待线程结束，不能配合线程池使用</li>
</ul>
</li>
<li>Future 实现（同步）：get() 方法阻塞等待执行结果
<ul>
<li>main 线程接收结果</li>
<li>get 方法是让调用线程同步等待</li>
</ul>
</li>
</ul>
<h4 id="interrupt"><a class="header-anchor" href="#interrupt"></a>interrupt</h4>
<p>打断线程</p>
<p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p>
<p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p>
<p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p>
<p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p>
<p>当线程在阻塞状态（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>）时被中断，会抛出 <code>InterruptedException</code>，并 <strong>清除中断状态</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompareAndSwap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断状态： &#123;&#125;&quot;</span> + t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834544.png" alt="image-20250223154404619"></p>
<h3 id="线程原理"><a class="header-anchor" href="#线程原理"></a>线程原理</h3>
<h4 id="运行机制"><a class="header-anchor" href="#运行机制"></a>运行机制</h4>
<p>Java Virtual Machine Stacks（Java 虚拟机栈）：<strong>每个线程启动后，虚拟机就会为其分配一块栈内存</strong></p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前正在执行的那个方法</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park 等方法</li>
</ul>
<p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p>
<ul>
<li>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</li>
<li><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</li>
</ul>
<p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<h4 id="线程状态"><a class="header-anchor" href="#线程状态"></a>线程状态</h4>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834158.png" alt="image-20250223133248781" style="zoom:50%;" />
<h2 id="线程池（核心）"><a class="header-anchor" href="#线程池（核心）"></a>线程池（核心）</h2>
<h3 id="基本概述"><a class="header-anchor" href="#基本概述"></a>基本概述</h3>
<p><strong>线程池</strong>：一个容纳多个线程都容器，容器中的线程可以重复使用，省去了繁琐的创建与销毁对象的操作</p>
<p><strong>线程池作用</strong>：</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<p><strong>核心思想</strong>：线程的复用，避免重复创建和销毁线程对象，同一个线程可以被重复利用来处理多个任务。</p>
<p><strong>池化技术 Pool</strong>：一种编程思想，核心是资源的重复利用，在请求量比较大时优化性能，降低系统频繁的资源开销</p>
<h3 id="阻塞队列"><a class="header-anchor" href="#阻塞队列"></a>阻塞队列</h3>
<p>有界队列和无界队列</p>
<ul>
<li>有界队列：有固定大小的队列，如设定大小固定的 <code>LinkedBlockingQueue</code></li>
<li>无界队列：没有设定固定大小，可以直接入队，知道溢出（超过 <code>Integer.MAX_VALUE</code>），相当于无界</li>
</ul>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的<strong>有界</strong>阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的<strong>无界</strong>（默认大小 Integer.MAX_VALUE）的阻塞队列</li>
<li>PriorityBlockQueue：支持优先级排序的<strong>无界</strong>阻塞队列</li>
<li>DelayedWorkQueue：使用优先级队列实现的延迟<strong>无界</strong>阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li>
<li>LinkedTransferQueue：由链表结构组成的<strong>无界</strong>阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li>
</ul>
<p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p>
<ul>
<li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li>
<li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li>
</ul>
<h4 id="核心方法"><a class="header-anchor" href="#核心方法"></a>核心方法</h4>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入（尾）</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（头）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查（队首元素）</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常组：
<ul>
<li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</li>
<li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li>
</ul>
</li>
<li>特殊值组：
<ul>
<li>插入方法：成功 true，失败 false</li>
<li>移除方法：成功返回出队列元素，队列没有就返回 null</li>
</ul>
</li>
<li>阻塞组：
<ul>
<li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li>
</ul>
</li>
<li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<h4 id="链表队列"><a class="header-anchor" href="#链表队列"></a>链表队列</h4>
<h5 id="入队：尾插"><a class="header-anchor" href="#入队：尾插"></a>入队：尾插</h5>
<ul>
<li>
<p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新节点入队：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 从右向左计算</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834223.png" alt="img"></p>
<h5 id="出队：出队头节点。FIFO"><a class="header-anchor" href="#出队：出队头节点。FIFO"></a>出队：出队头节点。FIFO</h5>
<ul>
<li>
<p>出队源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取临头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 自己指向自己，help GC</span></span><br><span class="line">    h.next = h;</span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 出队的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 【当前节点置为 Dummy 节点】</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>h = head</code> → <code>first = h.next</code></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834716.png" alt="img"></p>
</li>
<li>
<p><code>h.next = h</code> → <code>head = first</code></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011834593.png" alt="img"></p>
<ul>
<li><code>first.item = null</code>：当前节点置为 Dummy 节点</li>
</ul>
</li>
</ul>
<p>Executor 框架</p>
<p>ThreadPoolExecutor 参数详解：</p>
<ul>
<li>核心线程数、最大线程数</li>
<li>任务队列（<code>BlockingQueue</code>）</li>
<li>拒绝策略（<code>RejectedExecutionHandler</code>）</li>
</ul>
<p>Executors 工具类：</p>
<ul>
<li>newFixedThreadPool</li>
<li>newCachedThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newScheduledThreadPool</li>
</ul>
<h3 id="Fork-Join-框架"><a class="header-anchor" href="#Fork-Join-框架"></a>Fork/Join 框架</h3>
<p><code>RecursiveTask</code> 和 <code>RecursiveAction</code></p>
<p>工作窃取（Work-Stealing）算法</p>
<h2 id="同步与锁"><a class="header-anchor" href="#同步与锁"></a>同步与锁</h2>
<h3 id="临界区"><a class="header-anchor" href="#临界区"></a>临界区</h3>
<p>临界资源：一次仅允许一个进程使用的资源称为临界资源</p>
<p>临界区：访问临界资源的代码块</p>
<p>竞争条件：多个线程在临界区内执行，由于代码的执行顺序不同，导致结果不可预测，称之为竞争条件</p>
<p>一个程序运行多个线程是没有问题，</p>
<p>多个线程 read 共享资源也没有问题，</p>
<p>多个线程 read-And-write 共享资源操作时发生指令交错，就会出现问题</p>
<h4 id="为了避免竞态条件发生-解决线程安全问题"><a class="header-anchor" href="#为了避免竞态条件发生-解决线程安全问题"></a>为了避免竞态条件发生/解决线程安全问题</h4>
<ul>
<li>阻塞式的解决方案：synchronized，lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h4 id="对象锁-synchronized"><a class="header-anchor" href="#对象锁-synchronized"></a>对象锁 synchronized</h4>
<p>保证了临界区内代码的原子性，采用互斥的方式让同一个时刻至多有一个线程能够持有对象锁，其他线程会阻塞在获取对象锁上，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p>互斥和同步都可以采用 synchronized 来完成，区别：</p>
<ul>
<li>互斥是，临界区的竞争条件一定会发生，但是保证了同一时刻只有一个线程的临界区代码在执行</li>
<li>同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个节点</li>
</ul>
<p>性能：</p>
<ul>
<li>线程安全，性能差</li>
<li>线程不安全，性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li>
</ul>
<h3 id="syn-ed"><a class="header-anchor" href="#syn-ed"></a>syn-ed</h3>
<h4 id="使用锁"><a class="header-anchor" href="#使用锁"></a>使用锁</h4>
<p>锁对象：理论上可以是任意到唯一对象</p>
<p>synchronized 是可重入、不公平的重量级锁</p>
<p>原则上：</p>
<ul>
<li>锁对象建议使用共享资源</li>
<li>实例方法中使用 this 作为锁对象，锁住的 this 正好是关系对象</li>
<li>静态方法中使用 类名.class 字节码作为锁对象，静态成员属于类，被所有实例对象共享，所以需要锁住类</li>
</ul>
<ol>
<li><strong>内置锁（Synchronized）</strong>：
<ul>
<li>同步代码块和方法</li>
<li>锁的升级（偏向锁 → 轻量级锁 → 重量级锁）</li>
</ul>
</li>
<li><strong>显式锁</strong>：
<ul>
<li><code>Lock</code> 接口</li>
<li><code>ReentrantLock</code>（可重入锁）</li>
<li><code>ReentrantReadWriteLock</code>（读写锁）</li>
<li><code>StampedLock</code>（乐观读锁）</li>
</ul>
</li>
<li><strong>锁的优化与工具</strong>：
<ul>
<li>公平锁 vs 非公平锁</li>
<li><code>Condition</code> 条件变量</li>
<li><code>LockSupport</code>（线程阻塞工具）</li>
</ul>
</li>
</ol>
<h2 id="原子操作和无锁编程"><a class="header-anchor" href="#原子操作和无锁编程"></a>原子操作和无锁编程</h2>
<h3 id="原子类-java-util-concurrent-atmoic"><a class="header-anchor" href="#原子类-java-util-concurrent-atmoic"></a>原子类(java.util.concurrent.atmoic)</h3>
<p>在 Java 中可以通过 java.util.concurrent.atmoic 包提供的具有原子性操作的类来保证变量的线程安全</p>
<ul>
<li>
<p>基础类型：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></p>
</li>
<li>
<p>引用类型：<code>AtomicReference</code>、<code>AtomicStampedReference</code>（解决 ABA 问题）</p>
</li>
<li>
<p>数组类型：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code></p>
</li>
<li>
<p>字段更新器：<code>AtomicIntegerFieldUpdater</code></p>
</li>
<li>
<p>AtomicMarkableReference</p>
</li>
<li>
<p>AtomicReferenceArray</p>
</li>
</ul>
<h3 id="CAS-CompareAndSwap"><a class="header-anchor" href="#CAS-CompareAndSwap"></a>CAS CompareAndSwap</h3>
<blockquote>
<p>既解决了原子性问题,又解决了内存可见性问题</p>
</blockquote>
<p>用于管理对共享数据的并发访问。,是一种无锁的非阻塞算法的实现</p>
<p><strong>核心思想</strong>是“比较并交换”，通过硬件指令保证操作的原子性。</p>
<h4 id="核心操作"><a class="header-anchor" href="#核心操作"></a>核心操作:</h4>
<ul>
<li><strong>CAS 操作包含三个操作数</strong>：
<ol>
<li><strong>内存地址（V）</strong>: 需要更新的变量。</li>
<li><strong>期望值（A）</strong>: 变量的当前值。</li>
<li><strong>新值（B）</strong>: 希望将变量更新为的值。</li>
</ol>
</li>
<li><strong>CAS 的操作逻辑</strong>：
<ul>
<li>如果内存地址 <code>V</code> 中的值等于期望值 <code>A</code>，则将 <code>V</code> 的值更新为 <code>B</code>。</li>
<li>如果 <code>V</code> 的值不等于 <code>A</code>，则不做任何操作。</li>
</ul>
</li>
<li><strong>执行过程</strong>
<ol>
<li>读取内存地址 <code>V</code> 的当前值。</li>
<li>比较 <code>V</code> 的值是否等于期望值 <code>A</code>。</li>
<li>如果相等，则将 <code>V</code> 的值更新为 <code>B</code>，并返回 <code>true</code>。</li>
<li>如果不相等，则返回 <code>false</code>，表示更新失败。</li>
</ol>
</li>
<li><strong>重试机制</strong>:
<ul>
<li>如果 CAS 操作失败（即 <code>V</code> 的值不等于 <code>A</code>），通常会通过循环重试，直到操作成功。</li>
<li>这种机制称为 <strong>自旋（Spin）</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">CAS</span><span class="params">(V, A, B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (V == A) &#123;</span><br><span class="line">        V = B;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CAS具有原子性"><a class="header-anchor" href="#CAS具有原子性"></a>CAS具有原子性:</h4>
<ul>
<li>CAS 操作是原子的，即在执行过程中不会被其他线程打断。</li>
<li>这确保了在多线程环境下，CAS 操作是线程安全的。</li>
</ul>
<h4 id="优点"><a class="header-anchor" href="#优点"></a>优点</h4>
<ul>
<li><strong>无锁</strong>
<ul>
<li>是一种无锁 lock-free 机制,避免了线程阻塞和上下文切换的开销</li>
</ul>
</li>
<li><strong>高效</strong>
<ul>
<li>低竞争环境下,性能优于传统锁机制</li>
</ul>
</li>
<li><strong>可扩展下</strong>
<ul>
<li>适用于多核处理器和高并发</li>
</ul>
</li>
</ul>
<h4 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h4>
<ul>
<li>
<p><strong>ABA 问题</strong></p>
<ul>
<li>在 CAS 操作中，如果变量的值从 <code>A</code> 变为 <code>B</code>，然后又变回 <code>A</code>，CAS 会误认为变量没有被修改过。</li>
<li>解决方法：使用版本号或时间戳（如 <code>AtomicStampedReference</code>）</li>
</ul>
</li>
<li>
<p><strong>自旋开销</strong>:</p>
<ul>
<li>在高竞争的情况下，CAS 的自旋重试会导致 CPU 资源浪费</li>
</ul>
</li>
<li>
<p><strong>复杂性</strong>:</p>
<ul>
<li>实现无锁数据结构需要复杂的逻辑，容易出错。</li>
</ul>
</li>
</ul>
<h2 id="并发容器"><a class="header-anchor" href="#并发容器"></a>并发容器</h2>
<h3 id="并发集合："><a class="header-anchor" href="#并发集合："></a>并发集合：</h3>
<h3 id="ConcurrentHashMap（分段锁、CAS-优化）"><a class="header-anchor" href="#ConcurrentHashMap（分段锁、CAS-优化）"></a>ConcurrentHashMap（分段锁、CAS 优化）</h3>
<p>线程安全的 hash 表,每一段都是一个独立的锁</p>
<p>java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能</p>
<p>ConcurrentHashMap 同步容器类是 Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</p>
<p>包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、 ConcurrentSkipListMap、 ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。</p>
<h3 id="CopyOnWriteArrayList（写时复制）"><a class="header-anchor" href="#CopyOnWriteArrayList（写时复制）"></a>CopyOnWriteArrayList（写时复制）</h3>
<h3 id="ConcurrentLinkedQueue（无界非阻塞队列）"><a class="header-anchor" href="#ConcurrentLinkedQueue（无界非阻塞队列）"></a>ConcurrentLinkedQueue（无界非阻塞队列）</h3>
<h3 id="BlockingQueue-接口："><a class="header-anchor" href="#BlockingQueue-接口："></a>BlockingQueue 接口：</h3>
<ul>
<li><code>ArrayBlockingQueue</code>（有界阻塞队列）</li>
<li><code>LinkedBlockingQueue</code>（可选有界）</li>
<li><code>PriorityBlockingQueue</code>（优先级队列）</li>
<li><code>SynchronousQueue</code>（直接传递队列）</li>
<li><code>DelayQueue</code>（延迟队列）</li>
</ul>
<h3 id="并发工具类："><a class="header-anchor" href="#并发工具类："></a>并发工具类：</h3>
<h3 id="ConcurrentSkipListMap（跳表实现的有序-Map）"><a class="header-anchor" href="#ConcurrentSkipListMap（跳表实现的有序-Map）"></a>ConcurrentSkipListMap（跳表实现的有序 Map）</h3>
<h3 id="ConcurrentSkipListSet"><a class="header-anchor" href="#ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3>
<h2 id="同步工具类"><a class="header-anchor" href="#同步工具类"></a>同步工具类</h2>
<ol>
<li><strong>闭锁与计数器</strong>：
<ul>
<li><code>CountDownLatch</code>（等待多个任务完成）</li>
<li><code>CyclicBarrier</code>（可重用的栅栏）</li>
<li><code>Phaser</code>（更灵活的屏障，支持阶段控制）</li>
</ul>
</li>
<li><strong>信号量</strong>：
<ul>
<li><code>Semaphore</code>（控制并发线程数）</li>
</ul>
</li>
<li><strong>交换器</strong>：
<ul>
<li><code>Exchanger</code>（线程间交换数据）</li>
</ul>
</li>
<li><strong>Future 与异步编程</strong>：
<ul>
<li><code>Future</code> 和 <code>FutureTask</code></li>
<li><code>CompletableFuture</code>（链式异步编程）</li>
</ul>
</li>
</ol>
<h2 id="线程间通信"><a class="header-anchor" href="#线程间通信"></a>线程间通信</h2>
<ol>
<li><strong>等待/通知机制</strong>：
<ul>
<li><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code></li>
</ul>
</li>
<li><strong>线程局部变量</strong>：
<ul>
<li><code>ThreadLocal</code>（线程私有数据）</li>
</ul>
</li>
<li><strong>中断机制</strong>：
<ul>
<li><code>interrupt()</code>、<code>isInterrupted()</code>、<code>InterruptedException</code></li>
</ul>
</li>
</ol>
<h2 id="实际场景"><a class="header-anchor" href="#实际场景"></a>实际场景</h2>
<ol>
<li><strong>并发设计模式</strong>：
<ul>
<li>生产者-消费者模式</li>
<li>线程池模式</li>
<li>Master-Worker 模式</li>
</ul>
</li>
<li><strong>无锁数据结构</strong>：
<ul>
<li>无锁队列（<code>ConcurrentLinkedQueue</code>）</li>
<li>无锁栈</li>
</ul>
</li>
<li><strong>性能优化</strong>：
<ul>
<li>减少锁竞争（减小锁粒度、锁分离）</li>
<li>避免死锁（锁顺序、超时机制）</li>
</ul>
</li>
<li><strong>工具与调试</strong>：
<ul>
<li><code>jstack</code> 分析线程状态</li>
<li><code>jconsole</code> 监控线程</li>
<li>使用 <code>ThreadDump</code> 诊断死锁</li>
</ul>
</li>
</ol>
<h1 id="Java学习"><a class="header-anchor" href="#Java学习"></a>Java学习</h1>
<h2 id="synchronized以String变量为锁变量可能遇到的问题："><a class="header-anchor" href="#synchronized以String变量为锁变量可能遇到的问题："></a>synchronized以String变量为锁变量可能遇到的问题：</h2>
<p>假如在一个接口去接受http请求，有N个学生进行请求，其中有M个学校，那么为了提高性能，能够异步的对不同学校的请求进行并行处理，则可以以学校的String school这个字段作为锁变量，进行多线程运行。</p>
<p>当进行模拟时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">extracted</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="string">&quot;bda&quot;</span>))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="string">&quot;qhua&quot;</span>))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="string">&quot;qhua&quot;</span>))</span><br><span class="line">	</span><br><span class="line">	thread0.start();</span><br><span class="line">	thread1.start();</span><br><span class="line">	thread2.start();</span><br><span class="line">	</span><br><span class="line">	thread0.join();</span><br><span class="line">	thread1.join();</span><br><span class="line">	thread2.join();</span><br><span class="line">	</span><br><span class="line">	sout(valuse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/saving&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saving</span><span class="params">(String school)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(school)&#123;</span><br><span class="line">        sout(school + <span class="string">&quot;学生交卷&quot;</span>);</span><br><span class="line">		save(school);</span><br><span class="line">		sout(school + <span class="string">&quot;学生交卷完毕&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以实现我们的需求</p>
<p>但是会有一个问题，在spring实现的http请求中的字符串并非以常量的形式存在，而是以new出来的一个新的对象的形式存在，那就会存在一个问题，那就是即使是来自相同学校的请求，由于他们是不同的对象，说得到的引用是不同的（相当于直接拿String A == String B，即使字面量相同，但由于 “==” 比较的是两个对象的地址值，因而结果为false）那就无法做到线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">extracted</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bda&quot;</span>)))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;qhua&quot;</span>)))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;qhua&quot;</span>)))</span><br><span class="line">	</span><br><span class="line">	thread0.start();</span><br><span class="line">	thread1.start();</span><br><span class="line">	thread2.start();</span><br><span class="line">	</span><br><span class="line">	thread0.join();</span><br><span class="line">	thread1.join();</span><br><span class="line">	thread2.join();</span><br><span class="line">	</span><br><span class="line">	sout(valuse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/saving&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saving</span><span class="params">(String school)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(school)&#123;</span><br><span class="line">        sout(school + <span class="string">&quot;学生交卷&quot;</span>);</span><br><span class="line">		save(school);</span><br><span class="line">		sout(school + <span class="string">&quot;学生交卷完毕&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么为了解决这个问题就需要是得来自相同学校的对象，即String字面量相同的对象能够实现互斥，可以采用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">extracted</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bda&quot;</span>)))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;qhua&quot;</span>)))</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; saving(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;qhua&quot;</span>)))</span><br><span class="line">	</span><br><span class="line">	thread0.start();</span><br><span class="line">	thread1.start();</span><br><span class="line">	thread2.start();</span><br><span class="line">	</span><br><span class="line">	thread0.join();</span><br><span class="line">	thread1.join();</span><br><span class="line">	thread2.join();</span><br><span class="line">	</span><br><span class="line">	sout(valuse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/saving&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saving</span><span class="params">(String school)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(school.intern())&#123;</span><br><span class="line">        sout(school + <span class="string">&quot;学生交卷&quot;</span>);</span><br><span class="line">		save(school);</span><br><span class="line">		sout(school + <span class="string">&quot;学生交卷完毕&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过intern方法来以string对象的字面量来作为锁资源，就可以解决问题。</p>
<p>但是还是会存在一个问题，那就得先说一下intern方法的底层原理：</p>
<ol>
<li>intern方法是一个native method(非java语言实现的java接口)，该方法的主要作用是，每当一个string对象调用，就会去串池里找是否有和对象字面量相同的常量对象：
<ol>
<li>如果有则直接返回常量对象的引用；</li>
<li>如果没有则会先创建常量对象，再返回该对象的引用。</li>
</ol>
</li>
</ol>
<p>因而通过intern方法虽然可以解决单个业务里相同请求串行，不同请求并行的需求</p>
<p>但是由于串池是一个全局的概念，如果有多个业务，需要以学校这个常量作为锁资源，就会造成阻塞，反而降低了性能。</p>
<p>那么解决方案有：</p>
<ol>
<li>创建一个字段单独针对一个接口去创建一个池，即使用一个HashMap，进而从全局的串池修改为局部的一个接口的池</li>
<li>直接将业务名称的请求地址和对象进行拼接，也可以避免不同业务之间进行阻塞</li>
</ol>
]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq 高级篇</title>
    <url>/2025/03/05/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/rabbitmq%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<h1 id="rabbitmq-高级篇"><a class="header-anchor" href="#rabbitmq-高级篇"></a>rabbitmq 高级篇</h1>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051944711.png" alt="image-20250305194433652"></p>
<p>假如 MQ 通知失败，那么会出现数据不一致的问题，此时就涉及到了消息可靠性（即消息至少被消费者处理过 1 次），接下来将介绍一些实践中常见的确保消息可靠性的手段</p>
<h2 id="发送者可靠性"><a class="header-anchor" href="#发送者可靠性"></a>发送者可靠性</h2>
<h3 id="发送者重连"><a class="header-anchor" href="#发送者重连"></a>发送者重连</h3>
<p>有时由于网络波动，可能出现发送者连接 MQ 失败的情况，此时通过配置可以开启连接失败后的重连机制：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure>
<p>【注：在网络存在不稳定的情况下，重试机制可以提高消息发送的成功率。但 SpringAMQP 提供的重试机制是阻塞式的，会阻塞当前线程的正常执行，影响业务性能，建议禁用重试机制而采用<strong>异步</strong>线程来执行发送消息到代码】</p>
<h3 id="发送者确认"><a class="header-anchor" href="#发送者确认"></a>发送者确认</h3>
<p>SpringAMQP 提供了 Publisher Confirm 和 Publisher Return 两种确认机制。开启确认机制后，当发送者发送消息给 MQ 后，MQ 会确认结果给发送者。返回结果情况如下：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503052118944.png" alt="发送者确认机制"></p>
<ul>
<li>消息投递到了 MQ，但路由失败。此时通过 PublisherReturn 返回路由异常原因，然后返回 ACK，告知投递成功。</li>
<li>临时消息投递到了 MQ，并且入队成功，返回 ACK，告知投递成功</li>
<li>持久化消息投递到了 MQ，并且入队完成持久化，返回 ACK，告知投递成功</li>
<li>其他情况都是 NACK，告知投递失败</li>
</ul>
<h4 id="开启确认机制："><a class="header-anchor" href="#开启确认机制："></a>开启确认机制：</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure>
<p>这里<code>publisher-confirm-type</code>有三种模式可选：</p>
<ul>
<li><code>none</code>：关闭confirm机制</li>
<li><code>simple</code>：同步阻塞等待MQ的回执</li>
<li><code>correlated</code>：MQ异步回调返回回执</li>
</ul>
<p>【注：一般我们推荐使用<code>correlated</code>，回调机制。】</p>
<h4 id="ReturnCallback"><a class="header-anchor" href="#ReturnCallback"></a>ReturnCallback</h4>
<p>用来确认消息是否从 Exchange 到 Queue，无法路由到任何 Queue 时触发回调</p>
<ul>
<li><strong>触发条件</strong>：
<ul>
<li>发送消息时设置了 <code>mandatory=true</code>（强制路由）。</li>
<li>Exchange 根据 <code>routingKey</code> 无法找到匹配的 Queue。</li>
</ul>
</li>
</ul>
<h4 id="ConfirmCallback"><a class="header-anchor" href="#ConfirmCallback"></a>ConfirmCallback</h4>
<p>确认消息是否被 RabbitMQ Broker 成功接收并持久化到 Exchange。</p>
<p><strong>触发场景</strong>：</p>
<ul>
<li><strong>成功</strong>：Broker 收到消息后会发送 <code>ack</code>（确认应答）。</li>
<li><strong>失败</strong>：Broker 可能返回 <code>nack</code>（未确认应答，例如 Exchange 不存在或队列不可用）</li>
</ul>
<p>【注：这种消息确认机制较为浪费性能，因此一般不建议开启】</p>
<h2 id="MQ可靠性"><a class="header-anchor" href="#MQ可靠性"></a>MQ可靠性</h2>
<p>默认情况下，rabbitmq 会将接收的消息保存在内存中以降低消息收发的延迟，但会导致两个问题：</p>
<ul>
<li>一旦 MQ 宕机，内存中的消息会丢失</li>
<li>内存空间有限，当消费者故障或处理过慢，会导致消息积压，引发 MQ 阻塞</li>
</ul>
<h3 id="数据持久化"><a class="header-anchor" href="#数据持久化"></a>数据持久化</h3>
<ul>
<li>交换机持久化：控制台或 Spring AMQP 创建的交换机一般默认是持久化的 <code>Durable</code></li>
<li>队列持久化：控制台或 Spring AMQP 创建的队列一般默认也是持久化到 <code>Durable</code></li>
<li>消息持久化：delivery mode 设置为： <code>persisent</code></li>
</ul>
<h3 id="Lazy-Queue"><a class="header-anchor" href="#Lazy-Queue"></a>Lazy Queue</h3>
<p>特点：</p>
<ul>
<li>接收到消息后直接存入磁盘，不再存储到内存</li>
<li>消费者要消费消息时，才会从磁盘读取并加载到内存（可以提前缓存部分消息到内存，最多 2048 条）</li>
</ul>
<p>【注：3.12版本后，所有队列都是 Lazy Queue 模式，无法更改】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>'&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;'</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li>
</ul>
<h2 id="消费者可靠性"><a class="header-anchor" href="#消费者可靠性"></a>消费者可靠性</h2>
<h3 id="消费者确认机制"><a class="header-anchor" href="#消费者确认机制"></a>消费者确认机制</h3>
<p>为了确认消费者是否成功处理消息。当消费者处理消息结束后，应该向 rabbitMQ 发送一个回执，告知 rabbitmq 自己对于消息的处理状态（处理成功，处理失败）</p>
<ul>
<li>ack：消费者处理成功，返回 ack 给 queue，而后 queue会把消息从队列中移除</li>
<li>nack：消费者处理异常，返回 nack 给 queue，queue 重新投递 msg 给消费者，不断重试。</li>
<li>reject：消费者处理失败，返回 reject，告知 queue 无需重发 msg，rabbitmq 从队列中删除该消息。（这种情况一般发生在 msg 本身有问题，可能是数据格式不符，也可能是危险消息）</li>
</ul>
<p>【注：以上三种情况都应该在消费者业务完成之后再返回状态】</p>
<p>SringAMQP 提供了三种消息确认机制，通过配置文件来选择处理方法：</p>
<ul>
<li>
<p><strong>none</strong>：不处理。即消息投递给消费者后立刻 ack，消息会立刻从 mq 删除。安全性较差（因为不知道内部业务是否成功处理消息，可能会需要队列重发 msg，但队列已经将 msg 删除了），不建议。</p>
</li>
<li>
<p><strong>manual</strong>：手动模式。需要自定义处理逻辑，发送 ack 或 reject，存在业务入侵，但更灵活</p>
</li>
<li>
<p><strong>auto</strong>：自动模式。SpringAMQP 利用 aop 对消息处理做了环绕增强，当业务正常执行时则自动返回 ack。【推荐】</p>
<p>业务抛出异常，会根据异常的不同而返回不同的结果：</p>
<ul>
<li>
<p>如果是业务异常，返回 nack</p>
</li>
<li>
<p>如果是消息处理或校验异常，自动返回 reject</p>
<p>返回 reject 的常见异常：</p>
<ul>
<li>MessageConversionException</li>
<li>MethodArgumentNotValidException</li>
<li>MethodArgumentTypeMismatchException</li>
<li>NoSuchMethodException</li>
<li>ClassCastException</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>配置设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span>  <span class="comment"># none 不做处理，manual 手动处理，auto spring 框架自动处理</span></span><br></pre></td></tr></table></figure>
<p>通过测试可以观察到，queue 接收到消息以后，一个消息会先进入 Ready 状态，在消费者发送异常时消息的状态：</p>
<ul>
<li>none：直接被 queue 移除</li>
<li>auto：会进入 nack 的状态，准备重发；进入 reject 状态，队列移除消息，不会重发</li>
</ul>
<h3 id="失败重试机制"><a class="header-anchor" href="#失败重试机制"></a>失败重试机制</h3>
<p>消费者出现异常后，消息会不断 requeue 到队列，再重发给消费者。如果消费者再次执行依然出错，消息会再次 requeue 到队列，再次投递，直到 ack 为止。</p>
<p>极端情况下，消费者一直处理失败，消息会不断 requeue，导致 mq 的消息处理激增，造成不必要的压力。（发送概率较低），为了防止这种极端情况，spring 也提供了消费者失败重试机制，消费者出现异常时利用本地重试，而不是无限制的 requeue 到 mq 队列。</p>
<p>修改consumer服务的application.yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>
<h4 id="失败消息处理策略"><a class="header-anchor" href="#失败消息处理策略"></a>失败消息处理策略</h4>
<p>开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有 MessageRecover 接口来处理，包含三种不同实现</p>
<ul>
<li>
<p>RejectAndDontRequeueRecoverer：重试耗尽后，直接 reject，丢弃消息【默认】</p>
</li>
<li>
<p>ImmediateRequeueMessageRecoverer：重试耗尽后，返回 nack，消息重新入队</p>
</li>
<li>
<p>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定交换机。【最推荐的方案，失败后将消息投递到指定的、专门存放异常消息的队列，由人工进行集中处理】</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503060923273.png" alt="image-20250306092320983"></p>
<p>实现方式：</p>
<ul>
<li>
<p>首先，consumer 定义接收失败消息的交换机、队列及其绑定关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后，定义 RepublishMessageRecoverer，关联队列和交换机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="业务幂等性-⭐-⭐-⭐"><a class="header-anchor" href="#业务幂等性-⭐-⭐-⭐"></a>业务幂等性 ⭐ ⭐ ⭐</h3>
<p><strong>解决消息重复消费的问题</strong>：可能因为意外导致 MQ 没有成功接收到消费者返回的 ack，而后会在意外恢复时重新向消费者投递已经处理过的消息，这会导致消息的重复处理，进而导致业务出现代码外的问题。</p>
<blockquote>
<p>幂等是一个数学概念，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=f(f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>，在程序开发中，是指同一个业务，执行一次或 n 次对业务状态的影响是一致的。</p>
</blockquote>
<p>判断业务是否天然具有幂等性：</p>
<p>幂等的：</p>
<ul>
<li>查询业务，根据 id 查询商品</li>
<li>删除业务，根据 id 删除商品</li>
</ul>
<p>非幂等的：</p>
<ul>
<li>用户下单，需要扣减余额、扣减库存</li>
<li>用户退款，需要恢复余额</li>
</ul>
<h4 id="唯一消息-id"><a class="header-anchor" href="#唯一消息-id"></a>唯一消息 id</h4>
<p>每个消息都设置一个<strong>唯一 id</strong>，利用 id 区分是否是重复消息</p>
<ul>
<li>每一条消息都生成一个唯一的 id，与消息一起投递给消费者</li>
<li>消费者收到消息后处理自己的业务，业务处理成功后将消息 id 保存到数据库</li>
<li>如果下次又收到了相同消息，去数据库查询是否已经存在，存在则作为重复消息丢弃</li>
</ul>
<p>在jackson消息转换器可以配置自动生成唯一 id</p>
<p>发送者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收者：</p>
<p>使用 Message 来接收队列投递的消息，而后通过 getProperties 和 getBody 方法来获取消息内的信息</p>
<p>【注：这种方案会多出业务无关的处理逻辑，造成了业务入侵】</p>
<h3 id="业务判断"><a class="header-anchor" href="#业务判断"></a>业务判断</h3>
<p>结合业务逻辑，基于业务本身做判断。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503061001513.png" alt="image-20250306100146277"></p>
<p>只有当订单状态为“未支付”时才能修改为“已支付”，其他状态都不会被修改，即修改业务的部分逻辑以达到幂等性</p>
<h3 id="黑马商场中保证支付与交易服务订单状态的一致性"><a class="header-anchor" href="#黑马商场中保证支付与交易服务订单状态的一致性"></a>黑马商场中保证支付与交易服务订单状态的一致性</h3>
<ul>
<li>首先，支付服务会在用户支付成功后通过 MQ 发送消息通知交易服务，完成订单状态同步</li>
<li>为了保证消息的可靠性，采用生产者确认机制，消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同事开启 MQ 的持久化，避免因服务器宕机导致消息的 丢失</li>
<li>最后在交易服务更新订单状态时进行了业务幂等判断（一般是分布式唯一 id ➕ 对支付状态的判断“是否为未支付”，只有未支付才可以进行修改），避免消息重复消费导致订单状态异常</li>
</ul>
<h2 id="延迟消息"><a class="header-anchor" href="#延迟消息"></a>延迟消息</h2>
<h3 id="背景引入"><a class="header-anchor" href="#背景引入"></a>背景引入</h3>
<p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p>
<p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p>
<p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p>
<p>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p>
<p>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p>
<p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p>
<p>在RabbitMQ中实现延迟消息也有两种方案：</p>
<ul>
<li>死信交换机+TTL</li>
<li>延迟消息插件</li>
</ul>
<h3 id="死信交换机"><a class="header-anchor" href="#死信交换机"></a>死信交换机</h3>
<p>当一个队列内的消息满足下列情况之一，就变成了死信（dead letter）：</p>
<ul>
<li>消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false</li>
<li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果队列通过 dead-letter-exchange 属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机</p>
]]></content>
      <tags>
        <tag>rabbitmq</tag>
        <tag>中间件</tag>
        <tag>高级篇</tag>
      </tags>
  </entry>
  <entry>
    <title>es 基础篇</title>
    <url>/2025/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/elasticsearch%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Elasticsearch学习"><a class="header-anchor" href="#Elasticsearch学习"></a>Elasticsearch学习</h1>
<blockquote>
<p><a href="https://www.elastic.co/docs">官方文档</a>，学习过程中遇到任何问题首先是尝试从官方文档中查找解决方法，同时也可以加深自己对技术特性的了解</p>
</blockquote>
<h2 id="Elasticsearch-生态丰富"><a class="header-anchor" href="#Elasticsearch-生态丰富"></a>Elasticsearch 生态丰富</h2>
<p>elasticsearch 生态丰富，包含一系列工具和功能，帮助用户处理、分析和可视化数据，</p>
<p>核心组成为：</p>
<ul>
<li>Elasticsearch：核心搜索引擎，负责存储、索引和搜索数据</li>
<li>Kibana：可视化平台、用于查询、分析和展示 Elasticsearch 中的数据</li>
<li>Logstash：数据处理管道，负责数据收集、过滤、增强和传输到 Elasticsearch。</li>
<li>Beats：轻量级的数据传输工具，收集和发生数据到 Logstash 或 Elasticsearch</li>
</ul>
<h2 id="核心概念"><a class="header-anchor" href="#核心概念"></a>核心概念</h2>
<ul>
<li><strong>索引 index</strong>：类似于关系型数据库中的表，索引是数据存储和搜索的 <strong>基本单位</strong>，每个索引可以存储多条文档数据</li>
<li><strong>文档 document</strong>：索引中的每条记录，类似于数据库中的行。以 json 格式存储</li>
<li><strong>字段 field</strong>：文档中的每个键值对，类似于数据库中的列。</li>
<li><strong>映射 mapping</strong>：（类似于 sql 建表语句）用于定义 Elasticsearch 索引中文档字段的数据类型及其处理方式，类似于关系型数据库中的 Schema 表结构，帮助控制字段的存储、索引和查询行为。</li>
<li><strong>集群 cluster</strong>：多个节点组成的群集，用于存储数据并提供搜索功能。集群中的每个节点都可以处理数据。</li>
<li><strong>分片 shard</strong>：为了实现横向扩展，ES 将索引拆分成多个分片，每个分片可以分布在不同节点上。</li>
<li><strong>副本 replica</strong>：分片的复制品，用于提高可用性和容错性。</li>
</ul>
<h2 id="全文检索（分词检索）的原理"><a class="header-anchor" href="#全文检索（分词检索）的原理"></a>全文检索（分词检索）的原理</h2>
<ol>
<li>分词：Elasticsearch 的分词器会将输入文本拆解为独立的词条（tokens），方便进行索引和搜索，分词的具体步骤：
<ul>
<li><strong>字符过滤</strong>：去除特殊字符、HTML 标签或进行其他文本清理。</li>
<li>分词：根据指定的分词器（analyzer），将文本按规则拆分为一个个词条，如：英文可以按空格、中文使用专门的分词器处理</li>
<li><strong>词汇过滤</strong>：对分词结果进行过滤，如：去掉停用词（无意义的词，如：“the”，“is”等）或进行词形归并（如：将动词变为原形）。</li>
</ul>
</li>
</ol>
<p>Elasticsearch 内置了很多分词器，比如按照空格分词等，默认只支持英文，详见<a href="https://www.elastic.co/docs">官方文档</a>。</p>
<ol start="2">
<li>倒排索引：</li>
</ol>
<p>倒排索引是 Elasticsearch 实现高效搜索的核心数据结构。将文档中的词条映射到文档 ID ，实现快速查找。</p>
<p>原理：</p>
<ul>
<li>每个文档在被索引时，分词器会将文档内容拆解为多个词条。</li>
<li>而后，Elasticsearch 为每个词条生成一个倒排索引，记录该词条在哪些文档中出现。</li>
</ul>
<h2 id="打分规则"><a class="header-anchor" href="#打分规则"></a>打分规则</h2>
<p>搜索到内容的同时要把和用户搜索最相关的内容展示在前面，因此需要引入打分规则。</p>
<p>打分规则(_Score)是用于衡量每个文档与查询条件的匹配度的评分机制，搜索结果的默认排序方式是按性关系得分(__Source)从高到低。</p>
<p>采用的是 <strong>BM25</strong> 算法来计算每个文档的得分，是基于词频、反向文档频率、文档长度等因素来评估文档和查询的相关性。</p>
<p>影响得分的主要因素：</p>
<ul>
<li><strong>词频 TF,Term Frequency</strong>：查询词在文档中出现的次数，出现次数越多，得分越高</li>
<li><strong>反向文档频率 IDF,Inverse document frequency</strong>：查询词在文档中出现的频率，词在越少的文档中出现，IDF 值越高，得分越高。</li>
<li><strong>文档长度</strong>：较短的文档被认为更有相关性，因为查询词在短文档中占的比例更大。</li>
</ul>
<h2 id="ES-查询语法"><a class="header-anchor" href="#ES-查询语法"></a>ES 查询语法</h2>
<p>Elasticsearch 支持多种查询语法，用于不同的场景和需求，主要包括查询 DSL, EQL, SQL 等。</p>
<h3 id="DSL-查询（Domain-Specific-Language）"><a class="header-anchor" href="#DSL-查询（Domain-Specific-Language）"></a>DSL 查询（Domain Specific Language）</h3>
<p>基于 JSON 的查询语言，是 Elasticsearch 中最常见的查询方式。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;message&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Elasticsearch 功能性强&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>查询会对 message 字段进行分词，并查找包括 “Elasticsearch” 和 “功能” 词条的文档。</p>
<h3 id="EQL-Event-Query-Language"><a class="header-anchor" href="#EQL-Event-Query-Language"></a>EQL Event Query Language</h3>
<p>用于检测和检索时间序列 事件 的查询语言，常用于日志和安全监控场景</p>
<h3 id="SQL-查询"><a class="header-anchor" href="#SQL-查询"></a>SQL 查询</h3>
<p>支持传统 SQL 数据库查询语法</p>
<h2 id="Elasticsearch-常见的查询条件"><a class="header-anchor" href="#Elasticsearch-常见的查询条件"></a>Elasticsearch 常见的查询条件</h2>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>介绍</th>
<th>示例</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td>用于全文检索，将查询字符串进行分词并匹配文档中对应的字段</td>
<td></td>
<td>适用于全文检索，分词后匹配文档内容。</td>
</tr>
<tr>
<td>term</td>
<td>精确匹配查询，不进行分词，通常用于结构化数据的精确匹配，如数字，日期，关键字等。</td>
<td></td>
<td>适用于字段的精确匹配，如状态、ID、布尔值等。</td>
</tr>
<tr>
<td>terms</td>
<td>匹配多个值中的任意一个，相当于多个 term 查询的组合</td>
<td></td>
<td>适用于多值匹配的场景。</td>
</tr>
<tr>
<td>range</td>
<td>范围查询，常用于数字，日期字段，支持大于get，小于let，区间等查询</td>
<td></td>
<td>适用于数值或日期的范围查询。</td>
</tr>
<tr>
<td>bool</td>
<td>组合查询，通过 must , should , must_not 等组合多个查询条件</td>
<td></td>
<td>适用于复杂的多条件查询，可以灵活组合。</td>
</tr>
<tr>
<td>wildcard</td>
<td>通配符查询，支持 * 和 ? ，匹配任意字符和匹配单个字符</td>
<td></td>
<td>适用于部分匹配的查询，如模糊搜索。</td>
</tr>
<tr>
<td>prefix</td>
<td>前缀查询，匹配以指定前缀开头的字段内容</td>
<td></td>
<td>适用于查找以指定字符串开头的内容。</td>
</tr>
<tr>
<td>fuzzy</td>
<td>模糊查询，允许指定程度的拼写错误或字符替换</td>
<td></td>
<td>适用于处理拼写错误或不完全匹配的查询。</td>
</tr>
<tr>
<td>exists</td>
<td>查询字段是否存在</td>
<td></td>
<td>适用于查找字段存在或缺失的文档。</td>
</tr>
<tr>
<td>match_phrase</td>
<td>短语匹配查询，要求查询的词语按顺序完全匹配</td>
<td></td>
<td>适用于严格的短语匹配，词语顺序和距离都严格控制。</td>
</tr>
<tr>
<td>match_all</td>
<td>匹配所有文档</td>
<td></td>
<td>适用于查询所有文档，通常与分页配合使用。</td>
</tr>
<tr>
<td>ids</td>
<td>基于文档 ID 查询，支持查询特定 ID 的文档</td>
<td></td>
<td>适用于根据文档 ID 查找特定文档。</td>
</tr>
<tr>
<td>geo_distance</td>
<td>地理位置查询，基于地理坐标和指定距离查询</td>
<td></td>
<td>适用于根据距离计算查找地理位置附近的文档。</td>
</tr>
<tr>
<td>aggregations</td>
<td>聚合查询，用于统计、计算和分组查询，类似于 SQL 中的 group_by</td>
<td></td>
<td>适用于统计和分析数据，比如求和、平均值、最大值等。</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<ul>
<li>精确匹配 vs. 全文检索：term 精确匹配，不分词；match 全文检索，会对查询词进行分词</li>
<li>组合查询：bool 查询可以灵活组合多个条件，适用于复杂的查询需求</li>
<li>模糊查询：fuzzy 和 wildcard 提供了灵活的模糊匹配方式，适用于拼写错误或不完全匹配场景。</li>
</ul>
<h2 id="ES-数据同步方案"><a class="header-anchor" href="#ES-数据同步方案"></a>ES 数据同步方案</h2>
<p>一般情况下，如果做查询搜索功能，使用 ES 来模糊搜索，但是数据是存放在数据库 MYSQL 中的，所以需要把 MYSQL 中的数据和 ES 进行同步，保证数据一致（以 MYSQL 为主）</p>
<p>数据流向：MYSQL =&gt; ES 单向</p>
<p>数据同步 2 个过程：全量同步（第一次） + 增量同步（更新数据）</p>
<h3 id="4-种主流方案："><a class="header-anchor" href="#4-种主流方案："></a>4 种主流方案：</h3>
<h4 id="定时任务"><a class="header-anchor" href="#定时任务"></a>定时任务</h4>
<p>固定xx分钟同步 1 次</p>
<ul>
<li>优：
<ul>
<li>简单、易于开发、部署、维护</li>
<li>占用资源少，无需引入复杂的第三方中间件</li>
<li>不用处理复杂的并发和实时性问题</li>
</ul>
</li>
<li>缺
<ul>
<li><strong>有时间差</strong>：无法做到实时同步，数据存在滞后</li>
<li>数据频繁变化时，无法确保数据完全同步，任意出现错过更新的情况</li>
<li>对大数据量的更新处理不够高效，可能会引入重复更新逻辑</li>
</ul>
</li>
<li>场景：
<ul>
<li>数据实时性要求不高</li>
<li>数据几乎不发生修改</li>
<li>数据容忍丢失</li>
</ul>
</li>
</ul>
<h4 id="双写"><a class="header-anchor" href="#双写"></a>双写</h4>
<p>写数据时，必须同时写 ES；更新删除数据库也同理</p>
<p>可以通过事务保持数据一致性，使用事务时，先保证 MYSQL 写成功，因为 ES 没有回滚功能，可以通过定时任务 + 日志 + 告警进行检测和修复（补偿）</p>
<ul>
<li>优：
<ul>
<li>简单，业务逻辑直接控制数据同步</li>
<li>可以利用事务部分保证 MYSQL 和 ES 的数据一致性</li>
<li>同步的时延较短，理论上做到实时更新 ES</li>
</ul>
</li>
<li>缺：
<ul>
<li>影响性能，因为操作 MYSQL 时也需要操作 ES。</li>
<li>一致性问题，如果 ES 写入失败，MYSQL 事务提交后，ES 可能丢失数据；或 ES 写入成功，但 MYSQL 事务提交失败，ES 无法回滚。因此需要引入额外的监控、补偿机制来检测同步失败的情况（定时任务、日志和告警修复）</li>
<li>代码复杂，需要对每一个写操作都进行<strong>双写</strong>处理</li>
</ul>
</li>
</ul>
<h4 id="用-Logstash-数据同步管道"><a class="header-anchor" href="#用-Logstash-数据同步管道"></a>用 Logstash 数据同步管道</h4>
<p>配合 Kafka 信息队列 +  beats 采集器：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011219736.png" alt="image-20250301121950666"></p>
<ul>
<li>
<p><strong>优</strong>:</p>
<ul>
<li><strong>配置驱动</strong>：基于配置文件，减少了手动编码，数据同步逻辑和业务代码解耦。</li>
<li><strong>扩展性好</strong>：可以灵活引入 Kafka 等消息队列实现异步数据同步，并可处理高吞吐量数据。</li>
<li>支持多种数据源：Logstash 支持丰富的数据源，方便扩展其他同步需求。</li>
</ul>
</li>
<li>
<p><strong>缺</strong>:</p>
<ul>
<li><strong>灵活性差</strong>：需要通过配置文件进行同步，复杂的业务逻辑可能难以在配置中实现，无法处理细粒度的定制化需求。</li>
<li>引入额外组件，维护成本高:通常需要引入 Kafka、Beats 等第三方组件，增加了系统的复杂性和运维成本。</li>
</ul>
</li>
<li>
<p>应用场景:</p>
<ul>
<li><strong>大数据同步</strong>：适合大规模、分布式数据同步场景。</li>
<li><strong>对实时性要求不高</strong>适合数据流处理或延迟容忍较大的系统,</li>
<li>系统已有 Kafka 或类似的消息队列架构:如果系统中已经使用了 Kafka 等中间件，使用 Logstash 管道会变得很方便。</li>
</ul>
</li>
</ul>
<h4 id="监听-MYSQL-Binlog"><a class="header-anchor" href="#监听-MYSQL-Binlog"></a>监听 MYSQL Binlog</h4>
<p>有任何数据变更时都能够实时监听到，并且同步到 Elasticsearch，一般不需要自己监听，可以使用现成的技术，如 Canal。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011225501.png" alt="image-20250301122512429"></p>
<p>Canal 核心原理：数据库每次修改时，会修改 binlog 文件，只需要监听文件的修改，就能第一时间得到信息并处理</p>
<ul>
<li>优：
<ul>
<li><strong>实时性强</strong>：能够在 MYSQL 数据发生变更的第一时间同步到 ES，做到真正的实时同步</li>
<li>轻量级：Binlog 时数据库自带的日志功能，不需要修改核心业务代码，只需要新增监听逻辑</li>
</ul>
</li>
<li>缺：
<ul>
<li>引入外部依赖：需要引入像 Canal 这类中间件，增加了系统复杂性和维护成本</li>
<li>运维难度增加：需要确保 Canal 或其他监听器的稳定运行，并且对 MYSQL 的 binlog 配置要求较高</li>
<li>一致性问题：如果 Canal 服务出现问题或暂停，数据可能会滞后或丢失，必须设计补偿机制。</li>
</ul>
</li>
<li>场景：
<ul>
<li>实时同步要求高：高并发，高数据一致性要求</li>
<li>数据频繁变化：数据变更频繁且需要高效增量同步</li>
</ul>
</li>
</ul>
<h2 id="分词器"><a class="header-anchor" href="#分词器"></a>分词器</h2>
<p>ES 自带的分词器只支持英文分词，因此需要多安装一个中文分词器 IK 分词器，IK 分词器提供了两个分词器： ik_smart 和 ik_max_word。</p>
<ul>
<li>ik_smart 是智能分词，尽量选择最像 “词” 的拆分方式，如：“好学生” 会被识别为一个词。
<ul>
<li>适用于<strong>搜索分词</strong>，即查询时使用，保证性能同时提供合理的分词精度。</li>
</ul>
</li>
<li>ik_max_word 是尽可能分词，可以包括组合词，比如：“好学生” 会被识别为 3 个词：好学生，好学，学生
<ul>
<li>适用于<strong>底层索引分词</strong>，确保在建立索引时尽可能多地分词，提高查询时的匹配度和覆盖面。</li>
</ul>
</li>
</ul>
<p>更多详见<a href="https://github.com/infinilabs/analysis-ik">analysis-ik 官方文档</a>。</p>
<h2 id="设计-ES-索引"><a class="header-anchor" href="#设计-ES-索引"></a>设计 ES 索引</h2>
<p>为了将 MySQL 题目表数据导入到 Elasticsearch 中并实现分词搜索,需要为 ES 索引定义 mapping。ES 的 mapping 用于定义字段的类型、分词器及其索引方式。<br>
相当于数据库的建表，数据库建表时我们要考虑索引，同样 Elasticsearch 建立索引时，要考虑到字段选取、分词器、字段格式等问题。</p>
<p>在实际操作中即根据数据库表的字段去设计 mapping ，</p>
<ol>
<li>考虑哪些字段需要作为 mapping 里的一个 properties。</li>
<li>考虑作为 properties 的字段的 “type”，“analyzer”，“search_analyzer”（在使用 IK 分词器时，则是建立索引用 ik_max_word，查询用 ik_smart）</li>
</ol>
<p>在面试鸭项目中 ，建立题目 mapping 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;editTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isDelete&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ul>
<li>
<p>title，content，answer：</p>
<p>这些字段被定义为 text 类型，适合存储较长的、需要全文搜索的内容。由于会有中文内容，所以使用 IK 中文分词器进行分词处理，提高查询的灵活性和匹配度。</p>
<ul>
<li><code>&quot;analyzer&quot;: &quot;ik_max_word&quot;</code>：用于索引时进行最大粒度的分词，生成较多词语，适合查询时提高召回率。</li>
<li><code>&quot;search_analyzer&quot;: &quot;ik_smart&quot;</code>：用于搜索时进行较智能的分词，生成较少的词语，用于提高搜索精度。</li>
</ul>
</li>
<li>
<p>使用 title.keyword：为 title 字段增加一个子字段 keyword，用于存储未分词的标题，支持精确匹配。还配置了 ignore_above: 256，表示如果 title 字段长度超过 256 个字符，将不会为 keyword 字段进行索引，避免过长文本导致性能问题。</p>
</li>
<li>
<p>tags：标签通常是预定义的、用于分类或标签筛选的关键字，通常不需要分词。设置为 keyword 类型以便支持精确匹配和聚合操作(例如统计某标签的出现频次)。 keyword 不进行分词，因此适合存储不变的、结构化的数据。</p>
</li>
<li>
<p>userid:用来唯一标识用户的数值字段。在 Elasticsearch 中，数值类型(如 1ong)非常适合用于精确査询、排序和范围过滤。与字符串相比，数值类型的查询和存储效率更高，尤其是对于大量用户数据的查询。</p>
</li>
<li>
<p>editTime、createTime、updateTime:时间字段被定义为 date 类型，并指定了格式 “yyyy-MM-dd HH:mm:ss”。这样做的好处是 Elasticsearch 可以基于这些字段进行时间范围査询、排序和聚合操作，如按时间过滤或统计某时间段的数据。</p>
</li>
<li>
<p>isDelete:使用 keyword 类型，表示是否被删除。 因为 keyword 是为精确匹配设计的，适用于枚举值精确查询的场景，性能好且清晰。</p>
<p>为什么不用 boolean 类型呢？因为 MySQL数据库存储的是 0 和 1，写入 ES 时需要转换类型。</p>
</li>
</ul>
<h3 id="无需显式指定-id-字段"><a class="header-anchor" href="#无需显式指定-id-字段"></a>无需显式指定 id 字段</h3>
<p>Elasticsearch 中，每个文档都有一个唯一的 _id 字段来标识文档，该字段用于文档的主键索引和唯一标识，通常开发者无需显式定义 id 字段（也可以在插入数据时手动指定 _id）。</p>
<h3 id="tags-支持数组"><a class="header-anchor" href="#tags-支持数组"></a>tags 支持数组</h3>
<p>Elasticsearch 中，所有到字段类型（包括 keyword 和 text）都默认支持数组。可以直接插入一个包含多个值的数组，Elasticsearch 会自动将其视为多个值的集合。</p>
<p>查询时，Elasticsearch 会将数组中的每个值视为独立的 keyword ，可以进行精确匹配。</p>
<h2 id="扩展"><a class="header-anchor" href="#扩展"></a>扩展</h2>
<h3 id="TODO-根据具体业务自定义-ES-词典，提高分词准确度"><a class="header-anchor" href="#TODO-根据具体业务自定义-ES-词典，提高分词准确度"></a>TODO 根据具体业务自定义 ES 词典，提高分词准确度</h3>
<p>根据官方文档，得知只需在文件 <code>IKAnalyzer.cfg.xml</code> 中添加词典即可根据业务定义 IK 分词词典，提高分词准确度</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011225011.png" alt="image-20250301122540945"></p>
<p>如上我添加了词典 <code>monkey.dic</code> 内容如下：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011225452.png" alt="image-20250301122533399"></p>
<p>分词效果由原来的：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011225028.png" alt="image-20250222160004958"></p>
<p>修正为：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011226058.png" alt="image-20250222155915135"></p>
<h3 id="TODO-使用-ES-查询时，关联获取题目的动态数据"><a class="header-anchor" href="#TODO-使用-ES-查询时，关联获取题目的动态数据"></a>TODO 使用 ES 查询时，关联获取题目的动态数据</h3>
<p>首先从 es 读取数据，而后对 es 读取的数据进行校验和更新，如果有需要进行修改的数据也可以在迭代器中进一步进行修改，从而达到获取题目的动态数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复用 MySQL / MyBatis Plus 的分页对象，封装返回结果</span></span><br><span class="line">        Page&lt;Question&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">        List&lt;Question&gt; resourceList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (searchHits.hasSearchHits()) &#123;</span><br><span class="line">            List&lt;SearchHit&lt;QuestionEsDTO&gt;&gt; searchHitList = searchHits.getSearchHits();</span><br><span class="line">            List&lt;Long&gt; questionIdList = searchHitList.stream()</span><br><span class="line">                    .map(searchHit -&gt; searchHit.getContent().getId())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            List&lt;Question&gt; questionList = questionMapper.selectBatchIds(questionIdList);</span><br><span class="line">            <span class="keyword">if</span>(questionList != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 建立 Map 快速确认 es 是否有滞后数据</span></span><br><span class="line">                Map&lt;Long, List&lt;Question&gt;&gt; idQuestionMap = questionList.stream().collect(Collectors.groupingBy(Question::getId));</span><br><span class="line"></span><br><span class="line">                Iterator&lt;SearchHit&lt;QuestionEsDTO&gt;&gt; iterator = searchHitList.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SearchHit&lt;QuestionEsDTO&gt; searchHit = iterator.next();</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">questionId</span> <span class="operator">=</span> searchHit.getContent().getId();</span><br><span class="line">                    <span class="keyword">if</span>(idQuestionMap.containsKey(questionId))&#123;</span><br><span class="line">                        <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> idQuestionMap.get(questionId).get(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span>(question.getIsDelete().equals(<span class="number">0</span>))</span><br><span class="line">                            log.info(<span class="string">&quot;实时更新数据&quot;</span>);</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">delete</span> <span class="operator">=</span> elasticsearchRestTemplate.delete(String.valueOf(questionId), QuestionEsDTO.class);</span><br><span class="line">                            log.info(<span class="string">&quot;数据已被软删除，delete question &#123;&#125;&quot;</span>, delete);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果被物理或逻辑删除，则需要从 es 中删除滞后的数据</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">delete</span> <span class="operator">=</span> elasticsearchRestTemplate.delete(String.valueOf(questionId), QuestionEsDTO.class);</span><br><span class="line">                        log.info(<span class="string">&quot;数据已被硬删除，delete question &#123;&#125;&quot;</span>, delete);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                questionIdList.forEach( questionId -&gt;&#123;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (SearchHit&lt;QuestionEsDTO&gt; questionEsDTOSearchHit : searchHitList) &#123;</span><br><span class="line">                resourceList.add(QuestionEsDTO.dtoToObj(questionEsDTOSearchHit.getContent()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="TODO-ES-接口支持降级"><a class="header-anchor" href="#TODO-ES-接口支持降级"></a>TODO ES 接口支持降级</h3>
<h3 id="TODO-防止重复执行定时任务"><a class="header-anchor" href="#TODO-防止重复执行定时任务"></a>TODO 防止重复执行定时任务</h3>
]]></content>
      <tags>
        <tag>中间件</tag>
        <tag>elasticsearch</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq 基础篇</title>
    <url>/2025/03/05/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/rabbitmq%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="rabbitMQ-基础篇"><a class="header-anchor" href="#rabbitMQ-基础篇"></a>rabbitMQ 基础篇</h1>
<p><img src="" alt="RabbitMQ"></p>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&amp;bvid=BV1S142197x7&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c&amp;p=85">MQ入门-01.MQ课程介绍_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.rabbitmq.com/tutorials">RabbitMQ 官方文档</a></p>
<p><a href="https://blog.csdn.net/web13508588635/article/details/144301392">RabbitMQ 常见问题与故障排查-CSDN博客</a></p>
<h2 id="背景引入"><a class="header-anchor" href="#背景引入"></a>背景引入</h2>
<p>一款高性能的异步通信组件</p>
<p>同步通信类似于：人和人之间打电话，没办法在同一时间和多个人打电话</p>
<p>异步通信类似于：人和人之间发微信，一个人可以同时和多个人进行聊天，并发能力强</p>
<p>原本的 openFegin 是一个同步操作，发送的请求必须实时等待返回结果，以下面的登录操作为例：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051042110.png" alt="image-20250305104252047"></p>
<p>修改成异步通信：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051043364.png" alt="image-20250305104356310"></p>
<p>只需要让其他的微服务监听到 MQ 的信息，而用户微服务可以让用户直接登录，无需过长时间等待</p>
<h2 id="初识MQ"><a class="header-anchor" href="#初识MQ"></a>初识MQ</h2>
<h3 id="同步调用"><a class="header-anchor" href="#同步调用"></a>同步调用</h3>
<p>以黑马商场的余额支付为例：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051050019.png" alt="image-20250305105049964"></p>
<p>业务分析：</p>
<ul>
<li>用户通过支付服务进行支付</li>
<li>支付服务调用用户服务进行用户余额的扣减
<ul>
<li>依据余额的扣减成功与否决定是否进行支付状态的更新，则此时需要使用同步调用</li>
</ul>
</li>
<li>支付服务调用交易服务，更订单状态，但由于交易服务并非强时效性的，因此并不是必须在支付服务完成任务后立刻进行的，所以可以采用异步调用，因此引入了异步调用。</li>
</ul>
<p>优点：</p>
<ul>
<li>时效性强（因为必须等待结果的返回）</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能下降，因为必须等待结果返回，因此会发生阻塞</li>
<li>拓展性差</li>
</ul>
<h3 id="异步调用"><a class="header-anchor" href="#异步调用"></a>异步调用</h3>
<p>异步调用是指：程序发起一个操作后，不需要等待操作完成，而是继续执行后续代码。操作完成后，通过<strong>回调、事件或消息通知</strong>的方式返回结果。异步调用是<strong>非阻塞的</strong>，因为发起操作而无需等待操作的完成</p>
<h3 id="实现异步调用的方式："><a class="header-anchor" href="#实现异步调用的方式："></a>实现异步调用的方式：</h3>
<ol>
<li>多线程</li>
<li>回调函数</li>
<li>消息队列</li>
</ol>
<h3 id="基于消息队列实现的异步调用"><a class="header-anchor" href="#基于消息队列实现的异步调用"></a>基于消息队列实现的异步调用</h3>
<p>异步调用通常基于消息通知的方式，包含三个角色：</p>
<ul>
<li>消息发送者：投递消息，即服务调用者</li>
<li>消息接受者：接收和处理消息的人，即服务提供者</li>
<li>消息代理：管理、暂存、转发消息，中转站服务器</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051102091.png" alt="image-20250305110229032"></p>
<p>以点外卖为例：用户下单，外卖员送外卖，但是为了防止用户有事无法立即拿外卖，所以外卖员可以把外卖暂时放在外卖柜，用户再监控外卖柜，查看外卖是否存在。</p>
<p>类似于计网里面路由的广播，发送者不关心接受者是谁，接受者不关心谁是发送者。</p>
<p>优势：</p>
<ul>
<li>解耦，具有高扩展性
<ul>
<li>因为生产者和消费者无需进行直接通信，可以通过消息代理来进行交互</li>
<li>而当有新的生产者或消费者时，只需要让生产者投递消息或消费者监听消息即可完成功能的扩展</li>
</ul>
</li>
<li>无需等待，性能好</li>
<li>故障隔离，防止级联失败</li>
<li>缓存消息，流量削峰填谷
<ul>
<li>在实际应用中考虑到服务集群，当消息代理具有大量消息时，由集群分别去消费消息代理里的信息，就不会造成服务负载的激增</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>时效性差，无法感知到消费者的状态，不知道最终结果</li>
<li>业务安全依赖于 Broker 的可靠性，一旦消息代理下线，服务会大规模失效</li>
</ul>
<p>应用场景：</p>
<ul>
<li>异步任务处理：常见的邮件发送、文件生成等</li>
<li>应用解耦：微服务之间通过消息队列进行通信，减少了关联性不强的服务之间的依赖</li>
<li>日志记录：将日志发送到啊消息队列，由专门的消费者进行处理，可以避免在本服务进行日志的记录</li>
</ul>
<h3 id="MQ-技术选型"><a class="header-anchor" href="#MQ-技术选型"></a>MQ 技术选型</h3>
<p>选择 rabbitMQ 的原因：</p>
<ul>
<li>虽然单机吞吐量一般。</li>
<li>长期而稳定的技术支持，开发 rabbitmq 的公司主要业务就是 rabbitmq，因此具有稳定的社区和技术支持。</li>
<li>使用的开发语言是 erlang，本身就是一种支持高并发的语言。</li>
<li>支持的协议丰富：支持SpringCloud默认支持的AMQP协议。</li>
<li>可用性和可靠性高。</li>
<li>消息延迟低。</li>
</ul>
<h3 id="rabbitmq-的整体架构及核心："><a class="header-anchor" href="#rabbitmq-的整体架构及核心："></a>rabbitmq 的整体架构及核心：</h3>
<p>virtual-host：虚拟主机，起到数据隔离的作用</p>
<ul>
<li>假设多个项目使用同一个 rabbitmq，则可以按项目构建不同的 virtual-host，进而让不同的项目的交换机和队列在各自的虚拟主机当中，起到数据隔离的作用。</li>
</ul>
<p>publisher：消息生产者</p>
<p>consumer：消息消费者</p>
<p>queue：队列，存储消息</p>
<p>exchange：交换机，负责路由消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051238628.png" alt="rabbitmq 的核心流程"></p>
<h3 id="rabbitmq-控制台的使用："><a class="header-anchor" href="#rabbitmq-控制台的使用："></a>rabbitmq 控制台的使用：</h3>
<p><strong>Exchanges 交换机</strong></p>
<p>点击 Exchanges，可以看到交换机列表</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051255313.png" alt="image-20250305125500242" style="zoom:67%;" />
<p>点击某一个交换机进入交换机界面：</p>
<p>核心功能是 publish message，指的是发布消息：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051255649.png" alt="image-20250305125549588"></p>
<p>【注：交换机只能进行消息的转发而无法存储消息，即如果一个消息在交换机发布后未被路由，最终消息会丢失，而不是存储在交换机当中】</p>
<p><strong>Queues 队列</strong></p>
<p>点击 Queues，可以看到交换机列表</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051258320.png" alt="queues 列表"></p>
<p>点击任意一个队列进入：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051258751.png" alt="队列内存储的消息信息"></p>
<p><strong>Bindings</strong>：绑定当前队列可以接收到哪个交换机的发布的消息，这是一种发布订阅者模式，即发布者不关心到底谁得到了消息，而有需要的队列只需要去订阅相应的发布者即可得到消息</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051259391.png" alt="image-20250305125917340" style="zoom:80%;" />
<h3 id="数据隔离"><a class="header-anchor" href="#数据隔离"></a>数据隔离</h3>
<p>创建用户，为用户创建一个命名与项目相关的 virtual host，</p>
<p>这样子登录不同的用户即可得到不同的虚拟主机</p>
<h2 id="SpringAMQP"><a class="header-anchor" href="#SpringAMQP"></a>SpringAMQP</h2>
<h3 id="yaml-文件配置"><a class="header-anchor" href="#yaml-文件配置"></a>yaml 文件配置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.246</span><span class="number">.129</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
<p><a href="https://spring.io/projects/spring-amqp">Spring AMQP 官方文档</a></p>
<p>基于 AMQP 协议定义的一套 API 规范，提供了模板来发送和接收消息。包含两部分：spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现。</p>
<h3 id="简单测试-rabbitmq"><a class="header-anchor" href="#简单测试-rabbitmq"></a>简单测试 rabbitmq</h3>
<p>消息发送者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> moru</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2025/3/5 下午1:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,spring amqp!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(queueName,msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消息接受者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> moru</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2025/3/5 下午1:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenRabbitMq</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;监听的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="workQueues-模式"><a class="header-anchor" href="#workQueues-模式"></a>workQueues 模式</h2>
<p>WorkQueues 任务模型，让多个消费者绑定到一个队列，共同消费 队列中的消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051354816.png" alt="image-20250305135432748"></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度远大于消费速度，长时间累计会导致消息无法被及时处理，可以使用 work 模型，多个消费者共同处理消息，消息处理的速度会随着消费者的增多而提高</p>
<h3 id="消息发送"><a class="header-anchor" href="#消息发送"></a>消息发送</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,spring amqp!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (count &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(queueName,msg);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="消息接收"><a class="header-anchor" href="#消息接收"></a>消息接收</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenSimpleQueueMsg1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;消费者 1 监听的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenSimpleQueueMsg2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">  log.error(<span class="string">&quot;消费者 2 监听的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果："><a class="header-anchor" href="#测试结果："></a>测试结果：</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">03-05 13:59:07:165  : 消费者 2 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:167  : 消费者 1 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:167  : 消费者 2 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:167  : 消费者 1 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:167  : 消费者 2 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:167  : 消费者 1 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:168  : 消费者 2 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:168  : 消费者 1 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:168  : 消费者 1 监听的信息为：hello,spring amqp!</span><br><span class="line">03-05 13:59:07:168  : 消费者 2 监听的信息为：hello,spring amqp!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以从结果看出，消费机制类似于轮询（默认采用的是轮询机制）。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。</p>
<p>为了防止性能好的机器性能无法完全释放，可以修改 listen 配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>
<p>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p>
<h3 id="Work模型的使用"><a class="header-anchor" href="#Work模型的使用"></a>Work模型的使用</h3>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置prefetch来控制消费者预取的消息数量</li>
</ul>
<h2 id="MQ交换机"><a class="header-anchor" href="#MQ交换机"></a>MQ交换机</h2>
<p>前面做的测试里面并没有引入交换机的概念，是生产者直接向消息队列发送消息以后消费者直接从队列当中获取，接下来要引入交换机，模式会有所变化：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051410983.png" alt="引入交换机的mq工作模式"></p>
<p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li>
<li><strong>Exchange</strong>：交换机，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。
<ul>
<li><strong>接收</strong>生产者发送的消息。</li>
<li><strong>路由</strong>消息到与其绑定的队列。</li>
<li>发送者只需要发送一次消息，就可以被多个队列接收到，进而每一个微服务只关注自己的队列即可，不需要发送者把消息一个个发送到队列中</li>
</ul>
</li>
<li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li>
<li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li>
</ul>
<p><strong>Exchange（交换机）</strong> 只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h3 id="Fanout-交换机"><a class="header-anchor" href="#Fanout-交换机"></a>Fanout 交换机</h3>
<p>广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051413106.png" alt="广播模式"></p>
<p>广播模式的流程为：</p>
<ol>
<li>可以有多个队列</li>
<li>每个队列都绑定到交换机上</li>
<li>生产者发送消息到交换机上</li>
<li>订阅了交换机消息的队列获取到消息</li>
<li>订阅了队列都消费者拿到队列中的消息</li>
</ol>
<blockquote>
<p>个人思考：“exchange” 并不主动发送消息给 xx 队列，因为绑定操作是由 queue 进行的，对于 exchange 来说它本身是无法感知到有什么 queue绑定了自己的，因此在 exchange 和 queue 之间有一个类似于“路由器”的机制，exchange 将消息发送给路由器之后再由路由器将消息分配给对应的 queue 。</p>
</blockquote>
<h4 id="消息发送-v2"><a class="header-anchor" href="#消息发送-v2"></a>消息发送</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testFanoutQueue</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;amq.fanout&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;使用 fanout 交换机测试&quot;</span>;</span><br><span class="line"></span><br><span class="line">  rabbitTemplate.convertAndSend(exchangeName,<span class="literal">null</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息接收-v2"><a class="header-anchor" href="#消息接收-v2"></a>消息接收</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenExchangeQueueMsg1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者 1 监听 fanout.queue1 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenExchangeQueueMsg2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;消费者 2 监听 fanout.queue2 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试结果"><a class="header-anchor" href="#测试结果"></a>测试结果</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">03-05 14:54:19:041  ...: 消费者 1 监听 fanout.queue1 的信息为：使用 fanout 交换机测试</span><br><span class="line">03-05 14:54:19:041 ...: 消费者 2 监听 fanout.queue2 的信息为：使用 fanout 交换机测试</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Direct-交换机"><a class="header-anchor" href="#Direct-交换机"></a>Direct 交换机</h3>
<p>订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</p>
<p>相较于 Fanout 多了一个验证消息的 Routingkey 和 BindingKey</p>
<ul>
<li>RoutingKey 由发布者指定</li>
<li>BindingKey 由 queue 设定</li>
<li>Exchange 将消息路由到 BindingKey 与 RoutingKey 一致的队列上。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051501057.png" alt="image-20250305150129983"></p>
<h4 id="消息发送-v3"><a class="header-anchor" href="#消息发送-v3"></a>消息发送</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;amq.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;使用 direct 交换机测试&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">blue</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">yel</span> <span class="operator">=</span> <span class="string">&quot;yel&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">red</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,blue,blue + <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,yel,yel + <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,red,red + <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息接收-v3"><a class="header-anchor" href="#消息接收-v3"></a>消息接收</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenDirectQueueMsg1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者 1 监听 fanout.queue1 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenDirectQueueMsg2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;消费者 2 监听 fanout.queue2 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue3&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenDirectQueueMsg3</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;消费者 3 监听 fanout.queue2 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换机绑定路由器如下"><a class="header-anchor" href="#交换机绑定路由器如下"></a>交换机绑定路由器如下</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051513724.png" alt="image-20250305151331664"></p>
<h4 id="测试结果-v2"><a class="header-anchor" href="#测试结果-v2"></a>测试结果</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">03-05 15:11:46:904 	: 消费者 2 监听 fanout.queue2 的信息为：yel: 使用 direct 交换机测试</span><br><span class="line">03-05 15:11:46:904  : 消费者 1 监听 fanout.queue1 的信息为：blue: 使用 direct 交换机测试</span><br><span class="line">03-05 15:11:46:907 	: 消费者 2 监听 fanout.queue2 的信息为：red: 使用 direct 交换机测试</span><br><span class="line">03-05 15:11:46:907  : 消费者 1 监听 fanout.queue1 的信息为：red: 使用 direct 交换机测试</span><br></pre></td></tr></table></figure>
<p>由测试结果可以看出，只有发送的 RoutingKey 与 BindingKey 一致，exchange 才会转发给对应的 queue</p>
<h3 id="Topic-交换机"><a class="header-anchor" href="#Topic-交换机"></a>Topic 交换机</h3>
<p>通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051516602.png" alt="image-20250305151605524"></p>
<p>可以实现一种分组，根据某个字段进行分组分配。</p>
<h4 id="消息发送-v4"><a class="header-anchor" href="#消息发送-v4"></a>消息发送</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;amq.topic&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;使用 direct 交换机测试&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c_w</span> <span class="operator">=</span> <span class="string">&quot;china.weather&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c_n</span> <span class="operator">=</span> <span class="string">&quot;china.new&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">j_w</span> <span class="operator">=</span> <span class="string">&quot;japan.weather&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">j_n</span> <span class="operator">=</span> <span class="string">&quot;japan.new&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,c_w, c_w+ <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,c_n,c_n + <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,j_w, j_w+ <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,j_n,j_n + <span class="string">&quot;: &quot;</span>+ msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息接收-v4"><a class="header-anchor" href="#消息接收-v4"></a>消息接收</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenTopicQueueMsg1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者 1 监听 topic.queue1 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenTopicQueueMsg2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;消费者 2 监听 topic.queue2 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue3&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenTopicQueueMsg3</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者 3 监听 topic.queue3 的信息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换机绑定如下"><a class="header-anchor" href="#交换机绑定如下"></a>交换机绑定如下</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051523860.png" alt="image-20250305152358796"></p>
<h4 id="测试结果-v3"><a class="header-anchor" href="#测试结果-v3"></a>测试结果</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">03-05 15:23:20:666 ...: 消费者 2 监听 topic.queue2 的信息为：china.weather: 使用 direct 交换机测试</span><br><span class="line">03-05 15:23:20:666 ...: 消费者 1 监听 topic.queue1 的信息为：china.weather: 使用 direct 交换机测试</span><br><span class="line">03-05 15:23:20:671 ...: 消费者 1 监听 topic.queue1 的信息为：china.new: 使用 direct 交换机测试</span><br><span class="line">03-05 15:23:20:671 ...: 消费者 2 监听 topic.queue2 的信息为：japan.weather: 使用 direct 交换机测试</span><br><span class="line">03-05 15:23:20:673 ...: 消费者 2 监听 topic.queue2 的信息为：japan.new: 使用 direct 交换机测试</span><br><span class="line">03-05 15:23:20:673 ...: 消费者 1 监听 topic.queue1 的信息为：japan.new: 使用 direct 交换机测试</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="headers-交换机"><a class="header-anchor" href="#headers-交换机"></a>headers 交换机</h3>
<p>头匹配，基于MQ的消息头匹配，用的较少。</p>
<h2 id="声明队列和交换机"><a class="header-anchor" href="#声明队列和交换机"></a>声明队列和交换机</h2>
<p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。</p>
<p>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p>
<p>（说白了就是用注解声明交换机和队列及绑定关系，如果控制台中不存在则创建，用代码代替了手动创建）</p>
<h3 id="基本API"><a class="header-anchor" href="#基本API"></a>基本API</h3>
<p>SpringAMQP 提供了一个 Queue 类，用来创建队列：</p>
<p>SpringAMQP 还提供了一个 Exchange 接口，来表示所有不同类型的交换机：</p>
<p>SpringAMQP 还提供了 ExchangeBuilder 来简化这个过程：</p>
<p>在绑定队列和交换机时，则使用 BindingBuilder 来创建 Binding 对象：</p>
<p>【注：一般来说都是由 consumer 创建 queue 和 exchange，因为在整个模式当中，发布者发布不发布消息对其本身业务来说并不影响，但消费者却需要消息队列和交换机来完成自身工作，因此一般在消费者创建】</p>
<h3 id="以-fanout-示例"><a class="header-anchor" href="#以-fanout-示例"></a>以 fanout 示例</h3>
<h4 id="基于-Bean-的方式声明队列和交换机"><a class="header-anchor" href="#基于-Bean-的方式声明队列和交换机"></a>基于 @Bean 的方式声明队列和交换机</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> moru</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2025/3/5 下午3:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fanout 交换机</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;backend.fanout&quot;</span>).build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;backend-fanout.queue&quot;</span>).build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="comment">// 这里直接按照 变量名 注入了 bean，所以不需要通过调用方法来获取参数</span></span><br><span class="line">  <span class="keyword">public</span> Binding <span class="title function_">fanoutBinding</span><span class="params">(Queue fanoutQueue, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue).to(fanoutExchange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于-RabbitListener-注解的方式来声明队列和交换机"><a class="header-anchor" href="#基于-RabbitListener-注解的方式来声明队列和交换机"></a>基于 @RabbitListener 注解的方式来声明队列和交换机</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">  value = @Queue(name = &quot;backend.annotate.fanout.queue&quot;),</span></span><br><span class="line"><span class="meta">  exchange = @Exchange(&quot;backend.annotate.fanout&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenFanoutByBackend</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;基于注解的方式，消费者监听 backend.annotate.fanout.queue 的消息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">  value = @Queue(name = &quot;backend.annotate.direct.queue&quot;),</span></span><br><span class="line"><span class="meta">  exchange = @Exchange(&quot;backend.annotate.direct&quot;),</span></span><br><span class="line"><span class="meta">  key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">listenDirectByBackend</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;基于注解的方式，消费者监听 backend.annotate.direct.queue 的消息为：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息转换器"><a class="header-anchor" href="#消息转换器"></a>消息转换器</h2>
<p>Spring 对消息对象的处理是由 spring 默认提供的 MessageConverter 进行的，而默认实现的 SimpleMessageConverter，基于 JDK 的 ObjectOutputStream 完成序列化</p>
<p>这种默认提供的方法存在一些问题：</p>
<ul>
<li>
<p>JDK 序列化有安全风险：容易被代码注入</p>
</li>
<li>
<p>JDK 序列化后的消息体积太大，因为从原本字节较少的原始数据转换成了 byte 数据进行传输，假设原数据为: <code>&#123;“name”: “moru”, “age”: 22&#125;</code> 变成了一大串乱码 <code>rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAN3CAAAAAQAAAACdAAEbmFtZXQA BiBtb3J1IHQAA2FnZXNyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAW eA==</code>；</p>
</li>
<li>
<p>JDK 序列化的信息可读性差，乱码的不具有可读性</p>
</li>
</ul>
<h2 id="实际业务操作："><a class="header-anchor" href="#实际业务操作："></a>实际业务操作：</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503051050019.png" alt="image-20250305105049964"></p>
<p>以黑马商场的 <em>支付-交易-用户</em> 为例：</p>
<p>在原本为引入 mq 的时候，支付模块需要通过 OpenFeign 来远程调用交易和用户模块的服务，这是一种同步机制，即支付模块必须等待被调用者的返回信息。</p>
<p>引入 rabbitmq 之后，我们进行了解耦：</p>
<p>在 pay 模块调用 rabbitmq 的自动装配的对象，使用该对象完成对特定队列的消息发送(本项目采用的转换器是 jackson，通过自动配置来在各个模块生效)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(exchange,routingKey,msg);</span><br><span class="line">&#125; <span class="keyword">catch</span>(AmqpException e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;发送支付状态消息失败，订单编号为:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rabbitmq</tag>
        <tag>中间件</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title>了解jdbc</title>
    <url>/2025/03/01/Java%E5%9F%BA%E7%A1%80/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a class="header-anchor" href="#JDBC"></a>JDBC</h1>
<blockquote>
<p>通过I/O操作对程序运行过程中出现的数据进行持久化，但保存下来的数据并不具备结构和逻辑，不便于管理与维护</p>
<p>通过关系型数据库，将数据进行存储，交由数据库进行维护，</p>
<ul>
<li>关系型数据库是通过库和表分隔不同的数据，表中数据存储的方式是行列，区分相同格式的不同数据。</li>
</ul>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011234675.png" alt="image-20240418090602529"></p>
<h2 id="基础"><a class="header-anchor" href="#基础"></a>基础</h2>
<h3 id="JDBC-v2"><a class="header-anchor" href="#JDBC-v2"></a>JDBC</h3>
<h4 id="概念："><a class="header-anchor" href="#概念："></a>概念：</h4>
<blockquote>
<p>JAVA Database Connectivity Java的数据库连接</p>
<p>JDBC为JAVA的一组独立于任何数据库管理系统的API</p>
<p>JDBC只提供接口规范，由各个数据库厂商提供实现，使用jar包，导入jar进行使用</p>
<p>体会接口编程，只关心接口和规范，无需关心实现</p>
</blockquote>
<p>不同的数据库使用不同的驱动jar包</p>
<h3 id="對JDBC的使用"><a class="header-anchor" href="#對JDBC的使用"></a>對JDBC的使用</h3>
<h4 id="Driver注冊驅動"><a class="header-anchor" href="#Driver注冊驅動"></a>Driver注冊驅動</h4>
<ul>
<li><code>Class.forName(&quot;com.sql.cj.jdbc.Driver&quot;);</code></li>
<li>儅使用JDBC鏈接數據庫時，需要加載數據庫特定的驅動程序，以便與數據庫進行通信，加載驅動程序的目的是爲了注冊驅動程序，使得JDBC API能夠識別并與特定的數據庫進行交互。</li>
<li>從JDK6開始，無需顯式調用<code>Class.forName()</code>來加載JDBC驅動程序，只要在類路徑中集成了對應的jar包，會自動在初始時完成驅動程序的注冊。</li>
</ul>
<h4 id="Connection"><a class="header-anchor" href="#Connection"></a><code>Connection</code></h4>
<ul>
<li>
<p>建立鏈接需要指定三個參數：數據庫url、用戶名、密碼</p>
<ul>
<li>
<p>URL：“jdbc:mysql://localhost:3306/atguigu”</p>
<p>jdbc:mysql//IP地址：端口號/數據庫名稱?參數鍵值對1&amp;參數鍵值對2</p>
</li>
</ul>
</li>
<li>
<p><code>Connection</code>接口還負責管理事務，<code>Connection</code>接口提供了<code>commit</code>和<code>rollback</code>方法，用戶提交事務和回滾事務。</p>
</li>
<li>
<p>可以創建<code>Statement</code>對象，用於執行SQL語句并與數據庫進行交互。</p>
</li>
<li>
<p>在使用JDBC技術時，必須要先獲取<code>Connection</code>對象，在使用完畢后，要釋放資源，避免資源浪費以及泄露。</p>
</li>
</ul>
<h4 id="Statement"><a class="header-anchor" href="#Statement"></a><code>Statement</code></h4>
<blockquote>
<p>用於執行SQL語句並於數據庫進行交互</p>
<p>通過<code>Statement</code>對象，可以向數據庫發送SQL語句並獲取執行結果</p>
</blockquote>
<ul>
<li>
<p>結果可以是一個或多個</p>
<ul>
<li>增刪改：受影響行數單個結果</li>
<li>查詢：單行單列，多行多列，單行多列</li>
</ul>
</li>
<li>
<p>使用<code>Statement</code>會產生SQL注入的問題，即通過使用如‘’對SQL原來的結構進行破壞，使得SQL語句變成永真句，進而完成注入，非法訪問得到數據。</p>
</li>
</ul>
<h4 id="PreparedStatement"><a class="header-anchor" href="#PreparedStatement"></a>PreparedStatement</h4>
<blockquote>
<p>本身為<code>Statement</code>的子接口，繼承于<code>Statement</code>接口，用於解決<code>Statement</code>SQL注入的問題。</p>
</blockquote>
<p>解決SQL注入的方法為：</p>
<ul>
<li>對傳入的SQL語句進行預編譯，使用一對<code>‘’</code>將用戶輸入的sql包裹起來，儅用戶輸入的語句含有‘’時，會將輸入的語句中的‘’使用轉義字符\‘和\’代替，以防止SQL注入的攻擊</li>
<li></li>
</ul>
<h4 id="ResultSet"><a class="header-anchor" href="#ResultSet"></a>ResultSet</h4>
<ul>
<li>
<p><code>ResultSet.next()</code>首先判斷是否存在下一行，若有則游標向下移動一行；若無則停止。</p>
</li>
<li>
<p>然後使用<code>ResultSet.getXXX()</code>方法來根據列名讀取相應的數據。</p>
</li>
</ul>
<blockquote>
<p>將多個零散的數據封裝成一個數據————ORM</p>
<p>ORM-Object Relative Mapping——對象-關係映射</p>
<p>利用對象操縱數據庫中的表、</p>
</blockquote>
<h2 id="常见问题"><a class="header-anchor" href="#常见问题"></a>常见问题</h2>
<ol>
<li>语法问题</li>
<li>库名出错</li>
</ol>
<h2 id="进阶"><a class="header-anchor" href="#进阶"></a>进阶</h2>
<h3 id="JDBC拓展"><a class="header-anchor" href="#JDBC拓展"></a>JDBC拓展</h3>
<h4 id="实体类和ORM"><a class="header-anchor" href="#实体类和ORM"></a>实体类和ORM</h4>
<blockquote>
<p>一个表对应一种对象</p>
<p>表中的一列数据对应对象的一种属性</p>
<p>因为数据库中的数据是零散的，通过将数据库中的数据对应到Java当中的一个对象上，以对象作为载体进行数据的操作，这个载体就是实体类</p>
<p>ORM-Object Relational Mapping</p>
<p>对象到关系数据库的映射：在编程中，将面向对象的概念和数据库中表的概念对应起来，以面向对象的角度操作数据库中的数据——一张表对应一个类；一行数据对应一个实例；一列对应一个类的属性</p>
</blockquote>
<h4 id="主键回显"><a class="header-anchor" href="#主键回显"></a>主键回显</h4>
<p>新增+修改</p>
<p>场景：用户注册，在成功注册后添加昵称</p>
<p>修改刚刚注册的用户数据。</p>
<h4 id="批量操作"><a class="header-anchor" href="#批量操作"></a>批量操作</h4>
<p>对于一次需要插入多个值，如果只是单纯采用for-i循环进行插入，由于需要多次进行建立连接的建立和断开，性能差，时间开销大：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMoreInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,name,pwd);</span><br><span class="line">	</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into  tmp(name,salary,age) values (?,?,?)&quot;</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			preparedStatement.setString(<span class="number">1</span>,<span class="string">&quot;第&quot;</span>+i +<span class="string">&quot;人&quot;</span>);</span><br><span class="line">			preparedStatement.setDouble(<span class="number">2</span>,<span class="number">100.0</span>+i);</span><br><span class="line">			preparedStatement.setInt(<span class="number">3</span>,<span class="number">20</span>+i);</span><br><span class="line">			</span><br><span class="line">			preparedStatement.executeUpdate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(end - start);</span><br><span class="line">		</span><br><span class="line">		preparedStatement.close();</span><br><span class="line">		connection.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因此采取批量操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMoreInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/atguigu?rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, name, pwd);</span><br><span class="line">	</span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into  tmp(name,salary,age) values (?,?,?)&quot;</span>;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;人&quot;</span>);</span><br><span class="line">		preparedStatement.setDouble(<span class="number">2</span>, <span class="number">100.0</span> + i);</span><br><span class="line">		preparedStatement.setInt(<span class="number">3</span>, <span class="number">20</span> + i);</span><br><span class="line">		</span><br><span class="line">		preparedStatement.addBatch();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	preparedStatement.executeBatch();</span><br><span class="line">	<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	</span><br><span class="line">	System.out.println(end - start);</span><br><span class="line">	</span><br><span class="line">	preparedStatement.close();</span><br><span class="line">	connection.close();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将多个值合并入同一条待执行的sql语句，则只需要建立一次连接即可完成值的插入，大大提高了效率</p>
<h3 id="连接池"><a class="header-anchor" href="#连接池"></a>连接池</h3>
<blockquote>
<p>池技术的核心思想：通过对已创建资源的复用，避免不必要的重复创建和销毁。</p>
</blockquote>
<p>预先创建一部分Connection对象，通过配置，由连接池负责创建连接，管理连接，释放连接等操作</p>
<h4 id="常见连接池"><a class="header-anchor" href="#常见连接池"></a>常见连接池</h4>
<ul>
<li>DBCP</li>
<li>C3P0</li>
<li>Proxool</li>
<li>Druid 德鲁伊</li>
<li>Hikari(shi ga li)</li>
</ul>
<h3 id="druid-德鲁伊"><a class="header-anchor" href="#druid-德鲁伊"></a>druid 德鲁伊</h3>
<h4 id="硬编码"><a class="header-anchor" href="#硬编码"></a>硬编码</h4>
<p>将连接池的配置和java代码耦合在一起</p>
<ul>
<li>不利于更新与维护</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardCodeDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 硬编码：将连接池的配置信息和JAVA代码耦合</span></span><br><span class="line"><span class="comment">			1. 创建DruidDataSource连接池对象</span></span><br><span class="line"><span class="comment">		 	2. 设置连接池的配置信息</span></span><br><span class="line"><span class="comment">		 	3. 通过连接池获取连接对象</span></span><br><span class="line"><span class="comment">		 	4. 回收连接【不是释放】，将连接归还给连接池，进行复用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 创建DruidDataSource连接池对象</span></span><br><span class="line">		<span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 设置连接池的配置信息</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1 必要配置信息</span></span><br><span class="line">		</span><br><span class="line">		druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>);</span><br><span class="line">		druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		druidDataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.2 非必要配置</span></span><br><span class="line">		druidDataSource.setInitialSize(<span class="number">10</span>); <span class="comment">//</span></span><br><span class="line">		druidDataSource.setMaxActive(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">DruidPooledConnection</span> <span class="variable">connection</span> <span class="operator">=</span> druidDataSource.getConnection();</span><br><span class="line">		</span><br><span class="line">		System.out.println(connection);</span><br><span class="line">		</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="软编码——推荐"><a class="header-anchor" href="#软编码——推荐"></a>软编码——推荐</h4>
<p>在根目录下创建db.properties配置文件</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011235750.png" alt="image-20240423230410644"></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/atguigu</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResourcesDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="comment">//1. 创建一个Properties集合，读取存储外部配置文件的key和value值</span></span><br><span class="line">	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 读取外部配置文件，获取输入流，加载到Properties集合当中</span></span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> DruidTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	properties.load(inputStream);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 基于Properties集合构建DruidDataSource连接池</span></span><br><span class="line">	<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 通过连接池获取连接对象</span></span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">	System.out.println(connection);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HikariCP连接池使用"><a class="header-anchor" href="#HikariCP连接池使用"></a>HikariCP连接池使用</h3>
<h4 id="硬编码-v2"><a class="header-anchor" href="#硬编码-v2"></a>硬编码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardCodeHikari</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 硬编码展示：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 创建HikariDataSource连接池对象</span></span><br><span class="line">	<span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 设置配置信息</span></span><br><span class="line">	<span class="comment">//2.1 必须设置的配置信息</span></span><br><span class="line">	hikariDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">	hikariDataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost/atguigu&quot;</span>);</span><br><span class="line">	hikariDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	hikariDataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.2 非必须设置的配置</span></span><br><span class="line">	hikariDataSource.setMinimumIdle(<span class="number">10</span>);</span><br><span class="line">	hikariDataSource.setMaximumPoolSize(<span class="number">20</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> hikariDataSource.getConnection();</span><br><span class="line">	System.out.println(connection);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	connection.close();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="软编码"><a class="header-anchor" href="#软编码"></a>软编码</h4>
<p><strong>Properties文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbcUrl</span> = <span class="string">jdbc:mysql:///atguigu</span></span><br><span class="line"><span class="attr">username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">password</span> = <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">minimumIdle</span> = <span class="string">10</span></span><br><span class="line"><span class="attr">maximumPoolSize</span> = <span class="string">20</span></span><br></pre></td></tr></table></figure>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResourcesHikari</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="comment">//1. 创建一个properties集合</span></span><br><span class="line">	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="comment">//2. 读取外部配置文件，获取输入流，加载到Properties集合中</span></span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span>  HikariTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;hikari.properties&quot;</span>);</span><br><span class="line">	<span class="comment">//3. 创建一个HikariCOnfig-连接池配置对象，将Properties集合传递进去</span></span><br><span class="line">	properties.load(inputStream);</span><br><span class="line">	</span><br><span class="line">	<span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>(properties);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 基于HikariConfig连接池配置对象，构建HikariDataSource</span></span><br><span class="line">	<span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">	</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> hikariDataSource.getConnection();</span><br><span class="line">	</span><br><span class="line">	System.out.println(connection);</span><br><span class="line">	</span><br><span class="line">	connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级篇"><a class="header-anchor" href="#高级篇"></a>高级篇</h2>
<h3 id="JDBC优化以及工具类封装"><a class="header-anchor" href="#JDBC优化以及工具类封装"></a>JDBC优化以及工具类封装</h3>
<blockquote>
<p>在用到了进阶篇的内容后，发现仍存在代码冗余的问题：</p>
<ol>
<li>一个项目中存在多个连接池；</li>
<li>获取链接</li>
<li>链接的回收</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插件一个连接池引用，因为需要提供给当前项目的全局进行使用，因此创建为公有的静态对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* DataSource 对象是 Java 中用于管理数据库连接的接口。</span></span><br><span class="line"><span class="comment">	* 它封装了与数据库的连接参数，允许程序通过该对象获取与数据库的连接，进行增删改查等操作。</span></span><br><span class="line"><span class="comment">	* */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在项目启动时，即创建连接池对象，赋值给dataSource</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建配置对象</span></span><br><span class="line">			<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//通过输入流得到配置文件当中的配置</span></span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> JDBCUtil.class.getClassLoader()</span><br><span class="line">					.getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//配置对象载入输入流得到的配置信息，完成配置实例的初始化</span></span><br><span class="line">			properties.load(inputStream);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//使用配置对象进行dataSource对象的创建和初始化</span></span><br><span class="line">			dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供对外获取连接的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//通过得到的dataSource对象建立连接</span></span><br><span class="line">			<span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供对外回收连接的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将建立好的连接进行回收到连接池当中，以便其他需要连接的地方可以获取连接</span></span><br><span class="line">			conn.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用ThreadLocal进行优化"><a class="header-anchor" href="#使用ThreadLocal进行优化"></a>使用ThreadLocal进行优化</h3>
<p>通过ThreadLocal让每个线程只使用一个连接进行数据库的操作，避免反复获取和回收连接导致的资源浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Senior.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 维护一个连接池对象，维护了一个线程绑定变量的ThreadLocal对象</span></span><br><span class="line"><span class="comment"> * 2. 对外提供在连接池中获取连接的方法</span></span><br><span class="line"><span class="comment"> * 3. 对外提供回收连接的方法,回收过程中，将要回收的连接从ThreadLocal当中移除</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 目的是为了：一个线程在多次数据库操作过程中，使用同一个连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtil2</span> &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//插件一个连接池引用，因为需要提供给当前项目的全局进行使用，因此创建为公有的静态对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * DataSource 对象是 Java 中用于管理数据库连接的接口。</span></span><br><span class="line"><span class="comment">	 * 它封装了与数据库的连接参数，允许程序通过该对象获取与数据库的连接，进行增删改查等操作。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在项目启动时，即创建连接池对象，赋值给dataSource</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建配置对象</span></span><br><span class="line">			<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//通过输入流得到配置文件当中的配置</span></span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> com.Senior.util.JDBCUtil.class.getClassLoader()</span><br><span class="line">					.getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//配置对象载入输入流得到的配置信息，完成配置实例的初始化</span></span><br><span class="line">			properties.load(inputStream);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//使用配置对象进行dataSource对象的创建和初始化</span></span><br><span class="line">			dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供对外获取连接的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//在ThreadLocal中获取Connection</span></span><br><span class="line">			<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">			<span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;<span class="comment">//当conn==null时，证明threadLocal为空，即本次为第一次取连接</span></span><br><span class="line">				<span class="comment">//在连接池中，获取一个连接并存储在threadLocal当中</span></span><br><span class="line">				conn = dataSource.getConnection();</span><br><span class="line">				</span><br><span class="line">				threadLocal.set(conn);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//通过得到的dataSource对象建立连接</span></span><br><span class="line">			<span class="keyword">return</span> conn;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供对外回收连接的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将建立好的连接进行回收到连接池当中，以便其他需要连接的地方可以获取连接</span></span><br><span class="line">			<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">				threadLocal.remove();</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="效果展示"><a class="header-anchor" href="#效果展示"></a>效果展示</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011235565.png" alt="image-20240424205748611"></p>
<p>可以看到，如果使用Util版本的连接池，则会获取到三个不同的连接</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011235417.png" alt="image-20240424205839547"></p>
<p>而使用了Util2的连接池后，则一个线程里只会获取到一个链接，并且进行反复使用</p>
<h3 id="DAO封装与BaseDAO工具类"><a class="header-anchor" href="#DAO封装与BaseDAO工具类"></a>DAO封装与BaseDAO工具类</h3>
<blockquote>
<p>DAO Data Access Object 数据访问对象</p>
<p>让数据在JAVA中以对象的形式存在，做到：</p>
<p>一张表对应一个实体类，一张表的操作对应一个DAO对象</p>
<p>在JAVA操作数据库时，我们将对同一张表的增删改查作统一的维护，维护的类就属于DAO层面</p>
<p>DAO只关注数据库的操作，供业务层Service调用</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2025/03/01/MySQL/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="MySQL-基础"><a class="header-anchor" href="#MySQL-基础"></a>MySQL 基础</h1>
<h2 id="数据库的概念"><a class="header-anchor" href="#数据库的概念"></a>数据库的概念</h2>
<h3 id="DB-DataBase"><a class="header-anchor" href="#DB-DataBase"></a>DB(DataBase):</h3>
<p>数据存储的仓库。保存了一系列有组织的数据。</p>
<h3 id="DBMS-DateBase-Management-Syetem"><a class="header-anchor" href="#DBMS-DateBase-Management-Syetem"></a>DBMS(DateBase Management Syetem)</h3>
<p>数据库通过DBMS创建和操作的容器。</p>
<h3 id="SQL-Structure-Query-Language"><a class="header-anchor" href="#SQL-Structure-Query-Language"></a>SQL(Structure Query Language)</h3>
<p>结构化语言：专门用于与数据库通信的语言</p>
<h2 id="数据库在开发中的应用"><a class="header-anchor" href="#数据库在开发中的应用"></a>数据库在开发中的应用</h2>
<ol>
<li><strong>设计</strong>：数据库设计</li>
<li><strong>编码</strong>：数据库操作</li>
<li><strong>优化</strong>：数据库优化</li>
</ol>
<h2 id="SQL"><a class="header-anchor" href="#SQL"></a>SQL</h2>
<h3 id="SQL通用语法"><a class="header-anchor" href="#SQL通用语法"></a>SQL通用语法</h3>
<ol>
<li>
<p>不区分大小写；但建议关键字大写，表名、列名小写</p>
</li>
<li>
<p>每条命令使用分号结尾</p>
</li>
<li>
<p>每条命令根据需要，可以进行缩进或换行</p>
<ol>
<li>建议：关键字一行；查询的东西一行；表名一行</li>
</ol>
</li>
<li>
<p>注释：</p>
<ol>
<li>
<pre><code>单行注释：#注释文字(MySQL独有)
单行注释：-- 注释文字
多行注释： /* 注释文字 */
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### SQL分类</span><br><span class="line"></span><br><span class="line">| 分类    | 全称                           | 说明                                                   |</span><br><span class="line">| ------- | ------------------------------ | ------------------------------------------------------ |</span><br><span class="line">| **DDL** | **Data Definition Language**   | 数据定义语言，用于定义数据库对象（数据库、表、字段）   |</span><br><span class="line">| **DML** | **Data Manipulation Language** | 数据操作语言，用于对数据库表中的数据进行增删改         |</span><br><span class="line">| **DQL** | **Data Query Language**        | 数据查询语言，用于查询数据库中表的记录                 |</span><br><span class="line">| **DCL** | **Data Control Language**      | 数据控制语言，用于创建数据库用户、控制数据库的访问权限 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## MySQL的操作语句</span><br><span class="line"></span><br><span class="line">&gt; 关系型数据库（MySQL就是一种关系型数据库）：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</span><br><span class="line">&gt; 2. 特点</span><br><span class="line">&gt;    1. 使用表存储数据，格式统一、便于管理</span><br><span class="line">&gt;    2. 使用SQL语言进行操作，标准统一，便于使用</span><br><span class="line"></span><br><span class="line">### MySQL服务登录和退出</span><br><span class="line"></span><br><span class="line">#### 登录</span><br><span class="line"></span><br><span class="line">1. 方式一：通过mysql自带的客户端</span><br><span class="line"></span><br><span class="line">   只限于root用户</span><br><span class="line"></span><br><span class="line">2. 方式二：通过windows自带客户端(cmd窗口)登录</span><br><span class="line"></span><br><span class="line">   ```s</span><br><span class="line">   mysql [-h 主机名 -P 端口号] -u 用户名 -p 密码</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="退出"><a class="header-anchor" href="#退出"></a>退出</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入exit or 使用“ctrl+c”</span><br></pre></td></tr></table></figure>
<h3 id="用户设置"><a class="header-anchor" href="#用户设置"></a>用户设置</h3>
<h4 id="用户权限"><a class="header-anchor" href="#用户权限"></a>用户权限</h4>
<ul>
<li><strong>Select_priv</strong></li>
<li><strong>Insert_priv</strong></li>
<li><strong>Update_priv</strong></li>
<li><strong>Delete_priv</strong></li>
<li><strong>Create_priv</strong></li>
<li><strong>Drop_priv</strong></li>
<li><strong>Reload_priv</strong></li>
<li><strong>Shutdown_priv</strong></li>
<li><strong>Process_priv</strong></li>
<li><strong>File_priv</strong></li>
<li><strong>Grant_priv</strong></li>
<li><strong>References_priv</strong></li>
<li><strong>Index_priv</strong></li>
<li><strong>Alter_priv</strong></li>
</ul>
<h4 id="添加用户"><a class="header-anchor" href="#添加用户"></a>添加用户</h4>
<ol>
<li>使用SQL的<strong>GRANT</strong>指令</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">CREATE</span>,<span class="keyword">DROP</span></span><br><span class="line"><span class="keyword">ON</span> TUTORIALS.<span class="operator">*</span></span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>		# 主机名可以使用<span class="string">&#x27;%&#x27;</span>通配</span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在mysql数据库中的user表添加新用户</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span> </span><br><span class="line">          (host, <span class="keyword">user</span>, password, </span><br><span class="line">           select_priv, insert_priv, update_priv) </span><br><span class="line">           <span class="keyword">VALUES</span> (<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, </span><br><span class="line">           PASSWORD(<span class="string">&#x27;guest123&#x27;</span>), <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上命令会在mysql数据库中的user表中创建一条用户信息记录</p>
<h3 id="切换数据库"><a class="header-anchor" href="#切换数据库"></a>切换数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名</span><br></pre></td></tr></table></figure>
<p>选择要操作的数据库，使用该命令后，所有的MySQL命令只针对该数据库</p>
<h3 id="显示本地服务器所有数据库"><a class="header-anchor" href="#显示本地服务器所有数据库"></a>显示本地服务器所有数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases</span><br></pre></td></tr></table></figure>
<p>列出MySQL数据库系统管理的数据库列表，即显示出所有数据库名</p>
<h3 id="显示数据库中所有的表"><a class="header-anchor" href="#显示数据库中所有的表"></a>显示数据库中所有的表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables</span><br></pre></td></tr></table></figure>
<p>在use命令选定一个数据库后，使用该命令可以显示当前数据库内所含的所有表</p>
<h3 id="显示某个表的表结构"><a class="header-anchor" href="#显示某个表的表结构"></a>显示某个表的表结构</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> 数据表</span><br></pre></td></tr></table></figure>
<p>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</p>
<h3 id="显示某个表的索引信息"><a class="header-anchor" href="#显示某个表的索引信息"></a>显示某个表的索引信息</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 数据表</span><br></pre></td></tr></table></figure>
<p>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</p>
<h2 id="DDL-Data-Defination-Language"><a class="header-anchor" href="#DDL-Data-Defination-Language"></a>DDL(Data Defination Language)</h2>
<h3 id="MySQL创建数据库"><a class="header-anchor" href="#MySQL创建数据库"></a>MySQL创建数据库</h3>
<h4 id="CREATE命令"><a class="header-anchor" href="#CREATE命令"></a>CREATE命令</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure>
<p><strong>完整命令为：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(假如不存在则创建，存在则不创建)] database_name</span><br><span class="line">  [<span class="keyword">CHARACTER SET</span> charset_name(设定字符集)]</span><br><span class="line">  [<span class="keyword">COLLATE</span> collation_name(设定排序规则)];</span><br></pre></td></tr></table></figure>
<h3 id="MySQL删除数据库"><a class="header-anchor" href="#MySQL删除数据库"></a>MySQL删除数据库</h3>
<h4 id="DROP命令删除数据库"><a class="header-anchor" href="#DROP命令删除数据库"></a>DROP命令删除数据库</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span>;        <span class="comment">-- 直接删除数据库，不检查是否存在</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL数据类型"><a class="header-anchor" href="#MySQL数据类型"></a>MySQL数据类型</h2>
<h4 id="数值类型"><a class="header-anchor" href="#数值类型"></a>数值类型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 Bytes</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 Bytes</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 Bytes</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 Bytes</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 Bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 Bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 Bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<h3 id="日期和时间类型"><a class="header-anchor" href="#日期和时间类型"></a>日期和时间类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">‘-838:59:59’/‘838:59:59’</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
<td style="text-align:left">YYYY-MM-DD hh:mm:ss</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC<br/>结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:left">YYYY-MM-DD hh:mm:ss</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h3 id="字符串类型"><a class="header-anchor" href="#字符串类型"></a>字符串类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 bytes</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<h3 id="枚举和集合类型-Enumeration-and-Set-Types"><a class="header-anchor" href="#枚举和集合类型-Enumeration-and-Set-Types"></a>枚举和集合类型(Enumeration and Set Types)</h3>
<ul>
<li><strong>ENUM</strong>: 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li>
<li><strong>SET</strong>: 集合类型，用于存储多个值，可以选择多个预定义的集合。</li>
</ul>
<h3 id="空间数据类型（Spatial-Data-Types）"><a class="header-anchor" href="#空间数据类型（Spatial-Data-Types）"></a>空间数据类型（Spatial Data Types）</h3>
<p>GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。</p>
<h2 id="DQL-Data-Query-Language"><a class="header-anchor" href="#DQL-Data-Query-Language"></a>DQL(Data Query Language)</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表	————基本查询</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	条件列表	————条件查询</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组字段列表	 ——分组查询</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组后条件列表		</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序字段列表	——排序查询</span><br><span class="line">limit</span><br><span class="line">	分页参数	————分页查询</span><br></pre></td></tr></table></figure>
<h3 id="部分语法"><a class="header-anchor" href="#部分语法"></a>部分语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询多个字段：</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span> <span class="keyword">from</span> 表名;</span><br><span class="line">查询所有字段(通配符):</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line">设置别名：</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> [<span class="keyword">as</span> 别名<span class="number">1</span>],字段<span class="number">2</span>[<span class="keyword">as</span> 别名<span class="number">2</span>] <span class="keyword">from</span> 表名;</span><br><span class="line">去除重复记录：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure>
<h3 id="聚合函数"><a class="header-anchor" href="#聚合函数"></a>聚合函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
<h4 id="count函数"><a class="header-anchor" href="#count函数"></a>count函数</h4>
<ol>
<li>
<p>不计算空值</p>
</li>
<li>
<p>通常使用 * 来统计总数据行数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_emp;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h2 id="分组查询"><a class="header-anchor" href="#分组查询"></a>分组查询</h2>
<h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2>
<blockquote>
<p>一段可以直接被另一端程序调用的程序或代码</p>
</blockquote>
<h3 id="字符串函数"><a class="header-anchor" href="#字符串函数"></a>字符串函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONCAT(S1,S2,…Sn)</td>
<td style="text-align:left">字符串拼接，将S1,S2,…Sn拼接成一个字符串</td>
</tr>
<tr>
<td style="text-align:left">LOWER(str)</td>
<td style="text-align:left">将字符串str转换为小写</td>
</tr>
<tr>
<td style="text-align:left">UPPER(str)</td>
<td style="text-align:left">将字符串str转换为大写</td>
</tr>
<tr>
<td style="text-align:left">LPAD(str,n,pad)</td>
<td style="text-align:left">左填充，用字符串pad对str左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td style="text-align:left">RPAD(str,n,pad)</td>
<td style="text-align:left">右填充，用字符串pad对str右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td style="text-align:left"><code>TRIM(str)</code></td>
<td style="text-align:left">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td style="text-align:left">SUBSTRING(str,start,len)</td>
<td style="text-align:left">返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
</tbody>
</table>
<h3 id="数值函数"><a class="header-anchor" href="#数值函数"></a>数值函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CEIL(X)</code></td>
<td style="text-align:left">向上取整</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOOR(X)</code></td>
<td style="text-align:left">向下取整</td>
</tr>
<tr>
<td style="text-align:left"><code>MOD(x,y)</code></td>
<td style="text-align:left">返回x/y的模</td>
</tr>
<tr>
<td style="text-align:left"><code>RAND()</code></td>
<td style="text-align:left">返回0~1的随机数</td>
</tr>
<tr>
<td style="text-align:left"><code>ROUND(x,y)</code></td>
<td style="text-align:left">求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody>
</table>
<h3 id="日期函数"><a class="header-anchor" href="#日期函数"></a>日期函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CURDATE()</td>
<td style="text-align:left">返回当前日期</td>
</tr>
<tr>
<td style="text-align:left">CURTIME()</td>
<td style="text-align:left">返回当前时间</td>
</tr>
<tr>
<td style="text-align:left">NOW()</td>
<td style="text-align:left">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR(date)</td>
<td style="text-align:left">获取指定date的年份</td>
</tr>
<tr>
<td style="text-align:left">MONTH(date)</td>
<td style="text-align:left">获取指定date的月份</td>
</tr>
<tr>
<td style="text-align:left">DAY(date)</td>
<td style="text-align:left">获取指定date的日期</td>
</tr>
<tr>
<td style="text-align:left">DATE_ADD(date,INTERVAL expr type)</td>
<td style="text-align:left">返回：一个日期/时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td style="text-align:left">DATEDIFF(date1,date2)</td>
<td style="text-align:left">返回起始时间date1和结束时间date2之间的天数（date1-date2）</td>
</tr>
</tbody>
</table>
<h3 id="流程控制函数"><a class="header-anchor" href="#流程控制函数"></a>流程控制函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IF(value,t,f)</td>
<td style="text-align:left">如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td style="text-align:left">IFNULL(value1,value2)</td>
<td style="text-align:left">如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td style="text-align:left">CASE WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td style="text-align:left">如果val1为true，返回res1，…否则返回default默认值</td>
</tr>
<tr>
<td style="text-align:left">CASE[expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td style="text-align:left">如果expr的值等于val1，返回res1，…否则返回default默认值</td>
</tr>
</tbody>
</table>
<h2 id="约束"><a class="header-anchor" href="#约束"></a>约束</h2>
<blockquote>
<p>作用于表中字段中的规则，用于限制存储在表中的数据</p>
<p>保证数据库中数据的正确性、有效性和完整性</p>
<p>创建表时对字段进行限制</p>
</blockquote>
<h3 id="NOT-NULL约束"><a class="header-anchor" href="#NOT-NULL约束"></a>NOT NULL约束</h3>
<blockquote>
<p>限制字段的数据不能为null</p>
<p><code>NOT NULL</code></p>
</blockquote>
<p>NOT NULL 约束强制列不接受 NULL 值。</p>
<p>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>
<h4 id="建表时进行约束"><a class="header-anchor" href="#建表时进行约束"></a>建表时进行约束</h4>
<p>下面的 SQL 强制 “ID” 列、 “LastName” 列以及 “FirstName” 列不接受 NULL 值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Persons (</span><br><span class="line">    ID <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    FirstName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="添加约束"><a class="header-anchor" href="#添加约束"></a>添加约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Persons</span><br><span class="line">MODIFY Age <span class="type">int</span> <span class="keyword">NOT NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除约束"><a class="header-anchor" href="#删除约束"></a>删除约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Persons</span><br><span class="line">MODIFY Age <span class="type">int</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="UNIQUE约束"><a class="header-anchor" href="#UNIQUE约束"></a>UNIQUE约束</h3>
<blockquote>
<p>保证该字段的所有数据都是唯一，不重复的</p>
<p><code>UNIQUE</code></p>
</blockquote>
<p>UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。</p>
<p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
<h4 id="建表时添加约束"><a class="header-anchor" href="#建表时添加约束"></a>建表时添加约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Persons(</span><br><span class="line">	P_Id <span class="type">int</span> <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">	LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="对已有表中字段添加约束"><a class="header-anchor" href="#对已有表中字段添加约束"></a>对已有表中字段添加约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Persons</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (P_Id)</span><br></pre></td></tr></table></figure>
<h4 id="删除已有约束"><a class="header-anchor" href="#删除已有约束"></a>删除已有约束</h4>
<h3 id="主键约束"><a class="header-anchor" href="#主键约束"></a>主键约束</h3>
<blockquote>
<p>主键是一行数据的唯一标识，要求非空且唯一</p>
<p><code>PRIMARY KEY</code></p>
</blockquote>
<h4 id="建表时添加约束-v2"><a class="header-anchor" href="#建表时添加约束-v2"></a>建表时添加约束</h4>
<h4 id="对已有表中字段添加约束-v2"><a class="header-anchor" href="#对已有表中字段添加约束-v2"></a>对已有表中字段添加约束</h4>
<h4 id="删除已有约束-v2"><a class="header-anchor" href="#删除已有约束-v2"></a>删除已有约束</h4>
<h3 id="默认约束"><a class="header-anchor" href="#默认约束"></a>默认约束</h3>
<blockquote>
<p>保存数据时，如果未指定该字段的值，采用默认值</p>
<p><code>DEFAULT</code></p>
</blockquote>
<h4 id="建表时添加约束-v3"><a class="header-anchor" href="#建表时添加约束-v3"></a>建表时添加约束</h4>
<h4 id="对已有表中字段添加约束-v3"><a class="header-anchor" href="#对已有表中字段添加约束-v3"></a>对已有表中字段添加约束</h4>
<h4 id="删除已有约束-v3"><a class="header-anchor" href="#删除已有约束-v3"></a>删除已有约束</h4>
<h3 id="检查约束"><a class="header-anchor" href="#检查约束"></a>检查约束</h3>
<blockquote>
<p>保证字段值满足某个条件</p>
<p><code>CHECK</code></p>
</blockquote>
<h4 id="建表时添加约束-v4"><a class="header-anchor" href="#建表时添加约束-v4"></a>建表时添加约束</h4>
<h4 id="对已有表中字段添加约束-v4"><a class="header-anchor" href="#对已有表中字段添加约束-v4"></a>对已有表中字段添加约束</h4>
<h4 id="删除已有约束-v4"><a class="header-anchor" href="#删除已有约束-v4"></a>删除已有约束</h4>
<h3 id="以上五种约束的使用"><a class="header-anchor" href="#以上五种约束的使用"></a>以上五种约束的使用</h3>
<p><strong>要求</strong>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011234160.png" alt="image-20240328160419729"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> <span class="keyword">user</span>(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment comment<span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not null</span> <span class="keyword">unique</span> comment<span class="string">&#x27;用户姓名&#x27;</span>,</span><br><span class="line">  age <span class="type">int</span> <span class="keyword">check</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span><span class="number">100</span>), comment<span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span><span class="string">&#x27;1&#x27;</span> comment<span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  gender <span class="type">char</span>(<span class="number">1</span>) comment<span class="string">&#x27;性别&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="外键约束"><a class="header-anchor" href="#外键约束"></a>外键约束</h3>
<blockquote>
<p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p>
<p><code>FOREIGN KEY</code></p>
</blockquote>
<h4 id="子表"><a class="header-anchor" href="#子表"></a>子表</h4>
<p>具有外键的表称之为子表(从表)</p>
<h4 id="父表"><a class="header-anchor" href="#父表"></a>父表</h4>
<p>外键所关联的表称之为父表(主表)</p>
<p>若无外键约束，则子表和父表只存在逻辑上的关系，没有物理联系</p>
<h4 id="建表时添加约束-v5"><a class="header-anchor" href="#建表时添加约束-v5"></a>建表时添加约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名</span><br><span class="line">    (</span><br><span class="line">        column1 datatype <span class="keyword">null</span><span class="operator">/</span><span class="keyword">not null</span>,</span><br><span class="line">        column2 datatype <span class="keyword">null</span><span class="operator">/</span><span class="keyword">not null</span>,</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> 外键约束名 <span class="keyword">FOREIGN KEY</span>  (column1,column2,... column_n) </span><br><span class="line">        <span class="keyword">REFERENCES</span> 外键依赖的表 (column1,column2,...column_n)</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE<span class="comment">--级联删除</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h4 id="对已有表中字段添加约束-v5"><a class="header-anchor" href="#对已有表中字段添加约束-v5"></a>对已有表中字段添加约束</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名</span><br><span class="line">    <span class="keyword">ADD CONSTRAINT</span> 外键约束名</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (column1, column2,...column_n) </span><br><span class="line">    <span class="keyword">REFERENCES</span> 外键所依赖的表 (column1,column2,...column_n)</span><br><span class="line">#    <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;<span class="comment">--级联删除</span></span><br></pre></td></tr></table></figure>
<h4 id="删除已有约束-v5"><a class="header-anchor" href="#删除已有约束-v5"></a>删除已有约束</h4>
<p>删除外键需要知道外键的名称，如果创建时没有设置名称则会自动生成一个，你需要获取改外键的信息。</p>
<p><strong>使用以下命令获取外键信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  constraint_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  information_schema.REFERENTIAL_CONSTRAINTS</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  constraint_schema <span class="operator">=</span> <span class="operator">&lt;</span><span class="string">&#x27;db_name&#x27;</span><span class="operator">&gt;</span> <span class="keyword">AND</span> table_name <span class="operator">=</span> <span class="operator">&lt;</span><span class="string">&#x27;table_name&#x27;</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  information_schema.KEY_COLUMN_USAGE</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  constraint_schema <span class="operator">=</span> <span class="operator">&lt;</span><span class="string">&#x27;db_name&#x27;</span><span class="operator">&gt;</span> <span class="keyword">AND</span> table_name <span class="operator">=</span> <span class="operator">&lt;</span><span class="string">&#x27;table_name&#x27;</span><span class="operator">&gt;</span> <span class="keyword">AND</span>   </span><br><span class="line">  referenced_table_name <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令来删除外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>fk_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除-更新行为"><a class="header-anchor" href="#删除-更新行为"></a>删除/更新行为</h4>
<table>
<thead>
<tr>
<th style="text-align:left">行为</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NO ACTION</td>
<td style="text-align:left">当父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。</td>
</tr>
<tr>
<td style="text-align:left">RESTRICT</td>
<td style="text-align:left">当父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致)</td>
</tr>
<tr>
<td style="text-align:left">CASCADE</td>
<td style="text-align:left">当父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td style="text-align:left">SET NULL</td>
<td style="text-align:left">当父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则设置子表中的外键值为null(要求外键允许取null)</td>
</tr>
<tr>
<td style="text-align:left">SET DEFAULT</td>
<td style="text-align:left">父表有变更时，子表将外键列设置为一个默认的值(Innodb不支持)</td>
</tr>
</tbody>
</table>
<h2 id="多表查询"><a class="header-anchor" href="#多表查询"></a>多表查询</h2>
<h3 id="多表关系"><a class="header-anchor" href="#多表关系"></a>多表关系</h3>
<h4 id="一对多"><a class="header-anchor" href="#一对多"></a>一对多</h4>
<p><strong>实现</strong>：在多的一方建立外键，指向一的一方的主键</p>
<h4 id="多对多"><a class="header-anchor" href="#多对多"></a>多对多</h4>
<p><strong>实现</strong>：建立一张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> db01;</span><br><span class="line"></span><br><span class="line">use db01;</span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> course(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary key</span> ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;课程表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> course (id, name)</span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">null</span>,<span class="string">&#x27;java&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;c++&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;php&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;sql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary key</span> ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) ,</span><br><span class="line">    stuID <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> student (id, name, stuID)</span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">null</span>,<span class="string">&#x27;dls&#x27;</span>,<span class="string">&#x27;20001000&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;sxun&#x27;</span>,<span class="string">&#x27;20001001&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;ytz&#x27;</span>,<span class="string">&#x27;20001002&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;wyx&#x27;</span>,<span class="string">&#x27;20001003&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student_course(</span><br><span class="line">    id <span class="type">int</span> auto_increment comment<span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary key</span> ,</span><br><span class="line">    stuID <span class="type">int</span> <span class="keyword">not null</span> ,</span><br><span class="line">    courseId <span class="type">int</span> <span class="keyword">not null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_courseID <span class="keyword">foreign key</span> (courseId) <span class="keyword">references</span> course(id),</span><br><span class="line">    <span class="keyword">constraint</span> fk_stuID <span class="keyword">foreign key</span> (stuID) <span class="keyword">references</span> student(id)</span><br><span class="line">)comment <span class="string">&#x27;学生课程中间表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> student_course (id, stuID, courseId)</span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="一对一"><a class="header-anchor" href="#一对一"></a>一对一</h4>
<p>多用于单表的拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。</p>
<p><strong>实现</strong>：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的(<code>UNIQUE</code>)</p>
<h3 id="多表查询-v2"><a class="header-anchor" href="#多表查询-v2"></a>多表查询</h3>
<h4 id="连接查询"><a class="header-anchor" href="#连接查询"></a>连接查询</h4>
<ul>
<li>
<p>内连接：相当于查询A、B交集部分数据</p>
</li>
<li>
<p>外连接：</p>
<ul>
<li>
<p>左外连接：查询左表所有数据+两张表交集部分数据</p>
</li>
<li>
<p>右外连接：查询右表所有数据+两张表交集部分数据</p>
</li>
<li>
<p>自连接：当前表和自身的连接查询，自连接必须使用表别名</p>
</li>
</ul>
</li>
<li>
<p>子查询：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011234022.png" alt="image-20240328174406429"></p>
</li>
</ul>
<h4 id="内连接"><a class="header-anchor" href="#内连接"></a>内连接</h4>
<p><strong>语法</strong>：</p>
<p>隐式内连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br></pre></td></tr></table></figure>
<p>显式内连接:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件</span><br></pre></td></tr></table></figure>
<h2 id="索引"><a class="header-anchor" href="#索引"></a>索引</h2>
<h1 id="数据库课本内容"><a class="header-anchor" href="#数据库课本内容"></a>数据库课本内容</h1>
<h2 id="数据库的基本概念（Ch1-Ch9）"><a class="header-anchor" href="#数据库的基本概念（Ch1-Ch9）"></a>数据库的基本概念（Ch1-Ch9）</h2>
<blockquote>
<p>这部分内容：</p>
<ol>
<li>什么是数据库</li>
<li>关系型数据模型和关系型语言</li>
<li>数据库的设计</li>
</ol>
</blockquote>
<h3 id="什么是数据库，什么是关系型数据库"><a class="header-anchor" href="#什么是数据库，什么是关系型数据库"></a>什么是数据库，什么是关系型数据库</h3>
<ol>
<li>数据库系统是对数据进行存储、管理、处理和维护的软件系统，数据库管理系统（DataBase-Management System,DBMS）用于管理互相关联的数据并用一系列特定的程序访问这些数据。</li>
<li>与文件处理系统(file-processing system)相比，
<ol>
<li>数据的冗余和不一致(data redundancy and inconsistency)</li>
<li>数据访问困难(difficulty in accessing data)</li>
<li>数据孤立(data isolation)</li>
<li>完整性问题(integrity problem)</li>
<li>原子性问题(atomicity problem)</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="数据视图"><a class="header-anchor" href="#数据视图"></a>数据视图</h3>
<ol>
<li><strong>数据的抽象：</strong>
<ol>
<li>物理层：描述数据的实际存储方式</li>
<li>逻辑层：描述数据库中存储什么数据及这些数据间存在什么关系。
<ol>
<li>在逻辑层用户无需关心复杂的物理实现方式，仅需要考虑如何使用，这就是<strong>物理数据独立性</strong></li>
</ol>
</li>
<li>视图层：简化数据库与用户间的交互</li>
</ol>
</li>
<li><strong>实例&amp;模式：</strong>
<ol>
<li>在任意时刻插入数据库的信息集合称为一个<strong>实例(instance)</strong>.</li>
<li>数据库的总体设计称作数据库<strong>模式(schema)</strong></li>
</ol>
</li>
</ol>
<h3 id="数据库语言"><a class="header-anchor" href="#数据库语言"></a>数据库语言</h3>
<ol>
<li>数据库操作语言(Data-Manipulation Language,DML)
<ol>
<li>对存储在数据库中的信息进行检索Query</li>
<li>插入新数据</li>
<li>删除数据</li>
<li>修改数据</li>
</ol>
</li>
<li>数据库定义语言(Data-Definition Language,DDL)
<ol>
<li>数据存储和定义，定义了数据库实现细节，通常来说用户不可见</li>
<li>定义一些<strong>一致性约束</strong>
<ol>
<li><strong>域约束 domain constraint：</strong></li>
<li><strong>参考完整性 reference integrity：</strong></li>
<li><strong>断言 assertion：</strong></li>
<li><strong>授权 authorization：</strong></li>
</ol>
</li>
<li>元数据 metadata，关于数据的数据</li>
</ol>
</li>
</ol>
<h3 id="数据查询："><a class="header-anchor" href="#数据查询："></a>数据查询：</h3>
<p>select语句：以n个表库为输入，仅返回一个符合查询推荐的表。</p>
<h3 id="数据库功能部件"><a class="header-anchor" href="#数据库功能部件"></a>数据库功能部件</h3>
<ol>
<li>存储管理器
<ol>
<li>权限及完整性管理器</li>
<li>事务管理器</li>
<li>文件管理器</li>
<li>缓冲管理器</li>
</ol>
</li>
<li></li>
<li>查询处理部件</li>
</ol>
<h2 id="数据库系统的实现技术（Ch10-Ch19）"><a class="header-anchor" href="#数据库系统的实现技术（Ch10-Ch19）"></a>数据库系统的实现技术（Ch10-Ch19）</h2>
<h2 id="数据库进阶讨论（Ch24-Ch26）"><a class="header-anchor" href="#数据库进阶讨论（Ch24-Ch26）"></a>数据库进阶讨论（Ch24-Ch26）</h2>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础篇</title>
    <url>/2025/03/01/Java%E5%9F%BA%E7%A1%80/JAVA%E5%AD%A6%E4%B9%A00/</url>
    <content><![CDATA[<h1 id="Java基础篇"><a class="header-anchor" href="#Java基础篇"></a>Java基础篇</h1>
<h2 id="✔Java学习路线"><a class="header-anchor" href="#✔Java学习路线"></a>✔Java学习路线</h2>
<h3 id="《卷》"><a class="header-anchor" href="#《卷》"></a>《卷》</h3>
<h3 id="阶段①-Java入门，培养兴趣"><a class="header-anchor" href="#阶段①-Java入门，培养兴趣"></a>阶段①:Java入门，培养兴趣</h3>
<p>&gt;<a href="https://search.bilibili.com/all?from_source=webcommentline_search&amp;keyword=%E5%9C%A8%E7%BA%BF%E5%86%99%E4%BB%A3%E7%A0%81">在线写代码</a>:菜鸟工具<br>
&gt;记笔记:typora+markdown语法（可导HTML）<br>
&gt;多写代码，少背代码<br>
&gt;找资料小技巧:评论区，新视频<br>
&lt;Java知识&gt;<br>
基础语法，面向<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011822985.webp" alt="[热词系列_对象]">。<br>
（课程推荐韩顺平老师的0基础30天入门Java）<br>
Java8（宋红康老师的Java8入门视频)</p>
<h3 id="阶段②-巩固基础【1星期】"><a class="header-anchor" href="#阶段②-巩固基础【1星期】"></a>阶段②:巩固基础【1星期】</h3>
<p>《Java核心技术卷1》<br>
牛客网刷题<br>
数据结构算法练习（leetbook）<br>
计算机网络<br>
计算机基础<br>
操作系统<br>
（先看些有趣的书籍，当成课外书）</p>
<h3 id="阶段③-Java企业开发基础"><a class="header-anchor" href="#阶段③-Java企业开发基础"></a>阶段③:Java企业开发基础</h3>
<p>数据库入门（7天，老杜MySQL入门视频，SQL自学网）<br>
学习开发框架（Java web——&gt;spring5，spring mvc，mybatis，springboot框架——&gt;同一家视频教程&gt;尚硅谷老师）<br>
开发规范（保命用——&gt;阿里巴巴Java开发手册）<br>
git，github（《GitHub漫游指南》）<br>
Linux服务器（……）<br>
前端基础（HTML，css，Java script，vue）</p>
<h3 id="阶段④-Java企业开发进阶"><a class="header-anchor" href="#阶段④-Java企业开发进阶"></a>阶段④:Java企业开发进阶</h3>
<p>设计模式（……）<br>
中间件<br>
（Redis缓存，RebbitMQ消息对列，nginx网关）<br>
netty网络编程<br>
微服务（springcloud，springcloud alibaba）<br>
接口管理（尚硅谷老师的视频）<br>
容器技术（docker，K8S，狂神老师的教程）<br>
ci/cd（狂神老师）</p>
<h3 id="阶段⑤-项目实战"><a class="header-anchor" href="#阶段⑤-项目实战"></a>阶段⑤:项目实战</h3>
<p>【干货资源】</p>
<h3 id="阶段⑥-Java高级知识"><a class="header-anchor" href="#阶段⑥-Java高级知识"></a>阶段⑥:Java高级知识</h3>
<p>并发编程（尚硅谷老师的教程）<br>
jvm Java虚拟机（重点，尚硅谷老师，宋老师，狂神老师等）<br>
架构设计</p>
<h3 id="阶段⑦-Java求职"><a class="header-anchor" href="#阶段⑦-Java求职"></a>阶段⑦:Java求职</h3>
<p>&gt;尽早规划<br>
&gt;雕琢简历<br>
&gt;多读面经<br>
&gt;多参与面试<br>
&gt;持续复盘总结<br>
【干货资源】</p>
<h3 id="阶段⑧-持续学习"><a class="header-anchor" href="#阶段⑧-持续学习"></a>阶段⑧:持续学习</h3>
<p>深入学习源码，了解底层原理，更多数据库中间键分布式技术，面相业务的解决方案，提升架构能力，大数据【干货资源】<br>
已<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011835442.webp" alt="[热词系列_三连]">，整个文档在鱼皮老哥的公众号里面可以获取，纯干货，值得！<br>
公众号链接直达:https://mp.weixin.qq.com/s/nWC8e2GfvFq7W4MEdg-OPQ</p>
<h2 id="Java的基本概念"><a class="header-anchor" href="#Java的基本概念"></a>Java的基本概念</h2>
<h3 id="相关术语"><a class="header-anchor" href="#相关术语"></a>相关术语</h3>
<ol>
<li>简单性</li>
<li>面向对象：一种程序设计的思想，其核心是将程序设计的重点放在对象与对象的接口上。</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>多态性</li>
</ol>
<h3 id="Java的三大机制"><a class="header-anchor" href="#Java的三大机制"></a>Java的三大机制</h3>
<ol>
<li>虚拟机——这一机制让Java有了平台独立性JVM
<ol>
<li>因为最终格式是独立于操作系统和平台的Java自定义的字节码、统一经过JVM进行解释执行，因而不会因为平台的不同而导致出现代码编译后不同的错误。</li>
</ol>
</li>
<li>垃圾回收机制</li>
<li>代码安全检测</li>
</ol>
<h3 id="Java面向对象的三大特性："><a class="header-anchor" href="#Java面向对象的三大特性："></a>Java面向对象的三大特性：</h3>
<ol>
<li>
<p>封装（packaging；encapsulation)</p>
</li>
<li>
<p>继承（inheritance)</p>
</li>
<li>
<p>多态（Polymorphism)</p>
</li>
</ol>
<h3 id="Java的applet和Internet"><a class="header-anchor" href="#Java的applet和Internet"></a>Java的applet和Internet</h3>
<h3 id="JVM、JRE、JDK"><a class="header-anchor" href="#JVM、JRE、JDK"></a>JVM、JRE、JDK</h3>
<ol>
<li>JVM——java虚拟机：负责解释java技术代码、加载java类并执行java技术程序</li>
<li>JRE——Java运行时环境：一个Java技术程序还需要一套平台的标准Java类库。 Java 类库是预先编写的代码库，可以与您编写的代码结合起来创建健壮的应用程序。 JVM 软件和 Java 类库合起来称为 Java 运行时环境 (JRE)。</li>
<li>JDK——Java开发工具包：包括JRE/Java工具(javac/java/jdb)和Java API</li>
</ol>
<h3 id="如何创建、编译并运行一个Java程序"><a class="header-anchor" href="#如何创建、编译并运行一个Java程序"></a>如何创建、编译并运行一个Java程序</h3>
<ol>
<li>创建源代码</li>
<li>编译源代码</li>
<li>编译成功则转换为字节码存储与硬盘中；失败则返回源代码的修改</li>
<li>执行字节码</li>
<li>输出结果</li>
</ol>
<h3 id="支持链式编程"><a class="header-anchor" href="#支持链式编程"></a>支持链式编程</h3>
<h2 id="运算符"><a class="header-anchor" href="#运算符"></a>运算符</h2>
<ul>
<li>
<p>算术运算符</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法 - 相加运算符两侧的值</td>
<td style="text-align:center">A + B 等于 30</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法 - 左操作数减去右操作数</td>
<td style="text-align:center">A – B 等于 -10</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法 - 相乘操作符两侧的值</td>
<td style="text-align:center">A * B等于200</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除法 - 左操作数除以右操作数</td>
<td style="text-align:center">B / A等于2</td>
</tr>
<tr>
<td style="text-align:center">％</td>
<td style="text-align:center">取余 - 左操作数除以右操作数的余数</td>
<td style="text-align:center">B%A等于0</td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增: 操作数的值增加1</td>
<td style="text-align:center">B++ 或 ++B 等于 21（区别详见下文）</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">自减: 操作数的值减少1</td>
<td style="text-align:center">B-- 或 --B 等于 19（区别详见下文）</td>
</tr>
</tbody>
</table>
<p>需要注意的细节是，自增/减符号前置与后置会有不同的区别：</p>
<p>前缀式xx会先进行xx操作，而后再进行其他的运算操作；可联想”前——先进行本身“；后缀式则会进行其他运算操作，即”后进行本身“。</p>
<ol>
<li>
<p><strong>前缀自增自减法(++a,–a):</strong> 先进行自增或者自减运算，再进行表达式运算。</p>
</li>
<li>
<p><strong>后缀自增自减法(a++,a–):</strong> 先进行表达式运算，再进行自增或者自减运算</p>
</li>
</ol>
</li>
<li>
<p>关系运算符</p>
<ol>
<li>即进行各种比较</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td style="text-align:left">（A == B）为假。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td style="text-align:left">(A != B) 为真。</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A&gt; B）为假。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A &lt;B）为真。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A&gt; = B）为假。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A &lt;= B）为真。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>位运算符</p>
<ol>
<li>在二进制形式上进行操作，</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">＆</td>
<td style="text-align:left">如果相对应位都是1，则结果为1，否则为0</td>
<td style="text-align:left">（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">如果相对应位都是 0，则结果为 0，否则为 1</td>
<td style="text-align:left">（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">如果相对应位值相同，则结果为0，否则为1</td>
<td style="text-align:left">（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td style="text-align:left">〜</td>
<td style="text-align:left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td style="text-align:left">（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td style="text-align:left">A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td style="text-align:left">A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;&gt;</td>
<td style="text-align:left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td style="text-align:left">A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算符</p>
<ol>
<li>即与、或、非三种逻辑操作</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td style="text-align:left">（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td style="text-align:left">| |</td>
<td style="text-align:left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td style="text-align:left">（A | | B）为真。</td>
</tr>
<tr>
<td style="text-align:left">！</td>
<td style="text-align:left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td style="text-align:left">！（A &amp;&amp; B）为真。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>短路逻辑运算符</p>
<p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
</li>
</ul>
</li>
<li>
<p>赋值运算符</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td style="text-align:center">C = A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td style="text-align:center">C + = A等价于C = C + A</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td style="text-align:center">C - = A等价于C = C - A</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td style="text-align:center">C * = A等价于C = C * A</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td style="text-align:center">C / = A，C 与 A 同类型时等价于 C = C / A</td>
</tr>
<tr>
<td style="text-align:center">％=</td>
<td style="text-align:center">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td style="text-align:center">C％= A等价于C = C％A</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt; =</td>
<td style="text-align:center">左移位赋值运算符</td>
<td style="text-align:center">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt; =</td>
<td style="text-align:center">右移位赋值运算符</td>
<td style="text-align:center">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td style="text-align:center">＆=</td>
<td style="text-align:center">按位与赋值运算符</td>
<td style="text-align:center">C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td style="text-align:center">^ =</td>
<td style="text-align:center">按位异或赋值操作符</td>
<td style="text-align:center">C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td style="text-align:center">| =</td>
<td style="text-align:center">按位或赋值操作符</td>
<td style="text-align:center">C | = 2等价于C = C | 2</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>其他运算符</p>
<ul>
<li>
<p>三元（条件）运算符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">variable</span> <span class="variable">x</span> <span class="operator">=</span> (expression) ? value <span class="keyword">if</span> <span class="literal">true</span> : value <span class="keyword">if</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>instanceof 运算符：</p>
<p>检查该对象是否是一个特定类型（类类型或接口类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( Object reference variable ) <span class="keyword">instanceof</span>  (class/<span class="keyword">interface</span> <span class="title class_">type</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>运算符优先级</p>
<p>大部分与生活常识相关，可依靠直觉</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">操作符</th>
<th style="text-align:center">关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后缀</td>
<td style="text-align:center">() [] . (点操作符)</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">一元</td>
<td style="text-align:center">expr++ expr–</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">一元</td>
<td style="text-align:center">++expr --expr + - ～ ！</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">乘性</td>
<td style="text-align:center">* /％</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">加性</td>
<td style="text-align:center">+ -</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">移位</td>
<td style="text-align:center">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">关系</td>
<td style="text-align:center">&gt; &gt;= &lt; &lt;=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">相等</td>
<td style="text-align:center">== !=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">＆</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">^</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">|</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">| |</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">条件</td>
<td style="text-align:center">？：</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">赋值</td>
<td style="text-align:center">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">逗号</td>
<td style="text-align:center">，</td>
<td style="text-align:center">左到右</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="修饰符"><a class="header-anchor" href="#修饰符"></a>修饰符</h2>
<h3 id="访问修饰符"><a class="header-anchor" href="#访问修饰符"></a>访问修饰符</h3>
<ul>
<li>default (即默认，什么也不写）: 在<strong>同一包内</strong>可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li>private : 在<strong>同一类</strong>内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li>public : 对<strong>所有类</strong>可见。使用对象：类、接口、变量、方法</li>
<li>protected : 对<strong>同一包内的类和所有子类</strong>可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<h3 id="非访问修饰符"><a class="header-anchor" href="#非访问修饰符"></a>非访问修饰符</h3>
<ul>
<li>
<p>static：用来修饰类方法和类变量。</p>
<ul>
<li>
<p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。静态变量一定得进行初始化</p>
</li>
<li>
<p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
</li>
<li>
<p>类内的静态变量和静态方法可以通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.变量名/方法名 ClassName.staticValue/staticFunction</span><br></pre></td></tr></table></figure>
<p>进行调用。</p>
</li>
</ul>
</li>
<li>
<p>final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
</li>
<li>
<p>abstract：用来创建抽象类和抽象方法。</p>
<ul>
<li>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</li>
<li>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</li>
<li>抽象类可以包含抽象方法和非抽象方法。</li>
</ul>
</li>
<li>
<p>synchronized：主要用于线程的编程。</p>
<ul>
<li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以同时配合其他四个访问修饰符一起使用。</li>
</ul>
</li>
<li>
<p>transient 修饰符</p>
<ul>
<li>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</li>
<li>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li>
</ul>
</li>
<li>
<p>volatile：主要用于线程的编程。</p>
</li>
</ul>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型"></a>基本数据类型</h2>
<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>Java 的两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h3 id="内置数据类型"><a class="header-anchor" href="#内置数据类型"></a>内置数据类型</h3>
<h4 id="类型种类"><a class="header-anchor" href="#类型种类"></a>类型种类</h4>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
<li>char</li>
</ul>
<h4 id="类型默认值"><a class="header-anchor" href="#类型默认值"></a>类型默认值</h4>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>数据类型</strong></th>
<th style="text-align:left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0.0f</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0.0d</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">‘u0000’</td>
</tr>
<tr>
<td style="text-align:left">String (or any object)</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<h3 id="引用数据类型"><a class="header-anchor" href="#引用数据类型"></a>引用数据类型</h3>
<ul>
<li>
<p>对象、数组都是引用数据类型。</p>
</li>
<li>
<p>所有引用类型的默认值都是null。</p>
</li>
</ul>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<ul>
<li>
<p>常量在程序运行时是不能被修改的。</p>
</li>
<li>
<p>在 Java 中使用 final 关键字来修饰常量、</p>
</li>
<li>
<p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制。</p>
<ul>
<li>字面量：字面量（literal）是用于表达源代码中一个固定值的表示法（notation）</li>
<li>个人理解：常量是被“变量化”的字面量&lt;变量化自我捏造，纯属方便自己理解）</li>
</ul>
</li>
</ul>
<h2 id="Number类"><a class="header-anchor" href="#Number类"></a>Number类</h2>
<p>当需要使用的是某种数据类型的变量而非内置数据类型时，Java提供了Number类（一种包装类）这一选择。</p>
<p>抽象类Object的子类有：Boolean、Character、Number</p>
<p>抽象类Number的子类有：Integer、Long、Byte、Double、Float、Short</p>
<h3 id="包装类："><a class="header-anchor" href="#包装类："></a>包装类：</h3>
<table>
<thead>
<tr>
<th style="text-align:left">包装类</th>
<th style="text-align:left">基本数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:left">Integer</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">Character</td>
<td style="text-align:left">char</td>
</tr>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">double</td>
</tr>
</tbody>
</table>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/OOP_WrapperClass.png" alt="Java Number类"></p>
<h4 id="使用包装类的原因："><a class="header-anchor" href="#使用包装类的原因："></a>使用包装类的原因：</h4>
<ul>
<li><strong>面向对象要求</strong>：</li>
</ul>
<h3 id="Number-Math-类方法"><a class="header-anchor" href="#Number-Math-类方法"></a>Number &amp; Math 类方法</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-xxxvalue.html">xxxValue()</a> 将 Number 对象转换为xxx数据类型的值并返回。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-compareto.html">compareTo()</a> 将number对象与参数比较。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-equals.html">equals()</a> 判断number对象是否与参数相等。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-valueof.html">valueOf()</a> 返回一个 Number 对象指定的内置数据类型</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-tostring.html">toString()</a> 以字符串形式返回值。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-parseInt.html">parseInt()</a> 将字符串解析为int类型。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-abs.html">abs()</a> 返回参数的绝对值。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-ceil.html">ceil()</a> 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-floor.html">floor()</a> 返回小于等于（&lt;=）给定参数的最大整数 。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-rint.html">rint()</a> 返回与参数最接近的整数。返回类型为double。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-round.html">round()</a> 它表示<strong>四舍五入</strong>，算法为 <strong>Math.floor(x+0.5)</strong>，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-min.html">min()</a> 返回两个参数中的最小值。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-max.html">max()</a> 返回两个参数中的最大值。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-exp.html">exp()</a> 返回自然数底数e的参数次方。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-log.html">log()</a> 返回参数的自然数底数的对数值。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-pow.html">pow()</a> 返回第一个参数的第二个参数次方。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-sqrt.html">sqrt()</a> 求参数的算术平方根。</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-sin.html">sin()</a> 求指定double类型参数的正弦值。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-cos.html">cos()</a> 求指定double类型参数的余弦值。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-tan.html">tan()</a> 求指定double类型参数的正切值。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-asin.html">asin()</a> 求指定double类型参数的反正弦值。</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-acos.html">acos()</a> 求指定double类型参数的反余弦值。</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-atan.html">atan()</a> 求指定double类型参数的反正切值。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-atan2.html">atan2()</a> 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-todegrees.html">toDegrees()</a> 将参数转化为角度。</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-toradians.html">toRadians()</a> 将角度转换为弧度。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/number-random.html">random()</a> 返回一个随机数。</td>
</tr>
</tbody>
</table>
<h2 id="Character类"><a class="header-anchor" href="#Character类"></a>Character类</h2>
<h3 id="转义序列"><a class="header-anchor" href="#转义序列"></a>转义序列</h3>
<p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。</p>
<p>下面列表展示了Java的转义序列：</p>
<table>
<thead>
<tr>
<th style="text-align:left">转义序列</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">在文中该处插入一个tab键</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">在文中该处插入一个后退键</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">在文中该处换行</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">在文中该处插入回车</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">在文中该处插入换页符</td>
</tr>
<tr>
<td style="text-align:left">\’</td>
<td style="text-align:left">在文中该处插入单引号</td>
</tr>
<tr>
<td style="text-align:left">\&quot;</td>
<td style="text-align:left">在文中该处插入双引号</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">在文中该处插入反斜杠</td>
</tr>
</tbody>
</table>
<h3 id="Character-方法"><a class="header-anchor" href="#Character-方法"></a>Character 方法</h3>
<p>下面是Character类的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-isletter.html">isLetter()</a> 是否是一个字母</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a> 是否是一个数字字符</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a> 是否是一个空白字符</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a> 是否是大写字母</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a> 是否是小写字母</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a> 指定字母的大写形式</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>() 指定字母的小写形式</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/character-tostring.html">toString</a>() 返回字符的字符串形式，字符串的长度仅为1</td>
</tr>
</tbody>
</table>
<p>对于Character类的方法的完整列表，参考的 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Character.html">java.lang.Character API</a> 规范。</p>
<h2 id="String类"><a class="header-anchor" href="#String类"></a>String类</h2>
<p>与c++不同，字符串在java中被抽象为一种引用对象，创建对象时，</p>
<p>可以使用直接创建的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用类实例化的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>直接使用双引号<code>“”</code>创建的字符串会存储在字符串常量池中。</p>
<ol>
<li>字符串常量池是Java专门用来存储字符串字面量的区域。它的一个特点是每当用直接创建的方式新创建一个字符串时，会先串池中查找是否存在相同内容的字符串，如果已存在，则直接返回串池内已存在的变量的引用，而不会创建新的对象。</li>
</ol>
</li>
<li>
<p>new关键字创建的字符串对象存储在堆区当中，每一个创建出来的变量都是独立的对象，在堆区里都有自己的地址，不共享。</p>
</li>
</ol>
<p>字符串的“==”比较，比较的其实是字符串的引用，而不是字符串的实际变量值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1;                    <span class="comment">// 相同引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png" alt="img"></p>
<p>String类有11种构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length()		<span class="comment">//它包含的字符数目</span></span><br><span class="line">charAt(index)	<span class="comment">//返回字符串中指定索引位置的字符。</span></span><br><span class="line">concat(s1)		<span class="comment">//字符拼接</span></span><br><span class="line">toUpperCase()	<span class="comment">//转换为大写</span></span><br><span class="line">toLowerCase()	<span class="comment">//转换为小写</span></span><br><span class="line">trim()			<span class="comment">//它去除字符串开头和结尾的空格（不包括字符串中间的空格），然后返回一个新的字符串。</span></span><br></pre></td></tr></table></figure>
<p>字符串比较：操作符 == 只能检测 string1 和 string2是否指向同一个对象， 但它不会告诉你它们的内容是否相同。</p>
<p>因此，不能使用 == 判断两个字符串 变量的内容是否相同 。 取而代之 ， 应该使用 equals 或者compareTo方法</p>
<p>String内的方法参考连接内：</p>
<p><a href="https://www.runoob.com/java/java-string.html">Java String 类 | 菜鸟教程 (runoob.com)</a></p>
<p>更详细，参看 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">Java String API</a> 文档:</p>
<h2 id="Scanner类"><a class="header-anchor" href="#Scanner类"></a>Scanner类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Scanner对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>
<h2 id="Java异常处理"><a class="header-anchor" href="#Java异常处理"></a>Java异常处理</h2>
<ol>
<li>常见的几大类异常：
<ul>
<li>用户输入非法数据</li>
<li>要打开的文件不存在</li>
<li>网络通信时连接中断</li>
<li>JVM内存溢出</li>
</ul>
</li>
<li>需要掌握以下三种类型的异常：
<ul>
<li>**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
</li>
</ol>
<h2 id="流程控制结构"><a class="header-anchor" href="#流程控制结构"></a>流程控制结构</h2>
<h3 id="顺序"><a class="header-anchor" href="#顺序"></a>顺序</h3>
<p>根据代码的书写顺序逐行执行</p>
<h3 id="分支"><a class="header-anchor" href="#分支"></a>分支</h3>
<ol>
<li>if-else</li>
<li>switch-case
<ol>
<li>存在case穿透现象，需要根据具体需求添加break语句</li>
</ol>
</li>
</ol>
<h3 id="循环"><a class="header-anchor" href="#循环"></a>循环</h3>
<ol>
<li>for循环</li>
<li>while循环</li>
</ol>
<h2 id="API"><a class="header-anchor" href="#API"></a>API</h2>
<p>Application Programming Interface 应用程序编程接口<br>
各种他人编写好的类，可以直接进行调用，提高开发效率。</p>
<h2 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h2>
<p>String StringBuilder StringJonier StringBuffer Pattern Matcher</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建String对象两种方式:</span><br><span class="line"><span class="number">1.</span> 直接赋值     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;蔡桂&quot;</span>;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">new</span>方法构造  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;蔡桂&quot;</span>);</span><br><span class="line">  构造方法有:</span><br><span class="line">    无参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span>;</span><br><span class="line">    传入字符串</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span>;</span><br><span class="line">    根据字符数组创建</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span>[] chs)</span>;</span><br><span class="line">    根据字节数组创建(ASCII码)</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] chs)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="串池"><a class="header-anchor" href="#串池"></a>串池</h3>
<p>StringTable:原本存储于方法区,JDK7之后方法区挪进了堆区,现存于堆区内;<br>
(<br>
栈区:存储方法与常量;<br>
堆区:存储new出来的对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">每当有一个String对象的创建:</span><br><span class="line">  <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">直接赋值<span class="string">&quot;=&quot;</span>;</span><br><span class="line">都会去堆区的串池当中查找被赋值的字符串是否存在于串池当中,</span><br><span class="line">当创建对象s1时,name不存在于串池中,则在串池中有: <span class="string">&quot;name&quot;</span> <span class="number">0x0001</span></span><br><span class="line">当创建对象s2时,name存在于串池中,则对已存在的<span class="string">&quot;name&quot;</span>进行复用;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="常用的方法"><a class="header-anchor" href="#常用的方法"></a>常用的方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compare</span><br><span class="line">比较<span class="string">&quot;==&quot;</span>符号分为:基本数据类型与引用数据类型</span><br><span class="line"><span class="number">1.</span> 基本数据类型比较的是数据值</span><br><span class="line"><span class="number">2.</span> 引用数据类型比较的是地址值</span><br><span class="line"></span><br><span class="line">比较的方法:</span><br><span class="line">  <span class="number">1.</span> <span class="type">boolean</span> equals&lt;严格比较&gt;</span><br><span class="line">  <span class="number">2.</span> Boolean equalsIgnoreCase&lt;忽略大小写&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(index)</span> 返回字符串对应下标index的字符;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>       返回字符串的长度;</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>; 截取字串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="StringBuilder"><a class="header-anchor" href="#StringBuilder"></a>StringBuilder</h3>
<p>一个可拓展的容器<br>
直接打印StringBuilder打印的不是地址值是属性值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造器</span><br><span class="line">无参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span>;</span><br><span class="line">有参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成员函数</span><br><span class="line">StringBuilder <span class="title function_">append</span><span class="params">(任意类型)</span>   字符串拼接</span><br><span class="line">StringBuilder <span class="title function_">reverse</span><span class="params">()</span>         反转字符串</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>                    获取字符串的长度——已经装了多少</span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span>;                 获取字符串的容量——最多装多少</span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>               将StringBuilder转换成String</span><br></pre></td></tr></table></figure>
<h3 id="StringJoiner"><a class="header-anchor" href="#StringJoiner"></a>StringJoiner</h3>
<p>拼接速度更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line">StringJoiner(间隔符号);</span><br><span class="line">StringJoiner(间隔符号,开始符号,结束符号);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成员函数</span><br><span class="line">StringJoiner <span class="title function_">add</span><span class="params">(添加元素)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的原理"><a class="header-anchor" href="#字符串的原理"></a>字符串的原理</h3>
<ol>
<li>
<p>拓展底层原理</p>
<ol>
<li>字符串存储的内存原理:
<ol>
<li>直接赋值会复用字符串常量池当中存在的</li>
<li>new出来的对象不会去复用,而是开辟一个新的空间</li>
</ol>
</li>
<li>&quot;==&quot;号进行比较的是:
<ol>
<li>基本数据类型比较数据值</li>
<li>引用数据类型比较地址值</li>
</ol>
</li>
</ol>
</li>
<li>
<p>字符串拼接原理</p>
<ol>
<li>拼接时无变量参与,触发字符串优化机制:编译时会将&quot;a&quot;+“b”+“c” 转换成 “abc”,将常量直接转换成字符串;即在编译后就是最终结果</li>
<li>拼接时有变量参与:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;a&quot;;</span><br><span class="line">String s2 = s1 + &quot;b&quot;</span><br><span class="line"></span><br><span class="line">相当于先创建一个临时的StringBuilder将s1中的&quot;a&quot;与&quot;b&quot;使用append()方法进行拼接,而后使用toString方法将这个临时的StringBuilder变量转换成String且返回值给到s2,即s2 的值最终为&quot;ab&quot;,而因为底层这一系列的额外操作,导致了String拼接字符串效率的低下. </span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="集合"><a class="header-anchor" href="#集合"></a>集合</h2>
<ol>
<li>一个可自动扩容的数组,相当于c++当中的vector</li>
<li>只可存储引用数据类型和包装类</li>
<li>集合内的元素都是同一种类型</li>
</ol>
<h3 id="ArrayList"><a class="header-anchor" href="#ArrayList"></a>ArrayList</h3>
<p>集合的元素的类型采用了泛型思想进行判定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建一个集合变量</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成员方法</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;     添加集合元素 —— 成功添加则返回<span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E,e)</span>;  移除特定元素——成功删除则返回<span class="string">&quot;true&quot;</span>?<span class="string">&quot;false&quot;</span>;</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;  移除所给出下标的元素</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E e)</span>; 修改下标处的元素</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>      获取下标处的元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;           获取长度</span><br></pre></td></tr></table></figure>
<h2 id="面向对象-进阶"><a class="header-anchor" href="#面向对象-进阶"></a>面向对象(进阶)</h2>
<h3 id="static关键字"><a class="header-anchor" href="#static关键字"></a>static关键字</h3>
<h4 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项:</h4>
<ol>
<li>该关键字定义的成员变量对于使用该包装类创建的每一个变量而言是共享的.</li>
<li>随着类的加载而加载,优先于对象的创建而被创建<br>
在堆内存当中有着一块单独的空间存放静态变量与静态方法——静态区</li>
<li>多用于测试类和工具类当中
<ol>
<li>测试类: 用来检测其他类是否书写正确的类</li>
<li>工具类: 用来完成某些特定方法的类,例如: 数学运算,逻辑运算;
<ol>
<li>类目见名知意</li>
<li>私有化构造方法&lt;这种类的对象是不具有意义的,因而将构造器进行私有化&gt;</li>
</ol>
</li>
</ol>
</li>
<li>JavaBean类很少使用
<ol>
<li>JavaBean类: 描述一类具有个性的事物的类</li>
</ol>
</li>
<li>静态方法中不存在this关键字(这一点导致了下一点,因为静态方法当中不存在this关键字,而访问其他非静态数据需要调用隐含的this关键字,因而静态方法只能访问静态的)</li>
<li>静态方法只能访问静态变量or方法</li>
<li>非静态方法可以访问所有(包括非静态和静态);</li>
</ol>
<p>由static存在一种特殊的设计模式——单例模式，即创建一个static对象用于程序运行。</p>
<h3 id="继承"><a class="header-anchor" href="#继承"></a>继承</h3>
<h4 id="注意事项-v2"><a class="header-anchor" href="#注意事项-v2"></a>注意事项:</h4>
<ol>
<li>使用继承,将多种类之间的相同共性提取出来,将提取出的共性特点抽象为父类的成员数据,而后被抽象的类作为该父类的子类去继承父类已有的特定.&lt;子类需要和父类有逻辑上的关联&gt;</li>
<li>Java当中的继承不可进行多继承;<br>
但存在多重继承.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B \rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></li>
</ol>
<h4 id="语法"><a class="header-anchor" href="#语法"></a>语法:</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> extend B &#123;&#125; </span><br></pre></td></tr></table></figure>
<h4 id="子类可继承的内容"><a class="header-anchor" href="#子类可继承的内容"></a>子类可继承的内容</h4>
<ol>
<li>构造器   私有和非私有均不继承</li>
<li>成员变量 私有和非私有均继承</li>
<li>成员方法 私有不可被继承;非私有可以被继承</li>
</ol>
<h4 id="成员方法的继承与调用"><a class="header-anchor" href="#成员方法的继承与调用"></a>成员方法的继承与调用</h4>
<ol>
<li>成员方法从最上层到最下层一一进行查找并调用</li>
<li>存在一个虚方法表,记录较为常用的成员方法
<ol>
<li>可被载入虚方法表的条件:
<ol>
<li>非private</li>
<li>非static</li>
<li>非final</li>
</ol>
</li>
<li>虚方法表会层层递增;例如存在继承关系: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B \rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 则A有一个虚方法表ATable,B在ATable的基础上添加自己的虚方法组成BTable;C在BTable基础上添加自己的虚方法组成CTable.</li>
</ol>
</li>
</ol>
<h4 id="继承中成员变量的访问特点"><a class="header-anchor" href="#继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h4>
<ol>
<li>就近原则:当查找某个变量时,先在局部范围内查找,再在本类成员变量位置查找,再到父类成员变量位置查找,逐级向上,直到找不到就报错;<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> extend A&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BShow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Bfunction&quot;</span>;</span><br><span class="line">    sout(name); <span class="comment">//&quot;Bfunction&quot;;</span></span><br><span class="line">    <span class="comment">/*当BShow存在name时,使用Bfunction;当BShow不存在name变量时,而B存在成员变量name&quot;B&quot;,则打印&quot;B&quot;;当只存在A当中的name&quot;A&quot;,则打印&quot;A&quot;. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="继承中成员方法的特点"><a class="header-anchor" href="#继承中成员方法的特点"></a>继承中成员方法的特点</h4>
<ol>
<li>就近原则:假设不使用super,直接调用函数名,因为存在隐含的this关键字,则是直接调用本类的方法,当在本类没找到时,则会向上查找父类是否存在.</li>
<li>方法重写:子类重写父类方法,因父类的方法不满足子类的需求,则需要对父类已经存在的方法进行重写.
<ul>
<li>方法重写的原理:
<ol>
<li>子类从父类继承而来的虚方法表当中的method()会被子类中重写的method()进行覆盖,则虚方法表内的方法就被重写了.</li>
</ol>
</li>
<li>重写注意事项:
<ol>
<li>重写的方法名,形参列表必须和父类保持一致</li>
<li>重写的方法,访问权限子类必须大于父类( 空着不写 &lt; protected &lt; public )</li>
<li>子类重写父类方法时,返回值类型子类必须小于等于父类</li>
<li>重写的方法尽量与父类完全一致</li>
<li>只有在虚方法表当中的方法才可以被重写:
<ol>
<li>私有方法不可被重写;</li>
<li>子类不能重写父类的静态方法</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> 重写注解</span><br><span class="line"><span class="number">1.</span> 放在重写的方法上,校验子类重写时语法是否正确</span><br><span class="line"><span class="number">2.</span> 加上注释,假如出现错误,则会有红色波浪线,表示存在语法错误</span><br><span class="line"><span class="number">3.</span> 加上后代码安全且优雅</span><br></pre></td></tr></table></figure>
<h4 id="继承中构造方法的访问特点"><a class="header-anchor" href="#继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h4>
<ol>
<li>父类的构造方法不会被子类继承</li>
<li>子类中所有构造方法默认先访问父类的无参构造，再执行自己
<ol>
<li>子类初始化可能需要使用父类的数据，假设父类没有初始化，则子类无法使用</li>
<li>子类初始化之前一定要调用父类的构造方法完成父类数据空间的初始化</li>
</ol>
</li>
<li>子类需要手动调用父类的有参构造</li>
</ol>
<h3 id="多态"><a class="header-anchor" href="#多态"></a>多态</h3>
<h4 id="定义"><a class="header-anchor" href="#定义"></a>定义</h4>
<ol>
<li>同类型对象表现出不同形态</li>
</ol>
<h4 id="表现形式"><a class="header-anchor" href="#表现形式"></a>表现形式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类类型  对象名称  = new 子类对象()</span><br></pre></td></tr></table></figure>
<h4 id="目的"><a class="header-anchor" href="#目的"></a>目的</h4>
<ol>
<li>使用父类类型作为形参,接收所有的子类对象,便于程序的拓展</li>
</ol>
<h4 id="优劣"><a class="header-anchor" href="#优劣"></a>优劣</h4>
<ol>
<li>优势:
<ol>
<li>多态形势下,右边对象可实现解耦合,便于拓展与维护</li>
<li>定义方法时,使用父类作为参数,可以接收所有子类对象</li>
</ol>
</li>
<li>劣势:
<ol>
<li>无法调用子类特有的功能</li>
<li></li>
</ol>
</li>
</ol>
<h2 id="包和final"><a class="header-anchor" href="#包和final"></a>包和final</h2>
<h3 id="包"><a class="header-anchor" href="#包"></a>包</h3>
<ol>
<li>就是文件夹,用来管理各种不同功能的JAVA类,方便后期代码维护</li>
<li>包名书写规则:
<ol>
<li>公司域名反写 + 包的作用,需要全部英文小写,见名知意</li>
</ol>
</li>
</ol>
<h3 id="使用其他类的规则"><a class="header-anchor" href="#使用其他类的规则"></a>使用其他类的规则</h3>
<ol>
<li>使用同一个包中的类时,不需要导包</li>
<li>使用java.lang包中的类时,不需要导包</li>
<li>其他情况均需要导包</li>
<li>如果同时使用两个包中的<mark>同名</mark>类,需要用<mark>全类名</mark></li>
</ol>
<h3 id="final关键字"><a class="header-anchor" href="#final关键字"></a>final关键字</h3>
<ol>
<li>final修饰的方法是最终方法,不可被重写</li>
<li>存在final关键字的类说明该类是最终类,不可被继承</li>
<li>final修饰变量,称为常量,只可以被赋值一次</li>
</ol>
<h3 id="常量-v2"><a class="header-anchor" href="#常量-v2"></a>常量</h3>
<ol>
<li>起名规则:
<ol>
<li>全部大写</li>
<li>多个单词:全部大写,单词间下划线隔开</li>
</ol>
</li>
<li>final修饰的变量
<ol>
<li>如果是基本数据类型:数据值不可改变</li>
<li>如果是引用数据类型:地址值不能发生改变,但对象内部的成员变量可以改变</li>
</ol>
</li>
</ol>
<h2 id="抽象类和抽象方法"><a class="header-anchor" href="#抽象类和抽象方法"></a>抽象类和抽象方法</h2>
<h3 id="抽象类"><a class="header-anchor" href="#抽象类"></a>抽象类</h3>
<ol>
<li>含有抽象方法的类叫做抽象类;但抽象类不一定有抽象方法</li>
<li>抽象类不能实例化,但抽象类可以有构造方法</li>
<li></li>
</ol>
<h3 id="抽象方法"><a class="header-anchor" href="#抽象方法"></a>抽象方法</h3>
<ol>
<li>使用关键字<mark>abstract</mark> 修饰的成员方法</li>
<li>抽象</li>
</ol>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<h3 id="接口的意义"><a class="header-anchor" href="#接口的意义"></a>接口的意义:</h3>
<ol>
<li>接口是一种规则,代表行为的抽象,一些事物普遍存在的但又不一定会相同的可以抽象为接口,再到具体的类中去实现接口&lt;例如:游泳接口,吃饭接口&gt;</li>
<li>当一个方法的参数是接口时,可以传递所有实现类的对象,接口多态(类似于子父类的关系)</li>
</ol>
<h3 id="适配器设计模式"><a class="header-anchor" href="#适配器设计模式"></a>适配器设计模式</h3>
<ol>
<li>找一个中间类,在接口和目的类中间&lt;中间类实现接口,目的类继承于中间类,可将这个中间类进行抽象,不让外界对该类进行实例化,中间类负责将接口的每一个方法进行空实现,当目的类需要接口当中的哪一个方法时,直接将从中间类那继承来的空方法进行重写即可.</li>
</ol>
<h2 id="内部类"><a class="header-anchor" href="#内部类"></a>内部类</h2>
<ol>
<li>在类内定义的类，称之为内部类</li>
<li>当一种事物是另一种事物的组成部分,且没有单独存在的必要性时,可以将其定义在类内;如ArrayList的迭代器,人的器官等.</li>
</ol>
<h3 id="分类"><a class="header-anchor" href="#分类"></a>分类</h3>
<ol>
<li>成员内部类
<ol>
<li>属于外部类的成员位置&lt;相当于定义了一个成员变量</li>
<li>
<pre><code>class A&#123;
  public class B&#123;&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 静态内部类</span><br><span class="line">   1. 只能访问外部类当中的静态变量和静态方法,如需要访问非静态则需要创建外部类的对象</span><br><span class="line">3. 局部内部类</span><br><span class="line">   1. 在方法体内定义一个类</span><br><span class="line">4. 匿名内部类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 匿名内部类</span><br><span class="line"></span><br><span class="line">存在抽象函数或接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Xxx&#123;</span><br><span class="line">	public abstract void xx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
</li>
</ol>
<p>则可以使用匿名内部类，不额外创建一个对象，但可以临时使用并且重写方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Xxx</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xx</span><span class="params">()</span>&#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-v3"><a class="header-anchor" href="#注意事项-v3"></a>注意事项</h3>
<ol>
<li>外部类和内部类是两个独立的字节码文件
<ol>
<li>
<pre><code>class Outer&#123;
  class Inner&#123;&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   2. 上代码产生的字节码文件为:</span><br><span class="line">      1. Outer.class</span><br><span class="line">      2. Outer&amp;Inner.class</span><br><span class="line">      3. 两个字节码中的方法加载到方法区当中;</span><br><span class="line">2. 在内部类的成员变量加载到堆内存当中时,会隐式加载一个外部类的this对象到堆内存当中,可以通过``` Outer.this ```,调用外部类的成员变量.</span><br><span class="line"></span><br><span class="line">3. 假设存在三个同名变量:</span><br><span class="line">   1. </span><br></pre></td></tr></table></figure>
  class Outer&#123;
    int a = 30;
    class Inner&#123;
      int a = 20;
      void show()&#123;
        int a = 10;

        sout(a);             //10
        sout(this.a);        //20
        sout(Outer.this.a);  //30
      &#125;
    &#125;
  &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 正则表达式</span><br><span class="line"></span><br><span class="line">### 普通字符</span><br><span class="line"></span><br><span class="line">1. [abc]  匹配[...]内的所有字符</span><br><span class="line">2. [^abc] 匹配除了[...]内的所有字符</span><br><span class="line">3. [a-z]  匹配a-z区间内的字符</span><br><span class="line">4. .      匹配除了换行符(\n \r)外的任意单个字符,相当于[^\n\r]</span><br><span class="line">5. [\s\S] 匹配所有. \s是匹配所有空白符,包括换行,\S匹配所有非空白符,不包括换行</span><br><span class="line">6. \w     匹配字母,数字,下划线</span><br><span class="line">7. \d     匹配任意一个阿拉伯数字(0-9).</span><br><span class="line"></span><br><span class="line">### 非打印字符</span><br><span class="line">1. \cx</span><br><span class="line">2. \f</span><br><span class="line">3. \n</span><br><span class="line">4. \r</span><br><span class="line">5. \s</span><br><span class="line">6. \S</span><br><span class="line">7. \t</span><br><span class="line">8. \v</span><br><span class="line"></span><br><span class="line">### 特殊字符</span><br><span class="line">特别字符	描述</span><br><span class="line">$	匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &#x27;\n&#x27; 或 &#x27;\r&#x27;。要匹配 $ 字符本身，请使用 \$。</span><br><span class="line">( )	标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。</span><br><span class="line">*	匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。</span><br><span class="line">+	匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</span><br><span class="line">.	匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。</span><br><span class="line">[	标记一个中括号表达式的开始。要匹配 [，请使用 \[。</span><br><span class="line">?	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</span><br><span class="line">\	将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， &#x27;n&#x27; 匹配字符 &#x27;n&#x27;。&#x27;\n&#x27; 匹配换行符。序列 &#x27;\\&#x27; 匹配 &quot;\&quot;，而 &#x27;\(&#x27; 则匹配 &quot;(&quot;。</span><br><span class="line">^	匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。</span><br><span class="line">&#123;	标记限定符表达式的开始。要匹配 &#123;，请使用 \&#123;。</span><br><span class="line">|	指明两项之间的一个选择。要匹配 |，请使用 \|。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 集合体系结构</span><br><span class="line">### 类型</span><br><span class="line">1. 单列集合</span><br><span class="line">2. 双列结合</span><br><span class="line">### Collection 单列集合祖宗接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### List 有序,可重复,有索引</span><br><span class="line">1. ArrayList</span><br><span class="line">2. LinkedList</span><br><span class="line">#### Set 无序,不重复,无索引</span><br><span class="line">1. HashSet</span><br><span class="line">2. TreeSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Stream流</span><br><span class="line"></span><br><span class="line">### 常见的中间方法</span><br><span class="line"></span><br><span class="line">|                    名称                    |                          说明                          |</span><br><span class="line">| :----------------------------------------: | :----------------------------------------------------: |</span><br><span class="line">|   Stream&lt;T&gt; filter(Predicate predicate)    |                  对流中的数据进行过滤                  |</span><br><span class="line">|       Stream&lt;T&gt; limit(long maxSize)        |                  获取前maxSize个元素                   |</span><br><span class="line">|           Stream&lt;T&gt; skip(long n)           |    跳过前n个数的数据，返回由该流的剩余元素组成的流     |</span><br><span class="line">| static Stream&lt;T&gt; concat(Stream a, Streamb) |                 合并a和b两个流为一个流                 |</span><br><span class="line">|            Stream&lt;T&gt; distinct()            |    返回进行去重后的流（依赖hashCode和equals方法 ）     |</span><br><span class="line">|       Stream&lt;T&gt; map(Function mapper)       |                   转换流中的数据类型                   |</span><br><span class="line">|             Stream&lt;T&gt; sorted()             |       返回由此流的元素组成的流，根据自然顺序排序       |</span><br><span class="line">|  Stream&lt;T&gt; sorted (Comparatorcomparator)   | 返回由该流的元素组成的流，根据提供的Comparator进行排序 |</span><br><span class="line"></span><br><span class="line">### 注意事项</span><br><span class="line">1. 使用链式法则进行书写，规避stream潜在的终结导致程序出现错误。</span><br><span class="line">2. 与lambda表达式相结合,简化代码.</span><br><span class="line"></span><br><span class="line">### 积累，常用的一些方法</span><br><span class="line"></span><br><span class="line">#### 集合求和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<p>/** 采取stream流的方式，使用mapToInt方法返回一个Instream对象后再调用Instream类内的sum方法*/</p>
<p>public main(){<br>
ArrayList<Integer> list = new ArrayList&lt;&gt;();</p>
<pre><code>Collectiond.addAll(list,1,2,3,4,5,6,7);

Integer totalNum = list.stream().mapToInt(Interger::intValue).sum();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 方法引用</span><br><span class="line"></span><br><span class="line">1. 将定义好的方法体作为函数式接口的一种实现,引用于匿名内部类和lambda表达式当中,进一步简化代码.</span><br><span class="line"></span><br><span class="line">### 注意事项</span><br><span class="line">1. 被引用处是函数式接口</span><br><span class="line">2. 被引用的方法已存在</span><br><span class="line">3. 被引用的方法形参和返回值需要和抽象函数保持一致</span><br><span class="line">4. 被引用的方法功能满足需求</span><br><span class="line"></span><br><span class="line">### 分类</span><br><span class="line">1. 引用静态方法</span><br><span class="line">   1. ```java</span><br><span class="line">      格式:</span><br><span class="line">      类名::静态方法</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>引用成员方法
<ol>
<li>
<pre><code class="language-java">格式:
对象::成员方法

其他类  其他类对象::方法名

(引用处不能是静态方法)
本类    this::方法名
父类    super::方法名
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 引用构造方法</span><br><span class="line">   1. ```java</span><br><span class="line">      格式:</span><br><span class="line">      类名::new</span><br><span class="line">      创建类对象</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li>其他调用方式
<ol>
<li><strong>类名</strong>引用成员方法
<ol>
<li>
<pre><code class="language-java"> 格式:
 类名::成员方法
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   2. 特殊注意事项:被引用的方法的形参需要和抽象方法的第二个形参到最后一个形参保持一致,同时返回值也需保持一致.</span><br><span class="line">      1. 第一个参数:表示被引用方法的调用者,决定了可以引用哪些类中的方法</span><br><span class="line">         在Stream流当中,第一个参数一般表示流里面的每一个数据</span><br><span class="line">         假设流里面的数据是字符串,那么使用这种方法进行方法引用,只能引用String这个类中的方法</span><br><span class="line">      2. 第二个参数到最后一个参数:根被引用方法的形参列表保持一致</span><br><span class="line">         如果没有第二个参数,声明被用于的方法需要是一个无参的成员方法</span><br><span class="line"></span><br><span class="line">   3. 局限:只可以引用抽象方法第一个形参对应的类内的成员方法</span><br><span class="line">2. 引用**数组的构造方法**</span><br><span class="line">   1. ```java</span><br><span class="line">       格式:</span><br><span class="line">       数据类型[]::new</span><br><span class="line">         </span><br><span class="line">       示例:</span><br><span class="line">       ArrayList&lt;Integer&gt; list = new ArrayList();</span><br><span class="line">       Collection.addAll(list,1,2,3,4);</span><br><span class="line">         </span><br><span class="line">       Integer[] arr2 = list.stream().toArray(Integer[]::new);</span><br><span class="line">       sout(Array.toString(arr2));</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法引用练习</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span>()&#123;</span><br><span class="line">   main()&#123;</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      Collection.addAll(list,<span class="string">&quot;zhansan-10&quot;</span>,<span class="string">&quot;lisi-15&quot;</span>,<span class="string">&quot;wangwu-15&quot;</span>,<span class="string">&quot;zhaoliu-20&quot;</span>,<span class="string">&quot;guaqi-25&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 涉及类型转换,需要使用map方法 </span></span><br><span class="line"><span class="comment">       * map方法执行完毕后,流内的数据已经是Student对象的形式.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Student[] stuArr = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      sout(Array.toString(stuArr));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Student&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      list1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhansan&quot;</span>,<span class="number">10</span>));</span><br><span class="line">      list1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">      list1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>,<span class="number">20</span>));</span><br><span class="line">      list1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">25</span>));</span><br><span class="line">      list1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;guaqi&quot;</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">      String[] stuStrArr = list1.stream().map(Student::setName).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      sout(stuStrArr);</span><br><span class="line"></span><br><span class="line">      String[] modifyStuStrArr = list1.stream().map(Student::splicingStr).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      sout(modifyStuStrArr);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>()&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   Student()&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   Student(String name,<span class="type">int</span> age)&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   Student(String str)&#123;</span><br><span class="line">      String[] arr = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.name = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">this</span>.age = Integer.parseINt(arr[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="built_in">this</span>.name = scanner.nextLine();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">splicingStr</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;-&quot;</span> + Integer.toString(<span class="built_in">this</span>.age); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a class="header-anchor" href="#异常"></a>异常</h2>
<ol>
<li>Throwable
<ol>
<li>Error 实际开发人员无需使用</li>
<li>Exception:代表程序可能出现的问题,通常用Exception以及他的子类来封装程序出现的问题
<ol>
<li>RuntimeException:RuntimeException及其子类,运行时出现异常,编译阶段不会出现异常提醒</li>
<li>其他异常:编译阶段出现异常提醒(如:日期解析异常)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="作用"><a class="header-anchor" href="#作用"></a>作用</h3>
<ol>
<li>查询bug的关键参考信息</li>
<li>作为方法内部的一种特殊返回值,以便通知调用者底层的执行情况</li>
</ol>
<h3 id="捕获异常"><a class="header-anchor" href="#捕获异常"></a>捕获异常</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当代码出现异常时,不会使得程序中断,可以继续程序的运行</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   可能出现异常的代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">   异常的处理代码;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionOptions</span>&#123;</span><br><span class="line">   main()&#123;</span><br><span class="line">      <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         sout(arr[<span class="number">10</span>]);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">         sout(<span class="string">&quot;索引越界异常&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sout(<span class="string">&quot;是否执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   main()&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();      <span class="comment">//返回此throwable的详细信息字符串</span></span><br><span class="line">         sout(message);</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> e.toString();        <span class="comment">//返回可抛出的简短描述</span></span><br><span class="line">         sout(str);</span><br><span class="line"></span><br><span class="line">         e.printStackTrace(); <span class="comment">//把异常的错误信息输出在控制台;只打印信息,不会终止程序的运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意事项:
<ol>
<li>如果有try语句内含有多种潜在异常,则需要每一种异常都写一个catch去捕获</li>
<li>如果要捕获的异常存在父子关系,则父类需要写在子类之下,以防止多态使得子类会被提前匹配,导致子类的处理方案不能执行.</li>
<li>try内语句的执行一直到遇到第一个异常跳转到catch内执行catch内的语句或没有异常顺利全部执行.</li>
<li>如果try内出现异常的语句没有对应的catch语句,则是交给Java的虚拟机执行虚拟机的异常解决方案</li>
</ol>
</li>
</ol>
<h3 id="抛出处理"><a class="header-anchor" href="#抛出处理"></a>抛出处理</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> <span class="keyword">throws</span> 异常名<span class="number">1</span>,异常名<span class="number">2.</span>..&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XxxException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>分类:
<ol>
<li>throws: 写在方法定义处,表示声明一个异常,告诉调用者使用本方法可能会有哪些异常</li>
<li>throw:  写在方法内,结束方法(相当于return) 手动抛出异常对象,交给调用者,throw语句后面的代码不会执行.</li>
</ol>
</li>
</ol>
<h3 id="自定义异常"><a class="header-anchor" href="#自定义异常"></a>自定义异常</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行时: RuntimeException </span><br><span class="line">编译时: Exception</span><br><span class="line">       要是编译时期的异常需要在方法定义时加上<span class="keyword">throws</span></span><br><span class="line">       如:</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(...)</span> <span class="keyword">throws</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameOutOfRangeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NameOutOfRangeException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NameOutOfRangeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">      <span class="built_in">super</span>(message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeOutOfRangeExcption</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AgeOutOfRangeExcption</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AgeOutOfRangeExcption</span><span class="params">(String message)</span>&#123;</span><br><span class="line">      <span class="built_in">super</span>(message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="File"><a class="header-anchor" href="#File"></a>File</h2>
<h3 id="常见构造方法"><a class="header-anchor" href="#常见构造方法"></a>常见构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">实际效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code> public File(String pathName)</code></td>
<td style="text-align:center">根据文件路径创建文件对象</td>
</tr>
<tr>
<td style="text-align:center"><code>public File(String parent,String child)</code></td>
<td style="text-align:center">根据父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td style="text-align:center"><code>public File(File parent,String child)</code></td>
<td style="text-align:center">根据父路径对应文件对象和子路径对应文件对象创建文件对象</td>
</tr>
</tbody>
</table>
<h3 id="父-子级路径概念"><a class="header-anchor" href="#父-子级路径概念"></a>父/子级路径概念</h3>
<p>如有: E:\Desktop\temporary\a.txt</p>
<ol>
<li>
<p>父级路径:文件名之前的所有路径,E:\Desktop\temporary 是父级路径</p>
</li>
<li>
<p>子级路径:文件名,a.txt是子级路径</p>
</li>
</ol>
<h3 id="File-的判断和获取"><a class="header-anchor" href="#File-的判断和获取"></a>File 的判断和获取</h3>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public boolean isDirectory()</code></td>
<td style="text-align:left">判断此路径名表示的 File 是否为文件夹</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean isFile()</code></td>
<td style="text-align:left">判断此路径名表示的 File 是否为文件</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean exists()</code></td>
<td style="text-align:left">判断此路径名表示的 File 是否存在</td>
</tr>
<tr>
<td style="text-align:left"><code>public long length()</code></td>
<td style="text-align:left">返回文件的大小（字节数量）</td>
</tr>
<tr>
<td style="text-align:left"><code>public String getAbsolutePath()</code></td>
<td style="text-align:left">返回文件的绝对路径</td>
</tr>
<tr>
<td style="text-align:left"><code>public String getPath()</code></td>
<td style="text-align:left">返回定义文件时使用的路径</td>
</tr>
<tr>
<td style="text-align:left"><code>public String getName()</code></td>
<td style="text-align:left">返回文件的名称，带后缀</td>
</tr>
<tr>
<td style="text-align:left"><code>public long lastModified()</code></td>
<td style="text-align:left">返回文件的最后修改时间（时间毫秒值）</td>
</tr>
</tbody>
</table>
<h3 id="File-的创建和删除"><a class="header-anchor" href="#File-的创建和删除"></a>File 的创建和删除</h3>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public boolean createNewFile()</code></td>
<td style="text-align:left">创建一个新的空的文件</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean mkdir()</code></td>
<td style="text-align:left">创建单级文件夹</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean mkdirs()</code></td>
<td style="text-align:left">创建多级文件夹</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean delete()</code></td>
<td style="text-align:left">删除文件、空文件夹（删了就没了，不会放入回收站）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">   main(String[] args)&#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\Xxx.type&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** creatNewFile()、mkdir()、mkdirs()方法      */</span></span><br><span class="line">      <span class="comment">// 1. 当要创建的文件不存在时,返回true;否则false</span></span><br><span class="line">      <span class="comment">// 2. 如果父级路径是不存在的,那方法会抛出异常IOException</span></span><br><span class="line">      <span class="comment">// 3. 创建的文件如果没有文件格式后缀,则创建一个没有后缀的文件,而不是创建一个文件夹;但是这样创建文件,会导致想要创建同名文件夹失败,因为windows系统下,资源路径唯一,不区分文件或文件夹,因而假如创建了无后缀文件: E://Test//test,那么使用方法mkdir()时,则返回为false,因为检测时检测到E://Test//test时发现已存在.</span></span><br><span class="line"></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> file.creatNewFile(); </span><br><span class="line"></span><br><span class="line">      sout(result)   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//再次调用时,文件已存在,则返回false</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> file.creatNewFile(); </span><br><span class="line">      sout(result)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//mkdir()使用不多</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//mkdirs()方法使用更多,因为在mkdirs()方法内部有检测机制,当检测是单级文件夹时,会调用mkdir();</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** delete()方法*/</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1. 如果是文件直接删除</span></span><br><span class="line"><span class="comment">       2. 如果是文件夹，空文件夹删除成功;如果是非空的文件夹,删除失败</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="File-的获取和遍历"><a class="header-anchor" href="#File-的获取和遍历"></a>File 的获取和遍历</h3>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public static File[] listRoots()</code></td>
<td style="text-align:left">列出可用的文件系统根</td>
</tr>
<tr>
<td style="text-align:left"><code>public String[] list()</code></td>
<td style="text-align:left">获取当前该路径下的所有内容</td>
</tr>
<tr>
<td style="text-align:left"><code>public String[] list(FilenameFilter filter)</code></td>
<td style="text-align:left">利用文件名过滤器获取当前该路径下的所有内容（打印名称）</td>
</tr>
<tr>
<td style="text-align:left"><code>public File[] listFiles()</code></td>
<td style="text-align:left">获取当前路径下所有内容（获取文件夹内所有的文件）</td>
</tr>
<tr>
<td style="text-align:left"><code>public File[] listFiles(FileFilter filter)</code></td>
<td style="text-align:left">利用文件名过滤器获取当前该路径下的所有内容（打印路径）</td>
</tr>
<tr>
<td style="text-align:left"><code>public File[] listFiles(FilenameFilter filter)</code></td>
<td style="text-align:left">利用文件名过滤器获取当前该路径下的所有内容（打印路径）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">   main(String[] args)&#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">fileDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\Xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">      File[] files = fileDir.listFiles();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">         <span class="comment">/**file表示files内的每一个文件(包括为隐藏和隐藏的) */</span></span><br><span class="line">         <span class="comment">// 1. 当调用者File表示的路径不支持,返回null</span></span><br><span class="line">         <span class="comment">// 2. 当调用者File表示的路径是文件时,返回null</span></span><br><span class="line">         <span class="comment">// 3. 当调用者File表示的路径是一个空文件夹时,返回长度为0的数组</span></span><br><span class="line">         <span class="comment">// 4. 当调用者File表示的路径是一个有内容文件夹时,将里面所有文件和文件夹路径存入File数组中并返回</span></span><br><span class="line">         <span class="comment">// 5. 当调用者File表示的路径是一个有隐藏文件的文件夹时,将里面所有文件和文件夹路径存入File数组中并返回,包括隐藏文件</span></span><br><span class="line">         <span class="comment">// 6. 当调用者File表示的路径是需要权限才可访问的文件夹时,返回null</span></span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO流"><a class="header-anchor" href="#IO流"></a>IO流</h2>
<p>程序/内存 读写硬盘里面的内容<br>
存储和读取数据的一种解决方案</p>
<ol>
<li>流的方向
<ol>
<li>输入流(Input)</li>
<li>输出流(Output)</li>
</ol>
</li>
<li>操作的文件类型
<ol>
<li>字节流——可操作所有文件</li>
<li>字符流——只可以操作纯文本文件(txt/md/xml/lrc)</li>
</ol>
</li>
<li>try…catch异常处理
<ol>
<li>
<pre><code class="language-java">// 为了防止因为异常抛出导致流未关闭,可以将关闭的语句放在finally语块中,除非JVM退出,否则finally语块中的语句一定会在最后被执行.
File file = new File(&quot;xxx.txt&quot;)
try&#123;
   FileOutputStream fos = new FileOutputStream(file);

   fos.write(xx);
&#125;catch(IOException e)&#123;
   e.printStackTrace();
&#125;finally&#123;
   fos.close();
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```mermaid</span><br><span class="line">stateDiagram</span><br><span class="line"></span><br><span class="line">IO流体系 --&gt; 字节流 </span><br><span class="line">IO流体系 --&gt; 字符流</span><br><span class="line"></span><br><span class="line">字节流 --&gt;InputStream(字节输入流)</span><br><span class="line">字节流	--&gt;OutputStream(字节输出流)</span><br><span class="line"></span><br><span class="line">字符流	--&gt;Reader(字符输入流)</span><br><span class="line">字符流	--&gt;Writer(字符输出流)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="字节流"><a class="header-anchor" href="#字节流"></a>字节流</h3>
<h4 id="InputStream"><a class="header-anchor" href="#InputStream"></a>InputStream</h4>
<ol>
<li>FileInputStream</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">   main(String[] args)&#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\Xxx.type&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//需要一个len接收每次读取的字节个数,以便后续转换字符串</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.read(bytes); <span class="comment">//读了多少个元素</span></span><br><span class="line">      sout(len);</span><br><span class="line">      <span class="comment">//将字节数组转换成字符串并进行打印,由于不能保证源文件的数据量刚好取模与字节数组的大小,所以需要根据每次读取的len长度来判断该次转换需要转换到字节数组的第几位,以防止多读取到错误信息.</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len);</span><br><span class="line">      sout(str);</span><br><span class="line">      fis.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="OutputStream-抽象类"><a class="header-anchor" href="#OutputStream-抽象类"></a>OutputStream 抽象类</h4>
<ol>
<li>FileOutputStream  继承OutputStream的子类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">   main(String[] args)&#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\Xxx.type&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建输出流对象fos,并用文件File名初始化;</span></span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">      <span class="comment">//内存将数据写入硬盘中</span></span><br><span class="line">      fos.write(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      fos.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符集"><a class="header-anchor" href="#字符集"></a>字符集</h3>
<ol>
<li>
<p><code>ASCII</code></p>
</li>
<li>
<p>GB2312-80</p>
</li>
<li>
<p><code>GBK</code></p>
</li>
<li>
<p><code>Unicode</code>—&gt;Uicode的一种编码方式: UTF-8编码规则:可变长度,用1-4个字节保存</p>
</li>
<li>
<p>UTF-8:</p>
<ol>
<li>
<p>编码方式:</p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>字符类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong>xxxxxxx</td>
<td>ASCII</td>
</tr>
<tr>
<td><strong>110</strong>xxxxx <strong>10</strong>xxxxxx</td>
<td></td>
</tr>
<tr>
<td><strong>1110</strong>xxxx <strong>10</strong>xxxxxx <strong>10</strong>xxxxxx</td>
<td>简体中文</td>
</tr>
<tr>
<td><strong>11110</strong>xxx <strong>10</strong>xxxxxx <strong>10</strong>xxxxxx</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
<li>
<p>乱码原因:</p>
<ol>
<li>读取数据时未读取完整</li>
<li>编码和解码方式不统一</li>
</ol>
</li>
</ol>
<h3 id="字符流"><a class="header-anchor" href="#字符流"></a>字符流</h3>
<ol>
<li>$ 字符流 = 字节流 + 字符集 $</li>
</ol>
<h4 id="Reader"><a class="header-anchor" href="#Reader"></a>Reader</h4>
<ol>
<li>XxxReader Xxx的读取字符流</li>
<li>FileReader 继承于Reader的字符输入流</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public FileReader(File file)</code></td>
<td style="text-align:left">创建字符输入流关联本地文件</td>
</tr>
<tr>
<td style="text-align:left"><code>public FileReader(String pathname)</code></td>
<td style="text-align:left">创建字符输入流关联本地文件</td>
</tr>
<tr>
<td style="text-align:left"><code>public int read()</code></td>
<td style="text-align:left">读取数据，读到末尾返回-1</td>
</tr>
<tr>
<td style="text-align:left"><code>public int read(char[] buffer)</code></td>
<td style="text-align:left">读取多个数据，读到末尾返回-1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>FileReader会按照编译器默认的编码解码方式进行读取，所以就算可以一次性读多个字节，但是遇到解码译码方式不对等的情况下依旧会产生乱码，这个时候可以利用 Charset 的<code>forName</code>方法指定FileReader的解码方式.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\HNU\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sout((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Writer"><a class="header-anchor" href="#Writer"></a>Writer</h4>
<ol>
<li>XxxWriter Xxx的写入字符流</li>
<li>FileWriter 继承于Writer的字符输出流</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建数据源对象</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(X:\\xxx);</span><br><span class="line">      <span class="comment">//创建目的源对象</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(X:\\xx);</span><br><span class="line"></span><br><span class="line">      copyDir(src,dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyDir</span><span class="params">(File src,File dest)</span>&#123;</span><br><span class="line"></span><br><span class="line">      dest.mkdirs();</span><br><span class="line">      <span class="comment">//递归进行文件夹的探底，没有遇到文件夹即可触底反弹</span></span><br><span class="line"></span><br><span class="line">      File[] files = src.listFiles();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">         <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="comment">//如果是文件，则进行拷贝</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,file.getName()));</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bytes)) != <span class="number">1</span>)&#123;</span><br><span class="line">               fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹，则递归</span></span><br><span class="line">            copyDir(file,<span class="keyword">new</span> <span class="title class_">File</span>(dest,file.getName()));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO流中的高级流"><a class="header-anchor" href="#IO流中的高级流"></a>IO流中的高级流</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line"></span><br><span class="line">IO流体系 --&gt; 字节流 </span><br><span class="line">IO流体系 --&gt; 字符流</span><br><span class="line"></span><br><span class="line">字节流 --&gt;InputStream\n(字节输入流)</span><br><span class="line">字节流	--&gt;OutputStream\n(字节输出流)</span><br><span class="line"></span><br><span class="line">字符流	--&gt;Reader\n(字符输入流)</span><br><span class="line">字符流	--&gt;Writer\n(字符输出流)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line"></span><br><span class="line">BufferedInputStream\n(字节缓冲输入流)</span><br><span class="line"></span><br><span class="line">BufferedOutputStream\n(字节缓冲输出流)</span><br><span class="line"></span><br><span class="line">BufferedReader\n(字符缓冲输入流)</span><br><span class="line"></span><br><span class="line">BufferedWriter\n(字符缓冲输出流)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="缓冲流"><a class="header-anchor" href="#缓冲流"></a>缓冲流</h3>
<blockquote>
<p>将基本流进行包装作为高级流,提高读写数据的性能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line"></span><br><span class="line">缓冲流 --&gt; 字节缓冲流</span><br><span class="line">缓冲流 --&gt; 字符缓冲流</span><br><span class="line"></span><br><span class="line">字节缓冲流 --&gt; BufferedInputStream\n(字节缓冲输入流)</span><br><span class="line">字节缓冲流 --&gt; BufferedOutputStream\n(字节缓冲输出流)</span><br><span class="line"></span><br><span class="line">字符缓冲流 --&gt; BufferedReader\n(字符缓冲输入流)</span><br><span class="line">字符缓冲流 --&gt; BufferedWriter\n(字符缓冲输出流)</span><br></pre></td></tr></table></figure>
<h4 id="BufferedInputStream-BufferedOutputStream"><a class="header-anchor" href="#BufferedInputStream-BufferedOutputStream"></a><em>BufferedInputStream</em> &amp; <em>BufferedOutputStream</em></h4>
<ol>
<li>缓冲区是一个大小为8192的字节数组</li>
<li>缓冲流传入一个基本流作为操作数，并且会在缓冲流内部对传入的基本流的生命周期进行管理。</li>
<li>缓冲流拷贝文件比基本流高效</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xx\\xx.txt&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;xx\\xxx.txt&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">node1[[数据源]] --- node2[基本流 &amp; 缓冲输入流] --&gt; node3[[缓冲区1]] ---node6[[缓冲区2]] --- node4[缓冲输出流 &amp; 基本流] --&gt; node5[[目的处]]</span><br><span class="line"></span><br><span class="line">node1:::Tier1</span><br><span class="line">node3:::Tier1</span><br><span class="line">node5:::Tier1</span><br><span class="line">node6:::Tier1</span><br><span class="line"></span><br><span class="line">node2:::Tier2</span><br><span class="line">node4:::Tier2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classDef Tier1 fill:black,stroke:green,stroke-width:3px </span><br><span class="line">classDef Tier2 fill:blue,stroke:lightblue,stroke-width:3px</span><br></pre></td></tr></table></figure>
<h4 id="BufferedReader-BufferedWriter"><a class="header-anchor" href="#BufferedReader-BufferedWriter"></a><em>BufferedReader</em> &amp; BufferedWriter</h4>
<ol>
<li>两个重要的方法</li>
</ol>
<p>​</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public String readLine()</code></td>
<td style="text-align:center">读取一行数据，直到文件末尾返回null</td>
</tr>
<tr>
<td><code>public void newLine()</code></td>
<td style="text-align:center">跨平台的换行(应该和JVM有关)</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ol start="2">
<li><strong>输入流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;xx\\xx.txt&quot;</span>));</span><br><span class="line">    	<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine(); <span class="comment">//换行符为终止符,但不读入换行符</span></span><br><span class="line">    	sout(line);</span><br><span class="line">    	</span><br><span class="line">    	<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">    	sout(line);</span><br><span class="line">    	</span><br><span class="line">    	br.close();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>输出流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;xx.xx.txt&quot;</span>),<span class="literal">true</span>);</span><br><span class="line">    	</span><br><span class="line">    	bw.write(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    	bw.newLine();</span><br><span class="line">    	</span><br><span class="line">    	bw.write(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    	bw.newLine();</span><br><span class="line">    	</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>缓冲流效率高的原因：
<ol>
<li>缓冲流带有一个字符缓冲区 8位，16k</li>
</ol>
</li>
</ol>
<h3 id="转换流"><a class="header-anchor" href="#转换流"></a>转换流</h3>
<blockquote>
<p>字符流和字节流之间的桥梁，将字符流和字节流进行互相转换，进而更好的对外部文件进行操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">node1[[数据源]] --- node2[基本流 &amp; 转换流] --&gt; node3[[缓冲区1]] ---node6[[缓冲区2]] --- node4[转换流 &amp; 基本流] --&gt; node5[[目的处]]</span><br><span class="line"></span><br><span class="line">node1:::Tier1</span><br><span class="line">node3:::Tier1</span><br><span class="line">node5:::Tier1</span><br><span class="line">node6:::Tier1</span><br><span class="line"></span><br><span class="line">node2:::Tier2</span><br><span class="line">node4:::Tier2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classDef Tier1 fill:black,stroke:green,stroke-width:3px </span><br><span class="line">classDef Tier2 fill:blue,stroke:lightblue,stroke-width:3px</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//已被替代</span></span><br><span class="line"><span class="comment">//        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;xx.xxxxx&quot;),&quot;GBK&quot;);//指定读取时使用的编码方式</span></span><br><span class="line"><span class="comment">//        int chr;</span></span><br><span class="line"><span class="comment">//        while((ch = isr.read())!= -1)&#123;</span></span><br><span class="line"><span class="comment">//            sout((char)chr);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;xx.xxx.txt&quot;</span>,Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="type">int</span> chr;</span><br><span class="line">		<span class="keyword">while</span>((ch = isr.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">		sout((<span class="type">char</span>)chr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化流-反序列化流"><a class="header-anchor" href="#序列化流-反序列化流"></a><em>序列化流</em> &amp; <em>反序列化流</em></h3>
<blockquote>
<p>将Java当中的对象按照一定规范存储到本地文件当中；</p>
</blockquote>
<ol>
<li>需要让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi>B</mi><mi>e</mi><mi>a</mi><mi>n</mi><mtext>类</mtext></mrow><annotation encoding="application/x-tex">JavaBean类</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">e</span><span class="mord mathnormal">an</span><span class="mord cjk_fallback">类</span></span></span></span>实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Serializable()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>方法，标记型接口。实现该接口表明该类可以被序列化。</li>
<li>序列化对象需要固定序列化ID，防止之后修改类时无法进行反序列读取操作。</li>
<li>序列化到文件中的数据不可修改，一旦修改无法进度反序列化读取</li>
<li>使用关键字<code>transient</code>修饰变量，表明该变量不参与序列化</li>
</ol>
<h4 id="序列化流-对象操作输入流的方法"><a class="header-anchor" href="#序列化流-对象操作输入流的方法"></a>序列化流 / 对象操作输入流的方法</h4>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public ObjectOutputStream(OutputStream out)</code></td>
<td>将基本流包装成高级流</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>成员方法</strong></td>
<td>说明</td>
</tr>
<tr>
<td><code>public final void writeObject(Object obj)</code></td>
<td>将对象序列化写入到文件当中</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="反序列化流-对象操作输入流的方法"><a class="header-anchor" href="#反序列化流-对象操作输入流的方法"></a>反序列化流 / 对象操作输入流的方法</h4>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public ObjectInputStream(OutputStream out)</code></td>
<td>将基本流包装成高级流</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>成员方法</strong></td>
<td>说明</td>
</tr>
<tr>
<td><code>public Object readObject()</code></td>
<td>把序列化到本地文件的对象读取到程序中</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="打印流"><a class="header-anchor" href="#打印流"></a><em>打印流</em></h3>
<blockquote>
<p>只可写，不可读</p>
<p><code>PrintStream</code> 和 <code>PrintWriter</code> 两个类</p>
</blockquote>
<blockquote>
<p>在System类文件中有一个特殊的打印输出流，<code>PrintStream out</code>也就是常用的<code>sout</code></p>
</blockquote>
<p>特点：</p>
<ol>
<li>打印文件只操作文件目的地，不操作数据源</li>
<li>字节打印流：默认自动刷新，特有的<code>println()</code>自动换行</li>
<li>字符打印流：自动刷新需要开启，特有的<code>println()</code>自动换行</li>
<li>特有的写出方法可实现，数据原样写出</li>
<li>特有的写出方法可实现自动刷新，自动换行</li>
</ol>
<h4 id="字节打印流"><a class="header-anchor" href="#字节打印流"></a><em>字节打印流</em></h4>
<p>字节打印流的方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><mark><code>public PrintStream(OutputStream/String)</code></mark></td>
<td>关联字节输出流/文件/文件路径</td>
</tr>
<tr>
<td><mark><code>public PrintStream(String fileName,Charset charset)</code></mark></td>
<td>指定字符编码</td>
</tr>
<tr>
<td><code>public PrintStream(OutputStream out,boolean autoFlush)</code></td>
<td>自动刷新</td>
</tr>
<tr>
<td><code>public PrintStream(OutputStream out,booklean autoFlush,String encoding)</code></td>
<td>指定字符编码自动刷新</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>成员方法</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td><code>public void write(int b)</code></td>
<td>常规方法：规则与之前一样，将指定字节写粗</td>
</tr>
<tr>
<td><code>public void println(Xxx xx)</code></td>
<td>特有方法：打印任意数据，自动刷新，自动换行</td>
</tr>
<tr>
<td><code>public void print(Xxx xx)</code></td>
<td>特有方法：打印任意数据，不换行</td>
</tr>
<tr>
<td><code>public void print(String format,Object .... args)</code></td>
<td>特有方法：带有占位符的打印语句，不换行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="压缩流和解压缩流"><a class="header-anchor" href="#压缩流和解压缩流"></a><em>压缩流和解压缩流</em></h3>
<blockquote>
<p>ZipInputStream</p>
</blockquote>
<ol>
<li>
<p>字节流的一种</p>
</li>
<li>
<p>java只能识别zip压缩文件</p>
</li>
</ol>
<h4 id="解压缩流-ZipInputStream"><a class="header-anchor" href="#解压缩流-ZipInputStream"></a><em>解压缩流</em> &amp; <em>ZipInputStream</em></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\xx.zip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deZip</span><span class="params">(File src,File dest)</span> <span class="keyword">throw</span> FileNotFoundException&#123;</span><br><span class="line">    	<span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src));</span><br><span class="line">    	<span class="comment">//获取每一个压缩包内的zipentry对象</span></span><br><span class="line">    	</span><br><span class="line">    	ZipEntry entry;     	<span class="comment">//表示当前从压缩包当中获取到的文件或文件夹</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>((<span class="type">e</span> <span class="variable">ntry</span> <span class="operator">=</span> zis.getNextEntry()) != <span class="literal">null</span>) </span><br><span class="line">    		sout(entry);</span><br><span class="line">    		<span class="keyword">if</span>(entry.isDirectory())&#123;</span><br><span class="line">    		</span><br><span class="line">    			<span class="comment">//假如是一个文件夹，则需要在目的地文件夹里创建一个同名的文件夹</span></span><br><span class="line">    			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toString());</span><br><span class="line">    			file.mkdirs();</span><br><span class="line">    			</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			<span class="comment">//</span></span><br><span class="line">    			FileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toString()));</span><br><span class="line">    			<span class="type">int</span> b;</span><br><span class="line">    			<span class="keyword">while</span>((b = zis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    				<span class="comment">//写的文件当中</span></span><br><span class="line">    				fos.write(b);</span><br><span class="line">    			&#125;</span><br><span class="line">    			fos.close();</span><br><span class="line">    			zis.closeEntry();</span><br><span class="line">    		&#125;</span><br><span class="line">    		</span><br><span class="line">    		zis.close();</span><br><span class="line">    &#125;</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="压缩流-ZipOutputStream"><a class="header-anchor" href="#压缩流-ZipOutputStream"></a><em>压缩流</em> &amp; ZipOutputStream</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建数据源文件对象</span></span><br><span class="line">    	<span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;X:\\xx&quot;</span>);</span><br><span class="line">		<span class="comment">//创建目的源父级路径文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">destParent</span> <span class="operator">=</span> src.getParentFile();</span><br><span class="line">        <span class="comment">//创建目的源文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destParent,src.getName()+<span class="string">&quot;.zip&quot;</span>); <span class="string">&quot;X:\xx.zip&quot;</span></span><br><span class="line">        <span class="comment">//创建压缩流关联压缩包</span></span><br><span class="line">        <span class="type">ZipOutputStream</span> <span class="variable">zos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest));</span><br><span class="line">		<span class="comment">//获取src里每一个文件，变成ZipEntry对象，放入压缩包当中</span></span><br><span class="line">        toZipMulti(src,zos,src.getName);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放压缩流</span></span><br><span class="line">        zos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//压缩单个文件    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toZip</span><span class="params">(File src,File dest)</span> <span class="keyword">throw</span> FileNotFoundException&#123;</span><br><span class="line">    	<span class="comment">//创建压缩流关联压缩包</span></span><br><span class="line">        <span class="type">ZipOutputStream</span> <span class="variable">zos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,<span class="string">&quot;a.zip&quot;</span>)));</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//创建ZipEntry对象：表示当前从压缩包当中获取到的文件或文件夹</span></span><br><span class="line">    	<span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        zos.putNextEntry(entry);</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            zos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		zos.closeEntry();</span><br><span class="line">        zos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toZipMulti</span><span class="params">(File src,ZipOutputStream zos,String fileName)</span> <span class="keyword">throw</span> FileNotFoundException&#123;</span><br><span class="line">        <span class="comment">//进入src文件，获取src文件列表</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历文件数组</span></span><br><span class="line">        <span class="keyword">for</span>(File file;files)&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(name+<span class="string">&quot;\\&quot;</span>+file.getName()); file: <span class="string">&quot;X:\\xx\\xxx.txt&quot;</span></span><br><span class="line">                zos.putNextEntry(entry);</span><br><span class="line">                <span class="comment">//读取文件中的数据，写入压缩包当中</span></span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> b;</span><br><span class="line">                <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    zos.write();</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                toZipMulti(file,zos,name +file.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程-JUC"><a class="header-anchor" href="#多线程-JUC"></a>多线程&amp;JUC</h2>
<blockquote>
<p>一个进程当中可以有许多条线程，同时执行多种命令</p>
<p>充分利用程序当中的等待时间，充分利用硬件资源</p>
</blockquote>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3>
<h4 id="进程和线程"><a class="header-anchor" href="#进程和线程"></a>进程和线程</h4>
<ol>
<li>进程：一个应用程序or一个软件</li>
<li>线程：一个进程当中的某个指令、执行单元or执行场景。</li>
<li>注：一个进程可以有多个线程，也可以同时启动多个线程</li>
</ol>
<blockquote>
<p>对于Java这门语言来说，当执行一个class文件时，即是首先启动了<strong>JVM</strong>这个进程，而后<strong>JVM</strong>再启动<mark>主线程main方法</mark>；同时启动一个<mark>垃圾回收线程</mark>负责看护、回收垃圾。</p>
</blockquote>
<h4 id="多线程的目的"><a class="header-anchor" href="#多线程的目的"></a>多线程的目的</h4>
<p>为了提高程序的处理效率，通过合理的资源分配方式，调度多项任务相间同时进行，充分利用硬件资源</p>
<h4 id="线程的两种方式"><a class="header-anchor" href="#线程的两种方式"></a>线程的两种方式</h4>
<ol>
<li>
<p>并发：同一时间，多个指令在单个CPU上<strong>交替</strong>进行</p>
</li>
<li>
<p>并行：同一时间，多个指令在多个CPU上<strong>同时</strong>进行</p>
</li>
</ol>
<h4 id="线程对象具有生命周期"><a class="header-anchor" href="#线程对象具有生命周期"></a>线程对象具有生命周期</h4>
<ul>
<li>
<p>新建状态**(NEW)**</p>
<ul>
<li>使用new关键字和Thread类或子类建立一个线程对象A后，则线程对象A处于新建状态。一直到进程<code>start()</code>这个线程。</li>
</ul>
</li>
<li>
<p>就绪状态**(RUNNABLE)**</p>
<ul>
<li>有执行资格，没有执行权</li>
<li>当线程对象A调用<code>start()</code>方法后，线程进入就绪状态、参与到等待队列中，等待JVM中线程调度器的调度的调度。</li>
</ul>
</li>
<li>
<p>运行状态</p>
<ul>
<li>有执行资格也有执行权</li>
<li>如果处于就绪状态的线程获取到了CPU资源，则执行<code>run()</code>方法，此时线程处于运行状态。处于运行状态的线程较为复杂，它有三种变化情况：阻塞、就绪与死亡状态。</li>
</ul>
</li>
<li>
<p>阻塞状态**(BLOCKED)**</p>
<ul>
<li>无执行资格也无执行权</li>
<li>一个线程执行了<code>sleep()</code> （睡眠）、<code>suspend()</code>（挂起）等方法后，失去了当前抢占的资源，进入阻塞状态，当睡眠时间或阻塞条件结束后，重新进入就绪状态，再次参与CPU资源的抢夺，在抢夺成功后才可以继续执行阻塞方法下面的其他代码。</li>
<li>阻塞分为：
<ul>
<li>等待阻塞**(WAITING)**：运行状态中的线程执行了<code>wait()</code>方法；</li>
<li>同步阻塞：线程在获取<code>synchronized</code>同步锁失败（因同步锁被其他线程占用；</li>
<li>其他阻塞：通过调用线程的<code>sleep()</code> **(TIMED_WAITING)**或 <code>join()</code>发出了<code>I/O</code>请求时，线程进入阻塞状态。当<code>sleep()</code>状态超时，<code>join()</code>等待下次终止或超时，或者<code>I/O</code>处理完毕，线程重新进入就绪状态。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>死亡状态**(TERMINATED)**</p>
<ul>
<li>线程死亡，变成垃圾，被垃圾回收机回收</li>
<li>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到死亡 状态。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011835010.png" alt="在这里插入图片描述"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011835090.jpg" alt="img"></p>
<h4 id="Thread-State"><a class="header-anchor" href="#Thread-State"></a>Thread State</h4>
<blockquote>
<p>在JAVA当中，并没有规定运行状态，因为当线程抢夺到CPU执行权后，程序将由 JVM 交还给操作系统，因而不需要额外定义一个“运行”的状态。</p>
</blockquote>
<ol>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED WAITING</li>
<li>TERMINATED</li>
</ol>
<h3 id="JAVA中三种线程实现方式"><a class="header-anchor" href="#JAVA中三种线程实现方式"></a>JAVA中三种线程实现方式</h3>
<ol>
<li>继承java.lang.Thread类，重写run方法（线程和任务绑死，无返回值）</li>
<li>实现java.lang.Runnable接口 ，实现run方法，实例化子类对象，传入Thread当中（线程和任务进行分离，无返回值）</li>
<li>使用Callable接口和Future接口方式实现（线程和任务进行分离，有返回值）</li>
</ol>
<h4 id="继承Thead类"><a class="header-anchor" href="#继承Thead类"></a>继承Thead类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//需要重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="实现Runnable接口"><a class="header-anchor" href="#实现Runnable接口"></a>实现Runnable接口</h4>
<p>使用此种方法实现线程更为常见，因为一个类实现了接口以后还可以去继承其他的类，开发中更加灵活</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="实现Callable接口和Future"><a class="header-anchor" href="#实现Callable接口和Future"></a>实现Callable接口和Future</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(callableDemo);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(future.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常见的成员方法"><a class="header-anchor" href="#常见的成员方法"></a>常见的成员方法</h3>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>String getName()</code></td>
<td style="text-align:left">返回线程名称</td>
</tr>
<tr>
<td style="text-align:left"><code>void setName(String name)</code></td>
<td style="text-align:left">设置线程名字（当线程没有手动命名时，会默认设置成Thread-xxx）</td>
</tr>
<tr>
<td style="text-align:left"><code>static Thread currentThread()</code></td>
<td style="text-align:left">获取当前线程对象</td>
</tr>
<tr>
<td style="text-align:left"><code>static void sleep(long time)</code></td>
<td style="text-align:left">线程休眠，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:left"><code>setPriority(int newPriority)</code></td>
<td style="text-align:left">设置线程优先级</td>
</tr>
<tr>
<td style="text-align:left"><code>final int getPriority()</code></td>
<td style="text-align:left">获取线程优先级</td>
</tr>
<tr>
<td style="text-align:left"><code>final void setDaemon(boolean on)</code></td>
<td style="text-align:left">设置为守护线程</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void yield()</code></td>
<td style="text-align:left">出让线程、礼让线程</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void join()</code></td>
<td style="text-align:left">插入线程、插队线程</td>
</tr>
</tbody>
</table>
<h4 id="注意事项-v4"><a class="header-anchor" href="#注意事项-v4"></a>注意事项</h4>
<p><code>run()</code>：不会启动线程，只是个普通的调用方法，不会分配新的分支线。</p>
<p><code>run()</code>：只能用try…catch…，不能throws：因为父类没有抛出异常，子类不能比父类抛出更多异常。</p>
<p><code>start()</code>：启动一个分支线程，在JVM中开辟一个新的栈空间。在<code>start()</code>方法结束后</p>
<h4 id="线程的sleep方法"><a class="header-anchor" href="#线程的sleep方法"></a>线程的sleep方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void sleep(long millis)</td>
<td>让当前线程休眠millis秒</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>静态方法</p>
</li>
<li>
<p>单位：毫秒</p>
</li>
<li>
<p>作用：让调用该方法的进程进入休眠，进入“阻塞状态“，放弃占用CPU时间片。</p>
</li>
<li>
<p><code>Thread.sleep()</code>方法：间隔特定的时间，执行一段特定代码，每个多久执行一次</p>
</li>
</ol>
<h4 id="关于线程中断sleep-的方法"><a class="header-anchor" href="#关于线程中断sleep-的方法"></a>关于线程中断sleep()的方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void interrupt()</td>
<td>终止线程的睡眠</td>
</tr>
</tbody>
</table>
<h4 id="强制终止一个线程的执行"><a class="header-anchor" href="#强制终止一个线程的执行"></a>强制终止一个线程的执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5秒之后强行终止t线程</span></span><br><span class="line">        t.stop(); <span class="comment">// 已过时（不建议使用。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">缺点：</span></span><br><span class="line"><span class="comment">1. 数据易丢失，因为该方法直接将线程杀死，线程尚未来得及保存的数据就会丢失，不建议使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Java中合理的结束一个线程的执行"><a class="header-anchor" href="#Java中合理的结束一个线程的执行"></a>Java中合理的结束一个线程的执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunable4</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunable4</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程</span></span><br><span class="line">        <span class="comment">// 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。</span></span><br><span class="line">        r.run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打一个布尔标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(run)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// return就结束了，你在结束之前还有什么没保存的。</span></span><br><span class="line">                <span class="comment">// 在这里可以保存呀。</span></span><br><span class="line">                <span class="comment">//save....</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//终止当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程调度"><a class="header-anchor" href="#线程调度"></a>线程调度</h3>
<blockquote>
<p>抢占式：哪个线程优先级高，抢到的CPU时间片的概率就高一些/久一些（JAVA采用抢占式调度模式）</p>
<p>均分式：平均分配CPU时间片，每个线程占用的CPU时间片时间长度一样（主打一个众生平等）</p>
</blockquote>
<h4 id="线程优先级"><a class="header-anchor" href="#线程优先级"></a>线程优先级</h4>
<blockquote>
<p>JVM自己创建的线程main 的优先级为<em>5</em></p>
<p>优先级越高，抢到CPU资源的概率越高。</p>
</blockquote>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int getPriority()</td>
<td>获得线程优先级</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>设置线程优先级</td>
</tr>
</tbody>
</table>
<ul>
<li>最低优先级1</li>
<li>默认最高为5</li>
<li>可设置最高为10</li>
</ul>
<p><strong>常量</strong></p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>static int MAX_PRIORITY</td>
<td>最高优先级（10）</td>
</tr>
<tr>
<td>static int NORM_PRIORITY</td>
<td>默认优先级（5）</td>
</tr>
<tr>
<td>static int MIN_PRIORITY</td>
<td>最低优先级（1）</td>
</tr>
</tbody>
</table>
<h4 id="守护线程"><a class="header-anchor" href="#守护线程"></a>守护线程</h4>
<blockquote>
<p>当其他非守护线程结束以后，守护线程才会陆续结束。即守护线程一定在非守护线程结束以后才结束。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<ol>
<li>聊天（线程1）与输入文件（线程2），在线程1结束后线程2没有存在必要，将线程2设置成守护线程，在线程1结束后紧接着也结束。</li>
</ol>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>final void setDaemon(boolean on)</code></td>
<td>设置该线程为守护线程</td>
</tr>
</tbody>
</table>
<h4 id="出让-礼让线程"><a class="header-anchor" href="#出让-礼让线程"></a>出让/礼让线程</h4>
<p><strong>静态方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void yield()</td>
<td>让位方法，当前线程暂停，回到就绪状态，将抢占的CPU资源让给其它线程。</td>
</tr>
</tbody>
</table>
<p>yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。</p>
<p>yield()方法的执行会让当前线程从“<strong>运行状态</strong>”回到“<strong>就绪状态</strong>”。相当于从正在执行重新回到排队状态</p>
<p>注意：在回到就绪之后，<strong>有可能还会再次抢到</strong>。</p>
<h4 id="插入线程"><a class="header-anchor" href="#插入线程"></a>插入线程</h4>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void join()</td>
<td>将一个线程合并到当前线程中，当前线程受阻塞，加入的线程执行直到结束</td>
</tr>
<tr>
<td>void join(long millis)</td>
<td>接上条，等待该线程终止的时间最长为 millis 毫秒</td>
</tr>
<tr>
<td>void join(long millis, int nanos)</td>
<td>接第一条，等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</td>
</tr>
</tbody>
</table>
<h3 id="线程同步"><a class="header-anchor" href="#线程同步"></a>线程同步</h3>
<h4 id="同步代码块"><a class="header-anchor" href="#同步代码块"></a>同步代码块</h4>
<blockquote>
<p>锁默认打开，一个线程进入后锁自动关闭；锁内的代码块执行完毕后，线程出来后，锁自动打开</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//静态变量，所有该类创建的线程对象共享一个已卖出票数的整数变量</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(MyThread.class)&#123;</span><br><span class="line">          <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruotedException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ticket++;</span><br><span class="line">            sout(getName() + <span class="string">&quot;卖出了&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步方法"><a class="header-anchor" href="#同步方法"></a>同步方法</h4>
<blockquote>
<p>先写同步代码块，再修改成同步方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用<span class="keyword">synchronized</span>修饰符修饰方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 返回值类型 方法名(方法参数)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">runDemo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ticket == <span class="number">100</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ticket++;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().getName()</span><br><span class="line">        + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!runDemo())&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>StingBuilder是线程不安全的，如果需要同步，则使用StringBuffer</p>
<p>源码中，StringBuffer所有的方法都是同步的</p>
<p>当代码是单线程的，不需要考虑数据安全，则选择StringBuilder</p>
<p>当代码采用了多线程，需要考虑数据安全，则选择StringBuffer</p>
</blockquote>
<h4 id="Lock—锁"><a class="header-anchor" href="#Lock—锁"></a>Lock—锁</h4>
<blockquote>
<p>给予了开发者手动上锁和解锁的方法</p>
<p>Lock是一个接口，不可以直接实例化。但可以采用它的实现类ReentrantLock来实例化</p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MtThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">runDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ticket++;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">50</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">150</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            Thread.currentThread().getName()</span><br><span class="line">                                    + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>案例测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MtThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MtThread</span>();</span><br><span class="line">        <span class="type">MtThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MtThread</span>();</span><br><span class="line">        <span class="type">MtThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MtThread</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h4>
<blockquote>
<p>避免死锁的核心即是，避免将两个锁进行嵌套，则可以避免一个锁导致另一个锁锁住了这个锁</p>
</blockquote>
<p><strong>若存在下述情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;线程A&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程A获取到了objA锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (objB)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取到了objB锁，顺利执行完毕&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;线程B&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取到了objB锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (objA)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程B获取到了objA锁，顺利执行完毕&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadDemo2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo2</span>();</span><br><span class="line">        <span class="type">ThreadDemo2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo2</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生产者和消费者（等待唤醒机制）"><a class="header-anchor" href="#生产者和消费者（等待唤醒机制）"></a>生产者和消费者（等待唤醒机制）</h3>
<blockquote>
<p>生产者负责生产数据</p>
<p>消费者负责消费数据</p>
<p>还需要一个等待平台去唤醒其他线程。</p>
</blockquote>
<h4 id="理想情况"><a class="header-anchor" href="#理想情况"></a>理想情况</h4>
<p>生产者优先于消费者抢夺到CPU资源，成功产出数据后；消费者抢夺到CPU资源并且消费生产者产出的数据。</p>
<h4 id="实际情况"><a class="header-anchor" href="#实际情况"></a>实际情况</h4>
<ol>
<li>消费者等待：消费者每次抢夺到CPU资源时，会先判断是否存在数据，若无数据则进入<code>wait</code>操作，不参与CPU资源的抢夺，生产者成功抢夺CPU资源；在生产者产出数据后，还需要去唤醒处于等待状态的消费者。；若有数据则消耗数据。</li>
<li>生产者等待：生产者每次抢夺到CPU资源时首先进行判断，假设判断已经产出数据，则进入<code>wait</code>操作，不参与CPU资源的抢夺，消费者成功抢夺到CPU资源，在消耗资源后，消费者再次抢夺到资源，但是检测到无数据，则唤醒处于等待的生产者，并且自身进入等待。</li>
</ol>
<p>逻辑参考如下：</p>
<img src="D:\DeskTable\博客学习截图传输\image-20240227175051674.png" alt="image-20240227175051674" style="zoom:50%;" />
<p>在消费者尚未将已经产生的数据消化完时，生产者进入<code>wait</code>操作，不参与CPU资源的抢夺，此时消费者抢夺到CPU资源。在消费者消化完数据后，需要去唤醒处于等待状态的生产者。</p>
<h4 id="常见方法"><a class="header-anchor" href="#常见方法"></a>常见方法</h4>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void wait()</code></td>
<td>当前线程等待，直到被其他线程唤醒</td>
</tr>
<tr>
<td><code>void notify()</code></td>
<td>随机唤醒单个线程</td>
</tr>
<tr>
<td><code>void notifyAll()</code></td>
<td>唤醒所有线程</td>
</tr>
</tbody>
</table>
<h4 id="阻塞队列实现唤醒机制"><a class="header-anchor" href="#阻塞队列实现唤醒机制"></a>阻塞队列实现唤醒机制</h4>
<blockquote>
<p>生产者和消费者需要使用同一条阻塞队列</p>
</blockquote>
<ol>
<li>接口关系：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">Iterable --- Collection --- Queue --- BlockingQueue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>两个实现类：</p>
<ol>
<li>ArrayBlockingQueue：数组构成，有界</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用阻塞队列不需要另外创建锁对象，put方法底层已经使用了锁对象锁定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">take同理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Cook类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo3.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(ArrayBlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;面条&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;厨师做了一道菜&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Foodie类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo3.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">food</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;食客吃了&quot;</span>+food);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Test类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo3.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(queue);</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(queue);</span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>LinkedBlockingQueue：链表构成，无界(但也不是真的无界，只是界限比较大，为int的max值)</li>
</ol>
</li>
</ol>
<h3 id="线程池"><a class="header-anchor" href="#线程池"></a>线程池</h3>
<ol>
<li>创建一个线程池，池子内是空的</li>
<li>提交任务，池子会创建新的线程对象，任务执行完毕将线程归还线程池；下次提交任务时，不需要额外创建新的线程，直接复用已有线程</li>
<li>如果提交任务时，池子内没有空闲线程且无法创建新的线程，任务排队等待</li>
</ol>
<p>代码实现</p>
<h4 id="Executors：线程池的工具类内的方法"><a class="header-anchor" href="#Executors：线程池的工具类内的方法"></a>Executors：线程池的工具类内的方法</h4>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public static ExecutorService newCachedThreadPool</code></td>
<td>创建一个上限无穷大的线程池</td>
</tr>
<tr>
<td><code>public static ExecutorService newFixedThreadPool(int nThreads)</code></td>
<td>创建有上限的线程池</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="使用Executors工具类创建一个线程池"><a class="header-anchor" href="#使用Executors工具类创建一个线程池"></a>使用Executors工具类创建一个线程池</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo4.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Executors工具类创建一个新的线程池并且返回</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向线程池当中提交任务</span></span><br><span class="line">        pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//销毁线程池</span></span><br><span class="line"><span class="comment">        pool1.shutdown();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用ThreadPoolExecutor自定义一个线程池"><a class="header-anchor" href="#使用ThreadPoolExecutor自定义一个线程池"></a>使用ThreadPoolExecutor自定义一个线程池</h4>
<blockquote>
<p>一个线程池可以容纳的最大任务数量（满负荷工作）为：corePoolSize + 临时线程数量 + 阻塞队列长度</p>
</blockquote>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>成员变量说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public ThreadPoolExecutor( int corePoolSize</code></td>
<td>核心线程数量（不能小于0</td>
</tr>
<tr>
<td><code>int maximinPoolSize</code></td>
<td>线程池中最大线程数量 &gt;=核心线程数量</td>
</tr>
<tr>
<td><code>long keepAilveTime</code></td>
<td>空闲时间（值）</td>
</tr>
<tr>
<td><code>TimeUnit unit</code></td>
<td>空闲时间（单位）</td>
</tr>
<tr>
<td><code>BlockingQueue&lt;Runnable&gt; workQueue</code></td>
<td>阻塞队列</td>
</tr>
<tr>
<td><code>ThreadFactory threadFactory</code></td>
<td>创建线程的方式</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler )</code></td>
<td>要执行的任务过多时的解决方案</td>
</tr>
</tbody>
</table>
<ol>
<li>创建临时线程的条件：
<ol>
<li>线程池内核心线程都被占用</li>
<li>阻塞队列被填满</li>
<li>多余的任务会去匹配临时线程的个数，额外再多的则执行解决方案</li>
</ol>
</li>
</ol>
<p><code>RejectedExecutionHandler </code>的拒绝策略</p>
<table>
<thead>
<tr>
<th>任务拒绝策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ThreadPoolExecutor.AbortPolicy</code></td>
<td><strong>默认策略</strong>：丢弃任务并且抛出<code>RejectedExecutionException</code>异常</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.DiscardPolicy</code></td>
<td>丢弃任务，但是不抛出异常&lt;不推荐&gt;</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.DiscardOldestPolicy</code></td>
<td>抛弃队列中等待最久的任务，而后把当前任务加入队列当中</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor.CallerRunPolicy</code></td>
<td>调用任务的<code>run()</code>方法绕过线程池直接执行</td>
</tr>
</tbody>
</table>
<h4 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ThreadDemo4.caigui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">6</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大并行数"><a class="header-anchor" href="#最大并行数"></a>最大并行数</h4>
<p>本地电脑处理器的数量（xx核xx线程）</p>
<h4 id="线程池的大小选取"><a class="header-anchor" href="#线程池的大小选取"></a>线程池的大小选取</h4>
<ol>
<li>CPU密集型运算：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>最大并行数</mtext><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">最大并行数+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">最大并行数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li>I/O密集型运算：$最大并行数 *  期望CPU利用率 * \frac{总时间(CPU计算时间 + 等待时间)}{CPU计算时间} $</li>
</ol>
<h4 id="线程池的拓展："><a class="header-anchor" href="#线程池的拓展："></a>线程池的拓展：</h4>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20240229142107777.png" alt="image-20240229142107777"></p>
<h3 id="volatile"><a class="header-anchor" href="#volatile"></a>volatile</h3>
<blockquote>
<p>Java提供的一种轻量级的同步机制。相比起synchronized 锁同步，volatile的开销要更低，因为该关键字不会引起线程上下文的切换问题。</p>
</blockquote>
<p>定义</p>
<blockquote></blockquote>
<h2 id="网络编程"><a class="header-anchor" href="#网络编程"></a>网络编程</h2>
<h3 id="定义-v2"><a class="header-anchor" href="#定义-v2"></a>定义</h3>
<blockquote>
<p>在网络通信协议下，不同计算机上运行的程序，进行的数据传输</p>
</blockquote>
<h3 id="常见的网络架构"><a class="header-anchor" href="#常见的网络架构"></a>常见的网络架构</h3>
<ol>
<li>BS
<ol>
<li>Browser/Server 浏览器/服务器</li>
<li>只需要浏览器，用户可以通过不同的网址进行访问</li>
</ol>
</li>
<li>CS
<ol>
<li>Client/Server 客户端/服务器</li>
<li>需要用户本地下载并按照客户端程序</li>
</ol>
</li>
</ol>
<h3 id="网络编程的三要素"><a class="header-anchor" href="#网络编程的三要素"></a>网络编程的三要素</h3>
<ol>
<li><strong>IP</strong>：设备在网络中的地址，是设备的唯一标识</li>
<li><strong>端口号</strong>：应用程序在设备中唯一的标识</li>
<li><strong>协议</strong>：数据在网络中传输的规则，常见的协议有UDP、TCP、http、https、ftp</li>
</ol>
<h4 id="IP-Internet-Protocol"><a class="header-anchor" href="#IP-Internet-Protocol"></a>IP(Internet Protocol)</h4>
<blockquote>
<p>互联网协议地址，是分配给上网设备的数字标签</p>
</blockquote>
<ol>
<li>
<p>IPv4</p>
<ol>
<li>采取32位地址长度，分为四组，每组八位，如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11000000101010000000000101000010</mn></mrow><annotation encoding="application/x-tex">11000000 10101000 00000001 01000010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11000000101010000000000101000010</span></span></span></span></li>
<li>为了便于使用和记忆，采用点分十进制表示法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11000000</mn><mtext> </mtext><mn>10101000</mn><mtext> </mtext><mn>00000001</mn><mtext> </mtext><mn>01000010</mn><mtext>  </mtext><mo>→</mo><mtext>  </mtext><mn>192.168.166</mn></mrow><annotation encoding="application/x-tex">11000000~10101000~ 00000001 ~01000010~~\rightarrow~~192.168.1 66</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11000000</span><span class="mspace nobreak"> </span><span class="mord">10101000</span><span class="mspace nobreak"> </span><span class="mord">00000001</span><span class="mspace nobreak"> </span><span class="mord">01000010</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">192.168.166</span></span></span></span></li>
</ol>
<p>弊端：数量较少，不够更多设备使用</p>
</li>
<li>
<p>IPv6</p>
<ol>
<li>采取128位地址长度，分成八组，每组16位</li>
<li>采用冒分十六进制表示法，省略高位的0</li>
</ol>
</li>
<li>
<p>特殊的IP，本机IP&amp;回收地址&amp;本地回环地址。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>127.0.0.1</mn></mrow><annotation encoding="application/x-tex">127.0.0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127.0.0.1</span></span></span></span> localhost。永远只会寻找当前所在本机</p>
</li>
</ol>
<h4 id="端口"><a class="header-anchor" href="#端口"></a>端口</h4>
<h4 id="协议"><a class="header-anchor" href="#协议"></a>协议</h4>
<ol>
<li>OSI协议：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层&lt;七层&gt;</li>
<li>TCP/IP模型：应用层、传输层、网络层、物理链路层
<ol>
<li>应用层：HTTP、FTP、Telent、DNS、…</li>
<li>传输层：TCP、UDP、…</li>
<li>网络层：IP、ICMP、ARP、…</li>
<li>物理链路层：硬件设备</li>
</ol>
</li>
</ol>
<p>UDP协议：</p>
<ul>
<li>User Datagram Protocol</li>
<li>UDP是<strong>面向无连接</strong>通信协议</li>
<li>速度快，易丢失，大小限制</li>
</ul>
<p>TCP协议：</p>
<ul>
<li>Transmission Control Protocol</li>
<li>TCP协议是<strong>面向连接</strong>的通信协议</li>
<li>速度慢，数据安全，无大小限制</li>
</ul>
<h3 id="UDP通信协议"><a class="header-anchor" href="#UDP通信协议"></a>UDP通信协议</h3>
<h4 id="发送数据"><a class="header-anchor" href="#发送数据"></a>发送数据</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.InterProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;信息放松测试&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line"></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="接收数据"><a class="header-anchor" href="#接收数据"></a>接收数据</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.InterProgram.Demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length);</span><br><span class="line"></span><br><span class="line">        ds.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port1</span> <span class="operator">=</span> dp.getPort();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,len));</span><br><span class="line">        System.out.println(<span class="string">&quot;数据是由&quot;</span> + address + <span class="string">&quot;这一设备发送的&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="反射"><a class="header-anchor" href="#反射"></a>反射</h2>
<h3 id="定义-v3"><a class="header-anchor" href="#定义-v3"></a>定义</h3>
<blockquote>
<p>允许对封装类的字段，方法和构造函数的信息进行编程访问</p>
</blockquote>
<p>反射可以获取的信息：</p>
<p>字段（成员方法）：修饰符、标识符、类型、赋值/获取值</p>
<p>构造方法：修饰符、方法名、形参、创建对象</p>
<p>成员方法：修饰符、方法名、形参、获取返回值、抛出的异常、注解、运行方法</p>
<h3 id="作用-v2"><a class="header-anchor" href="#作用-v2"></a>作用</h3>
<blockquote>
<ol>
<li>获取一个类内的所有信息，获取到后再执行其他的业务逻辑</li>
<li>结合配置文件，动态的创建对象并调用方法</li>
</ol>
</blockquote>
<h4 id="应用场景"><a class="header-anchor" href="#应用场景"></a>应用场景</h4>
<ol>
<li>
<p>对于任意一个对象，都可以把对象的所有字段与值保存到文件当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张山&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        saveObject(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\IntellijIDEA\\projects\\DailyStudy\\src\\Test.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (Field field: fields</span><br><span class="line">             ) &#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入本地文件</span></span><br><span class="line">            bw.write((field.getName() + <span class="string">&quot;=&quot;</span> +field.get(obj)));</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反射和配置文件结合，动态创建对象和运行方法</p>
</li>
</ol>
<h3 id="获取-解剖"><a class="header-anchor" href="#获取-解剖"></a>获取&amp;解剖</h3>
<blockquote>
<p>从Java字节码文件中去获取，再进行解剖</p>
</blockquote>
<h3 id="获取class对象的方法"><a class="header-anchor" href="#获取class对象的方法"></a>获取class对象的方法</h3>
<ol>
<li><code>Class.forName(&quot;全类名&quot;)</code></li>
<li><code>类名.class</code></li>
<li>``对象.getClass()`</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo1;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//全类名</span></span><br><span class="line">        <span class="comment">//最常用</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla1</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;cn.Reflect.Demo1.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类名.class</span></span><br><span class="line">        <span class="comment">//当作参数进行传递</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla2</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象.class</span></span><br><span class="line">        <span class="comment">//当已经有了类对象时才使用</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>().getClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(cla1 == cla2);</span><br><span class="line">        System.out.println(cla2 == cla3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射获取构造方法"><a class="header-anchor" href="#反射获取构造方法"></a>反射获取构造方法</h3>
<ol>
<li>Class类中用于获取构造方法的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Constructor&lt;?&gt;[] getConstructors</code></td>
<td>返回所有<strong>public</strong>构造方法对象的数组</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[]getDeclaredConstructors()</code></td>
<td>返回所有构造方法对象的数组</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... paramentTypes)</code></td>
<td>返回单个<strong>public</strong>构造方法对象</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;..paramentTypes)</code></td>
<td>返回单个构造方法对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>Constructor类中用于创建对象的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T newInstance(Object… initargs)</code></td>
<td>根据指定的构造方法创建对象</td>
</tr>
<tr>
<td><code>setAccessible(boolean flag)</code></td>
<td>设置为<code>true</code>，表示取消访问检查</td>
</tr>
</tbody>
</table>
<h4 id="代码实现-v2"><a class="header-anchor" href="#代码实现-v2"></a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;Person&#123;name = &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;\t age = &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.Reflect.Demo2.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] cons1 =  cla.getConstructors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor[] cons2 = cla.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;getConstructors()方法：获取类内所有的构造方法&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor con: cons1</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n getDeclaredConstructors()方法：获取类内所有的构造方法&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor con: cons2</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取单个构造函数，参数列表需要一一对应</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> cla.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> cla.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> cla.getDeclaredConstructor(String.class,Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="效果图"><a class="header-anchor" href="#效果图"></a>效果图</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20240229165113198.png" alt="image-20240229165113198" style="zoom:50%;" /> 
<h4 id="java-lang-reflect-Modifier"><a class="header-anchor" href="#java-lang-reflect-Modifier"></a>java.lang.reflect.Modifier</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public static final int</code></td>
<td>ABSTRACT</td>
<td>1024</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>FINAL</td>
<td>16</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>INTERFACE</td>
<td>512</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>NATIVE</td>
<td>256</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>PRIVATE</td>
<td>2</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>PROTECTED</td>
<td>4</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>PUBLIC</td>
<td>1</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>STATIC</td>
<td>0</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>STRICT</td>
<td>2048</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>SYNCHRONIZED</td>
<td>32</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>TRANSIENT</td>
<td>128</td>
</tr>
<tr>
<td><code>public static final int</code></td>
<td>VOLATILE</td>
<td>64</td>
</tr>
</tbody>
</table>
<h3 id="暴力反射"><a class="header-anchor" href="#暴力反射"></a>暴力反射</h3>
<blockquote>
<p>一种可以突破私有化修饰符限制，对数据进行修改的操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;Person&#123;name = &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;\t age = &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有以上Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.Reflect.Demo2.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Class中的getDeclaredConstructor方法获取Person类中的构造方法，并返回使用Constructor对象接收</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> cla.getDeclaredConstructor(String.class,Integer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到con3对象后，通过方法steAccessible(true)临时取消权限校验，因而可以动用私有化数据</span></span><br><span class="line">        <span class="comment">//暴力反射，破坏修饰符限制</span></span><br><span class="line">        con3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) con3.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(per);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反射获取成员变量、"><a class="header-anchor" href="#反射获取成员变量、"></a>反射获取成员变量、</h3>
<ol>
<li>Class类中用于获取成员变量的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Field[] getFields()</code></td>
<td>返回所有<strong>public</strong>成员变量对象的数组</td>
</tr>
<tr>
<td><code>Field[] getDeclaredField()</code></td>
<td>返回所有成员变量对象的数组</td>
</tr>
<tr>
<td><code>Field getField(String name)</code></td>
<td>返回单个<strong>public</strong>成员变量对象</td>
</tr>
<tr>
<td><code>Field getDeclaredField(String name)</code></td>
<td>返回单个成员变量对象</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>Field类中用于创建对象的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void set(Object obj,Object value)</code></td>
<td>給成员变量赋值</td>
</tr>
<tr>
<td><code>Object get(Object obj)</code></td>
<td>获取成员变量里的值</td>
</tr>
</tbody>
</table>
<h4 id="代码实现-v3"><a class="header-anchor" href="#代码实现-v3"></a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.Reflect.Demo3.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field: fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//打印反射出的成员变量信息</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//打印成员变量的权限修饰符</span></span><br><span class="line">        System.out.println(name.getModifiers());</span><br><span class="line">        <span class="comment">//获取成员变量的名字</span></span><br><span class="line">        System.out.println(name.getName());</span><br><span class="line">        <span class="comment">//获取成员变量的数据类型</span></span><br><span class="line">        System.out.println(name.getType());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量记录的值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> name.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(p,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(name.get(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="效果图-v2"><a class="header-anchor" href="#效果图-v2"></a>效果图</h4>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20240229213536490.png" alt="image-20240229213536490"></p>
<h3 id="反射获取成员方法"><a class="header-anchor" href="#反射获取成员方法"></a>反射获取成员方法</h3>
<ol>
<li>Class类中用于获取成员方法的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Method[] getMethods()</code></td>
<td>返回所有<strong>public</strong>成员方法对象的数组，包括继承的</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>返回所有成员方法对象的数组，不包括继承的</td>
</tr>
<tr>
<td><code>Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个<strong>public</strong>成员方法对象</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个成员方法对象</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>Method类中用于创建对象的方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object invoke(Object obj,Object... args)</code></td>
<td>运行方法</td>
</tr>
<tr>
<td>参数一：用obj对象调用该方法</td>
<td></td>
</tr>
<tr>
<td>参数二：调用方法的传递的参数（若无则不用写）</td>
<td></td>
</tr>
<tr>
<td>返回值：方法的返回值（若无则不用写）</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="代码实现-v4"><a class="header-anchor" href="#代码实现-v4"></a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.Reflect.Demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.Reflect.Demo4.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Method[] methods1 = clazz.getMethods();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;获取类中所有的公有化的成员方法，包括从父类继承而来的&quot;);</span></span><br><span class="line"><span class="comment">        for (Method method: methods1</span></span><br><span class="line"><span class="comment">             ) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(method);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;获取所有的本类中的成员方法&quot;);</span></span><br><span class="line"><span class="comment">        Method[] methods2 = clazz.getDeclaredMethods();</span></span><br><span class="line"><span class="comment">        for (Method method: methods2</span></span><br><span class="line"><span class="comment">             ) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(method);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(method3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要一个对象去调用反射得到的成员方法</span></span><br><span class="line">        method3.invoke(<span class="keyword">new</span> <span class="title class_">Person</span>(),<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="效果图-v3"><a class="header-anchor" href="#效果图-v3"></a>效果图</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20240229214829748.png" alt="image-20240229214829748" style="zoom:50%;" /> 
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句练习</title>
    <url>/2025/03/01/MySQL/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SQL语句练习"><a class="header-anchor" href="#SQL语句练习"></a>SQL语句练习</h1>
<h2 id="1378"><a class="header-anchor" href="#1378"></a>1378</h2>
<p><a href="https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/">使用唯一标识码替换员工ID</a></p>
<p><code>Employees</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，id 是这张表的主键。</span><br><span class="line">这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。</span><br></pre></td></tr></table></figure>
<p><code>EmployeeUNI</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，(id, unique_id) 是这张表的主键。</span><br><span class="line">这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。</span><br></pre></td></tr></table></figure>
<p>展示每位用户的 <strong>唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p>
<p>你可以以 <strong>任意</strong> 顺序返回结果表。</p>
<p>返回结果的格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employees 表:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line">EmployeeUNI 表:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line">输出：</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line">解释：</span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure>
<p><strong>ANSWER：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> en.unique_id , e.name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Employees <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> EmployeeUNI <span class="keyword">as</span> en</span><br><span class="line"><span class="keyword">on</span> e.id <span class="operator">=</span> en.id</span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong></p>
<p>本题为联表查询，个人认为难点在于如何将 <code>unique_id</code> 填充为 <code>null</code>，同时为了保证员工姓名这一行保留，因而可以使用左结合，以id作为结合条件，而如果在EmployeeUNI不存在的也会给unique_id填充null。</p>
]]></content>
      <tags>
        <tag>sql</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 学习</title>
    <url>/2025/03/01/%E5%89%8D%E7%AB%AF/JS%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="JS"><a class="header-anchor" href="#JS"></a>JS</h1>
<blockquote>
<p>js三大组成部分：<strong>BOM、ECMA核心、DOM</strong></p>
</blockquote>
<h2 id="JS常用对象"><a class="header-anchor" href="#JS常用对象"></a>JS常用对象</h2>
<p><a href="https://www.apiref.com/javascript-zh/index.htm">JavaScript_API参考文档(中文版)</a></p>
<h3 id="Array"><a class="header-anchor" href="#Array"></a>Array</h3>
<h3 id="Math"><a class="header-anchor" href="#Math"></a>Math</h3>
<h3 id="Number"><a class="header-anchor" href="#Number"></a>Number</h3>
<h3 id="Date"><a class="header-anchor" href="#Date"></a>Date</h3>
<h3 id="Boolean"><a class="header-anchor" href="#Boolean"></a>Boolean</h3>
<h3 id="String"><a class="header-anchor" href="#String"></a>String</h3>
<h2 id="事件"><a class="header-anchor" href="#事件"></a>事件</h2>
<blockquote>
<p>事件既可以浏览器的行为，也开始用户的行为。</p>
<p>大当行为发生时，自动触发对应的JS函数运行——事件的发生</p>
<p>JS事件驱动指的是行为触发代码运行的这种特性</p>
</blockquote>
<h3 id="常见事件"><a class="header-anchor" href="#常见事件"></a>常见事件</h3>
<h4 id="鼠标事件"><a class="header-anchor" href="#鼠标事件"></a>鼠标事件</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011237366.png" alt="image-20240512231705770"></p>
<h4 id="键盘事件"><a class="header-anchor" href="#键盘事件"></a>键盘事件</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011237752.png" alt="image-20240512231740544"></p>
<h4 id="表单事件"><a class="header-anchor" href="#表单事件"></a>表单事件</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011237568.png" alt="image-20240512231820221"></p>
<h3 id="事件绑定"><a class="header-anchor" href="#事件绑定"></a>事件绑定</h3>
<h2 id="BOM编程"><a class="header-anchor" href="#BOM编程"></a>BOM编程</h2>
<h3 id="BOM定义："><a class="header-anchor" href="#BOM定义："></a>BOM定义：</h3>
<ul>
<li>BOM <strong>Browser Object Model</strong>，浏览器对象模型</li>
<li>由一系列对象组成，是访问、控制、修改浏览器的属性和方法</li>
<li>将浏览器窗口各个组成部分抽象成给个对象，通过各个对象的API操作组件行为</li>
<li>对象结构：
<ul>
<li>window 顶级对象，代表整个窗口
<ul>
<li>location：地址栏</li>
<li>history：访问历史</li>
<li>screen：屏幕</li>
<li>navigator：浏览器软件本身</li>
<li>document：当前解析的html文档</li>
<li>console：开发者工具的控制台</li>
<li>localStorage：本地数据持久化存储</li>
<li>sessionStorage：本地数据会话级存储</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql进阶</title>
    <url>/2025/03/14/MySQL/MySql%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="MySQL-进阶"><a class="header-anchor" href="#MySQL-进阶"></a>MySQL 进阶</h1>
<h2 id="存储引擎"><a class="header-anchor" href="#存储引擎"></a>存储引擎</h2>
<h3 id="MySQL-体系结构"><a class="header-anchor" href="#MySQL-体系结构"></a>MySQL 体系结构</h3>
<p>连接层、服务层、引擎层和存储层</p>
<p><strong>连接层</strong>：最上层的一些客户端和连接服务，主要是连接处理，授权认证及其相关的安全方案。服务器为每一个安全连接的用户验证操作权限</p>
<p><strong>服务层</strong>：数据库的核心服务，sql 接口、完成缓存查询、sql 的分析与优化等等</p>
<p><strong>引擎层</strong>：真正负责 mysql 中数据的存储和提取，服务器通过 api 和存储引擎进行通信。</p>
<p><strong>存储层</strong>：将数据存储在文件系统上，完成与引擎的交互</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151606656.png" alt="mysql 体系架构"></p>
<p>建表时可以指定引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释]</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB [COMMENT 表注释];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看当前数据库支持的所有引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure>
<h3 id="InnoDB"><a class="header-anchor" href="#InnoDB"></a>InnoDB</h3>
<p>mysql 5.5 之后默认的存储引擎，兼顾高性能和高可靠性</p>
<p>特点：</p>
<ul>
<li>DMl 遵循 ACID 模型，支持事务</li>
<li>行级锁，提高并发访问性能</li>
<li>支持外键 foreign key 约束，保证数据的完整性和正确性</li>
</ul>
<p>存储形式：（在文件系统中的存储文件形式）</p>
<ul>
<li>xxx.ibd：xxx为表名，InnoDB 引擎的每张表都会对应这样子一个表空间文件，存储该表的表结构（frm，sdi）、数据和索引</li>
</ul>
<p>InnoDB 的逻辑存储结构：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151611104.png" alt="InnoDB 的逻辑存储结构"></p>
<h3 id="MyISAM"><a class="header-anchor" href="#MyISAM"></a>MyISAM</h3>
<p>mysql 早期默认的存储引擎</p>
<p>特点：不支持事务、不支持外键、只支持表级锁，访问速度快（因为无需考虑事务操作）</p>
<p>存储形式：</p>
<ul>
<li>.sdi：存储表结构信息</li>
<li>.myd：存储数据</li>
<li>.myi：存储索引</li>
</ul>
<h3 id="Memory"><a class="header-anchor" href="#Memory"></a>Memory</h3>
<p>该引擎的数据存储在内存中，因此是临时性的，数据的持久性不好，只能当作临时缓存使用</p>
<p>特点：数据存放在内存，hash 索引是默认索引</p>
<p>存储形式：</p>
<ul>
<li>xxx.sdi：存储表结构信息</li>
</ul>
<h3 id="InnoDB-和-MyISAM-对比："><a class="header-anchor" href="#InnoDB-和-MyISAM-对比："></a>InnoDB 和 MyISAM 对比：</h3>
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">MyISAM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">事务</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">锁机制</td>
<td style="text-align:center">行级锁</td>
<td style="text-align:center">表级锁</td>
</tr>
<tr>
<td style="text-align:center">外键</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h3 id="引擎选择"><a class="header-anchor" href="#引擎选择"></a>引擎选择</h3>
<p>需要根据具体的应用业务需求选择：</p>
<ul>
<li>如果应用需要对事务的完整性有要求，且并发下要求数据的一致性，数据操作涉及增删改查，选择 InnoDB</li>
<li>如果应用需求以<strong>读和插入</strong>为主，且对事务的完整性和并发性要求不高，可以选择</li>
<li>如果只是想要制作临时表，缓存数据，可以选择 memory</li>
</ul>
<h2 id="索引"><a class="header-anchor" href="#索引"></a>索引</h2>
<p>为了帮助高效的查找数据而建立的一种数据结构，其本质是一颗 b+ 树（InnoDB）</p>
<p>好处：</p>
<ul>
<li>提高了数据的检索效率，降低系统的 IO 成本</li>
<li>通过索引对数据进行排序，降低数据排序成本，提高性能</li>
</ul>
<p>坏处：</p>
<ul>
<li>建立和存储索引需要消耗一定的空间</li>
<li>更新表时的速度会受影响，因为需要涉及到对索引对更新</li>
</ul>
<h3 id="索引结构"><a class="header-anchor" href="#索引结构"></a>索引结构</h3>
<p>MySQl 索引时在引擎层实现的，不同存储引擎有不同的数据结构，常用的：</p>
<p><strong>B+ 树索引</strong>：大部分引擎都支持 B+ 树</p>
<p><strong>hash 索引</strong>：底层使用哈希表实现，只适用于精确查询，不支持范围查询</p>
<p><strong>Full-text 全文索引（倒排索引）</strong>：是一种通过建立倒排索引，快速匹配文档的方式</p>
<p><strong>R-tree 索引</strong>：空间索引，MyISAM 引擎的一种特殊类型，用于地理空间数据的存储和计算</p>
<p>MySQL 各种引擎的支持情况：</p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+ 树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>full-text 索引</td>
<td>5.6 版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h4 id="B-树"><a class="header-anchor" href="#B-树"></a>B 树</h4>
<p>以一颗最大度数（<code>max-degree</code>）为 <code>5</code>（<code>5</code> 阶）的 <code>b-tree</code> 为例（每个结点最多存储 <code>4</code> 个 <code>key</code> ，<code>5</code> 个指针）【树的“度数”指的是一个节点当中可以存储多少个指针】</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151630359.png" alt="普通 B 树"></p>
<h4 id="B-树-v2"><a class="header-anchor" href="#B-树-v2"></a>B+ 树</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151630846.png" alt="普通 B+ 树"></p>
<p>MySQL 在原有 B+ 树的基础上进行优化，增加了一个指向相邻叶子节点的指针，从原本的单向链表修改为循环双向链表，提高了区间访问的性能</p>
<h4 id="Hash-索引"><a class="header-anchor" href="#Hash-索引"></a>Hash 索引</h4>
<p>通过采用 hash 算法，将 key 转换成 hash 值，找到可以映射的槽，然后存储在 hash 表中，再查询时可以根据查询的 key 进行 hash ，得到 hash 值然后去相对应的槽中获取值，如果产生了哈希冲突，则通过链表法来解决</p>
<p>特点：</p>
<ul>
<li>只能用于等值比较（=，in），不支持范围查询（between，&gt;,&lt;,…）【hash 特点决定的】</li>
<li>无法利用索引完成排序</li>
<li>查询效率高，通常只需要一次索引即可，效率高于 B+ 树【使用 B+ 树可能涉及到多次节点的比较】</li>
</ul>
<p>InnoDB 为什么选择 B+ 树作为索引结构</p>
<ul>
<li>相对于平衡二叉树，层级少，且无法做太复杂的调整</li>
<li>相比 B 树，B+ 树只在叶子节点存储数据，上层节点可以存储更多的 key 值，同时指针数也可以提高，可以保证层数不会太高，影响性能。</li>
<li>相比于 hash 索引，B+ 树还支持范围查询以及排序，普遍性更好</li>
</ul>
<h3 id="索引分类"><a class="header-anchor" href="#索引分类"></a>索引分类</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建且唯一</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表的某列中存在数据重复</td>
<td>可以有多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特点数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找文本中的关键词，而不是比较索引中对值</td>
<td>可以有多个</td>
<td>fulltext</td>
</tr>
</tbody>
</table>
<p>在 InnoDB 存储引擎中，根据引擎的存储形式，分为：</p>
<p>聚集索引：将数据存储与索引放在一起，索引的叶子节点即存储了一整行的数据，（必须）有且只有一个</p>
<p>二级索引：叶子节点存储的是主键 id，如果需要涉及到索引值之外的值，则需要回表操作，可以有多个</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151649596.png" alt="聚集索引与非聚集索引（二级索引）"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503151649747.png" alt="需要进行回表操作"></p>
<p><strong>聚集索引选取规则</strong>：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ul>
<p><strong>根据 InnoDB 主键索引的 B+ tree 高度推算大致存储数据量</strong>：</p>
<p>假设：一行数据 1k，在 InnoDB 中一个节点就是一个页，而一页的大小是 16k，一个指针占用 6 个字节，假设主键使用 bigint，占用 8 个字节</p>
<p>计算过程：设 key 的数量为 n，node 数量为 n+1，则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>6</mn><mo>=</mo><mn>16</mn><mo>∗</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n*8 + (n+1)*6 = 16*1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>，计算出 n ≈ 1170，则有指针 1171个</p>
<p>如果树高度为 2：则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>16</mn><mi>k</mi><mo>=</mo><mn>18736</mn></mrow><annotation encoding="application/x-tex">1171 * 16k =18736</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18736</span></span></span></span></p>
<p>如果树高度为 2：则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>21939856</mn></mrow><annotation encoding="application/x-tex">1171*1171*16 = 21939856</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">21939856</span></span></span></span></p>
<h3 id="索引语法"><a class="header-anchor" href="#索引语法"></a>索引语法</h3>
<p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name,...);</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>
<h3 id="SQL-性能分析"><a class="header-anchor" href="#SQL-性能分析"></a>SQL 性能分析</h3>
<h4 id="SQL-执行频率"><a class="header-anchor" href="#SQL-执行频率"></a>SQL 执行频率</h4>
<p><code>MySQL</code> 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 <code>INSERT</code> 、<code>DELETE</code> 、<code>SELECT</code> 的访问频次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="慢日志查询"><a class="header-anchor" href="#慢日志查询"></a>慢日志查询</h4>
<p>慢查询日志记录了所有执行时间超过指定参数（<code>long_query_time</code> ，单位：秒，默认 <code>10</code> 秒）的所有 <code>SQL</code> 语句的日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="profile"><a class="header-anchor" href="#profile"></a>profile</h4>
<p><code>show profiles</code> 能够在左 <code>SQL</code> 优化时帮助我们了解时间都耗费到哪里去了。通过 <code>have_profiling</code> 参数，能够看到当前 <code>MySQL</code> 是否支持 <code>profile</code> 操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>
<p>默认 <code>profiling</code> 是关闭的，可以用过 <code>set</code> 语句在 <code>session/global</code> 级别开启 <code>profiling</code> ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="explain执行计划"><a class="header-anchor" href="#explain执行计划"></a>explain执行计划</h4>
<p><code>EXPLAIN</code> 或者 <code>DESC</code> 命令获取 <code>MySQL</code> 如何执行 <code>SELECT</code> 语句的信息，包括在 <code>SELECT</code> 语句执行过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain<span class="operator">/</span><span class="keyword">desc</span></span><br><span class="line">EXPALIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure>
<p><code>EXPALIN</code> 执行计划各字段含义：</p>
<ul>
<li>
<p><code>id</code>：<code>select</code> 查询的序列号，表示查询中执行 <code>select</code> 字句或者是操作表的顺序（若 <code>id</code> 相同，执行顺序从上到下；若 <code>id</code> 不同，值越大，越先执行）。</p>
</li>
<li>
<p><code>select_type</code>：表示 <code>SELECT</code> 的类型，常见的取值有 <code>SIMPLE</code>（简单表，即不使用表连接或者子查询）、<code>PRIMARY</code>（主查询，即外层的查询）、<code>UNION</code>（<code>UNION</code> 中的第二个或者后面的查询语句）、<code>SUBQUERY</code>（<code>SELECT/WHERE</code> 之后包含了子查询）等。</p>
</li>
<li>
<p><code>type</code>：表示连接类型，性能由好到差的连续类型为 <code>NULL</code> 、<code>system</code> 、<code>const</code> 、<code>eq_ref</code> 、<code>ref</code> 、<code>range</code> 、<code>index</code> 、<code>all</code> 。</p>
</li>
<li>
<p><code>possible_key</code>：显示可能应用在这张表上的索引，一个或多个。</p>
</li>
<li>
<p><code>key</code>：实际使用的索引，如果为 <code>NULL</code> ，则没有使用索引。</p>
</li>
<li>
<p><code>Key_len</code>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p>
</li>
<li>
<p><code>rows</code>：<code>MySQL</code> 认为必须要执行查询的行数，在 <code>innodb</code> 引擎的表中，是一个估计值，可能并不是准确的。</p>
</li>
<li>
<p><code>filtered</code>：表示返回结果的行数站需读取行数的百分比，<code>filtered</code> 的值越大越好。</p>
</li>
</ul>
<h4 id="最左前缀原则"><a class="header-anchor" href="#最左前缀原则"></a>最左前缀原则</h4>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，<strong>索引将部分失效（后面的字段索引失效）</strong>。</p>
<p><strong>范围查询</strong></p>
<p>联合索引中，出现范围查询（<code>&gt;</code> ，<code>&lt;</code>），<strong>范围查询右侧的列索引失效</strong>。如果想避免失效，尽量使用 <code>&gt;=</code> 和 <code>&lt;=</code> 。</p>
<h4 id="索引失效情况"><a class="header-anchor" href="#索引失效情况"></a>索引失效情况</h4>
<p><strong>索引列运算</strong></p>
<p>不要在索引列上进行运算操作，<strong>索引将失效</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>)<span class="operator">=</span><span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串不加引号</strong>（类型不匹配引起的）</p>
<p>字符串类型字段使用时，不加引号，<strong>索引失效</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone<span class="operator">=</span><span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure>
<p><strong>模糊查询</strong></p>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 索引生效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>or 连接的条件</strong></p>
<p>用 <code>or</code> 分割开的条件，如果 <code>or</code> 前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会被用到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于age没有索引，所以即使id、phone有索引，索引也会失效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> age<span class="operator">=</span><span class="number">23</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user phone<span class="operator">=</span><span class="string">&#x27;17799990017&#x27;</span> <span class="keyword">or</span> age<span class="operator">=</span><span class="number">23</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据分布影响</strong></p>
<p>如果 <code>MySQL</code> 评估使用索引比全表更慢，则不使用索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>;</span><br><span class="line"><span class="comment">-- 使用索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="SQL-提示"><a class="header-anchor" href="#SQL-提示"></a>SQL 提示</h5>
<p>优化数据库的一种手段，就是在数据库中加入人为提示来做到优化操作的目的，例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 建议<span class="keyword">sql</span>使用索引，<span class="keyword">sql</span>不一定接受你的建议</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> te_user use index (idx_user_age_date_address) <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"># 提示<span class="keyword">sql</span>禁用索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> te_user ignore index (idx_user_age_date_address) <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"># 强制<span class="keyword">sql</span>使用索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> te_user force index (idx_user_age_date_address) <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<h5 id="覆盖索引"><a class="header-anchor" href="#覆盖索引"></a>覆盖索引</h5>
<p>尽量使用覆盖索引（即 select 后面的字段都包含索引当中，避免回表操作）</p>
<h5 id="前缀索引"><a class="header-anchor" href="#前缀索引"></a>前缀索引</h5>
<p>当字段类型为长文本时，存储索引需要的空间开销很大，索引也非常大，查询会浪费磁盘 IO，影响效率，此时可以只提取字符串的一部分具有<strong>较大差异性</strong>的字符前缀作为索引，提高查询效率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 提取字符串前n个字符建立索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> table_name(<span class="keyword">COLUMN</span>);</span><br><span class="line"></span><br><span class="line"># 可以根据选择性来决定前缀的长度</span><br><span class="line"># 选择性是指不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高(区分度高)</span><br><span class="line"># 唯一索引的选择性是<span class="number">1</span>，是最好的索引选择性，性能也是最好的</span><br><span class="line"></span><br><span class="line"># 根据下述公式求取索引的选择性</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 字段名) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(字段名, 起始, 终止)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"># 增加前缀索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_address_3 <span class="keyword">on</span> te_user(address(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p><strong>单列索引和联合索引</strong>：实际业务中，考虑到非主键索引的查询一般都会是多个值一起查，所以建立联合索引更加符合实际需求，而考虑到最左前缀原则，使用联合索引需要尽量把查询条件后面使用频率较高的字段作为最左边的索引值，</p>
<h3 id="设计原则"><a class="header-anchor" href="#设计原则"></a>设计原则</h3>
<ol>
<li>对于数据量较大（<strong>超过100多万的数据</strong>），且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，<strong>尽量建立唯一索引</strong>，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li><strong>尽量使用联合索引</strong>，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储 NULL 值，请在创建表时使用 NOTNULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<h3 id="SQL-优化"><a class="header-anchor" href="#SQL-优化"></a>SQL 优化</h3>
<h4 id="insert-优化"><a class="header-anchor" href="#insert-优化"></a>insert 优化</h4>
<p>对于小批量的数据的插入，优化方案：</p>
<ul>
<li>使用批量插入，一次插入保持在 1000 条以下，如果数据量比 1000 多一些，则采取多次批量插入</li>
<li>使用手动提交事务，在默认的自动提交事务前提下，insert 语句插入数据前后需要开启和提交事务，可以切换为手动提交，避免耗时操作</li>
<li>按照主键顺序插入，顺序插入效率高于乱序插入（原因是在插入时，按照主键顺序插入不会有页分裂、合并操作的消耗）</li>
</ul>
<p>对于大批量的数据来说，使用专门提供的 load 指令进行插入，将本地数据加载到数据库中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接服务器时，加上参数 --local -infile</span></span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="built_in">set</span> global local_infile = 1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认开关是否开启</span></span><br><span class="line"><span class="keyword">select</span> @@local_infile;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行load指令将准备好的数据加载到表结构中</span></span><br><span class="line">load data </span><br><span class="line">	<span class="built_in">local</span> infile 文件路径</span><br><span class="line">	into table 表名</span><br><span class="line">	fields terminated by 字段分隔符</span><br><span class="line">	lines terminated by 行分隔符;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设本地test.sql文件中格式为：12,testName12,20,2024-01-27,湖南长沙,13829978811</span></span><br><span class="line"><span class="comment"># 对于本地.sql文件的数据插入命令如下</span></span><br><span class="line">load data </span><br><span class="line">	<span class="built_in">local</span> infile <span class="string">&#x27;D:/HNU/test.sql&#x27;</span></span><br><span class="line">	into table te_user</span><br><span class="line">	fields terminated by <span class="string">&#x27;,&#x27;</span></span><br><span class="line">	lines terminated by <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="主键优化"><a class="header-anchor" href="#主键优化"></a>主键优化</h4>
<p>InnoDB 引擎中，表数据是根据主键顺序组织存放的，这种存放方式的表称为<strong>索引组织表（IOT，index-organized-table）</strong>。B+ 树中的节点存放在“页 page”中，页可以为空，也可以填充一半或全部填充。每个页包含 2~N 行记录（如果一行记录过大，会造成行溢出），根据主键顺序排列</p>
<p>如果主键乱序插入，会扰乱原本已经排序好的页，MySQL 会通过建立新的页并调整已经存放在页中对数据来达到维护数据按照主键顺序排列的目的，这就是<strong>页分裂</strong></p>
<p>当删除一行记录时，进行的其实是逻辑删除（打上一个可覆盖的标记），运行这个数据被其他数据说明使用，当删除的数据达到一定阈值（默认阈值时 50%），就会查看当前页和相邻两个页是否有合并的可能性，如果有则合并相邻的页以节省空间，这就是<strong>页合并</strong></p>
<p>故最终，我们可以得出主键的设计原则：</p>
<ol>
<li>满足业务要求的情况下，尽量降低主键的长度，降低占用的磁盘空间和节省搜索时的磁盘 IO。</li>
<li>插入数据时尽量选择顺序插入，选择使用自增主键。</li>
<li>尽量不要使用 UUID 做主键或者时其他自然主键，如身份证号，节省主键长度并避免出现页分裂的情况。</li>
<li>在业务操作时尽量避免对主键进行修改，因为修改主键会牵动索引结构，修改成本高。</li>
</ol>
<h4 id="order-by-优化"><a class="header-anchor" href="#order-by-优化"></a>order by 优化</h4>
<p>MySQL 有两种排序方式，为：</p>
<ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。<strong>故我们在优化 order by 时尽量优化为 using index 排序方式。</strong></li>
</ol>
<p>可以在创建索引的时候指定索引的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_name <span class="keyword">on</span> table_name(字段名<span class="number">1</span> <span class="keyword">asc</span>, 字段名<span class="number">2</span> <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure>
<p>order by 的优化原则：</p>
<ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序，一个升序一个降序，此时要注意联合索引在创建时的规则。</li>
<li>如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256K）。</li>
</ol>
<h4 id="group-by-优化"><a class="header-anchor" href="#group-by-优化"></a>group by 优化</h4>
<h4 id="limit-优化"><a class="header-anchor" href="#limit-优化"></a>limit 优化</h4>
<h4 id="count-优化"><a class="header-anchor" href="#count-优化"></a>count 优化</h4>
<h4 id="update-优化"><a class="header-anchor" href="#update-优化"></a>update 优化</h4>
<h2 id="视图"><a class="header-anchor" href="#视图"></a>视图</h2>
<p>视图 View 是一种虚拟存在的表，视图中对数据不会在数据库中实际存在，行和列数据来自定义视图的查询中使用的表（基表），并且是在使用视图时动态生成的（会自动更新）【相当于把一条查询语句的查询结果固定了下来，同时会依据数据库进行动态更新】</p>
<p>人话就是：视图不存在查询结果，只保存查询的 sql 逻辑，所以在创建视图时，主要的工作是创建查询的 sql 语句上。每次进行查询工作，都需要编写查询代码进行查询，视图的作用就是不必每次都重新编写查询 sql 代码，而是通过视图直接查看即可。</p>
<h3 id="基本语法"><a class="header-anchor" href="#基本语法"></a>基本语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建语法(与修改语法一致，修改时<span class="keyword">or</span> replace要加)</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br><span class="line"></span><br><span class="line"># 查询语法</span><br><span class="line"># 查看创建视图的<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br><span class="line"># 查看视图数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称;</span><br><span class="line"></span><br><span class="line"># 另一种修改语法</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> user_v1 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> te_user <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 查询视图</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> user_v1;</span><br><span class="line"></span><br><span class="line"># 查询视图数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_v1;</span><br><span class="line"></span><br><span class="line"># 修改视图</span><br><span class="line"># <span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> user_v1 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> te_user <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> user_v1 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> te_user <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> user_v1;</span><br></pre></td></tr></table></figure>
<h3 id="检查选项"><a class="header-anchor" href="#检查选项"></a>检查选项</h3>
<p>当使用 with cascaded check option 子句创建视图时，Mysql 会通过视图检查正在更改的每个行，如插入、更新、删除，以使其符合视图的定义。Mysql 允许基于另一个视图来创建视图，还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供两个选项：cascaded 和 local，默认是 cascaded</p>
<p>存储过程</p>
<p>略。。。</p>
<p>存储函数</p>
<p>略。。。</p>
<h2 id="触发器"><a class="header-anchor" href="#触发器"></a>触发器</h2>
<p>触发器是与表有关的数据库对象，指在 insert / update / delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p>
<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发（影响多少行就触发多少次），不支持语句级触发（不管一次影响多少行，最后只触发一次）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">触发器类型</th>
<th style="text-align:left">NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INSERT 型触发器</td>
<td style="text-align:left">NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td style="text-align:left">UPDATE 型触发器</td>
<td style="text-align:left">OLD 表示修改之前的数据，NEW 表示将要或者已经修改后的数据</td>
</tr>
<tr>
<td style="text-align:left">DELETE 型触发器</td>
<td style="text-align:left">OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建触发器</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE <span class="operator">/</span> AFTER <span class="keyword">INSERT</span> <span class="operator">/</span> <span class="keyword">UPDATE</span> <span class="operator">/</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> # 行级触发器</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	trigger_stmt;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"># 查看触发器</span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure>
<p>INSERT 型触发器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 通过触发器记录te_user表的数据变更日志，将变更日志插入到user_logs表中</span><br><span class="line"><span class="keyword">create table</span> user_logs(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">    operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">    operate_time datetime <span class="keyword">not null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">    operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">    operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary key</span>(id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> te_user_insert_trigger</span><br><span class="line">    after <span class="keyword">insert</span></span><br><span class="line">    <span class="keyword">on</span> te_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    # 往日志表中插入数据</span><br><span class="line">    <span class="keyword">insert into</span></span><br><span class="line">        user_logs (id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (</span><br><span class="line">         <span class="keyword">null</span>,</span><br><span class="line">         <span class="string">&#x27;insert&#x27;</span>,</span><br><span class="line">         now(),</span><br><span class="line">         new.id,</span><br><span class="line">         concat(<span class="string">&#x27;插入的数据内容为: id=&#x27;</span>, new.id, <span class="string">&#x27; name=&#x27;</span>, new.name, <span class="string">&#x27; age=&#x27;</span>, new.age, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"># 使用触发器</span><br><span class="line"><span class="keyword">insert into</span> te_user <span class="keyword">values</span>(<span class="number">16</span>, <span class="string">&#x27;testName16&#x27;</span>, <span class="number">20</span>, now(), <span class="string">&#x27;湖南长沙&#x27;</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line"># 查看触发器</span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line"># 删除触发器</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> te_user_insert_trigger;</span><br></pre></td></tr></table></figure>
<p>UPDATE 型触发器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 修改型触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> te_user_update_trigger</span><br><span class="line">    after <span class="keyword">update</span></span><br><span class="line">    <span class="keyword">on</span> te_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    # 往日志表中插入数据</span><br><span class="line">    <span class="keyword">insert into</span></span><br><span class="line">        user_logs (id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (</span><br><span class="line">         <span class="keyword">null</span>,</span><br><span class="line">         <span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">         now(),</span><br><span class="line">         new.id,</span><br><span class="line">         concat(<span class="string">&#x27;更新前: id=&#x27;</span>, old.id, <span class="string">&#x27; name=&#x27;</span>, old.name, <span class="string">&#x27;更新后: id=&#x27;</span>, new.id, <span class="string">&#x27; name=&#x27;</span>, new.name, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"># 修改数据</span><br><span class="line"><span class="keyword">update</span> te_user <span class="keyword">set</span> address <span class="operator">=</span> <span class="string">&#x27;湖南长沙&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">13</span>;</span><br></pre></td></tr></table></figure>
<p>DELETE 型触发器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除数据的触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> te_user_delete_trigger</span><br><span class="line">    after <span class="keyword">delete</span></span><br><span class="line">    <span class="keyword">on</span> te_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    # 往日志中插入数据</span><br><span class="line">    <span class="keyword">insert into</span></span><br><span class="line">        user_logs (id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (</span><br><span class="line">         <span class="keyword">null</span>,</span><br><span class="line">         <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">         now(),</span><br><span class="line">         old.id,</span><br><span class="line">         concat(<span class="string">&#x27;删除的数据: id=&#x27;</span>, old.id, <span class="string">&#x27; name=&#x27;</span>, old.name, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"># 删除数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> te_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a class="header-anchor" href="#锁"></a>锁</h2>
<h3 id="概述"><a class="header-anchor" href="#概述"></a>概述</h3>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、IO）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<ol>
<li>全局锁：锁定数据库中的<strong>所有表</strong>。</li>
<li>表级锁：每次操作锁住<strong>整张表</strong>。</li>
<li>行级锁：每次操作锁住对应的<strong>行数据</strong>。</li>
</ol>
<h3 id="全局锁"><a class="header-anchor" href="#全局锁"></a>全局锁</h3>
<p>全局锁对整个数据库实例上锁，加锁后整个实例处于<strong>只读</strong>状态，后续 DML 的写语句、DDL 语句、已经更新操作的事务提交语句都将被阻塞。</p>
<p><strong>使用场景</strong>：<strong>全库的逻辑备份</strong>，对所有表进行锁定，从而获取一致性视图，保证数据完整和一致</p>
<p>全局锁进行逻辑备份，sql 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 加全局锁，上锁后其他客户端只能读不能写，如果有更新操作，会阻塞</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"># 在windows命令行中备份数据，因为这条语句不是mysql命令</span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 要备份的数据库 <span class="operator">&gt;</span> 以.<span class="keyword">sql</span>文件形式存放的路径</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p>在全局加锁是一个较重的操作，存在问题：</p>
<ul>
<li>如果主库上备份，备份期间无法执行更新操作，业务基本停摆</li>
<li>如果从库上备份，备份期间从库不能同步主库的 binlog，造成主从延迟</li>
</ul>
<p>在 InnoDB 引擎上，可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 不加全局锁的数据备份</span><br><span class="line">mysqldump <span class="comment">--single-transaction -u用户名 -p密码 要备份的数据库 &gt; 以.sql文件形式存放的路径</span></span><br></pre></td></tr></table></figure>
<h3 id="表级锁"><a class="header-anchor" href="#表级锁"></a>表级锁</h3>
<p>表级锁，每次操作锁住一张表，锁定粒度大，发生锁冲突可能性高，并发性能差</p>
<p>三类表级锁</p>
<ul>
<li>表锁</li>
<li>元数据锁 meta data lock mdl</li>
<li>意向锁</li>
</ul>
<h3 id="表锁"><a class="header-anchor" href="#表锁"></a>表锁</h3>
<p>两类表锁：</p>
<ul>
<li>表共享读锁（read lock）：读锁只能读，不能写，读锁间不会互斥，但是读锁和写锁间会互斥</li>
<li>表独占写锁（write lock）：对于上锁的事务来说<strong>可读可写</strong>，对于其他事务来说<strong>不能读也不能写</strong></li>
</ul>
<p>【读锁不会对数据做出改动，因为大家可以一起读；但是写锁会对数据做出改动，因此为了防止在写的过程中别人读到脏数据或写的过程中别人来抢着写，因此需要与其他事务的读/写锁互斥】</p>
<p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 加锁</span><br><span class="line">lock tables 表名... read <span class="operator">/</span> write</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接;</span><br></pre></td></tr></table></figure>
<h3 id="元数据锁"><a class="header-anchor" href="#元数据锁"></a>元数据锁</h3>
<p>MDL 加锁过程是系统自动控制的，无需显式调用，在访问一张表时自动上锁，MDL 锁主要作用是<strong>维护表元数据（即表的结构信息）的一致性</strong>，当表上有活动事务时，不可以对元数据进行更改操作。</p>
<p>人话就是，如果表还有未提交的事务，说明当前外界对这张表对操作还没完，不可以擅自去修改表的结构信息，防止发生冲突，确保读写的准确性。</p>
<p>在 MySQL 5.5 引入了 MDL，对一张表进行增删改查时，加 MDL 读锁（共享）；对表结构进行更新操作时，加 MDL 写锁（排他）【基本上读锁都是共享的，因为大家可以一起读；写是互斥的，因为其他人得写完再读再写才可以保持数据的一致性】</p>
<table>
<thead>
<tr>
<th style="text-align:left">对应 SQL</th>
<th style="text-align:left">锁类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>lock tables xxx read / write</code></td>
<td style="text-align:left">shared_read_only / shared_no_read_write</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>select</code>、<code>select ... lock in share mode</code></td>
<td style="text-align:left">shared_read**（本会话只能读不能写，其他会话可以读也可以写）**</td>
<td style="text-align:left">与 shared_read、shared_write 兼容，与 exclusive 互斥</td>
</tr>
<tr>
<td style="text-align:left"><code>insert</code>、<code>update</code>、<code>delete</code>、<code>select ... for update</code></td>
<td style="text-align:left">shared_write**（所有会话都可以读，但只有本会话可以写）**</td>
<td style="text-align:left">与 shared_read、shared_write 兼容，与 exclusive 互斥</td>
</tr>
<tr>
<td style="text-align:left"><code>alter table...</code></td>
<td style="text-align:left">exclusive**（本会话可以读也可以写，但是别的会话不能读也不能写）**</td>
<td style="text-align:left">与其他的 MDL 都互斥</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	object_type, </span><br><span class="line">	object_schema, </span><br><span class="line">	object_name, </span><br><span class="line">	lock_type, </span><br><span class="line">	lock_duration </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	performance_schema, </span><br><span class="line">	metadata_locks;</span><br></pre></td></tr></table></figure>
<h3 id="意向锁"><a class="header-anchor" href="#意向锁"></a>意向锁</h3>
<p>当我们正在对表某一行数据进行操作时，系统会自动给表加上一个元数据锁，使得所有会话都可以读，但只有本会话可写，假设这个时候有其他客户端想要对表上表锁，则会发生锁冲突，为了避免冲突，客户端需要一行行检查行数据是否有元数据锁，这种操作十分消耗性能</p>
<p>为了避免 DML 在执行种，加的行锁和表锁冲突，在 InnoDB 中引入意向锁，可以通过意向锁来判断是否可以上表锁</p>
<ol>
<li>意向共享锁 IS：与表锁读锁（read）兼容，与表锁写锁（write）互斥</li>
<li>意向排他锁 IX：与表锁读锁（read）和写锁（write）都互斥，意向锁之间不会互斥</li>
</ol>
<p>查看意向锁及行锁的加锁情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	object_schema,</span><br><span class="line">	object_name,</span><br><span class="line">	index_name,</span><br><span class="line">	lock_type,</span><br><span class="line">	lock_mode,</span><br><span class="line">	lock_data</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">对应 SQL</th>
<th style="text-align:left">锁类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>select</code></td>
<td style="text-align:left">不会加意向锁</td>
</tr>
<tr>
<td style="text-align:left"><code>select ... lock in share mode</code></td>
<td style="text-align:left">IS</td>
</tr>
<tr>
<td style="text-align:left"><code>select ... for update</code></td>
<td style="text-align:left">IX</td>
</tr>
<tr>
<td style="text-align:left"><code>insert</code>、<code>update</code>、<code>delete</code></td>
<td style="text-align:left">IX</td>
</tr>
</tbody>
</table>
<h3 id="行级锁"><a class="header-anchor" href="#行级锁"></a>行级锁</h3>
<p>每次操作锁住对应的行数据，锁粒度最小，发生锁冲突可能性低，并发性能高。在 InnoDB 中，数据是基于主索引来组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁（上锁的是索引，不是数据）</p>
<p>分为三类：</p>
<ul>
<li>行锁 record lock：锁主单个记录的锁，防止其他事务对此进行 update 和 delete。在 RC、RR 隔离级别下都支持。</li>
<li>间隙锁 gap lock：锁住索引之间的间隙（不含索引），确保索引的间隙不变，防止其他事务在间隙进行 insert 导致幻读，在 RR 隔离级别下支持。</li>
<li>临键锁 next-key lock：行锁和间隙锁的组合，同时锁住索引与索引之间的间隙 gap，在 RR 隔离级别下支持。</li>
</ul>
<h4 id="行锁"><a class="header-anchor" href="#行锁"></a>行锁</h4>
<p>类似于上面，还是两种：</p>
<ul>
<li>共享锁（S，读锁）：允许一个事务去读一行，阻止其他事务的排他锁</li>
<li>排他锁（X，写锁）：允许活动排他锁的事务更新数据，阻止其他事务活动共享锁和排他锁</li>
</ul>
<p>总结：只有 SS 兼容、X 与 X、S 都不兼容</p>
<table>
<thead>
<tr>
<th style="text-align:left">SQL</th>
<th style="text-align:left">行锁类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>insert</code></td>
<td style="text-align:left">排他锁</td>
<td style="text-align:left">自动加锁</td>
</tr>
<tr>
<td style="text-align:left"><code>update</code></td>
<td style="text-align:left">排他锁</td>
<td style="text-align:left">自动加锁</td>
</tr>
<tr>
<td style="text-align:left"><code>delete</code></td>
<td style="text-align:left">排他锁</td>
<td style="text-align:left">自动加锁</td>
</tr>
<tr>
<td style="text-align:left"><code>select</code></td>
<td style="text-align:left">不加任何锁</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>select ... lock in share mode</code></td>
<td style="text-align:left">共享锁</td>
<td style="text-align:left">需要手动在 select 后面加上 lock in share mode</td>
</tr>
<tr>
<td style="text-align:left"><code>select ... for update</code></td>
<td style="text-align:left">排他锁</td>
<td style="text-align:left">需要手动在 select 后面加上 for update</td>
</tr>
</tbody>
</table>
<p>InnoDB 默认是 RR 的事务隔离级别，通过使用临键锁来尽量规避幻读。</p>
<ul>
<li>
<p>索引上的等值查询（唯一索引），给不存在的记录加锁，优化成间隙锁</p>
<p>例如：数据库中有主键：1、2、4、8；当查询 id = 5 时，由于 5 这条记录不存在，因此会采用间隙锁来锁住 4~8 之间的空隙（但不包含 4 和 8），防止其他事务写入该间隙以造成幻读。</p>
</li>
<li>
<p>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，临键锁退化成间隙锁</p>
<p>例如：假设有二级索引：2、4、5、16、18、18、20、22；当查询 age = 18 时，会把 16~18 之间的上临键锁，且 18 这一行上行锁和 18~20 之间的间隙也上间隙锁，因为二级索引是非唯一的，所以可以存在多个 18，最终效果是（16,20）开区间都被上锁了。如果在读期间不上锁，那么其他事务进行插入操作，插入新的 18，那么就会造成幻读现象</p>
</li>
<li>
<p>索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</p>
<p>例如：有唯一索引：2、19；当查询 number &gt;= 2 时，会先把 2 上行锁，2 和 9 之间上临键锁、9 到正无穷之间上临键锁</p>
</li>
</ul>
<p>【对于索引{1、2、4、5、7、9}来说，有 id &gt;= 4，那么，临键锁的范围：<code>(2, 4]</code>、<code>(4, 5]</code>、<code>(5, 7]</code>、<code>(7, 9]</code>、<code>(9, +∞)</code>；行锁的范围：<code>id = 4, 5, 7, 9</code>。】，所谓临键锁就是一个行锁➕一个间隙锁</p>
<h2 id="InnoDB-引擎"><a class="header-anchor" href="#InnoDB-引擎"></a>InnoDB 引擎</h2>
<p><a href="https://www.cnblogs.com/wtzbk/p/14410608.html">MYSQL查询和插入数据的流程是怎样的 - 大魔王先生 - 博客园</a></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503170925170.png" alt="InnoDB 引擎架构"  />
<p>逻辑存储结构</p>
<p>之前已经提到过，逻辑存储结构从大到小为：表空间（tablespace）、段（Segment）、区（extent）、页（page）、行（row），接下来详细介绍这五种存储结构</p>
<ol>
<li>表空间：ibd 文件，一个数据库实例可以对应多个表空间，用于存储记录、索引等数据</li>
<li>段：分为数据段、索引段、回滚段，InnoDB 是索引组织表，数据段是 B+ 树的叶子节点，索引段是非叶子节点。段用来管理多个区。</li>
<li>区：表空间的单元结构，大小固定 1M，一个区当中默认包含 64 个连续的页。</li>
<li>页：是 InnoDB 存储引擎磁盘管理的最小单元，每个页大小默认为 16kb，为了保证页连续性，一般一次会申请 4~5 个区</li>
<li>行：具体的每一条数据。当中有两个固定的隐藏字段：Trx_id（记录最后一次事务操作的id）和 roll_pointer（一个指针，指向操作前的上一版数据）</li>
</ol>
<h3 id="引擎架构"><a class="header-anchor" href="#引擎架构"></a>引擎架构</h3>
<h4 id="内存结构"><a class="header-anchor" href="#内存结构"></a>内存结构</h4>
<p><strong>Buffer Pool</strong>：缓冲池是主内存的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行 CRUD 操作时，先操作缓存池中的数据（如果没有数据，则从磁盘加载并缓存），然后再以一定频率刷盘，从而减少磁盘 IO，提高性能。</p>
<p>缓存池以 page 为单位，采用链表管理，根据状态，page 分为三种类型：</p>
<ul>
<li>free page：空闲页</li>
<li>clean page：被使用的页，但数据还没被修改</li>
<li>dirty page：脏页，被使用 page，但数据被修改过，与磁盘中数据不一致</li>
</ul>
<p><strong>Change Buffer</strong>：更新缓存区（针对非唯一二级索引页），在执行 DML 语句时，如果 xx 数据的 page 没有在 Buffer Pool 时，不会直接操作磁盘，而会将数据变更暂存到 change buffer 中，在未来读取 xx 数据时会和 change buffer 合并后再返回给 buffer pool，最后再将合并的数据刷盘。</p>
<p>与聚集索引不同，二级索引通常不是唯一的，并且以相对随机的顺序进行插入。每一次操作都可能影响不相邻的二级索引页，如果每次都操作磁盘，会造成大量的磁盘 io，有了 change buffer 后，可以有效减少磁盘 io，提高效率。</p>
<p><strong>Adaptive Hash index</strong>：自适应 hash 索引，用于优化对 buffer pool 数据的查询。InnoDB 会监控表上各索引页的查询，如果观察到热点页就会建立 hash 索引以提高目的，无需人工干预（相关参数：<code>adaptive_hash_index</code>）</p>
<p><strong>Log Buffer</strong>：日志缓存区，用来保存要写入磁盘中的 log 日志数据（redo log、undo log），默认大小为 16MB，日志缓存区中的内容会定期刷盘，如果需要更新、插入或删除多行事务，增加日志缓冲区大小可以节省磁盘 io。（缓冲区大小：<code>innodb_log_buffer_size</code>，日志刷新到磁盘时机：<code>innodb_flush_log_at_trx_commit</code>）</p>
<h4 id="磁盘结构"><a class="header-anchor" href="#磁盘结构"></a>磁盘结构</h4>
<p><strong>System Tablespace</strong>：系统表空间，Change Buffer 存放在这里。如果表示在系统表空间创建的（不是每个表文件或通用表空间中），它也可能包含表和索引数据。（在 MySQL 5.x 版本中还包含 InnoDB 数据字典、unlog 等，参数：<code>innodb_data_file_path</code>）</p>
<p><strong>Doublewrite Buffer Files</strong>：双写缓冲区，InnoDB 将数据页从 Buffer pool 写入到磁盘前会先将数据写入<strong>双写缓冲区</strong>，进行数据备份，便于系统异常恢复（文件扩展名为<code>dblwr</code>）</p>
<p><strong>Redo log</strong>：重做日志，用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲区（redo log buffer）以及重做日志文件（redo log），前者在内存中，后者在磁盘中。当事务提交之后会把所有修改信息存放到该日志中，用于在刷新脏页到磁盘时，发生错误时进行数据恢复。</p>
<p><strong>file-per-table tablespaces</strong>：每张表具有独立的表空间，存放在这个区域中。（参数：<code>innodb_file_per_table</code>）</p>
<p><strong>general tablespaces</strong>：通用表空间，需要通过 create tablespaces 语法创建通用表空间，创建表时，可以指定使用该空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建通用表空间</span><br><span class="line"><span class="keyword">CREATE</span> TABLESPACE xxx <span class="keyword">ADD</span></span><br><span class="line">DATAFILE <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">ENGINE <span class="operator">=</span> engine_name;</span><br><span class="line"></span><br><span class="line"># 将表存放入表空间中</span><br><span class="line"><span class="keyword">CREATE TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure>
<p><strong>undo tablespaces</strong>：撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小16M），用于存储 undo log 日志。</p>
<p><strong>Temporary Tablespaces</strong>：临时表空间，InnoDB 使用会话临时表空间和全局临时表空间来存储用户的临时表等数据。</p>
<h4 id="后台线程"><a class="header-anchor" href="#后台线程"></a>后台线程</h4>
<p>后台线程的作用是把 InnoDB 缓冲池中的数据在合适的时候<strong>刷新到磁盘文件</strong>当中。</p>
<p><strong>Master Thread</strong>：核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo 页的回收。</p>
<p><strong>IO Thread</strong>：在 InnoDB 引擎中大量使用了 AIO（异步非阻塞 IO） 来处理 IO 请求，这样可以极大提高数据库的性能，而 IO Thread 主要负责这些 IO 请求的回收。</p>
<table>
<thead>
<tr>
<th style="text-align:left">线程类型</th>
<th style="text-align:left">默认个数</th>
<th style="text-align:left">职责</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read thread</td>
<td style="text-align:left">4</td>
<td style="text-align:left">负责读操作</td>
</tr>
<tr>
<td style="text-align:left">Write thread</td>
<td style="text-align:left">4</td>
<td style="text-align:left">负责写操作</td>
</tr>
<tr>
<td style="text-align:left">Log thread</td>
<td style="text-align:left">1</td>
<td style="text-align:left">负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td style="text-align:left">Insert buffer thread</td>
<td style="text-align:left">1</td>
<td style="text-align:left">负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody>
</table>
<p>使用<code>show engine innodb status;</code>查看上述状态信息。</p>
<p><strong>Purge Thread</strong>：主要用于回收事务已经提交的 undo log，在事务提交之后，undo log 可能不用了，就用它来回收。</p>
<p><strong>Page Cleaner Thread</strong>：协助 Master Thread 刷新脏页数据到磁盘中，它可以减轻 Master Thread 的负担，减少阻塞。</p>
<h3 id="事务原理"><a class="header-anchor" href="#事务原理"></a>事务原理</h3>
<p>概念回顾：</p>
<p>事务是一组操作的集合，是不可分割的工作单位，要么一起完成后提交，要么其中某个操作失败整体撤回，特点是 ACID：</p>
<ul>
<li>原子性 atomictiy：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li>
<li>一致性 consistency：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性 isolation：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性 durability：事务一旦提交或回滚，对数据库的数据的改变是永久的。</li>
</ul>
<p>其中，原子性、一致性、持久性由 redo log 和 undo log 来保证；隔离性由锁机制和 mvcc（多版本并发控制）来实现。</p>
<h4 id="redo-log"><a class="header-anchor" href="#redo-log"></a>redo log</h4>
<p>重做日志，属于引擎的磁盘结构，用于解决事务<strong>持久性</strong>。该日志文件由两部分组成：重做日志缓冲区（redo log buffer）和重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息存放到该日志中，用于在刷新脏页到磁盘时，发生错误时进行数据恢复。</p>
<p>客户端发器请求操作 MySQL 服务器，先操作 Buffer Pool（如果要操作的数据不存在这里，则调用后台线程从磁盘中读取数据）。这个时候，缓冲区的数据变更了，但是磁盘的数据没有变更，出现脏页。如果脏页在往磁盘中进行刷新时出错，事务已经提交了，但是脏页的数据并没有刷新到磁盘中，事务的持久性就无法得到保障。</p>
<p>redo log 的设计目的就是为了解决这个问题，redo log 会将增删改的信息存放到 redo log buffer 中，记录数据页的物理变化，当事务进行提交时，redo log buffer 中的日志会刷新到磁盘中形成日志文件 redo log（Write-Ahead Logging，WAL，预写日志）【日志先行，也称为写前日志，实际写数据之前，先把修改的数据记录到日志文之间中。即先写日志，再写磁盘】，先保存一次数据的变化（因为保存的只是改变的几条记录而不是整张表，因此速度快且出错概率小），当脏页刷盘出错，可以利用 redo log 来进行数据恢复。</p>
<h4 id="undo-log"><a class="header-anchor" href="#undo-log"></a>undo log</h4>
<p>回滚日志，存放在引擎的磁盘结构中，用于解决事务的原子性问题（失败后的撤销解决方案），该日志文件会记录数据被修改前的信息，主要作用是：提供回滚依据和 mvcc</p>
<p>与 redo log 记录物理日志不同，undo log 记录的是逻辑日志，可以认为当 delete 一条记录时，undo log 会记录一条相对应的 insert 记录（用于恢复），反之亦然，当 update 一条记录时，记录一条记载了原本数据记录的 update 语句记录。执行 rollback 时，就可以读取 undo log 当中用于恢复数据的 sql 记录以恢复数据。</p>
<p>undo log 的销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这个日志还会涉及到 MVCC。</p>
<p>undo log 的存储：undo log 采用段的方式进行存储，存放在前面介绍的回滚段中，内部包含1024个 undo log segment。</p>
<h3 id="MVVCC"><a class="header-anchor" href="#MVVCC"></a>MVVCC</h3>
<h4 id="前导基本概念"><a class="header-anchor" href="#前导基本概念"></a>前导基本概念</h4>
<p>当前读：读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录加锁。加共享/排他锁的操作都可以认为是当前读。</p>
<p>快照读：读取的是<strong>某一时刻的记录，不一定是最新版本</strong>，不加锁，是非阻塞读。简单的 select 就是快照读。</p>
<p>三种事务隔离级别：</p>
<ul>
<li>RC read commited：每次 select 都会生成一个快照（所以会产生不可重复读的问题）</li>
<li>RR repeated read：开启事务后第一个 select 语句才生成一次快照读，之后的查询都根据这一次进行</li>
<li>Serializable：快照读退化成当前读</li>
</ul>
<h4 id="隐藏字段"><a class="header-anchor" href="#隐藏字段"></a>隐藏字段</h4>
<p>记录中的隐藏字段：</p>
<table>
<thead>
<tr>
<th style="text-align:left">隐藏字段</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DB_TRX_ID</td>
<td style="text-align:left">最近修改事务ID，记录插入这条记录或者最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td style="text-align:left">DB_ROLL_PTR</td>
<td style="text-align:left">回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本</td>
</tr>
<tr>
<td style="text-align:left">DB_ROW_ID</td>
<td style="text-align:left">隐藏主键，如果表结构没有指定主键，才会生成本字段</td>
</tr>
</tbody>
</table>
<h4 id="undo-log-版本链"><a class="header-anchor" href="#undo-log-版本链"></a>undo log 版本链</h4>
<p>前面介绍过，undo log 是回滚日志，在 insert、update、delete 的时候产生的便于数据回滚的日志。当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除。</p>
<p>undo log 版本链指的是不同事务或者相同事务对<strong>同一条</strong>记录进行修改，会导致该记录的 undo log 生成一条记录版本链表，链表的头部是最新的记录，链表尾部是最早的记录。undo log 版本链</p>
<p>前面介绍过，undo log 是回滚日志，在 insert、update、delete 的时候产生的便于数据回滚的日志。当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除。</p>
<p>【insert 操作产生的 undo log 对于其他事务的<strong>读操作</strong>没有影响，只在回滚时需要使用，因此可以立刻删除；而 update 和 delete 是对原本已经有的数据做出修改，为了被其他事务用于保持一致性读，因此需要保持 undo log 的记录，不可以立刻删除，例如，如果一个事务 A 修改了某条记录，而事务 B 在事务 A 提交之前开始了快照读，事务 B 需要读取修改前的数据。】</p>
<p>undo log 版本链指的是不同事务或者相同事务对<strong>同一条</strong>记录进行修改，会导致该记录的 undo log 生成一条记录版本链表，链表的头部是最新的记录，链表尾部是最早的记录。</p>
<h4 id="ReadView"><a class="header-anchor" href="#ReadView"></a>ReadView</h4>
<p>读视图是快照读 sql 执行时 mvcc 提取数据的依据，其中记录的四个核心字段是：</p>
<ul>
<li>m_ids：当前活跃的事务 <strong>id 集合</strong></li>
<li>min_trx_id：活跃事务集合中最小的 id</li>
<li>max_trx_id：预分配事务 id，即当前活跃事务 id 中最大值 + 1（事务 id 是自增的）</li>
<li>creator_trx_id：当前这个 readview 创建者的事务 id</li>
</ul>
<p>在 undo log 中有一个<code>trx_id</code>字段，表示当前事务的 ID。版本链数据访问规则：</p>
<ol>
<li><code>trx_id == creator_trx_id</code>：可以访问该版本，说明数据是当前这个事务更改的。</li>
<li><code>trx_id &lt; min_trx_id</code>：可以访问该版本，说明数据已经提交了。</li>
<li><code>trx_id &gt; max_trx_id</code>：不可以访问该版本，说明该事务是在 ReadView 生成后才开启。</li>
<li><code>min_trx_id &lt;= trx_id &lt;= max_trx_id</code>：如果<code>trx_id</code>不在<code>m_ids</code>之中，说明数据已经提交，可以访问该版本。</li>
</ol>
<p>不同的隔离级别，生成 ReadView 的时机不同：</p>
<ol>
<li>READ COMMITTED（读已提交）：在事务中每一次执行快照读时生成 ReadView。（因此是每次查询都会有一次快照读）</li>
<li>REPEATABLE READ（可重复读）：仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView。（因此是第一次执行的查询生成一次快照读）</li>
</ol>
<h2 id="运维（但开发）"><a class="header-anchor" href="#运维（但开发）"></a>运维（但开发）</h2>
<h3 id="主从复制"><a class="header-anchor" href="#主从复制"></a>主从复制</h3>
<p>主从复制是指将主数据库的 ddl 和 dml 操作通过<strong>二进制日志 binlog</strong>传到从库服务器中，然后在库上对这些日志重新执行（也就做重做 redo），从而使得从库和主库的数据保持同步</p>
<p>mysql 支持一台主库 master 同时向多台从库 slave 进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
<p>mysql 主从复制的三个优点：</p>
<ul>
<li>主库出现问题，可以快速切换从库提供服务</li>
<li>实现读写分离，降低主库的访问压力</li>
<li>可以在从库上进行备份，避免备份操作影响主库服务</li>
</ul>
<h4 id="原理"><a class="header-anchor" href="#原理"></a>原理</h4>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 学习</title>
    <url>/2025/03/01/%E5%89%8D%E7%AB%AF/HTML%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="HTML学习"><a class="header-anchor" href="#HTML学习"></a>HTML学习</h1>
<h2 id="根标签"><a class="header-anchor" href="#根标签"></a>根标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; &lt;/html&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>其余所有标签均放在这个标签内</li>
</ul>
<h2 id="根标签下的两个一级子标签"><a class="header-anchor" href="#根标签下的两个一级子标签"></a>根标签下的两个一级子标签</h2>
<h3 id="头标签"><a class="header-anchor" href="#头标签"></a>头标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt; &lt;/head&gt;</span><br></pre></td></tr></table></figure>
<p>定义不显示页面主体,但重要的内容</p>
<ul>
<li>字符集</li>
<li>css引入</li>
<li>js引入</li>
<li>其他…</li>
</ul>
<h3 id="体标签"><a class="header-anchor" href="#体标签"></a>体标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt; &lt;/body&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>定义展示页面中的内容</li>
</ul>
<h2 id="文档说明"><a class="header-anchor" href="#文档说明"></a>文档说明</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2>
<ul>
<li>tag       标签</li>
<li>attribute 属性:对标签特征进行设置的一种方式,一般在开始标签中定义</li>
<li>text      文本:双标签内的文字</li>
<li>element   元素: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>开始标签</mtext><mo>+</mo><mtext>属性</mtext><mo>+</mo><mtext>文本</mtext><mo>+</mo><mtext>结束标签</mtext><mo>→</mo><mtext>一个元素</mtext></mrow><annotation encoding="application/x-tex">开始标签+属性+文本+结束标签 \rightarrow 一个元素</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">开始标签</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">属性</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">文本</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">结束标签</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">一个元素</span></span></span></span></li>
</ul>
<h2 id="语法细节"><a class="header-anchor" href="#语法细节"></a>语法细节</h2>
<ol>
<li>根标签只有一个</li>
<li>单/双标签需要正确关闭(为了浏览器可以顺利识别)</li>
<li>标签可以嵌套但不可以交叉嵌套——必须一个包含另一个</li>
<li>注释：<code> &lt;!-- --&gt;</code></li>
<li>单双引号均表示字符串,在多个字符串包含时,需要单双引号交替使用</li>
<li>大小写不严格区分,但需要统一是大&amp;小写,不可大小写混用</li>
</ol>
<!--超链接-->
<p>&gt; <a href="https://www.w3schools.com/">w3school</a><br>
&gt; <a href = "https://www.w3schools.com/">w3school</a><br>
&gt; <img src="" alt="[热词]"></p>
<h2 id="列表标签"><a class="header-anchor" href="#列表标签"></a>列表标签</h2>
<p><strong>有序列表&amp;无序列表</strong></p>
<h3 id="有序"><a class="header-anchor" href="#有序"></a>有序:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<h3 id="无序"><a class="header-anchor" href="#无序"></a>无序</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h2 id="超链接标签"><a class="header-anchor" href="#超链接标签"></a>超链接标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href = &quot;http.xxx.com&quot;&gt; &lt;/a&gt; </span><br><span class="line"></span><br><span class="line">href 属性:用于定义跳转的目标资源地址</span><br><span class="line"></span><br><span class="line">target 属性:用于定义目标资源的打开方式</span><br><span class="line">    _self   在当前窗口打开链接</span><br><span class="line">    _blank  在新窗口打开链接</span><br></pre></td></tr></table></figure>
<h3 id="相对-绝对路径"><a class="header-anchor" href="#相对-绝对路径"></a>相对&amp;绝对路径</h3>
<p>相对路径:根据当前资源所在路径出发去寻找资源<br>
绝对路径:根据一个统一的根目录出发去寻找资源</p>
<h2 id="图片标签"><a class="header-anchor" href="#图片标签"></a>图片标签</h2>
<p>img标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img标签的三种属性</span><br><span class="line">    1. src      图片路径</span><br><span class="line">    2. title    鼠标悬停时的提示文字</span><br><span class="line">    3. alt      图片加载失败时的提示文字</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 学习笔记</title>
    <url>/2025/03/01/Java%E5%BA%95%E5%B1%82/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a class="header-anchor" href="#JVM"></a>JVM</h1>
<p><img src="" alt="jvm"></p>
<blockquote>
<p>本文参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">黑马程序员JVM虚拟机入门到实战全套视频教程，java大厂面试必会的jvm一套搞定（丰富的实战案例及最热面试题）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="认识-JVM"><a class="header-anchor" href="#认识-JVM"></a>认识 JVM</h2>
<p>jvm 全称 java virtual machine 本质是一个运行的程序，核心职责是 运行由 jdk 编译产生的 Java 字节码文件。</p>
<h3 id="jvms三大核心功能："><a class="header-anchor" href="#jvms三大核心功能："></a>jvms三大核心功能：</h3>
<ol>
<li>解释与运行：对字节码文件中的指令实时解释为机器码，交由计算机执行</li>
<li>内存管理：自动为对象、方法分配内存；垃圾回收机制，自动监测和回收不再使用的对象</li>
<li>即时编译：将热点代码翻译为机器码后会将这段机器码存储到内存中，避免重复翻译导致的时耗</li>
</ol>
<p>常见的 jvm：Hotspot、GraalVM、OpenJ9等，另外 DragonWell 龙井 JDK 也提供了一款功能增强版的 JVM。我们平时默认使用的虚拟机是 Oracle 官方的 HotSpot。</p>
<h2 id="JVM-的组成"><a class="header-anchor" href="#JVM-的组成"></a>JVM 的组成</h2>
<ul>
<li>
<p>类加载器：ClassLoader，作用是把从外界（磁盘或网络）读取的字节码文件加载到内存中</p>
</li>
<li>
<p>运行时数据区域：负责管理 jvm 使用到的内存（方法区、堆区）</p>
<p>如：字节码文件通过类加载器加载后会存放在该区域</p>
</li>
<li>
<p>执行引擎：包括即时编译器、解释器、垃圾回收器等。负责将字节码文件中的指令解释成机器码，同时调用即时编译器优化性能。</p>
</li>
<li>
<p>本地接口：调用本地已经编译的方法，如虚拟机中提供的 c/c++方法。（HotSpot 虚拟机本身由 c++ 编写，一些底层接口需要调用相关方法）</p>
</li>
</ul>
<p>示意图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031514092.png" alt="img"></p>
<h2 id="字节码"><a class="header-anchor" href="#字节码"></a>字节码</h2>
<p>本文学习过程中使用  <a href="https://github.com/ingokegel/jclasslib">jclasslib</a>  工具查看字节码文件。使用 <a href="https://arthas.aliyun.com/doc/">Arthas</a> 进行线上监控诊断。</p>
<h3 id="字节码文件的组成"><a class="header-anchor" href="#字节码文件的组成"></a>字节码文件的组成</h3>
<p>字节码文件以二进制组成，保存的是源代码编译后的信息</p>
<h4 id="基础信息"><a class="header-anchor" href="#基础信息"></a>基础信息</h4>
<blockquote>
<p>魔数、字节码文件对应的 Java 版本号、访问标识、父类和接口</p>
</blockquote>
<ul>
<li>
<p>魔数 Magic：java 字节码文件的文件头（文件的起始的几个固定字节 <code>ca fe ba be</code>）称之为 魔数</p>
<ul>
<li>
<p>文件无法通过文件拓展名来确定文件类型，文件拓展名可以随意修改，不影响文件的内容</p>
</li>
<li>
<p>软件通过文件的文件头去校验文件的类型，如果软件不支持该类型就会报错</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031451968.png" alt="魔数"></p>
<ul>
<li>
<p>版本号：</p>
<ul>
<li>
<p><strong>主版本号</strong>：java 的主版本号 - 44 即可知道当前 jdk 版本</p>
</li>
<li>
<p><strong>副版本号</strong>：主版本号相同时，内部进行区分，一般只关心主版本号</p>
</li>
</ul>
<p>低版本无法运行高版本</p>
<p><strong>当主版本不兼容时，解决措施</strong>：</p>
<ul>
<li>
<p>升级 JDK（升级版本，容易引发其他兼容问题，且需要大量测试）</p>
</li>
<li>
<p>讲第三方依赖的版本号降低或更换依赖，以满足 JDK 版本要求（推荐）</p>
</li>
</ul>
</li>
<li>
<p>访问标识：</p>
</li>
<li>
<p>类、父类、接口索引：</p>
</li>
</ul>
<h4 id="常量池"><a class="header-anchor" href="#常量池"></a>常量池</h4>
<blockquote>
<p>保存了字符串常量、类或接口、字段名，主要在字节码指令中使用</p>
</blockquote>
<p>常量池的作用：</p>
<ul>
<li>避免相同内容的重复定义，节省内存（以 String 为例，当有两个 String 变量的字面量相同时，则让这两个字符串变量指向同一块内存空间）</li>
<li>字节码在设计时，会根据字段的属性信息先去找常量池中的 <code>String_info</code>，再根据索引去找常量池中的 <code>info</code>（<code>info</code> 字面量的存在是为了当变量名和字符串文本名一致的时候，可以复用，节省空间），此时才是真正存储字符串文本内容的地方。</li>
<li>此处可以借鉴c++当中的指针思想，a 和 b 两个变量的字面量相同时，同时指向地址变量 c，而地址变量 c 会指向最终的字面量 “val”</li>
</ul>
<h4 id="字段"><a class="header-anchor" href="#字段"></a>字段</h4>
<p>当前类或接口声明的字段信息</p>
<h4 id="方法"><a class="header-anchor" href="#方法"></a>方法</h4>
<p>当前类或接口声明的方法信息字节码指令，由编译器编译生成字节码</p>
<ul>
<li>
<p>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的 Code 属性中。其中，操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。</p>
<p>指令可见 官方 jvm 规范</p>
<ul>
<li>iconst_x</li>
<li>istore_x</li>
<li>iload_i</li>
<li>iadd</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="属性"><a class="header-anchor" href="#属性"></a>属性</h4>
<p>类的属性，如源码的文件名，内部类列表等</p>
<h3 id="常见的字节码工具"><a class="header-anchor" href="#常见的字节码工具"></a>常见的字节码工具</h3>
<p><code>javap</code> 命令：适合在服务器上查看字节码文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -<span class="built_in">cp</span> &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>
<p><code>Arthas</code></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031622612.png" alt="image-20250303162231430" style="zoom:50%;" />
<h2 id="类的生命周期"><a class="header-anchor" href="#类的生命周期"></a>类的生命周期</h2>
<p>类的生命周期描述了一个类加载、使用、卸载的整个过程。类的生命周期主要有五个阶段，分别是：加载、连接(连接里包括验证、准备和解析)、初始化、使用、卸载</p>
<h3 id="应用场景"><a class="header-anchor" href="#应用场景"></a>应用场景</h3>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031631773.png" alt="image-20250303163156675" style="zoom: 50%;" /> 
<h3 id="加载-loading："><a class="header-anchor" href="#加载-loading："></a>加载 loading：</h3>
<ol>
<li>类加载器根据类的全限定名通过不同的渠道以二进制流方式获取字节码信息，开发者可以使用 Java 代码扩展不同的渠道。</li>
<li>类加载完后，jvm 会将字节码中的信息保存到方法区中（方法区是虚拟概念，具体实现有不同），</li>
<li>同时，生成一个 <code>InstanceKlass</code> 对象，保存类的所有信息，里面还包括实现特定功能，如：多态的信息。</li>
<li>除此之外 ，jvm 还会在堆中生成一份和方法区中数据类似的 <code>java.lang.Class</code> 对象，作用是在使用反射时可以在 Java 代码中去获取类的信息以及<strong>存储静态字段的数据</strong>。<code>InstanceKlass</code> 和 <code>java.lang.Class</code> 可以通过一个引用相互关联，<code>InstanceKlass</code> 中信息更丰富，但是有些需要对开发者闭源，并且 <code>InstanceKlass</code> 可以被 C/C++ 操作，是给 JVM 使用的；而 <code>java.lang.Class</code> 是给 Java 开发者使用的。</li>
</ol>
<h3 id="连接-Linking："><a class="header-anchor" href="#连接-Linking："></a>连接 Linking：</h3>
<ul>
<li>
<p><strong>验证</strong>：验证内容是否满足《Java 虚拟机规范》，一般无需开发者参与（参照编译原理的词法、语法检测）</p>
</li>
<li>
<p><strong>准备</strong>：给静态变量分配内存并设置初始值（默认值）</p>
<p>注：如果有 final 关键字，则直接赋值进行初始化。</p>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503031735435.png" alt="image-20250303173545369"></p>
<ul>
<li>
<p><strong>解析</strong>：将常量池中的符号引用替换成指向内存的直接引用</p>
<p>直接引用不在使用编号，而是使用内存中地址来访问具体数据</p>
</li>
</ul>
<h3 id="初始化-initialing："><a class="header-anchor" href="#初始化-initialing："></a>初始化 initialing：</h3>
<ul>
<li>
<p>执行<strong>静态代码块</strong>中的代码，并为静态变量赋值,此处的赋值是程序中定义的值，而非准备阶段的默认值</p>
</li>
<li>
<p>执行字节码文件中 clinit 部分的字节码指令</p>
</li>
<li>
<p>以下几种方式会触发类的初始化：</p>
<ol>
<li>访问一个类的静态变量或者静态方法，注意变量是 <code>final</code> 修饰的并且等号右边是常量不会触发初始化（这种在连接阶段就已经赋好值了）。</li>
<li>调用 <code>Class.forName(String className)</code> 时。</li>
<li><code>new</code> 一个该类的对象时。</li>
<li>执行 <code>Main</code> 方法的当前类。</li>
<li>final 修饰的变量如果赋值的内容需要指令才能得出结果，会执行 clinit 方法进行初始化</li>
</ol>
<p>根据上面的内容可以推导最后结果为 D A C B C B</p>
<ul>
<li>首先是静态代码块，在类初始化时最先打印 “D”</li>
<li>而后 main 方法内的 “A”</li>
<li>之后是创建 Main 对象时：因为初始代码块的优先级高于构造函数
<ul>
<li>先执行初始代码块，打印 “C”</li>
<li>再执行构造函数，打印 “B”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 输出结果: DACBCB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.启动main方法，初始化Main类，先走Main的clinit，执行static代码块，打印D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.打印A</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建Main对象，调用构造方法，先走构造代码块，再走无参构造，打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="comment">// 4.重复创建，再次打印CB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>clinit</code> 指令在特定情况下不会出现，比如：</p>
<ol>
<li>无静态代码块且无静态变量赋值语句。</li>
<li>有静态变量的声明，但是没有赋值语句。</li>
<li>静态变量的定义使用 <code>final</code> 关键字，这类变量会在准备阶段直接进行初始化。</li>
<li>数组的创建不会导致数组中<strong>元素的类</strong>进行初始化。</li>
</ol>
</li>
<li>
<p>如果出现继承，则：</p>
<ol>
<li>直接访问父类的静态变量，不会触发子类的初始化</li>
<li>子类的初始化 <code>clinit</code> 调用前，会先调用父类的 <code>clinit</code> 初始化方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出结果为1</span></span><br><span class="line">        <span class="comment">// 因为是直接使用B02的静态变量，这个时候是只走父类的初始化的</span></span><br><span class="line">        <span class="comment">// 如果在前面加上 new B02();   那么就会打印2</span></span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类加载器"><a class="header-anchor" href="#类加载器"></a>类加载器</h2>
<p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术，只参与<strong>加载过程中的字节码获取并加载到内存</strong>这一部分。通过加载字节码数据放入内存转换成 <code>byte[]</code>，接下来调用虚拟机底层方法将 <code>byte[]</code> 转换成方法区和堆中的数据。</p>
<h3 id="类加载器的分类"><a class="header-anchor" href="#类加载器的分类"></a>类加载器的分类</h3>
<ul>
<li>
<p>虚拟机底层实现：源代码位于 Java 虚拟机的源码中，实现语言与虚拟机底层语言一致，如 hotspot 使用 c++</p>
<p>加载程序运行时的基础类被正确加载，如 java.lang.String，确保其可靠性</p>
</li>
<li>
<p>JDK 中默认提供或自定义：jdk 中默认提供了多种处理不同渠道的类加载器，开发者也可以根据需求定制</p>
<p>继承自抽象类 <code>ClassLoader</code> 的所有类加载器</p>
</li>
</ul>
<p>类加载器的设计 JDK 8 和 8 之后的版本差别较大，JDK 8 及之前的版本中默认的类加载器有如下几种：</p>
<ul>
<li>虚拟机底层实现 c++：启动类加载器 Bootstrap，加载 Java 中最核心的类</li>
<li>Java：扩展类加载器 Extension，允许扩展 Java 中比较通用的类；应用程序加载器 Application，加载应用使用的类</li>
</ul>
<h4 id="启动类加载器"><a class="header-anchor" href="#启动类加载器"></a>启动类加载器</h4>
<p>启动类加载器（Bootstrap ClassLoader）是由 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器。</p>
<p>会默认加载 Java 安装目录下 /jre/lib 的类文件，如 rt.jar、tools.jar、resource.jar等</p>
<p>由启动类加载器加载的<strong>基础类</strong>，无法通过 <code>.class.getClassLoader()</code> 来获取类加载器，因为这种方法获取的类加载器是 Java 的类加载器，而并非虚拟机底层的类加载器。</p>
<p>如果要对核心类进行扩展，可以通过启动类加载器去加载用户 jar 包。可用的方法是使用参数进行扩展，在 IDEA 的运行调试配置中添加 <code>-Xbootclasspath/a:jar包目录/jar包名</code> 来进行扩展。</p>
<h4 id="扩展类加载器"><a class="header-anchor" href="#扩展类加载器"></a>扩展类加载器</h4>
<p>ExtClassLoader</p>
<p>扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器。它们的源码都位于 <code>sun.misc.Launcher</code> 中，是一个静态内部类。继承自 <code>URLClassLoader</code>。具备通过目录或者指定 jar 包将字节码文件加载到内存中。在 JDK 8 中主要用来加载 java 安装目录下 <code>/jre/lib/ext</code> 下的扩展类文件。</p>
<p>扩展类加载器主要加载扩展功能（有些功能我们平时并不常用）。如果我们需要编写一些通用但是不常用的 jar 包，可以通过扩展类加载器来进行加载。在 JDK 8 中可以使用 <code>-Djava.ext.dirs=&quot;原始jar包目录;新增jar包目录&quot;</code> 进行扩展。</p>
<h4 id="应用程序加载器"><a class="header-anchor" href="#应用程序加载器"></a>应用程序加载器</h4>
<p>AppClassLoader</p>
<p>应用程序类加载器主要用来加载 <code>classpath</code> 下的类文件，包括了我们自己编写的 java 文件以及第三方库中的类文件。</p>
<h3 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制"></a>双亲委派机制</h3>
<p>功能：</p>
<ul>
<li><strong>保证类加载的安全性</strong>：通过双亲委派机制避免恶意代码替换 JDK 中的核心类库，如：java.lang.String，确保核心类库的完整性和安全性</li>
<li><strong>避免重复加载</strong>：双亲委派机制可以避免同一个类被多次加载</li>
</ul>
<p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下进行加载</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032118133.png" alt="image-20250303211859044"></p>
<p>每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，避免重复加载。否则会将加载请求委派给父类加载器。如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p>
<ul>
<li>向上查找：如果已经加载过，就直接返回 Class 对象，加载过程结束，就能避免类重复加载</li>
<li>向下尝试加载：起到了加载优先级的作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行类声明周期中的连接阶段</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<p>记住 load 和 find</p>
<p><code>loadClass</code> 方法在实现时有进行加锁操作，目的是为了防止多线程环境下被重复加载，调用 <code>findClass</code> 方法查找类是否已经加载了，如果有则直接返回对象，如果没有则会继续向上查找，直到 <code>parent</code> 为空再去查找启动类加载器；如果都为空，则需要一直委派到自己实现的加载器类</p>
<p><strong>双亲委派的核心逻辑</strong>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032159666.png" alt="image-20250303215959586"></p>
<h3 id="打破双亲委派机制"><a class="header-anchor" href="#打破双亲委派机制"></a>打破双亲委派机制</h3>
<p>打破双亲委派机制的方法有三种：</p>
<h4 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器"></a>自定义类加载器</h4>
<p>自定义类加载器并重写 <code>loadClass</code> 方法，就可以将双亲委派机制的代码去除。Tomcat 通过这种方式实现应用之间的类隔离。</p>
<p>一个 Tomcat 程序中是可以运行多个 Web 应用的，如果这两个应用中出现了相同限定名的类，比如 Servlet 类，Tomcat 要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载 Web 应用 1 中的 <code>MyServlet</code> 之后，Web 应用 2 中相同限定名的 <code>MyServlet</code> 类就无法被加载了。所以，Tomcat 使用了自定义类加载器来实现应用之间类的隔离，每一个应用会有一个独立的类加载器加载对应的类。</p>
<p>正确实现一个<strong>自定义类加载器</strong>的方式是重写 <code>findClass</code> 方法，不会破坏双亲委派机制。</p>
<h4 id="线程上下文类加载器"><a class="header-anchor" href="#线程上下文类加载器"></a>线程上下文类加载器</h4>
<p>利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。</p>
<p>JDBC 中使用了 <code>DriverManager</code> 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。<code>DriverManager</code> 类位于 <code>rt.jar</code> 包中，由<strong>启动类加载器</strong>来加载。而我们自己引入的数据库驱动是由<strong>应用程序类加载器</strong>来加载，这违反了双亲委派机制（按照双亲委派机制的正常逻辑，<code>DriverManager</code> 类无法直接访问由应用程序类加载器加载的 JDBC 驱动类，因为类加载器通常只会访问自己或祖先加载器加载的类。但在 JDBC 场景中，<code>DriverManager</code> 却可以访问这些由应用程序类加载器加载的驱动类）。</p>
<p>JDBC 是如何实现这种 “违反” 双亲委派机制的操作呢？</p>
<p>首先，我们先来解决一个问题，就是：<code>DriverManager</code> 是如何知道 <code>jar</code> 包中要加载的驱动在哪儿的？</p>
<p>实际上，JDBC 采用了 JDK 内置的 SPI（Service Provider Interface）机制：</p>
<blockquote>
<p>SPI机制：</p>
<ol>
<li>
<p>JDBC 定义了一个核心接口 <code>java.sql.Driver</code>，所有数据库驱动都需要实现这个接口。例如：</p>
<ul>
<li>MySQL 的驱动实现类是 <code>com.mysql.cj.jdbc.Driver</code>。</li>
<li>PostgreSQL 的驱动实现类是 <code>org.postgresql.Driver</code>。</li>
</ul>
</li>
<li>
<p>每个数据库驱动的 JAR 包中，都会包含一个 SPI 配置文件来主动暴露自己的实现类类名，路径为： <code>META-INF/services/java.sql.Driver</code></p>
<p>配置文件的内容是实现类的全限定名。例如，MySQL 的配置文件中内容为：<code>com.mysql.cj.jdbc.Driver</code></p>
</li>
<li>
<p><code>ServiceLoader</code> 扫描 <code>META-INF/services/java.sql.Driver</code>  文件，找到所有实现了 <code>java.sql.Driver</code> 接口的类、使用类加载器加载驱动类、而后注册驱动到 <code>DriverManager</code>、最后根据 URL 选择合适的驱动创建连接</p>
</li>
</ol>
</blockquote>
<p>观察加载过程我们发现，<strong>驱动文件确实是由应用程序类加载器来加载的</strong>，那么，SPI 中是又是如何获取到应用程序类加载器的呢？实际上，SPI 中使用了线程上下文中保存的类加载器进行类加载（<code>Thread.currentThread().getContextClassLoader()</code>），而被保存的这个类加载器一般是应用程序类加载器（通过该线程上下文可以在程序任何地方获取到类加载器）。</p>
<p>不过，JDBC 只是在 <code>DriverManager</code> 加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依旧遵循双亲委派机制，所以，从这个角度上看，JDBC 的驱动加载并不会真正打破双亲委派机制。</p>
<h4 id="Osgi-框架的类加载器"><a class="header-anchor" href="#Osgi-框架的类加载器"></a>Osgi 框架的类加载器</h4>
<p>历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载。Osgi 还是用类加载器实现了热部署（指在服务不停止的情况下，动态更新字节码文件到内存中）的功能。</p>
<p>不过，现如今我们可以使用 Arthas 来帮助我们进行热部署，基本步骤如下：</p>
<ol>
<li>在服务器上部署 arthas，并启动。</li>
<li><code>jad --source-only 类全限定名 &gt; 目录/文件名.java</code>，利用 <code>jad</code> 命令反编译，然后可以用其他编译器，比如 vim 来修改源码。</li>
<li><code>sc -d 类全限定名</code>，利用 <code>sc</code> 命令查看类对应的类加载器 hashcode。</li>
<li><code>mc -c 类加载器的hashcode 目录/文件名.java -d 输出目录</code>，使用 <code>mc</code> 命令来编译修改过的代码。</li>
<li><code>retransform class文件所在目录/xxx.class</code>，用 <code>retransform</code> 命令加载新的字节码。</li>
<li><strong>注意事项</strong>：程序重启之后，字节码文件会恢复（因为 <code>retransform</code> 是做内存上的更新），除非将 class 文件放入 jar 包中进行更新。并且，<code>retransform</code> 也不能添加方法或者字段，也不能更新正在执行中的方法。（只能当做一种应急手段）</li>
</ol>
<h3 id="JDK-9-之后的类加载器"><a class="header-anchor" href="#JDK-9-之后的类加载器"></a>JDK 9 之后的类加载器</h3>
<p>JDK 9 引入了 module 的概念，类加载器设计上有了很多变化</p>
<ol>
<li>
<p>启动类加载器使用 Java 编写，位于 <code>jdk.internal.loader.ClassLoader</code> 类中。Java 中的 <code>BootClassLoader</code> 继承自 <code>BuiltinClassLoader</code>，实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过 java 代码获取到，返回的仍然是 null，保持了统一。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936205.png" alt="image-20250304093613115"></p>
</li>
<li>
<p>扩展类加载器被替换成了平台类加载器（Platform Class Loader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，<strong>自身没有特殊逻辑</strong>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040936512.png" alt="image-20250304093642439"></p>
</li>
<li>
<p>应用程序类加载器的继承关系发生了改变，从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，其余没有特殊变化。</p>
</li>
</ol>
<h2 id="JMM运行时数据区"><a class="header-anchor" href="#JMM运行时数据区"></a>JMM运行时数据区</h2>
<h3 id="什么是运行时数据区"><a class="header-anchor" href="#什么是运行时数据区"></a>什么是运行时数据区</h3>
<p>运行时数据区指的是：jvm 在运行 Java 程序过程中管理的内存区域</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040942498.png" alt="image-20250304094232418" style="zoom:67%;" />
<blockquote>
<p>线程不共享：每当创建一个线程，每一个线程都有一份独立的<strong>程序计数器、Java 虚拟机栈、本地方法栈</strong>，数据不共享，但安全性高</p>
<p>线程共享：数据共享，每个线程都可以获取与使用，线程不安全</p>
</blockquote>
<h3 id="程序计数器"><a class="header-anchor" href="#程序计数器"></a>程序计数器</h3>
<p>程序计数器（Program Counter Register），也叫 PC 寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令地址。</p>
<p>加载阶段，jvm 讲字节码文件中的指令读取到内存后，会将原文件中的偏移量转换成内存地址。每一天字节码指令都会有一个内存地址。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503040953897.png" alt="image-20250304095304805" style="zoom:67%;" />
<p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p>
<p>在多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到的那一句指令并继续执行</p>
<blockquote>
<p><strong>内存溢出</strong>是指程序在使用某一刻区域时，存放的数据需要占用的内存大小超出了虚拟机可以提供的内存上限</p>
<p>每个线程只存储固定长度的内存地址，因此程序计数器不会发生内存溢出</p>
</blockquote>
<h3 id="栈"><a class="header-anchor" href="#栈"></a>栈</h3>
<h4 id="Java-虚拟机栈"><a class="header-anchor" href="#Java-虚拟机栈"></a>Java 虚拟机栈</h4>
<p>Java 虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，FILO，每个方法的调用使用一个栈帧（Stack Frame）来保存</p>
<p>Java 代码在遇到异常，报错的时候，会把异常时的栈帧信息打印出来。也就是说，发生异常时，控制台上打印出来的，是栈帧信息。</p>
<p>Java 虚拟机栈随线程创建而创建，而回收则会在线程的销毁时进行。</p>
<h4 id="栈帧的组成"><a class="header-anchor" href="#栈帧的组成"></a>栈帧的组成</h4>
<ul>
<li>
<p>局部变量表：主要作用是方法执行过程中存放所有的局部变量。编译成字节码文件时就可以确定局部变量表的内容。栈帧中的局部变量表本质上是一个数组，数组中每个位置称之为槽（slot），long 和 double 类型占用两个槽，其他类型占用一个槽</p>
<p>在字节码文件记录的局部变量表信息中，<code>Nr.</code> 表示局部变量的编号，<code>起始PC</code> 和 <code>长度</code> 划定了局部变量生效的范围，<code>序号</code> 表示变量在栈帧中槽的起始编号。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041017338.png" alt="image-20250304101742258" style="zoom: 80%;" />
<p>实例方法中的序号为 0 的位置存放的是 this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041018955.png" alt="image-20250304101808880"></p>
<p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致</p>
<p>局部变量表会保存的内容有：实例方法的 <code>this</code> 对象，方法的参数，方法体中声明的局部变量</p>
<p>为了节省空间，局部变量表中的槽可以复用，一旦某个局部变量不再失效，当前槽可以再次被使用。当某个变量已经不再被使用，则可以将变量丢弃后把槽给新的变量使用。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041023902.png" alt="image-20250304102312810" style="zoom:80%;" />
</li>
<li>
<p>操作数栈：是在虚拟机执行指令过程中存放临时数据或中间数据的，也是一种栈式结构，在编译期就可以确定操作数栈的最大深度，进而在执行时正确分配内存大小</p>
</li>
<li>
<p>帧数据：主要包含动态链接、方法出口、异常表的引用。</p>
<p><strong>动态链接</strong>：当前类的字节码指令引用了其他类的属性或方法时，需要将符合引用（编号）转换成对应的运行时常量池中的内存地址，动态链接（类似于一个map表）就保存了编号到运行时常量池的内存地址的映射关系。</p>
<p><strong>方法出口</strong>：方法在正确或异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址，所以当前栈帧中，需要存储此方法出口的地址</p>
<p><strong>异常表</strong>：存放代码异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p>
</li>
</ul>
<p>每个栈的空间是有限的，如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出，出现 <code>StackOverflowError</code> 的错误（系统级错误，程序无法运行）。虚拟机设置中，可以使用 <code>-Xss栈大小</code> 来设置栈帧最大大小，不过必须是 <em>1024</em> 的倍数。Win（64位）下的 JDK 8 测试最小值位 180 K，最大为 1024 M。一般来说，工作中即使使用了递归操作，栈的深度最多也只能到几百，不会出现栈溢出。所以可以手动指定参数为 <code>-Xss256k</code> 来节省内存。</p>
<h4 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"></a>本地方法栈</h4>
<p>除了 Java 虚拟机，栈区还包括本地方法栈。Java 虚拟机栈存储了 Java 方法调用时的栈帧，而本地方法栈存储的是 native 本地方法的栈帧。在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存中生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。(了解即可)</p>
<h3 id="堆"><a class="header-anchor" href="#堆"></a>堆</h3>
<ul>
<li>
<p>一般 Java 程序中堆内存是空间<strong>最大的一块内存</strong>区域。创建出来的对象都存在堆上。</p>
<p>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<p>堆内存大小是有上限的，当对象一直向堆中放入对象达到上限后，就会抛出 <code>OutOfMemory</code> 错误。</p>
</li>
<li>
<p>堆空间有三个需要关注的值：used、total、max。</p>
<ul>
<li>used 指的是当前已经使用的堆内存，</li>
<li>total 指的是 Java 虚拟机已经分配的可用堆内存</li>
<li>max 是 Java 虚拟机可以分配的最大堆内存</li>
</ul>
<p>随着堆中的对象增多，当 total 可以使用的内存即将不足时，jvm 会继续分配内存给堆。【注：并不是当 used = max = total】时，堆内存才溢出，堆内存溢出的判断条件比较复杂，在垃圾回收章节再详细介绍。</p>
</li>
<li>
<p>如果不设置任何的虚拟机参数，max 默认是系统内存的四分之一，total 默认是系统内存的六十四分之一。在实际应用中一般都需要 total 和 max 的值。使用 <code>-Xmx</code> 修改 max 值（必须大于 2 M），<code>-Xms</code> 修改 total 值（必须大于 1 M）。在服务端程序开发时，建议将 max 值和 total 值设置为相同的值，这样程序启动后可使用的总内存就是最大内存，无需向 JVM 申请，减少申请空间的额外开销</p>
</li>
<li>
<p>需要注意的是，如果使用 Arthas 显示 heap 堆大小，会发现其和设置的值并不相同。这是因为 Arthas 使用的是 JMX 技术中的内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。</p>
</li>
</ul>
<h3 id="方法区"><a class="header-anchor" href="#方法区"></a>方法区</h3>
<p>方法区是《Java 虚拟机规范》中设计的虚拟概念，每款虚拟机设计各不相同。Hotspot 的设计如下：</p>
<ul>
<li>JDK 7 及之前的版本将方法存放在<strong>堆区域</strong>中的永久代空间里，堆的大小由虚拟机参数 <code>-XX:MaxPermSize=值</code> 控制。</li>
<li>JDK 8 及之后的版本将方法去存放在<strong>元空间</strong>中，元空间位于操作系统维护的<strong>直接内存</strong>中，默认情况下只要不超过系统承受的上限，可以一直分配。可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大大小进行限制。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041446781.png" alt="方法区不同JDK版本中实现对比图"></p>
<p>方法区是存放基础信息的位置，线程共享，主要包含三个内容：</p>
<p><strong>类的元信息</strong>：保存所有类的基本信息</p>
<ul>
<li>存储每个类的基本信息（元信息），一般称之为 InstanceKlass 对象。在类<strong>加载阶段</strong>完成。</li>
</ul>
<p><strong>运行时常量池</strong>：保存字节码文件中的常量池内容</p>
<ul>
<li>字节码文件中是通过编号查表的方式找到常量的，这种常量池称之为静态常量池。</li>
<li>当常量池加载到内存中后，可以通过内存地址快速的定位常量池中的内容，这种常量池称之为动态常量池</li>
<li>核心：将原本由编号查询常量的方式替换成用内存地址的方式去查询</li>
</ul>
<p><strong>字符串常量池</strong>：（字节码文件中有一部分区域时字符串常量池）字符串常量池存储在代码中定义的常量字符串内容</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041529238.png" alt="image-20250304152918152"></p>
<p>与运行时常量池作用接近：早期设计中，字符串常量池是属于运行时常量池的一部分，存储的位置也一致。后续做出了调整，进行了拆分</p>
<ul>
<li>JDK 7 之前：运行时常量池包含了字符串常量池，都位于永久代中</li>
<li>JDK 7 ：字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li>
<li>JDK 8 ：永久代修改为元空间，字符串常量池还在堆中</li>
</ul>
<p>可以使用 <code>intern</code> 方法主动把字符串放到字符串常量池中，JDK 6 版本的 <code>intern</code> 方法会把第一次遇到的字符串实例复制一份到字符串常量池中；而 JDK 7 及以后因为字符串常量池就在堆上，故是在堆上复制一个引用到字符串常量池中。并且，因为载入基础包等原因，JVM 在加载后，字符串常量池中会默认加载完毕 <code>java</code> 等字符串。</p>
<p>【注：在不同版本的 JDK 当中，静态变量的存放也是不同的，在 JDK 6 及其之前版本，静态变量存放在方法区也就是永久代中，JDK 7 之后的版本中，静态变量是存放在堆区的 Class 对象中，脱离了永久代】</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041449067.png" alt="JDK6 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451007.png" alt="JDK7 的 运行时数据区结构"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503041451165.png" alt="JDK8 的 运行时数据区结构"></p>
<h3 id="直接内存"><a class="header-anchor" href="#直接内存"></a>直接内存</h3>
<p>直接内存（Direct Memory）并不在《Java 虚拟机规范》中存在，所以<strong>并不属于 Java 运行时的内存区域</strong>，而是由操作系统本地分配的内存区域。虽然直接内存不是虚拟机运行时数据区的一部分，但是使用也被频繁使用，也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>在 JDK 1.4 中引入了 NIO（Non-Blocking I/O，也被称为 New I/O） 机制，使用了直接内存，主要为了解决两个问题：</p>
<ol>
<li>Java 堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li>
<li>IO 操作，如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到 Java 堆中，现在直接放入直接内存即可，同时 Java 堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路</li>
</ol>
<p>要创建直接内存上的数据，可以使用 <code>ByteBuffer</code>，语法（Arthas 的 <code>memory</code> 命令可以直接查看直接内存的大小，属性名 <code>direct</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(size);</span><br></pre></td></tr></table></figure>
<p>如果要手动调整直接内存的大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code>，来为 JVM 的直接内存分配大小。</p>
<h2 id="自动垃圾回收"><a class="header-anchor" href="#自动垃圾回收"></a>自动垃圾回收</h2>
<p>在 C/C++ 这类没有自动垃圾回收机制的语言中，一个对象如果不在使用需要手动释放，否则会造成<strong>内存泄漏</strong>的问题（内存泄漏的累计会导致内存溢出）。释放对象的过程称之为垃圾回收，而程序员需要手动编码进行回收的方式称之手动回收。</p>
<p>Java 中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection 简称 GC）机制。通过垃圾回收器来对不在使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言，如 C#、Python、Go 都有自己的垃圾回收器。如果想要查看垃圾回收的信息，可以通过 <code>verbose:gc</code> 参数。</p>
<p>线程不共享的部分（程序计数器、Java 虚拟机栈、本地方法栈），都是随着线程的创建而创建、线程的销毁而销毁。方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。</p>
<h3 id="方法区的回收"><a class="header-anchor" href="#方法区的回收"></a>方法区的回收</h3>
<p>方法区中能回收的内容主要是不在使用的类。判定一个类是否可以被<strong>卸载</strong>（类的生命周期当中最后一个），需要同时满足三个条件：</p>
<ol>
<li>
<p>（没有可以使用的东西了）此类所有<strong>实例对象都已经被回收</strong>，在堆中已经不存在任何该类的实例对象以及子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（连加载它的都没了）加载该类的<strong>类加载器已经被回收</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:D:\\lib\\&quot;</span>)&#125;</span><br><span class="line">);</span><br><span class="line">loader = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（没有任何地方用到）该类对应的 java.lang.Class 对象没有在任何地方被引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;cn.scut.my.A&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果需要手动触发垃圾回收，可以调用 <code>System.gc</code> 方法。调用该方法并不一定会立即触发垃圾回收，仅仅是发送一个请求，具体是否执行回收操作由 Java 虚拟机自行判断</p>
<p>开发中此类场景一般很少出现，主要是在 OSGI、JSP 的热部署等应用场景中，每个 jsp 文件对应一个唯一的类加载器，当一个 jsp 文件修改了，就直接卸载这个 jsp 类加载器。重新创建类加载器，重新加载 jsp 文件。</p>
<h3 id="堆回收"><a class="header-anchor" href="#堆回收"></a>堆回收</h3>
<p>Java 中的对象是否能够被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许回收。</p>
<p>判断堆上的对象是否被引用的判断方法：引用计数法和可达性分析法。</p>
<h4 id="引用计数法"><a class="header-anchor" href="#引用计数法"></a>引用计数法</h4>
<p>引用计数法会为每个对象维护一个引用计数器（初始值为 0），当对象被引用时加 1，取消引用时减 1。</p>
<p>优点：实现简单，C++ 中的智能指针就是采用了引用计数法</p>
<p>缺点：</p>
<ol>
<li>每次引用和取消引用都需要维护计数器，影响性能</li>
<li>存在循环引用的问题，当 A 中有 B，B 中有 A 的情况下，会出现 AB 都无法回收的问题。</li>
</ol>
<h4 id="可达性分析-强引用"><a class="header-anchor" href="#可达性分析-强引用"></a>可达性分析&amp;强引用</h4>
<p>【这种通过 GC Root 对象与普通对象之间产生的引用关系称之为<strong>强引用</strong>】</p>
<p>Java 使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。</p>
<p>可达性算法基础：所有普通对象都会和根对象形成引用关系，</p>
<p>可达性算法：如果某个对象是从 GC Root 可以沿着引用链到达，那么该对象就不会回收。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503190907192.png" alt="可达性算法演示图"></p>
<p>GC Root 对象主要有（预先规定好）：</p>
<ul>
<li>线程 Thread 对象，引用线程栈帧中的<strong>方法参数、局部变量</strong>等。</li>
<li>系统类加载器加载的 java.lang.Class 对象，引用类中的静态变量</li>
<li>监视器对象，用来保存同步锁 synchronized 关键字持有的对象。</li>
<li>本地方法调用时使用的全局对象。</li>
</ul>
<h4 id="五种对象引用"><a class="header-anchor" href="#五种对象引用"></a>五种对象引用</h4>
<p>可达性算法中描述的对象引用，一般指的是<strong>强引用</strong>，即 GC Root 对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外还有其他 4 种对象引用</p>
<h5 id="软引用"><a class="header-anchor" href="#软引用"></a>软引用</h5>
<p>弱于强引用，如果一个对象只有软引用关系，那么当<strong>程序内存不足时，就会将软引用中的数据回收</strong>，释放内存，在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用，<strong>软引用常用于缓存中</strong>。使用的时候，通过要让 GC Root 来关联 <code>SoftReference</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据放入软引用中</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(bytes);</span><br></pre></td></tr></table></figure>
<p>软引用的对象会在内存不足时被回收，但 SoftReference 对象本身也需要被回收，如何知道 SoftReference 对象需要回收？SoftReference 提供了一套队列机制：</p>
<ol>
<li>软引用创建时，通过构造器传入引用队列</li>
<li>在软引用中包含的对象被回收时，该软引用对象会被放入引用队列</li>
<li>通过代码遍历引用队列，将 SoftReference 的强引用删除</li>
</ol>
<h5 id="弱引用"><a class="header-anchor" href="#弱引用"></a>弱引用</h5>
<p>整体机制和软引用几乎一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收，jdk 1.2 版本之后提供了 WeakReference 类来实现弱引用，弱引用主要是 <strong>ThreadLocal</strong> 中使用。弱引用对象本身也可以使用队列进行回收。（平时开发使用概率不大）</p>
<h5 id="虚引用和终结器引用"><a class="header-anchor" href="#虚引用和终结器引用"></a>虚引用和终结器引用</h5>
<p>在常规开发中不会使用的</p>
<p><strong>虚引用也叫幽灵引用/幻影引用</strong>，不能通过虚引用对象获取包含的对象。虚引用唯一的作用是：当对象被垃圾回收器回收时，可以接收到对应的通知。java 中使用 PhantomReference 实现虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</p>
<p><strong>终结器引用</strong>：在对象需要回收时，对象将会放置在 Finalize 类中的引用队列中，并在稍后由一条由 FinalizerThread 线程从队列中获取对象，然后执行对象的 finalize 方法。在这个过程中可以在 finalize 中再将自身对象使用强引用关联上，但不建议，如果耗时太长会影响其他对象的回收。</p>
<h2 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法"></a>垃圾回收算法</h2>
<p>简单来说，垃圾回收需要做的就是两件事：</p>
<ol>
<li>找到内存中存活的对象</li>
<li>释放不再存活对象的内存，让这部分空间可以再次被利用</li>
</ol>
<h3 id="垃圾回收算法的评价标准"><a class="header-anchor" href="#垃圾回收算法的评价标准"></a>垃圾回收算法的评价标准</h3>
<p>java 垃圾回收过程会通过单独的 GC 线程来完成，不管哪一种 GC 算法，都会有部分阶段需要停止所有用户线程。这个过程称之为 Stop The World 简称 STW，如果 STW 时间过长则会影响用户的使用。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191417580.png" alt="程序运行过程中 STW 的发生"></p>
<p>三个评价标准：</p>
<p><strong>吞吐量</strong>：指的是 CPU 用于执行用户代码的时间和 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 / (执行用户代码时间 + GC 时间)。吞吐量越高，垃圾回收效率也高</p>
<p><strong>最大暂停时间</strong>：指的是所有在垃圾回收过程中的 STW 时间最大值</p>
<p><strong>堆使用效率</strong>：不同算法，对堆内存的使用方式不同，如标记清除算法、使用的是完整的堆内存；复制算法则会将堆一分为二，每次只使用一半内存。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191423557.png" alt="标记清除算法和复制算法对比图"></p>
<p>三个指标是类似于 CAP 的不可能三角问题，不可兼得：堆内存越大，STW 越长；而 STW 减少，势必导致吞吐量降低。根据合适的场景选择算法</p>
<h3 id="标记清除算法"><a class="header-anchor" href="#标记清除算法"></a>标记清除算法</h3>
<p>核心思想：将垃圾回收分为两个阶段，标记阶段和清除阶段</p>
<p><strong>标记阶段</strong>：将所有存活的对象进行标记，java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191431447.png" alt="标记阶段"></p>
<p><strong>清除阶段</strong>：从内存中删除没有被标记（也就是非存活）的对象。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191431052.png" alt="清除阶段"></p>
<p>优点：实现简单，只需要在第一阶段给每个对象维护一个标记位，第二个阶段根据标记位进行删除即可</p>
<p>缺点：</p>
<ul>
<li>碎片化问题：如图所示，会有大量的不连续空间，导致看似有很多空闲空间，但是实际去申请时很多碎片无法被利用（当申请空间较大时）</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191432814.png" alt="碎片化问题图示"></p>
<ul>
<li>分配速度慢：由于碎片的存在，需要额外维护一个空闲链表，最坏情况可能需要 o(n) 才能找到合适的空闲空间分配内存。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191434891.png" alt="空闲链表分配内存"></p>
<h3 id="复制算法"><a class="header-anchor" href="#复制算法"></a>复制算法</h3>
<p>核心是：将内存一分为二：</p>
<ol>
<li>From 空间和 To 空间，每次对象分配阶段，只能使用 From 空间。</li>
<li>垃圾回收时，将 From 中存活的对象复制到 To 空间，本质就是把 GC Root 对象搬运到 To 空间后再把 GC Root 关联的对象也搬运到 To 空间。</li>
<li>而后清理掉 From 中没有被复制的（也就是非存活的）对象。</li>
<li>最后将两块空间的 From 和 To 名字互换。</li>
</ol>
<p>优点：</p>
<ol>
<li>吞吐量高：只需要遍历一次存活对象而后复制到 To 空间即可，比标记清除算法少一次遍历</li>
<li>不会发生碎片化：按对象顺序复制到 To 空间，剩余的都是连续可用的内存空间</li>
</ol>
<p>缺点：堆内存使用效率低，只有一般都内存可以使用</p>
<h3 id="标记整理算法"><a class="header-anchor" href="#标记整理算法"></a>标记整理算法</h3>
<p>也叫<strong>标记压缩算法</strong>，针对标记清理算法碎片化问题的一种优化</p>
<p>分为两个阶段：</p>
<ol>
<li>标记阶段：将所有存活对象进行标记，java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象
<ol>
<li>整理（➕ 清理）阶段：将存活对象移动到堆的一端，清理掉其他的非存活对象的内存空间</li>
</ol>
</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191443452.png" alt="标记和整理阶段"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191444164.png" alt="整理和清理阶段"></p>
<h3 id="分代-GC-算法"><a class="header-anchor" href="#分代-GC-算法"></a>分代 GC 算法</h3>
<p>如今使用最广的算法：</p>
<p>将内存整体划分为：</p>
<p>Young 区（年轻代/新生代）：存活时间比较短的对象，使用的是<strong>复制算法</strong>*</p>
<ul>
<li>伊甸园区 eden_space：对象刚刚创建出来存放的地方</li>
<li>幸存区(survivor_space)分为 S0 和 S1：用于实现复试算法</li>
</ul>
<p>Old 区(tenured_gen)（老年代）：存活时间比较长的对象，使用的是<strong>标记-清除和标记-整理</strong>算法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191452521.png" alt="分代 gc 算法的内存划分"></p>
<p>在 JDK 8 中，添加 <code>-XX:+UserSerialGC</code> 参数使用分代回收的垃圾回收器，运行程序。在 Arthas 中使用 <code>memory</code> 命令查看内存，显示出上述几个区域的使用情况。</p>
<h4 id="算法流程"><a class="header-anchor" href="#算法流程"></a>算法流程</h4>
<ol>
<li>分代回收算法中，创建出来的对象会先放入 Eden 区</li>
<li>直到 Eden 区填满，新创建对象无法放入,触发年轻代的 GC 机制，称之为 Minor GC 或 Young GC：Minor GC 会根据可达性分析算法将 eden 和 from 这两个区中需要回收的对象进行回收，把没有回收的对象放入 to 区，</li>
<li>而后将 from 区和 to 区名字互换，重复第 2 阶段</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191505388.png" alt="Minor GC 完成前" style="zoom: 80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191505614.png" alt="Minor GC 完成后" style="zoom: 80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191508837.png" alt="image-20250319150812753"  />
<ol start="4">
<li>每次 Minor GC 都会为对象记录他的年龄，初始值为 0，每进行一次 GC 会加一，当对象年龄到达 15（最大值，具体的默认值与连接回收器有关），对象会从新生代晋升到老年代；</li>
<li>当老年代空间不足（如图），无法放入新的对象时，先尝试 Minor GC （此时有一种特殊情况：新生代满了会进行 Minor GC，如果 Minor GC 之后如果新生代还是不足，一些年龄未达标的对象也会有“要存入”老年代的操作，但是事实上无法存入，就会触发 Full GC），如果还是不足，则会触发 Full GC，对整个堆进行垃圾回收（之所以先进行 Minor GC，是因为，如果新生代在清理完之后还能先继续承担一部分对象，且这部分对象并不一定会移入老年代）</li>
<li>如果 Full GC 依然无法回收老年代的对象，那么当对象继续放入老年代时，就会报错 “out of memory”。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191515616.png" alt="老年代已满"></p>
<p>思考：</p>
<p>为什么划分老年代和新生代，这种设计的原理依据是什么：因为系统中创建的大部分对象都是临时使用，使用完以后就可以被释放了；老年代中存放的是长期存活的对象，比如 Spring 的 bean 对象，在程序启动后不会被回收，所以新生代的大小默认小于老年代。接近于 3:7 的比例</p>
<h2 id="垃圾回收器"><a class="header-anchor" href="#垃圾回收器"></a>垃圾回收器</h2>
<p>垃圾回收器是垃圾回收算法的具体实现。</p>
<p>根据分代 GC 算法，可以将垃圾回收器分为年轻代和老年代，除了 G1 之外其他垃圾回收器必须成对组合进行使用。具体关系图如下：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191600287.png" alt="不同垃圾回收器的组合关系"></p>
<h3 id="组合一"><a class="header-anchor" href="#组合一"></a>组合一</h3>
<h4 id="Serial-垃圾回收器"><a class="header-anchor" href="#Serial-垃圾回收器"></a>Serial 垃圾回收器</h4>
<p>Serial 是一种<strong>单线程串行回收</strong>年轻代的垃圾回收器，使用<strong>复制算法</strong>回收年轻代，进行垃圾回收操作时，会阻塞用户线程，对 Eden 区和 From 区进行回收。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191616733.png" alt="串行回收"></p>
<p>优点：单 CPU 处理器下吞吐量较高</p>
<p>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程被阻塞太长时间</p>
<p>可用场景比较少。</p>
<h4 id="SerialOld-垃圾回收器"><a class="header-anchor" href="#SerialOld-垃圾回收器"></a>SerialOld 垃圾回收器</h4>
<p>SerialOld 垃圾回收器是 Serial 回收器的老年代版本，也是采用<strong>单线程进行回收</strong>。针对老年代区使用的算法是<strong>标记-整理算法</strong>，使用 <code>-XX:+UseSerialGC</code> 可以让新生代、老年代都是用串行回收器。</p>
<ul>
<li>优点：单 CPU 处理器下吞吐量非常出色。</li>
<li>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待。</li>
<li>使用场景：与 Serial 垃圾回收器搭配使用，或者在 CMS 特殊情况下使用。</li>
</ul>
<h3 id="组合二"><a class="header-anchor" href="#组合二"></a>组合二</h3>
<h4 id="ParNew-垃圾回收器"><a class="header-anchor" href="#ParNew-垃圾回收器"></a>ParNew 垃圾回收器</h4>
<p>parNew 年轻代垃圾回收器本质上是对 Serial 在多 CPU 下的优化，使用<strong>多线程</strong>进行垃圾回收。使用 <code>-XX:+UseParNewGC</code> 可以让新生代使用 ParNew 回收器，老年代使用串行回收器。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191623637.png" alt="parNew 多线程进行垃圾回收"></p>
<ul>
<li>优点：多 CPU 处理器下停顿时间较短。</li>
<li>缺点：吞吐量和停顿时间不如 G1，所以在 JDK 9 之后不建议使用。</li>
<li>使用场景：JDK 8 及之前的版本中，与 CMS 老年代回收器搭配使用。</li>
</ul>
<h4 id="CMS-Concurrent-Mark-Sweep-垃圾回收器"><a class="header-anchor" href="#CMS-Concurrent-Mark-Sweep-垃圾回收器"></a>CMS(Concurrent Mark Sweep)垃圾回收器</h4>
<p>CMS 垃圾回收器关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少用户线程的等待时间，参数：<code>-XX:+UseConcMarkSweepGC</code>。使用标记清除（整理）算法回收老年代</p>
<ul>
<li>优点：系统由于垃圾回收出现的停顿时间较短，用户体验好</li>
<li>缺点：内存碎片化问题、退化问题、浮动垃圾问题</li>
<li>适用场景：大型的互联网系统中用户请求数据量大、频率高的场景，如订单接口、商品接口等</li>
</ul>
<p>CMS 执行步骤：</p>
<ol>
<li>初始标记：用极短的时间标记出 GC Roots 可达的对象</li>
<li>并发标记：标记所有对象，用户线程不需要暂停</li>
<li>重新标记：由于并发标记阶段有些对戏发生了变化，存在错标、漏标等问题，需要重新标记。</li>
<li>并发清理：清理死亡对象，用户线程不需要暂停</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191631079.png" alt="cms 执行步骤"></p>
<p>CMS 存在的问题：</p>
<ul>
<li>使用了标记-清除算法，垃圾清理完之后会产生大量的内存碎片，会在 full gc 时进行碎片的整理，这个操作会导致用户线程暂停，可以使用 <code>-XX：CMSFullGCsBeforeCompaction=N</code> 参数（默认为 0）调整 N 次 Full GC 之后再整理，但是最终还是得整理</li>
<li>无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。</li>
<li>如果老年代内存不足无法分配对象，CMS 会退化成 Serial Old 单线程回收老年代</li>
</ul>
<h3 id="组合三"><a class="header-anchor" href="#组合三"></a>组合三</h3>
<h4 id="Parallel-Scavenge-垃圾回收器"><a class="header-anchor" href="#Parallel-Scavenge-垃圾回收器"></a>Parallel Scavenge 垃圾回收器</h4>
<p>JDK 8 默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备<strong>自动调整堆内存大小</strong>的特点，使用复制算法对年轻代进行回收，参数：<code>-XX:+UseParallelGC</code>。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191641532.png" alt="ps 垃圾回收过程"></p>
<ul>
<li>优点：吞吐量高，且手动可控，为了提高吞吐量，jvm 会动态调整堆的参数</li>
<li>缺点：不能保证单次的停顿时间</li>
<li>适用场景：后台任务，不需要与用户交互，并且容易产生大量对象，如大数据的处理、大文件导出</li>
</ul>
<p>Oracle 官方建议在使用 Parallel Scavenge 和 Parallel Old 这个组合的时候，<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整堆内存大小。</p>
<ul>
<li>最大暂停时间：<code>-XX:MaxGCPauseMillis=n</code>，设置每次垃圾回收时的最大停顿毫秒数。</li>
<li>吞吐量：<code>-XX:GCTimeRatio=n</code>，设置吞吐量为 n（<code>用户线程执行时间 = n / n + 1</code>）。</li>
<li>自动调整内存大小：<code>-XX:+UseAdaptiveSizePolicy</code> 设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小。</li>
</ul>
<h4 id="Parallel-Old-垃圾回收器"><a class="header-anchor" href="#Parallel-Old-垃圾回收器"></a>Parallel Old 垃圾回收器</h4>
<p>Parallel Old 是为 Parallel Scavenge 设计的老年代版本，利用<strong>多线程并发</strong>回收。对老年代区域使用标记 - 整理算法。参数：<code>-XX:+UseParallelOldGC</code>。</p>
<ul>
<li>优点：并发执行，在多核 CPU 下效率较高。</li>
<li>缺点：暂停时间会比较长。</li>
<li>使用场景：与 Parallel Scavenge 配套使用。</li>
</ul>
<h3 id="G1-垃圾回收器"><a class="header-anchor" href="#G1-垃圾回收器"></a>G1 垃圾回收器</h3>
<p>JDK 9 之后默认的垃圾回收器是 G1 垃圾回收器（jdk 9 之后建议使用 G1 垃圾回收器）</p>
<p>Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小</p>
<p>CMS 关注暂停时间，但是吞吐量会下降</p>
<p>G1 垃圾回收器综合了以上两种垃圾回收器的优点：</p>
<ul>
<li>支持巨大的堆空间回收，并有较高的吞吐量</li>
<li>支持多 CPU 并行垃圾回收</li>
<li>允许用户设置最大暂停时间</li>
</ul>
<p>G1 的整个堆被划分成多个大小相等的区域，称之为区 region，区域不要求是连续的。</p>
<p>分为 eden、survior、old 区。region 的大小通过堆空间大小 / 2048 计算得到，也可以通过参数 -XX:G1HeapRegionSize = 32m 指定（其中 32m 指定 region 大小为 32m），region size 必须是 2 的指数幂，范围是 1~32 M。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191703529.png" alt="堆空间划分示意图"></p>
<p>G1 垃圾回收器两种方式：</p>
<h4 id="年轻代回收-Young-GC"><a class="header-anchor" href="#年轻代回收-Young-GC"></a>年轻代回收 Young GC</h4>
<p>回收 eden 区和 survivor 区中不可用的对象。会导致 STW，G1 中可以通过参数 -XX:MaxGCPauseMillis=n（默认 200）设置每次垃圾回收时的最大暂停时间（毫秒级），G1  垃圾回收器会尽可能保证暂停时间</p>
<p><strong>执行流程</strong>：</p>
<ol>
<li>新创建的对象会存放在 eden 区，当 G1 判断年轻代区不足（max 默认 60%），无法分配对象，需要回收时会执行 Young GC</li>
<li>标记出 eden 和 survivor 区域中的存活对象</li>
<li>根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的 survivor 区（年龄➕1），情况区域。</li>
</ol>
<p>G1 在进行 Young GC 的过程中会去记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个 Region 区域了。<br>
比如 <code>-XX:MaxGCPauseMillis=n</code>（默认200），每个 Region 回收耗时 40 ms，那么这次回收最多只能回收 4 个 Region。</p>
<ol start="4">
<li>后续 Young GC 时与之前差不多，只不过 survivor 区中存活对象会被搬运到另一个 survivor 区</li>
<li>当某个存活对象年龄达到阈值（默认 15），将会放入老年代当中。</li>
<li>部分对象大小超过 region 的一半，会直接放入老年代，这些老年代被成为 humongous 区。例如：堆内存是 4G，每个 region 2m，只要一个大对象超过了 1m 就会被放入 humongous 区，如果对象过大会横跨多个 region。</li>
<li>多次回收后，old 区会积累，直到达到一定的阈值（<code>-XX:initiatingHeapOccupancyPercent</code> 默认为 45%）会触发混合回收 MixedGC，回收所有年轻代和部分老年代的对象以及大对象区，采用复制算法来实现。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191715558.png" alt="触发混合回收"></p>
<h4 id="混合回收-Mixed-GC"><a class="header-anchor" href="#混合回收-Mixed-GC"></a>混合回收 Mixed GC</h4>
<p>混合回收分为：初始标记（initial mark）、并发标记（Concurrent mark）、最终标记（remark/finalize marking）、并发清理（cleanup）【初始标记会和年轻代回收一起执行】</p>
<p>G1 对老年代的清理会选择存活度最低的区域进行，这样子可以保证回收效率最高，也是 Garbage first 名字的由来。如果清理过程中发现没有足够的空 Region 存放转移的对象，会出现 Full GC。<strong>单线程</strong>执行标记-整理算法，<strong>此时会导致用户线程的暂停</strong>。所以尽量保证应该用的堆内存有一定多余的空间。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191719630.png" alt="混合回收工作流程"></p>
<p>混合回收执行效果：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503191722608.png" alt="混合回收执行效果"></p>
<ul>
<li>优点：对比较大的堆，如超过 6G 的堆回收时，延迟可控、不会产生内存碎片、并发标记的 SATB 算法效率高</li>
<li>缺点：jdk 8 之前不够成熟，需要提高 jdk 版本</li>
<li>适用场景：jdk 8 最新版本，jdk 9 之后默认使用</li>
</ul>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<p>主要记忆两种组合和 G1 这四种组合来记忆</p>
<p>按照性能来讲解：jdk 8 及之前</p>
<ul>
<li>关注暂停时间：parNew + CMS</li>
<li>关注吞吐量：Parallel Scavenge + Parallel Old</li>
<li>G1</li>
</ul>
<p>jdk 9 之后，尽量使用 G1 垃圾回收器</p>
]]></content>
      <tags>
        <tag>java 底层</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>typora-latex主题修改经验</title>
    <url>/2025/03/01/%E5%89%8D%E7%AB%AF/typora-latex%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="修改代码块"><a class="header-anchor" href="#修改代码块"></a>修改代码块</h2>
<h2 id="修改界面文字编辑框之外的背景颜色"><a class="header-anchor" href="#修改界面文字编辑框之外的背景颜色"></a>修改界面文字编辑框之外的背景颜色</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011237346.png" alt="image-20240314220552043"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">起始状态 --&gt;<span class="selector-attr">[0]</span>---&gt; <span class="selector-attr">[匹配任意数量的0]</span> --&gt;(<span class="number">0</span>)--&gt;<span class="selector-attr">[匹配两个连续的0]</span><span class="built_in">--</span>(<span class="number">0</span>)--&gt;<span class="selector-attr">[匹配两个连续的0]</span>--&gt;(<span class="number">0</span>)--&gt;<span class="selector-attr">[匹配任意数量的0或1]</span> --&gt;(<span class="number">1</span>)--&gt;<span class="selector-attr">[匹配任意数量的0或1]</span> --&gt;(<span class="number">1</span>)--&gt;<span class="selector-attr">[接受状态]</span></span><br><span class="line">               |           ^                                                   |</span><br><span class="line">               |           |<span class="built_in">_____________________</span>(<span class="number">1</span>)____________________________|</span><br><span class="line">               |----------------------------------------------------------------|</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>github-action</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Github-Action/</url>
    <content><![CDATA[<h1 id="Github-Action"><a class="header-anchor" href="#Github-Action"></a>Github Action</h1>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>为了避免每次项目更新都进行手动的：打包、关闭旧版本程序和启动新版本程序等步骤，使用github提供的github-action来完成上述的过程的自动化实现。</p>
<h2 id="什么是-Gitub-Actions？"><a class="header-anchor" href="#什么是-Gitub-Actions？"></a>什么是 Gitub-Actions？</h2>
<p>GitHub Actions 是自动化工作流程工具，用于自动化构建、测试、部署和集成软件项目。它通过一系列事件、触发器和任务来执行各种操作，以实现持续集成和持续交付。</p>
<p>GitHub 允许你可以发布以及共享你自己的 Actions，别人可以通过市场找到你的 Actions 从而不需要在重复造轮子了。</p>
<h2 id="什么是-CI-CD？"><a class="header-anchor" href="#什么是-CI-CD？"></a>什么是 CI/CD？</h2>
<p>CI/CD 是持续集成（Continuous Integration）与持续交付 / 持续部署（Continuous Delivery/Continuous Deployment）的缩写，是一种软件开发实践和方法论。</p>
<p>持续集成（CI）是指开发人员将其代码频繁地集成到共享代码存储库中，并通过自动化构建和测试流程来验证代码的正确性。这样可以确保团队成员的代码变更能够快速地集成到主干代码中，并减少代码集成过程中的错误。</p>
<p>持续交付（CD）是指将通过持续集成产生的软件交付给质量保证团队进行进一步的自动化测试、部署和发布。持续交付的目标是确保软件始终处于可部署状态，以便可以随时交付给用户。</p>
<p>持续部署（CD）是持续交付的进一步延伸，指将通过持续交付阶段产生的可部署软件自动地部署到生产环境中，使软件能够快速地、可靠地投入使用。</p>
<p>通过采用 CI/CD 实践，团队可以实现更快速、可靠、高质量的软件交付。自动化的构建、测试、部署和发布流程能够减少人为错误，提高开发团队的生产效率，并使软件交付过程更加可靠和可追踪。</p>
<blockquote>
<p>以上为概念性知识点，对github-action的原理有一个大概的了解，方便更好的理解实际脚本代码中的运行逻辑和含义。</p>
</blockquote>
<h2 id="术语"><a class="header-anchor" href="#术语"></a>术语</h2>
<blockquote>
<p>一些基础术语</p>
</blockquote>
<ol>
<li>
<p><strong>workflow （工作流程）</strong>： 持续集成一次运行的过程，就是一个 workflow。</p>
<ol>
<li>
<p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<code>.github/workflows</code>目录</p>
</li>
<li>
<p>可以采用yaml格式文件作为 workflow 文件，一个</p>
<p>库中可以有多个 workflow 文件，会各自按照对应的event条件执行。</p>
<p>只要github发现有yml文件，且满足event条件，就会自动运行。</p>
</li>
</ol>
</li>
<li>
<p><strong>Event （事件）</strong>：触发工作流运行的动作，例如每次的push、pull_request等</p>
</li>
<li>
<p><strong>job （任务）</strong> ：每一个<strong>job</strong>都是工作流中独立的单元，</p>
</li>
<li>
<p><strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
</li>
<li>
<p><strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
</li>
</ol>
<h2 id="本项目的部署"><a class="header-anchor" href="#本项目的部署"></a>本项目的部署</h2>
<h3 id="流程分析"><a class="header-anchor" href="#流程分析"></a>流程分析</h3>
<p>本项目后端是以SpringBoot为框架搭建的单体架构，因此对于自动化部署的操作可以分解为：</p>
<ol>
<li>项目在本地修改成功后push到origin仓库</li>
<li>参与者在origin仓库进行pull_request操作，更新upstream仓库的指定分支</li>
<li>使用github action对于更新后的项目进行Maven构建，生成jar包</li>
<li>将jar包添加到入docker镜像，并设置好运行规则</li>
<li>将docker上传至个人的阿里云docker镜像源仓库</li>
<li>服务器从项目docker镜像源处拉取docker镜像</li>
<li>将拉取的镜像运行，指定端口号为8121</li>
</ol>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h3>
<p>依据上面的思路，实现以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="comment">#  push:</span></span><br><span class="line"><span class="comment">#    branches: [&quot;release/test&quot;]</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">&quot;release/test&quot;</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">compile:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">17</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&quot;17&quot;</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">&quot;adopt&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># maven缓存，避免重复拉取，会影响速度</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Dependies</span> <span class="string">Cache</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">~/.m2/repository</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-maven-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/pom.xml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-maven-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 编译打包</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mvn package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string"></span>        <span class="attr">working-directory:</span> <span class="string">./bookdone</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 制作docker镜像并推送到阿里云容器镜像服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span> <span class="string">and</span> <span class="string">push</span> <span class="string">docker</span> <span class="string">image</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 构建Docker镜像</span></span><br><span class="line">          <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;:latest</span> <span class="string">\</span></span><br><span class="line">            <span class="string">--build-arg</span> <span class="string">JAR_FILE=target/*.jar</span> <span class="string">\</span></span><br><span class="line">            <span class="string">-f</span> <span class="string">./bookdone/Dockerfile</span> <span class="string">./bookdone</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 登录阿里云容器镜像服务</span></span><br><span class="line">          <span class="string">docker</span> <span class="string">login</span> <span class="string">--username=$&#123;&#123;secrets.ALIYUN_USERNAME&#125;&#125;</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;</span> <span class="string">--password=$&#123;&#123;secrets.ALIYUN_PWD&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 上传镜像</span></span><br><span class="line">          <span class="string">docker</span> <span class="string">tag</span> <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;/$&#123;&#123;vars.REGISTRY_NAMESPACE&#125;&#125;/$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;:latest</span></span><br><span class="line"></span><br><span class="line">          <span class="string">docker</span> <span class="string">push</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;/$&#123;&#123;vars.REGISTRY_NAMESPACE&#125;&#125;/$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;:latest</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 登出</span></span><br><span class="line">          <span class="string">docker</span> <span class="string">logout</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Step 2: 安装 SSH 客户端</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">SSH</span> <span class="string">client</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">openssh-client</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Step 3: 使用 SSH 登录阿里云服务器并部署 Docker 镜像</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Alibaba</span> <span class="string">Cloud</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sshpass -p &quot;$&#123;&#123;secrets.SERVER_PWD&#125;&#125;&quot; ssh -o StrictHostKeyChecking=no $&#123;&#123;secrets.SERVER_USERNAME&#125;&#125;@$&#123;&#123;secrets.SERVER_IP&#125;&#125; &lt;&lt; EOF</span></span><br><span class="line"><span class="string">            echo &quot;1. docker login aliyun start==&gt;&quot;</span></span><br><span class="line"><span class="string">            echo $&#123;&#123;secrets.ALIYUN_PWD&#125;&#125; | docker login $&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125; --username=$&#123;&#123;secrets.ALIYUN_USERNAME&#125;&#125; --password-stdin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;2. docker stop and remove old container&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">container</span> <span class="string">stop</span> <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">container</span> <span class="string">rm</span> <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;3. docker image rm==&gt;&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">image</span> <span class="string">rm</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;/$&#123;&#123;vars.REGISTRY_NAMESPACE&#125;&#125;/$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">image</span> <span class="string">rm</span> <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;4. docker pull new image==&gt;&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">pull</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;/$&#123;&#123;vars.REGISTRY_NAMESPACE&#125;&#125;/$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;:latest</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;5. docker tag==&gt;&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">tag</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;/$&#123;&#123;vars.REGISTRY_NAMESPACE&#125;&#125;/$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;:latest</span> <span class="string">bookdone:latest</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;6. docker run new container==&gt;&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">container</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">\</span></span><br><span class="line">              <span class="string">-p</span> <span class="number">8121</span><span class="string">:8121</span> <span class="string">\</span></span><br><span class="line">              <span class="string">--name</span> <span class="string">bookdone</span> <span class="string">\</span></span><br><span class="line">              <span class="string">-v</span> <span class="string">/home/lys/test/logs:/app/logs</span> <span class="string">\</span></span><br><span class="line">              <span class="string">$&#123;&#123;vars.IMAGE_NAME_PRE&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;7. docker logout==&gt;&quot;</span></span><br><span class="line">            <span class="string">docker</span> <span class="string">logout</span></span><br><span class="line">          <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Step 4: Docker登出</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Logout</span> <span class="string">from</span> <span class="string">Docker</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">docker</span> <span class="string">logout</span> <span class="string">$&#123;&#123;vars.REGISTRY_MIRROR&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="需要配置的变量："><a class="header-anchor" href="#需要配置的变量："></a>需要配置的变量：</h4>
<p><strong>secret-key</strong>：</p>
<ol>
<li><strong>ALIYUN_USERNAME</strong>：aliyun3766755971</li>
<li><strong>ALIYUN_PWD</strong>：caigui0725</li>
<li><strong>SERVER_USERNAME</strong>：root</li>
<li><strong>SERVER_PWD</strong>: Xiaoyaxuan911.0</li>
<li><strong>SERVER_IP</strong>：120.76.45.161</li>
</ol>
<p><strong>vars-key</strong>：</p>
<ol>
<li><strong>IMAGE_NAME_PRE</strong>：bookdone</li>
<li><strong>REGISTRY_MIRROR</strong>：crpi-lu7jrqe86z5u10qs.cn-guangzhou.personal.cr.aliyuncs.com</li>
<li><strong>REGISTRY_NAMESPACE</strong>：docker_repository4caigui</li>
</ol>
<h3 id="实际效果展示"><a class="header-anchor" href="#实际效果展示"></a>实际效果展示</h3>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20240920120709634.png" alt="image-20240920120709634"></p>
<h2 id="规范化操作："><a class="header-anchor" href="#规范化操作："></a>规范化操作：</h2>
<h3 id="PR-操作流程"><a class="header-anchor" href="#PR-操作流程"></a><strong>PR 操作流程</strong></h3>
<h4 id="Fork-库并创建分支"><a class="header-anchor" href="#Fork-库并创建分支"></a>Fork 库并创建分支</h4>
<ul>
<li>每位贡献者从主库 <code>release/test</code> 分支 fork 项目至个人仓库，并创建新的开发分支（例如 <code>feature/xxx</code> 或 <code>bugfix/xxx</code>），确保开发分支命名规范，便于识别。</li>
</ul>
<h4 id="本地开发并提交代码"><a class="header-anchor" href="#本地开发并提交代码"></a>本地开发并提交代码</h4>
<ul>
<li>
<p>在本地进行开发、调试，确保提交内容符合代码规范。</p>
</li>
<li>
<p>提交时附上清晰的 commit message，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat: 添加xxx功能</span><br><span class="line">fix: 修复xxx问题</span><br><span class="line">refactor: 重构xxx模块</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Pull-Request-提交"><a class="header-anchor" href="#Pull-Request-提交"></a>Pull Request 提交</h4>
<ul>
<li>当完成开发或修复后，将代码 push 到 fork 仓库，并向主库的 <code>release/test</code> 分支提交 PR（Pull Request）。</li>
<li>在提交 PR 时，请确保以下几点：
<ul>
<li><strong>PR 标题</strong>清晰简明，包含任务编号（如适用），如 <code>feat: 添加登录接口 (#123)</code></li>
<li><strong>PR 描述</strong>中包含详细的变更内容、相关 issue 链接、影响模块和测试策略等。</li>
<li>在提交 PR 之前，请确保已在本地或 CI 环境中通过所有测试。</li>
</ul>
</li>
</ul>
<h4 id="PR-审核流程"><a class="header-anchor" href="#PR-审核流程"></a>PR 审核流程</h4>
<ul>
<li>团队成员或维护者对 PR 进行审核，确保代码质量和功能正确。</li>
<li>审核通过后，PR 合并至 <code>release/test</code> 分支。</li>
</ul>
<p>在pr审核通过之后就会启动工作流以实现项目更新后的构建和服务器部署。</p>
]]></content>
      <tags>
        <tag>自动化部署</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a class="header-anchor" href="#Docker"></a>Docker</h1>
<blockquote>
<p>学习路线：</p>
<p>[单机版Docker]概述——安装——命令——镜像——容器数据卷——DockerFile——Docker网络原理——IDEA整合Docker</p>
<p>[进阶版]Docker Compose——Docker Swarm（简化版的jenkins）</p>
</blockquote>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>开发和上线使用的是两套环境，应用环境，应用配置</p>
<p>开发 —— 运维；在我的电脑上正常，当迁移后出现了问题。</p>
<h2 id="常见命令"><a class="header-anchor" href="#常见命令"></a>常见命令</h2>
<ol>
<li><code>docker pull</code>：拉取image</li>
<li><code>docker images</code>：查看本地image</li>
<li><code>docker rm -rf</code>：强制删除容器</li>
<li><code>docker rmi</code>：删除本地image</li>
<li><code>docker build</code>：根据dockerfile构建image</li>
<li><code>docker save</code>：将本地image以压缩包的形式保存下来，再通过<code>docker load</code>加载到本地</li>
<li><code>docker run</code>：创建一个image的实例——容器container</li>
<li><code>docker stop</code>：停止一个容器container</li>
<li><code>docker statr</code>：重新开启处于停止状态的容器container</li>
</ol>
<p>全部指令官方文档：<a href="https://docs.docker.com/">Docker 文档</a></p>
<h2 id="数据卷"><a class="header-anchor" href="#数据卷"></a>数据卷</h2>
<p>本次docker之旅困难重重，对于vmware和ubuntu的熟练使用还是任重道远</p>
<blockquote>
<p>todo：仍旧未解决的vmware-tools安装失败问题，但是为了学习进度只能姑且放弃，后期再来找补。</p>
</blockquote>
<p>创建一个数据卷：</p>
<ol>
<li>数据卷的创建需要在容器创建时进行挂载，一旦容器创建好就不能再进行挂载。</li>
<li>数据卷可以帮助我们在主机环境去管理容器当中的环境与内容，由于每一个容器都是只包括容器所需要的最低限度的运行程序和脚本，因此可能在容器中很多指令无法应用，进而难以对容器的配置或文件进行修改等操作，通过挂载数据卷，相当于多了一个操作接口，进而可以在主机环境中对容器内的文件或配置进行修改。</li>
</ol>
<h2 id="Dockfile语法"><a class="header-anchor" href="#Dockfile语法"></a>Dockfile语法</h2>
<h3 id="镜像分层："><a class="header-anchor" href="#镜像分层："></a>镜像分层：</h3>
<ol>
<li>Entrypoint入口：镜像运行入口，一般是程序启动的脚本和参数</li>
<li>Layer 层：添加安装包、依赖、配置等，每次操作都形成新的一层</li>
<li>BaseImage基础镜像：一些应用程序运行时所依赖的系统函数库、环境、配置和文件等</li>
</ol>
<h3 id="语法指令："><a class="header-anchor" href="#语法指令："></a>语法指令：</h3>
<blockquote>
<p>详细语法：<a href="https://docs.docker.com/engine/reference/builder">官方文档</a></p>
</blockquote>
<p><code>from</code>：指定基础镜像</p>
<p><code>env</code>：设置环境变量，可以在后面指令使用</p>
<p><code>copy</code>：拷贝本地文件到镜像的指定目录</p>
<p><code>run</code>：执行linux的shell命令，一般是安装过程的命令</p>
<p><code>expose</code>：指定容器运行时监听的端口，给镜像使用者看，相当于一个端口使用说明</p>
<p><code>entrypoint</code>：镜像中应用的启动命令，容器运行时调用</p>
<h3 id="自定义镜像"><a class="header-anchor" href="#自定义镜像"></a>自定义镜像</h3>
<h2 id="容器网络"><a class="header-anchor" href="#容器网络"></a>容器网络</h2>
<p><code>docker network create network_name</code></p>
<p><code>docker network connect network_name container_name</code></p>
<p><code>docker run -d --name new_container --network network_name -p port_number image_name</code></p>
<h2 id="Docker挂载数据库"><a class="header-anchor" href="#Docker挂载数据库"></a>Docker挂载数据库</h2>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name mysql_container \</span></span><br><span class="line"><span class="language-bash">    -v /path/to/mysql-data:/var/lib/mysql \</span></span><br><span class="line"><span class="language-bash">    -v /path/to/my.cnf:/etc/mysql/my.cnf \</span></span><br><span class="line"><span class="language-bash">    -v /path/to/init.sql:/docker-entrypoint-initdb.d/init.sql \</span></span><br><span class="line"><span class="language-bash">    -e MYSQL_ROOT_PASSWORD=rootpassword \</span></span><br><span class="line"><span class="language-bash">    -p 3306:3306 \</span></span><br><span class="line"><span class="language-bash">    -d mysql:latest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vue框架了解</title>
    <url>/2025/03/01/%E5%89%8D%E7%AB%AF/Vue/</url>
    <content><![CDATA[<h1 id="Vue"><a class="header-anchor" href="#Vue"></a>Vue</h1>
<blockquote>
<p>一套前端框架</p>
<p>框架：一套半成品软件——可重用、通用的软件基础代码模型</p>
<p>MVVM Model-View-ViewModel：数据双向绑定</p>
</blockquote>
<p>常用指令</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">v-bing</td>
<td style="text-align:left">为html标签绑定属性值，如设置href，css样式等</td>
</tr>
<tr>
<td style="text-align:left">v-model</td>
<td style="text-align:left">在表单元素上创建双向数据绑定</td>
</tr>
<tr>
<td style="text-align:left">v-on</td>
<td style="text-align:left">为html标签绑定事件</td>
</tr>
<tr>
<td style="text-align:left">v-if</td>
<td style="text-align:left"><strong>条件性的渲染某元素</strong></td>
</tr>
<tr>
<td style="text-align:left">v-else-if</td>
<td style="text-align:left"><strong>判定为true时渲染</strong></td>
</tr>
<tr>
<td style="text-align:left">v-else</td>
<td style="text-align:left"><strong>否则不渲染</strong></td>
</tr>
<tr>
<td style="text-align:left">v-show</td>
<td style="text-align:left">根据条件展示某元素，区别在于切换的是display属性的值</td>
</tr>
<tr>
<td style="text-align:left">v-for</td>
<td style="text-align:left">列表渲染，遍历容器的元素或对象的属性</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">url</span>:<span class="string">&quot;xxx&quot;</span></span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>v-bind</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">缩写格式为：<span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>v-model</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生命周期</p>
<ul>
<li>
<p>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（又称为“钩子”）</p>
<blockquote>
<p>每一个生命周期事件都对应一个函数，都可以手动调用以达到实现特定功能的目的</p>
</blockquote>
<p>beforeCreate，创建前</p>
<p>created，创建后</p>
<p>beforeMount，挂载前</p>
<p>mounted，挂载后</p>
<ul>
<li>
<p>在vue实例当中，手动创建函数mounted(){}，在使用这一函数的时候发送请求到服务端来获取数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">E.g:</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">		</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//自动调用</span></span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Vue挂载完毕后，发送请求到服务端获取数据&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">		</span></span><br><span class="line"><span class="language-javascript">		&#125;,</span></span><br><span class="line"><span class="language-javascript">	&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>beforeUpdate，更新前</p>
<p>update，更新后</p>
<p>beforeDestroy，销毁前</p>
<p>destroyed，销毁后</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发</title>
    <url>/2025/03/01/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="微信小程序开发"><a class="header-anchor" href="#微信小程序开发"></a>微信小程序开发</h1>
<h2 id="开发流程概览"><a class="header-anchor" href="#开发流程概览"></a>开发流程概览</h2>
<h3 id="目录结构"><a class="header-anchor" href="#目录结构"></a>目录结构</h3>
<p>小程序主体部分由三个文件组成，必须放在项目的根目录下</p>
<ol>
<li>app.js：必需存在，小程序的逻辑部分</li>
<li>app.json：必须存在，小程序公共配置</li>
<li>app.wxss：非必需存在，控制小程序的样式</li>
</ol>
<p>示例图：</p>
<img src="D:\DeskTable\博客学习截图传输\image-20240902213656778.png" alt="image-20240902213656778" style="zoom:50%;" /> 
<h3 id="一个小程序页面的构成："><a class="header-anchor" href="#一个小程序页面的构成："></a>一个小程序页面的构成：</h3>
<ol>
<li>js：必需，页面的逻辑</li>
<li>wxml：必需，页面的结构</li>
<li>json：非必需，页面的配置</li>
<li>wxss：非必需，页面的样式表</li>
</ol>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="GIT"><a class="header-anchor" href="#GIT"></a>GIT</h1>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<h3 id="Git的作用"><a class="header-anchor" href="#Git的作用"></a>Git的作用</h3>
<ol>
<li>备份</li>
<li>代码还原</li>
<li>协同开发</li>
<li>追溯问题代码的编写人和编写时间</li>
</ol>
<h3 id="版本控制方式"><a class="header-anchor" href="#版本控制方式"></a>版本控制方式</h3>
<ol>
<li>集中式版本控制：版本库集中存放在中央服务器当中，team里每个人在需要对代码进行修改迭代时从中央服务器下载，在修改完后提交到中央版本库当中。例如：SVN和CVS</li>
<li>分布式版本控制：不存在“中央服务器”，每个人电脑上有一套完整的版本库。无需联网，多人协作时只需要各自修改的内容推送到team内每个成员， 就能看到对方的修改。例如Git</li>
</ol>
<h3 id="Git"><a class="header-anchor" href="#Git"></a>Git</h3>
<p>Git是分布式的，不需要中央服务器。而在实际使用中有一个中心服务器只是为了方便团队开发者交换修改的代码，该服务器相当于一个公共开发者永不关机的PC。</p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 使用记录</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Linux-使用指南"><a class="header-anchor" href="#Linux-使用指南"></a>Linux 使用指南</h1>
<h2 id="Ubuntu忘记密码的解决方法"><a class="header-anchor" href="#Ubuntu忘记密码的解决方法"></a><a href="https://blog.csdn.net/Zhishuifuyue/article/details/113857580">Ubuntu忘记密码的解决方法</a></h2>
<p>下面是修改密码的详细步骤：</p>
<p>1、重启Ubuntu系统，开机时长按shift（这里要注意鼠标按键必须是在虚拟机里，而不是在windows里）按键进入Ubuntu的GRUB菜单，选择Advance Options for ubuntu 选项，如下如所示：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238114.png" alt="img"></p>
<p>2、在高级模式中选择Recovery mode模式，<strong>按‘E’键进入编辑模式（必须先按E键，而不是Enter键）</strong>，如下图所示：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238633.png" alt="img"></p>
<p>3、在编辑模式中通过上下键移动光标寻找到RO，并将其修改为RW模式，（刚开始看不到RO，按键盘向下箭头可以往下走）如下图所示，</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238291.png" alt="img"></p>
<p>ro改成rw后，按ctrl+ X 进入系统 ,正在进入系统，如下图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238234.png" alt="img"></p>
<p>4、进入系统后，会显示BIOS界面，选择root并回车确认，如下图所示：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238745.png" alt="img"></p>
<p>5、如上选择回车root，使用命令passwd修改密码，格式：passwd   用户名（自己的登录用户名），回车，然后会提示要求你输入新的密码，如下所示：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238010.png" alt="img"></p>
<p>6、修改完成后，输入reboot 回车，重启系统，在登录界面使用刚修改的密码即可登录。</p>
<h2 id="查询当前-IP"><a class="header-anchor" href="#查询当前-IP"></a>查询当前 IP</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose</title>
    <url>/2025/03/04/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/docker-compose/</url>
    <content><![CDATA[<h1 id="docker-compose"><a class="header-anchor" href="#docker-compose"></a>docker-compose</h1>
<h2 id="基本语法"><a class="header-anchor" href="#基本语法"></a>基本语法</h2>
<p>docker-compose.yml文件的基本语法可以参考官方文档：</p>
<p>https://docs.docker.com/compose/compose-file/compose-file-v3/</p>
<p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p>
<p>举例来说，用docker run部署MySQL的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>
<p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<p>对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>docker run 参数</strong></th>
<th style="text-align:left"><strong>docker compose 指令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">–name</td>
<td style="text-align:left">container_name</td>
<td style="text-align:left">容器名称</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">ports</td>
<td style="text-align:left">端口映射</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">environment</td>
<td style="text-align:left">环境变量</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">volumes</td>
<td style="text-align:left">数据卷配置</td>
</tr>
<tr>
<td style="text-align:left">–network</td>
<td style="text-align:left">networks</td>
<td style="text-align:left">网络</td>
</tr>
</tbody>
</table>
<p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p>
<p>黑马商城部署文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<h2 id="基础命令"><a class="header-anchor" href="#基础命令"></a>基础命令</h2>
<p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p>
<p>https://docs.docker.com/compose/reference/</p>
<p>基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure>
<p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>参数或指令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Options</td>
<td style="text-align:left">-f</td>
<td style="text-align:left">指定compose文件的路径和名称</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Commands</td>
<td style="text-align:left">up</td>
<td style="text-align:left">创建并启动所有service容器</td>
</tr>
<tr>
<td style="text-align:left">down</td>
<td style="text-align:left">停止并移除所有容器、网络</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ps</td>
<td style="text-align:left">列出所有启动的容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">logs</td>
<td style="text-align:left">查看指定容器的日志</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:left">停止容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">start</td>
<td style="text-align:left">启动容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">restart</td>
<td style="text-align:left">重启容器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">查看运行的进程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec</td>
<td style="text-align:left">在指定的运行中容器中执行命令</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>教学演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>
<p>打开浏览器，访问：http://192.168.246.129:8080</p>
<h2 id="配置-MySQL"><a class="header-anchor" href="#配置-MySQL"></a>配置 MySQL</h2>
<h3 id="编写-cnf-文件"><a class="header-anchor" href="#编写-cnf-文件"></a>编写 cnf 文件</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">###### [client]配置模块 ######</span></span><br><span class="line">[<span class="string">client</span>]</span><br><span class="line"><span class="string">default-character-set=utf8mb4</span></span><br><span class="line"><span class="string">socket=/var/lib/mysql/mysql.sock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### [mysql]配置模块 ######</span></span><br><span class="line">[<span class="string">mysql</span>]</span><br><span class="line"><span class="comment"># 设置MySQL客户端默认字符集</span></span><br><span class="line"><span class="string">default-character-set=utf8mb4</span></span><br><span class="line"><span class="string">socket=/var/lib/mysql/mysql.sock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### [mysqld]配置模块 ######</span></span><br><span class="line">[<span class="string">mysqld</span>]</span><br><span class="line"><span class="string">port=3306</span></span><br><span class="line"><span class="string">user=mysql</span></span><br><span class="line"><span class="comment"># 设置sql模式 sql_mode模式引起的分组查询出现*this is incompatible with sql_mode=only_full_group_by，这里最好剔除ONLY_FULL_GROUP_BY</span></span><br><span class="line"><span class="string">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span></span><br><span class="line"><span class="string">datadir=/var/lib/mysql</span></span><br><span class="line"><span class="string">socket=/var/lib/mysql/mysql.sock</span></span><br><span class="line"><span class="string">server-id</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL8 的密码认证插件 如果不设置低版本navicat无法连接</span></span><br><span class="line"><span class="string">default_authentication_plugin=mysql_native_password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用符号链接以防止各种安全风险</span></span><br><span class="line"><span class="string">symbolic-links=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="string">max_connections=1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="string">character-set-server=utf8mb4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="string">default-storage-engine=INNODB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0: 表名将按指定方式存储，并且比较区分大小写;</span></span><br><span class="line"><span class="comment"># 1: 表名以小写形式存储在磁盘上，比较不区分大小写；</span></span><br><span class="line"><span class="string">lower_case_table_names=0</span></span><br><span class="line"></span><br><span class="line"><span class="string">max_allowed_packet=16M</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="string">default-time_zone=&#x27;+8:00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="编写-sql-文件进行数据库初始化"><a class="header-anchor" href="#编写-sql-文件进行数据库初始化"></a>编写 sql 文件进行数据库初始化</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> exit init_db;</span><br><span class="line">use init_db;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="编写-yml-文件"><a class="header-anchor" href="#编写-yml-文件"></a>编写 yml 文件</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span> <span class="comment"># 服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.18</span> <span class="comment"># 或其它mysql版本</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql8</span> <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span> <span class="comment"># root用户密码</span></span><br><span class="line"><span class="comment">#      - TZ=Asia/Shanghai # 设置容器时区 我这里通过下面挂载方式同步的宿主机时区和时间了,这里忽略</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/docker/mysql8/log:/var/log/mysql</span> <span class="comment"># 映射日志目录，宿主机:容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/docker/mysql8/data:/var/lib/mysql</span> <span class="comment"># 映射数据目录，宿主机:容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/docker/mysql8/conf.d:/etc/mysql/conf.d</span> <span class="comment"># 映射配置目录，宿主机:容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span> <span class="comment"># 让容器的时钟与宿主机时钟同步，避免时间的问题，ro是read only的意思，就是只读。</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span> <span class="comment"># 指定宿主机端口与容器端口映射关系，宿主机:容器</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 容器随docker启动自启</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置-redis"><a class="header-anchor" href="#配置-redis"></a>配置 redis</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis/data:/data</span>  <span class="comment"># 挂载 Redis 数据目录到当前目录下的 redis/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-Nacos"><a class="header-anchor" href="#配置-Nacos"></a>配置 Nacos</h2>
<h3 id="编写-env-文件："><a class="header-anchor" href="#编写-env-文件："></a>编写 env 文件：</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.246.129</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=root</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure>
<h3 id="编写-yml-文件-v2"><a class="header-anchor" href="#编写-yml-文件-v2"></a>编写 yml 文件</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker-compose config                  ## 检查当前目录docker-compose.yml文件配置是否正确</span></span><br><span class="line"><span class="comment">## docker-compose up -d                   ## -d 为后台启动</span></span><br><span class="line"><span class="comment">## docker-compose up -d --force-rereate  ## 强制重新创建容器,修改挂载文件后使用该命令启动,谨慎使用,调试时可使用,使用此命令可能造成数据丢失</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:v2.0.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos2.0.3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMX=1g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMS=1g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TOMCAT_ACCESSLOG_ENABLED=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=172.16.223.140</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_KEY=nacos2023</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_VALUE=nacos2023</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_TOKEN=SecretKey345901234567890126785678901234567890123901234567890123445678</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs/:/home/nacos/logs</span></span><br><span class="line">      <span class="comment"># - ./conf/custom.properties:/home/nacos/init.d/custom.properties</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8848</span><span class="string">:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9848</span><span class="string">:9848</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置-rabbitMQ"><a class="header-anchor" href="#配置-rabbitMQ"></a>配置 rabbitMQ</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">rabbitmq:3.8-management</span></span><br><span class="line">     <span class="attr">container_name:</span> <span class="string">rabbitmq</span></span><br><span class="line">     <span class="attr">hostname:</span> <span class="string">hmall</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">5672</span><span class="string">:5672</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">15672</span><span class="string">:15672</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">       <span class="attr">RABBITMQ_DEFAULT_USER:</span> <span class="string">hmall</span></span><br><span class="line">       <span class="attr">RABBITMQ_DEFAULT_PASS:</span> <span class="string">hmall</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="comment">#     volumes:</span></span><br><span class="line"><span class="comment">#       - ./rabbitmq/plugins:/plugins</span></span><br><span class="line">     <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>
<h2 id=""><a class="header-anchor" href="#"></a></h2>
]]></content>
      <tags>
        <tag>docker-compose</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea设置</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/idea%E5%81%8F%E9%97%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Idea设置"><a class="header-anchor" href="#Idea设置"></a>Idea设置</h1>
<h2 id="项目启动数量默认限制为5"><a class="header-anchor" href="#项目启动数量默认限制为5"></a>项目启动数量默认限制为5</h2>
<p>点开<em>settings</em>后可以看到在advanced settings里搜索temporary即可找到设置，修改默认数量即可</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011238608.png" alt="image-20241101225455911"></p>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>k&#39;f</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/maven/</url>
    <content><![CDATA[<h1 id="MAVEN"><a class="header-anchor" href="#MAVEN"></a>MAVEN</h1>
<blockquote>
<p>一套管理和构建java项目的工具</p>
<p>管理jar包，避免版本冲突</p>
</blockquote>
<h2 id="依赖的自动管理"><a class="header-anchor" href="#依赖的自动管理"></a>依赖的自动管理</h2>
<p>在maven的pom.xml文件当中进行信息的配置，而后会自动下载所需要的依赖包</p>
<p>不需要手动导入jar包，实现了自动导入</p>
<h2 id="统一项目结构"><a class="header-anchor" href="#统一项目结构"></a>统一项目结构</h2>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20240527155522617.png" alt="image-20240527155522617"></p>
<h2 id="项目构建"><a class="header-anchor" href="#项目构建"></a>项目构建</h2>
<h2 id="POM文件中的常见配置"><a class="header-anchor" href="#POM文件中的常见配置"></a>POM文件中的常见配置</h2>
<h3 id="properties"><a class="header-anchor" href="#properties"></a>properties</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义常用的属性--&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">  &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">  &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mybatis基础</title>
    <url>/2025/03/01/%E6%8F%92%E4%BB%B6/Mybatis/</url>
    <content><![CDATA[<h1 id="MyBatis学习"><a class="header-anchor" href="#MyBatis学习"></a>MyBatis学习</h1>
<h2 id="什么是MyBatis"><a class="header-anchor" href="#什么是MyBatis"></a>什么是MyBatis</h2>
<p>是一个持久化框架，用于简化JDBC的开发</p>
<h2 id="结合JDBC的使用操作"><a class="header-anchor" href="#结合JDBC的使用操作"></a>结合JDBC的使用操作</h2>
<h3 id="五大步骤"><a class="header-anchor" href="#五大步骤"></a>五大步骤</h3>
<ol>
<li>建立驱动连接</li>
<li>连接数据库，获取连接对象 Connection</li>
<li>获取执行SQL的对象Statement，执行SQL，取得返回结果</li>
<li>封装返回结果</li>
<li>释放资源</li>
</ol>
]]></content>
      <tags>
        <tag>mybaits</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2025/03/01/redis/Redis/</url>
    <content><![CDATA[<h1 id="Redis基础篇"><a class="header-anchor" href="#Redis基础篇"></a>Redis基础篇</h1>
<p>NoSQL(No Structed Query Language)：</p>
<p>非关系形（非结构化的）数据库</p>
<p>redis是一个基于内存的key-value的数据库，key一般为String类型，value类型多样： String,Hash,List,Set,SortedSet,GEO,BitMap,Hyperlog</p>
<p>​</p>
<h2 id="String类型"><a class="header-anchor" href="#String类型"></a>String类型</h2>
<ol>
<li>数字类型<code>int</code>,<code>float</code>的字符串存储时转换为二进制码进行存储</li>
<li>真正的字符串则是转换成字节码进行存储</li>
</ol>
<p><strong>常见指令：</strong></p>
<ul>
<li><code>set</code>:</li>
<li><code>get</code>:</li>
<li><code>mset</code>:</li>
<li><code>mget</code>:</li>
<li><code>incr</code>:</li>
<li><code>incrbyfloat</code></li>
<li><code>incrby steps</code>:</li>
<li><code>decr</code>:</li>
<li><code>decrby steps</code>:</li>
<li><code>setnx</code>:</li>
<li><code>setex</code>:</li>
</ul>
<h3 id="key的层级结构"><a class="header-anchor" href="#key的层级结构"></a>key的层级结构</h3>
<blockquote>
<p>使用：项目名：业务名：类型：key</p>
</blockquote>
<h2 id="Hash类型"><a class="header-anchor" href="#Hash类型"></a>Hash类型</h2>
<ul>
<li>
<p><code>hset key field value</code></p>
</li>
<li>
<p><code>hget key field</code>：获取</p>
</li>
<li>
<p><code>hmset key field value</code>：设置一个hash类型的key和field的value</p>
</li>
<li>
<p><code>hmget key field</code>：获取key中的多个field及其value</p>
</li>
<li>
<p><code>hgetall key</code>：获取key中所有的field和value</p>
</li>
<li>
<p><code>hkeys </code>：获取key中所有的filed</p>
<ul>
<li>
<pre><code class="language-livescript">127.0.0.1:6379[1]&gt; hkeys heima:user:1
1) &quot;name&quot;
2) &quot;age&quot;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `hvals`：获取key中所有的value</span><br><span class="line"></span><br><span class="line">  - ```livescript</span><br><span class="line">    127.0.0.1:6379[1]&gt; hvals heima:user:1</span><br><span class="line">    1) &quot;heima&quot;</span><br><span class="line">    2) &quot;18&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
<li>
<p><code>hincrby steps</code>：让一个hash类型的key的字段自增并指定步长</p>
</li>
<li>
<p><code>hsetnx</code>：添加一个hash类型的key和field（field需要不存在，否则不执行）</p>
</li>
</ul>
<h2 id="List类型"><a class="header-anchor" href="#List类型"></a>List类型</h2>
<h2 id="Set类型"><a class="header-anchor" href="#Set类型"></a>Set类型</h2>
<ul>
<li><code>sadd key member</code>:向一个set容器中添加元素</li>
<li><code>smembers key </code>：获取set中所有的元素</li>
<li><code>srem key member</code>：移除set中的指定元素</li>
<li><code>sismember key member</code>：判断一个元素是否存在于set中</li>
<li><code>scan key</code>：返回set中元素的个数</li>
</ul>
<h2 id="在Java客户端中使用Redis"><a class="header-anchor" href="#在Java客户端中使用Redis"></a>在Java客户端中使用Redis</h2>
<blockquote>
<p>在java中有三种方式使用redis，分别是：jedis，</p>
</blockquote>
<h3 id="Jedis"><a class="header-anchor" href="#Jedis"></a>Jedis</h3>
<h4 id="需要导入的依赖："><a class="header-anchor" href="#需要导入的依赖："></a>需要导入的依赖：</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 单元测试Junit --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 配置Maven的JDK编译级别 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="模板代码："><a class="header-anchor" href="#模板代码："></a>模板代码：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定义一个redis连接对象*/</span></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	使用 JedicConnectionFactory 连接池进行jedis连接的管理</span></span><br><span class="line"><span class="comment">    	通过连接池进行Jedis对象的初始化与连接的创建</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis = JedicConnectionFactory.getJedis();</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入一个 String 类型的键值对数据*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入一个 HashMap 类型的键值对数据*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String,String &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;heima:user:3&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map1 = jedis.hgetAll(<span class="string">&quot;heima:user:3&quot;</span>);</span><br><span class="line">        System.out.println(map1.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试连接池 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String,String &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;heima:user:4&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map1 = jedis.hgetAll(<span class="string">&quot;heima:user:4&quot;</span>);</span><br><span class="line">        System.out.println(map1.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭连接，释放jedis资源*/</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="配置资源"><a class="header-anchor" href="#配置资源"></a>配置资源</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;softMinEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blockWhenExhausted&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPool&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6379&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis集群 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisCluster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisCluster&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.HostAndPort&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.28.184.25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructorarg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7006&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring-Data-Redis"><a class="header-anchor" href="#Spring-Data-Redis"></a>Spring Data Redis</h3>
<h4 id="引入依赖："><a class="header-anchor" href="#引入依赖："></a>引入依赖：</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis 缓存操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pool 对象池 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用lettuce客户端需要引入commons-pool2依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="application-yml文件的配置"><a class="header-anchor" href="#application-yml文件的配置"></a>application.yml文件的配置</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 地址</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="comment"># 端口，默认为6379</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment"># 密码，没有不填</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="comment"># 几号库</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">sentinel:</span></span><br><span class="line">        <span class="attr">master:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">nodes:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="attr">cluster:</span></span><br><span class="line">        <span class="attr">nodes:</span> <span class="number">30.46</span><span class="number">.34</span><span class="number">.190</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="comment"># 连接池的最大数据库连接数</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">200</span></span><br><span class="line">          <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">          <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">50</span></span><br><span class="line">          <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义RedisTemplate的配置类"><a class="header-anchor" href="#自定义RedisTemplate的配置类"></a>自定义RedisTemplate的配置类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*自定义Redis配置类，进行序列化以及RedisTemplate设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.data.redis.mode&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisMode;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisProperties properties;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfig</span><span class="params">(RedisProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceConnectionFactory <span class="title function_">redisConnectionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;LettuceClientConfigurationBuilderCustomizer&gt; builderCustomizers,</span></span><br><span class="line"><span class="params">            ClientResources clientResources)</span> &#123;</span><br><span class="line">        GenericObjectPoolConfig&lt;?&gt; config = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        config.setMaxTotal(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxActive());</span><br><span class="line">        config.setMaxIdle(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxIdle());</span><br><span class="line">        config.setMinIdle(<span class="built_in">this</span>.properties.getLettuce().getPool().getMinIdle());</span><br><span class="line">        config.setMaxWait(<span class="built_in">this</span>.properties.getLettuce().getPool().getMaxWait());</span><br><span class="line"> </span><br><span class="line">        <span class="type">LettucePoolingClientConfiguration</span> <span class="variable">clientConfiguration</span> <span class="operator">=</span> LettucePoolingClientConfiguration</span><br><span class="line">                .builder()</span><br><span class="line">                .poolConfig(config)</span><br><span class="line">                .build();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (redisMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;master&quot;</span>:</span><br><span class="line">                <span class="type">RedisStandaloneConfiguration</span> <span class="variable">redisStandaloneConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisStandaloneConfiguration</span>();</span><br><span class="line">                redisStandaloneConfiguration.setDatabase(<span class="built_in">this</span>.properties.getDatabase());</span><br><span class="line">                redisStandaloneConfiguration.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisStandaloneConfiguration.setHostName(<span class="built_in">this</span>.properties.getHost());</span><br><span class="line">                redisStandaloneConfiguration.setPort(<span class="built_in">this</span>.properties.getPort());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisStandaloneConfiguration, clientConfiguration);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;sentinel&quot;</span>:</span><br><span class="line">                <span class="type">RedisSentinelConfiguration</span> <span class="variable">redisSentinelConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSentinelConfiguration</span>();</span><br><span class="line">                redisSentinelConfig.setDatabase(<span class="built_in">this</span>.properties.getDatabase());</span><br><span class="line">                redisSentinelConfig.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisSentinelConfig.setMaster(<span class="built_in">this</span>.properties.getSentinel().getMaster());</span><br><span class="line">                redisSentinelConfig.setSentinels(</span><br><span class="line">                        <span class="built_in">this</span>.properties.getSentinel().getNodes().stream()</span><br><span class="line">                                .map(RedisNode::fromString).collect(Collectors.toList())</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisSentinelConfig, clientConfiguration);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cluster&quot;</span>:</span><br><span class="line">                <span class="type">RedisClusterConfiguration</span> <span class="variable">redisClusterConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisClusterConfiguration</span>();</span><br><span class="line">                redisClusterConfiguration.setPassword(<span class="built_in">this</span>.properties.getPassword());</span><br><span class="line">                redisClusterConfiguration.setClusterNodes(</span><br><span class="line">                        <span class="built_in">this</span>.properties.getCluster().getNodes().stream()</span><br><span class="line">                                .map(RedisNode::fromString).collect(Collectors.toList())</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisClusterConfiguration, clientConfiguration);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的redis mode配置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(om, Object.class);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置数据源的连接工厂（默认会传入框架中自带的，也就是读取配置文件装配的LettuceConnectionFactory）        </span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 设置值（value）的序列化采用Jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer序列化和反序列化redis hash类型的key值</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 序列化和反序列化redis hash类型的value值</span></span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h4 id="RedisTemplate"><a class="header-anchor" href="#RedisTemplate"></a>RedisTemplate</h4>
<p><strong>常用的操作API</strong></p>
<blockquote>
<p>redisTemplate 通常不直接操作键值，而是通过 opsForXxx() 访问</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hashKey(K key)</td>
<td>Boolean</td>
<td>key是否存在</td>
</tr>
<tr>
<td>countExistingKeys(Collection<K> keys)</td>
<td>Long</td>
<td>redis中keys的数量</td>
</tr>
<tr>
<td>delete(K key)</td>
<td>Boolean</td>
<td>删除key</td>
</tr>
<tr>
<td>delete(Collention<K> keys)</td>
<td>Long</td>
<td>批量删除key</td>
</tr>
<tr>
<td>type(K key)</td>
<td>DataType</td>
<td>获取key的类型</td>
</tr>
<tr>
<td>rename(K oldKey,K newKey)</td>
<td>void</td>
<td>重命名key</td>
</tr>
<tr>
<td>renameIfAbsent(K oldKey,K newKey)</td>
<td>Boolean</td>
<td>如果存在，重命名key</td>
</tr>
<tr>
<td>expire(K key,Long timeout,TimeUnit unit)</td>
<td>Boolean</td>
<td>为key设置过期时间</td>
</tr>
<tr>
<td>expireAt(K key,Date date)</td>
<td>Boolean</td>
<td>为key设置过期时间</td>
</tr>
<tr>
<td>getExpire(K key)</td>
<td>Long</td>
<td>获取key的过期时间</td>
</tr>
<tr>
<td>getExpire(K key,TimeUnit timeUnit)</td>
<td>Long</td>
<td>获取key的过期时间</td>
</tr>
<tr>
<td>persist(K key)</td>
<td>Boolean</td>
<td>移除key的过期时间，使其变为永久</td>
</tr>
<tr>
<td>move(K key,int dbIndex)</td>
<td>Boolean</td>
<td>将key移动到dbIndex中</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:left">返回值类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">redisTemplate.opsForValue()</td>
<td style="text-align:left">ValueOperations</td>
<td style="text-align:left">操作 String 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.opsForHash()</td>
<td style="text-align:left">HashOperations</td>
<td style="text-align:left">操作 Hash 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.opsForList()</td>
<td style="text-align:left">ListOperations</td>
<td style="text-align:left">操作 List 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.opsForSet()</td>
<td style="text-align:left">SetOperations</td>
<td style="text-align:left">操作 Set 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.opsForZSet()</td>
<td style="text-align:left">ZSetOperations</td>
<td style="text-align:left">操作 SortedSet 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.boundValueOps(K key)</td>
<td style="text-align:left">BoundValueOperations</td>
<td style="text-align:left">操作 String 类型 数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.boundHashOps(K key)</td>
<td style="text-align:left">BoundHashOperations</td>
<td style="text-align:left">操作 Hash 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.boundListOps(K key)</td>
<td style="text-align:left">BoundListOperations</td>
<td style="text-align:left">操作 List 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.boundSetOps(K key)</td>
<td style="text-align:left">BoundSetOperations</td>
<td style="text-align:left">操作 Set 类型数据</td>
</tr>
<tr>
<td style="text-align:left">redisTemplate.boundZSetOps(K key)</td>
<td style="text-align:left">BoundZSetOperations</td>
<td style="text-align:left">操作 SortedSet 类型数据</td>
</tr>
</tbody>
</table>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;heima:user:5&quot;</span>,<span class="keyword">new</span> <span class="title class_">Usr</span>(<span class="string">&quot;rose&quot;</span>,<span class="number">19</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;heima:user:5&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(o.toString());</span><br></pre></td></tr></table></figure>
<h4 id="StringRedisTemplate"><a class="header-anchor" href="#StringRedisTemplate"></a>StringRedisTemplate</h4>
<blockquote>
<p>继承了RedisTemplate，API与RedisTemplate基本一致，只不过在使用时多了一步需要开发者自己进行json序列化和反序列化的过错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(obj);</span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;heima:user:6&quot;</span>,json);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonUsr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;heima:user:6&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*手动序列化*/</span></span><br><span class="line"><span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> mapper.readValue(jsonUsr,Usr.class);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/01/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/testWorkFlow/</url>
    <content><![CDATA[{"name":"package and deploy on AliyunCloud","on":{"push":{"branches":["future"]},"pull_request":{"branches":["future"]}},"jobs":{"build":{"runs-on":"ubuntu-latest","steps":[{"uses":"actions/checkout@v4"},{"name":"Set up JDK 11","uses":"actions/setup-java@v4","with":{"java-version":"17","distribution":"temurin","cache":"maven"}},{"name":"Build with Maven","run":"mvn -B package --file pom.xml"},{"name":"Update dependency graph","uses":"advanced-security/maven-dependency-submission-action@571e99aab1055c2e71a1e2309b9691de18d6b7d6"}]}}}]]></content>
  </entry>
  <entry>
    <title>lombok插件使用</title>
    <url>/2025/03/07/%E6%8F%92%E4%BB%B6/lombok%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="lombok-插件使用-Java"><a class="header-anchor" href="#lombok-插件使用-Java"></a>lombok 插件使用 Java</h1>
<p>1、lombok简介及安装<br>
lombok作用：提高开发效率，通过注解形式使javabean生成get、set、有参数、无参数、toString等方法，无需手动实现。</p>
<p>倘若不使用lombok可以使用的注解有：<br>
注解介绍：<br>
下面只是介绍了几个常用的注解，更多的请参见： https://projectlombok.org/features/index.html</p>
<p>@Getter / @Setter</p>
<p>可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。</p>
<p>@EqualsAndHashCode</p>
<p>默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p>
<p>@ToString</p>
<p>生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p>
<p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</p>
<p>无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。</p>
<p>@Data</p>
<p>@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。</p>
<p>IDEA安装lombok插件：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503070951826.png" alt="image-20250307095153630"></p>
<p>maven 引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>插件</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 基础篇</title>
    <url>/2025/03/01/Spring/Spring%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Spring-基础篇"><a class="header-anchor" href="#Spring-基础篇"></a>Spring 基础篇</h1>
<h1 id="概念与术语解析"><a class="header-anchor" href="#概念与术语解析"></a>概念与术语解析</h1>
<h2 id="什么是脚手架"><a class="header-anchor" href="#什么是脚手架"></a>什么是脚手架</h2>
<p>脚手架在实际生活中是一种用在建筑领域的辅助工具，或者说是为了保证各施工过程顺利进行而搭设的工作平台。</p>
<p>对应到软件工程领域，脚手架可以解释为帮助开发人员在开发过程中使用的<strong>开发工具、开发框架（即别人已经造好的轮子不要重复造）</strong>，使用脚手架你无须从头开始搭建或者编写底层软件。</p>
<p>参考Stack Overflow对于脚手架的定义（更加偏向于应用服务框架使用的一种编程思想或者说编程范式）（仅供参考！！）：</p>
<p><strong>脚手架（scaffolding）</strong>：是一种元编程的方法，程序员编写一份规格说明书（Specification），用来描述怎样去使用数据库，然后由编译器脚手架根据这份规格说明书生成相应的代码，进行增、删、改、查等数据库的操作，在脚手架上更高效地建造出强大的应用。</p>
<h1 id="Spring简史"><a class="header-anchor" href="#Spring简史"></a>Spring简史</h1>
<h2 id="Spring-1-x-时代"><a class="header-anchor" href="#Spring-1-x-时代"></a>Spring 1.x 时代</h2>
<p><strong>特点</strong>:</p>
<ul>
<li>引入了**控制反转（IoC）<strong>和</strong>面向切面编程（AOP）**的概念，也是spring框架的核心技术。</li>
<li>提供了轻量级的容器，允许开发者通过 XML 配置文件管理对象的生命周期，在spring1.x时，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。</li>
<li>使得开发者能够将业务逻辑与基础设施代码分离。</li>
</ul>
<h2 id="Spring-2-0-2006"><a class="header-anchor" href="#Spring-2-0-2006"></a>Spring 2.0 (2006)</h2>
<p><strong>特点</strong>:</p>
<ul>
<li>随着 JDK1.5 引入的注解支持，spring2.x 使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。</li>
<li>引入了新的 AOP 支持，允许更灵活的切面定义。</li>
<li>加强了对 Web 应用的支持，包括 Spring MVC 的改进。</li>
</ul>
<h2 id="Spring-3-0-2009"><a class="header-anchor" href="#Spring-3-0-2009"></a>Spring 3.0 (2009)</h2>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>使用Java配置的方式来配置Beans，进一步减少了 XML 配置的需求。</p>
<ul>
<li>Java 配置方式是指使用 Java 类来定义和配置 Spring 应用程序中的 Beans，而不是使用传统的 XML 配置文件。这种方式通过使用注解（如 <code>@Configuration</code> 和 <code>@Bean</code>）来声明 Bean 的创建和依赖关系，使得配置更直观和可维护
<ul>
<li><strong>类型安全</strong>：通过 Java 代码，编译器可以检查配置的正确性。</li>
<li><strong>更好的 IDE 支持</strong>：开发环境可以提供自动补全和重构支持。</li>
<li><strong>灵活性</strong>：可以使用 Java 语言的所有特性（如条件判断、循环等）来<strong>动态创建</strong> Beans。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>支持 RESTful Web 服务，促进了现代 Web 应用程序的开发。</p>
</li>
<li>
<p>引入了表达式语言（SpEL）以增强配置的灵活性。</p>
</li>
</ul>
<h2 id="4-Spring-4-0-2013"><a class="header-anchor" href="#4-Spring-4-0-2013"></a>4. <strong>Spring 4.0 (2013)</strong></h2>
<p><strong>特点</strong>:</p>
<ul>
<li>增加了对 Java 8 的支持，特别是对 Lambda 表达式和流的支持。</li>
<li>引入了新的 WebSocket 支持，使得实时应用程序的开发变得更加容易。</li>
<li>增强了对 Spring MVC 的支持，提供了更好的 REST 功能。</li>
</ul>
<h2 id="Spring-5-0-2017"><a class="header-anchor" href="#Spring-5-0-2017"></a>Spring 5.0 (2017)</h2>
<p><strong>特点</strong>：</p>
<ul>
<li>引入了响应式编程支持，推出了 WebFlux 模块，允许开发者构建非阻塞的应用程序。</li>
<li>加强了对 Kotlin 的支持，允许使用 Kotlin 语言进行 Spring 开发。</li>
<li>改进了对微服务架构的支持，简化了与 Spring Cloud 的集成。</li>
</ul>
<h2 id="Spring-5-1-和-5-2-2018-2019"><a class="header-anchor" href="#Spring-5-1-和-5-2-2018-2019"></a>Spring 5.1 和 5.2 (2018-2019)</h2>
<p>特点:</p>
<ul>
<li>进一步增强了反应式编程的特性，改善了与 R2DBC 的集成。</li>
<li>增加了对更多 Spring Boot 特性的支持，如配置属性的简化。</li>
</ul>
<h2 id="Spring-6-0-2022"><a class="header-anchor" href="#Spring-6-0-2022"></a>Spring 6.0 (2022)</h2>
<p><strong>特点</strong>:</p>
<ul>
<li>完全支持 Java 17 和 Jakarta EE 9。</li>
<li>重构了许多核心模块，以利用 Java 语言的新特性和改进。</li>
<li>加强了对模块化和微服务架构的支持，进一步优化了开发体验。</li>
</ul>
<h2 id="Spring"><a class="header-anchor" href="#Spring"></a>Spring</h2>
<ol>
<li><strong>Spring</strong>：
<ul>
<li><strong>介绍</strong>：Spring是一个开源框架，提供了全面的基础设施支持，用于Java应用的开发。核心特性包括依赖注入和面向切面的编程。</li>
<li><strong>知识点</strong>：IoC（控制反转）、AOP（面向切面编程）、Spring容器等。</li>
</ul>
</li>
<li><strong>Spring MVC</strong>：
<ul>
<li><strong>介绍</strong>：Spring MVC是Spring框架的一部分，专注于构建Web应用。它采用MVC（模型-视图-控制器）设计模式，分离了应用的不同层。</li>
<li><strong>知识点</strong>：控制器、视图解析器、数据绑定、请求处理等。</li>
</ul>
</li>
<li><strong>Spring Boot</strong>：
<ul>
<li><strong>介绍</strong>：Spring Boot是Spring的扩展，旨在简化Spring应用的配置和部署。它提供了开箱即用的配置，减少了开发者的工作量。</li>
<li><strong>知识点</strong>：自动配置、独立应用、嵌入式服务器、Spring Boot Starter等。</li>
</ul>
</li>
<li><strong>Spring Cloud</strong>：
<ul>
<li><strong>介绍</strong>：Spring Cloud是为分布式系统提供工具的框架，支持微服务架构的开发。它提供了服务发现、负载均衡、配置管理等功能。</li>
<li><strong>知识点</strong>：Eureka（服务发现）、Ribbon（负载均衡）、Hystrix（熔断器）、Config Server（配置管理）等。</li>
<li><strong>核心组件</strong>：
<ul>
<li><strong>服务发现</strong>：如 Eureka、Consul。</li>
<li><strong>配置中心</strong>：如 Spring Cloud Config。</li>
<li><strong>负载均衡</strong>：如 Ribbon、Spring Cloud LoadBalancer。</li>
<li><strong>服务调用</strong>：如 Feign、RestTemplate。</li>
<li><strong>熔断器</strong>：如 Hystrix、Resilience4j。</li>
<li><strong>网关</strong>：如 Spring Cloud Gateway、Zuul。</li>
<li><strong>分布式追踪</strong>：如 Sleuth、Zipkin。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Spring JDBC</strong>：简化数据库操作</li>
<li><strong>Spring ORM</strong>：集成 Hibernate、MyBatis 等 ORM 框架</li>
<li><strong>Spring Security</strong>：提供安全认证和授权功能</li>
</ol>
<p><strong>区别对比</strong>：</p>
<ul>
<li><strong>功能范围</strong>：Spring是基础框架，Spring Boot简化配置，Spring MVC专注于Web开发，Spring Cloud支持微服务。</li>
<li><strong>应用场景</strong>：Spring适合通用Java开发，Spring Boot适合快速开发，Spring MVC用于构建Web应用，Spring Cloud用于构建分布式系统。</li>
</ul>
<p>如果想深入某一部分，随时告诉我！</p>
<h1 id="SpringBoot"><a class="header-anchor" href="#SpringBoot"></a>SpringBoot</h1>
<h2 id="基础知识："><a class="header-anchor" href="#基础知识："></a>基础知识：</h2>
<h3 id="HTTP协议-请求类型："><a class="header-anchor" href="#HTTP协议-请求类型："></a>HTTP协议&amp;请求类型：</h3>
<p>根据 HTTP 标准的不同，HTTP 请求可以使用多种请求方法。<br>
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br>
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<blockquote>
<p>GET,POST,PUT,DELETE使用较多</p>
</blockquote>
<ol>
<li><strong>GET</strong>：获取资源</li>
<li><strong>POST</strong>：传输请求实体</li>
<li><strong>PUT</strong>：传输文件</li>
<li><strong>DELETE</strong>：删除文件</li>
<li>HEAD：获得报文首部</li>
</ol>
<h3 id="三层架构"><a class="header-anchor" href="#三层架构"></a>三层架构</h3>
<p>将后端程序进行分离，划分为三个不同的层次</p>
<ol>
<li>Controller 控制层：负责接受前端发生的请求，对请求进行处理并响应数据</li>
<li>Service 业务逻辑层：处理具体的业务逻辑，例如将读取到的数据进行过滤</li>
<li>Data Access Object DAO 数据访问层：负责数据访问操作，即常规的增删改查</li>
</ol>
<h3 id="分层解耦"><a class="header-anchor" href="#分层解耦"></a>分层解耦</h3>
<ol>
<li>控制反转 Inversion Of Control IOC 对象的创建控制权由程序本身转移到外部容器中</li>
<li>依赖注入 Dependency Injection DI 容器为应用程序提供运行时所依赖的资源</li>
<li>Bean对象 IOC容器中创建、管理的对象，称之为bean</li>
</ol>
<h4 id="Bean的声明"><a class="header-anchor" href="#Bean的声明"></a>Bean的声明</h4>
<table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@Component</td>
<td style="text-align:left">声明bean的基础注解</td>
<td style="text-align:left">不属于以下三类，使用该注解(例如一些工具类)</td>
</tr>
<tr>
<td style="text-align:left">@Controller</td>
<td style="text-align:left">@Component的衍生注解</td>
<td style="text-align:left">属于控制权类</td>
</tr>
<tr>
<td style="text-align:left">@Service</td>
<td style="text-align:left">@Component的衍生注解</td>
<td style="text-align:left">属于业务逻辑类</td>
</tr>
<tr>
<td style="text-align:left">@Repository</td>
<td style="text-align:left">@Component的衍生注解</td>
<td style="text-align:left">属于数据访问类(由于与mabatis整合，用的少)</td>
</tr>
</tbody>
</table>
<h4 id="Resource和Autowired的区别"><a class="header-anchor" href="#Resource和Autowired的区别"></a>Resource和Autowired的区别</h4>
<ol>
<li>Autowired是spring框架提供的注解，Resource是JDK提供的注解</li>
<li>Autowired默认按类型注入，Resource默认按类名称注入</li>
</ol>
<h2 id="注入中的ByName和ByType"><a class="header-anchor" href="#注入中的ByName和ByType"></a>注入中的ByName和ByType</h2>
<ol>
<li>ByName依据的是Bean在IOC容器中的name（id）来匹配</li>
<li>ByType依据的是变量类型与Bean的Class类型进行匹配</li>
</ol>
<h3 id="AutoWired"><a class="header-anchor" href="#AutoWired"></a>AutoWired</h3>
<blockquote>
<p>由Spring提供，默认是byType方式进行注入，即注入时会到容器中去匹配Bean的类型，因此Autowired注入的对象必须在IOC容器中存在（除非加上属性 required = false，以忽略当前要注入的Bean）</p>
</blockquote>
<p>关于Autowired的警告：</p>
<ol>
<li>
<p>不推荐使用字段注入：</p>
<p>平常最常用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用上面的注入方式，可能会出现三种问题：</p>
<ol>
<li>
<p>对象的外部可见性：即，无法在容器外实例化TestService（在测试类中无法注入该组件），无法脱离容器访问目标对象，当在其他地方使用实例化的TestService对象时，会出现空指针异常（错误不明显）</p>
</li>
<li>
<p>循环的依赖注入：</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestA</span>()&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestB testB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestB</span>()&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestA testA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在可以idea中不会报错，但是在编译时，会造成循环的依赖注入死锁，即当前Bean已作为循环引用的一部分注入到了其他Bean中，无法被使用，造成死锁。</p>
</li>
<li>
<p>无法注入final对象，也无法注入static变量</p>
</li>
</ol>
</li>
<li>
<p>官方推荐的注入方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(DiscoveryClient discoveryClient , RestTemplate restTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="built_in">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Spring中前后端数据交互的方式"><a class="header-anchor" href="#Spring中前后端数据交互的方式"></a>Spring中前后端数据交互的方式</h2>
<p>前端两种请求方式：<strong>GET</strong>，<strong>POST</strong></p>
<ol>
<li>GET：有请求参数，没有请求体
<ol>
<li>使用场景：仅仅需要查询数据库内容，前端到后端数据库<strong>获取get</strong>数据</li>
</ol>
</li>
<li>POST：有请求体，也可以有请求参数
<ol>
<li>使用场景：前端需要<strong>交付数据</strong>，并对数据库的内容进行<strong>增删改</strong></li>
</ol>
</li>
</ol>
<p>请求和响应都具备四部分内容：</p>
<ol>
<li><strong>请求行（响应行）</strong></li>
<li><strong>请求头（响应头）</strong>：有一个重要的header——content-type：告诉接收方如何解析对象的body数据。</li>
<li><strong>空行</strong></li>
<li><strong>请求体（响应体）</strong></li>
</ol>
<p>在Java中，可以使用json实现前后端数据交互</p>
<p>json有两种形式：json字符串和json对象</p>
<p>后端controller层接受请求时，常用两个注解：</p>
<ol>
<li>@RequestParam（请求参数）：常用于get方法</li>
<li>@RequestBody（请求体）：常用于post方法</li>
</ol>
<blockquote>
<p>不使用注解也可以获取到请求参数（请求体）数据，因为SpringMVC会自动映射</p>
</blockquote>
<h1 id="SpringTask"><a class="header-anchor" href="#SpringTask"></a>SpringTask</h1>
<blockquote>
<p>一款由Spring提供的任务调度工具，定时任务框架，可以按照约定时间自动执行某个代码逻辑</p>
</blockquote>
<p>定时自动执行某段Java代码</p>
<h2 id="核心部分：cron表达式"><a class="header-anchor" href="#核心部分：cron表达式"></a>核心部分：cron表达式</h2>
<blockquote>
<p>一个字符串，通过cron表达式可以定义任务触发时间</p>
</blockquote>
<p><strong>构成规则：</strong></p>
<ol>
<li></li>
</ol>
<h1 id="SpringCloud"><a class="header-anchor" href="#SpringCloud"></a>SpringCloud</h1>
<h2 id="单体架构"><a class="header-anchor" href="#单体架构"></a>单体架构</h2>
<ol>
<li>将业务中的所有功能进行集成，集中到一个项目中进行开发，并打包到一个jar/war包进行部署。</li>
<li>优点：架构简单，部署成本低</li>
<li>缺点：
<ol>
<li>团队协作成本高</li>
<li>系统发布效率低（编译一个大型的单体架构项目所需时间及其旧）</li>
<li>系统可用性差</li>
</ol>
</li>
</ol>
<h2 id="微服务架构"><a class="header-anchor" href="#微服务架构"></a>微服务架构</h2>
<ol>
<li>将一个项目以业务需求进行拆分，分成一个个小型的项目，再进行连接</li>
</ol>
<h3 id="服务拆分的原则："><a class="header-anchor" href="#服务拆分的原则："></a>服务拆分的原则：</h3>
<h4 id="何时拆："><a class="header-anchor" href="#何时拆："></a>何时拆：</h4>
<ol>
<li>创业型项目：先使用单体架构快速开发，随着规模的扩大再逐渐拆分</li>
<li>确定的大型项目：资金充足的情况下，项目的架构清晰明了，可以直接使用微服务，避免后续的拆分，先难后易</li>
</ol>
<h4 id="怎么拆"><a class="header-anchor" href="#怎么拆"></a>怎么拆</h4>
<ol>
<li>
<p>高内聚：职责尽量单一，业务关联度和完整度高</p>
</li>
<li>
<p>低耦合：每个微服务的功能相对独立，降低对其他服务的依赖</p>
</li>
<li>
<p>拆分方式：</p>
<ol>
<li><strong>纵向</strong>：按照业务模块进行拆分</li>
<li><strong>横向</strong>：抽取公共服务，提高复用性</li>
</ol>
</li>
</ol>
<h4 id="实际拆分服务"><a class="header-anchor" href="#实际拆分服务"></a>实际拆分服务</h4>
<ol>
<li>工程结构：
<ol>
<li>独立Project</li>
<li>maven聚合</li>
</ol>
</li>
</ol>
<h3 id="远程调用"><a class="header-anchor" href="#远程调用"></a>远程调用</h3>
<blockquote>
<p>在进行服务拆分的时候不可避免的需要有A服务的业务需要调用B服务的业务下的数据库，但是为了进行功能的拆分解耦，又不能出现B服务的业务代码，因此可以参考前后端联调的方式，由A服务向B服务发出一个http的get请求，B服务正常的响应请求，返回数据。</p>
</blockquote>
<p>在Java中使用远程调用，可以通过调用RestTemplate接口，通过实例化一个RestTemplate的对象，进而发出http请求，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于XxxApplication类本身就是一个注册类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>
<p>所以可以直接在XxxApplication当中将RestTemplate注册到Bean容器当中</p>
<h3 id="服务治理"><a class="header-anchor" href="#服务治理"></a>服务治理</h3>
<h4 id="三种角色"><a class="header-anchor" href="#三种角色"></a>三种角色</h4>
<ol>
<li>
<p>服务提供者：暴露接口服务，供其他服务调用</p>
</li>
<li>
<p>服务消费者：调用其他服务提供的接口</p>
</li>
<li>
<p>注册中心：记录并监控微服务各个实例的状态，推送服务变更信息（心跳机制）</p>
<ol>
<li>
<p>心跳机制：<a href="https://blog.csdn.net/aspnet_lyc/article/details/37318861">参考的原文链接</a></p>
<p>就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。</p>
<p>发包方：可以是客户也可以是服务端，看哪边实现方便合理。<br>
心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。</p>
</li>
</ol>
</li>
</ol>
<h4 id="消费者如何得知提供者地址"><a class="header-anchor" href="#消费者如何得知提供者地址"></a>消费者如何得知提供者地址</h4>
<p>服务提供者会在启动时注册自己的信息到注册中心，消费者可以从注册中心订阅和拉取服务信息</p>
<h4 id="消费者如何得知服务状态的变更"><a class="header-anchor" href="#消费者如何得知服务状态的变更"></a>消费者如何得知服务状态的变更</h4>
<p>服务提供者通过心跳机制来向注册中心报告自己的健康状态，当心跳异常时，注册中心会将异常的服务剔除（登记死亡），并通知订阅了服务的消费者。</p>
<h4 id="在提供者有多个实例时，如何选择："><a class="header-anchor" href="#在提供者有多个实例时，如何选择："></a>在提供者有多个实例时，如何选择：</h4>
<p>消费者根据负载均衡算法从多个实例选择一个。</p>
<h3 id="OpenFeign"><a class="header-anchor" href="#OpenFeign"></a>OpenFeign</h3>
<p><a href="https://so.csdn.net/so/search?q=Feign%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;spm=1001.2101.3001.7020">OpenFeign客户端</a>是一个web声明式http远程调用工具，直接可以根据服务名称去注册中心拿到指定的服务IP集合，提供了接口和注解方式进行调用，内嵌集成了Ribbon本地负载均衡器。</p>
<p>定义一个接口，用以订阅某个服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span> <span class="comment">//声明服务的名称（即需要拉取的实例的所属的服务的名称）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span><span class="comment">//声明http请求的类型为Get 模仿生成请求url</span></span><br><span class="line">    <span class="comment">/*声明请求的返回值类型*/</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">( <span class="comment">/*请求url的请求参数*/</span> <span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OpenFeign的最佳实践"><a class="header-anchor" href="#OpenFeign的最佳实践"></a>OpenFeign的最佳实践</h4>
<p>为了防止出现重复的代码（当需要在Xxx服务当中使用Item-service时，就需要在Xxx服务当中去引入以上这些相同的代码，造成了代码的冗余与维护的不便。）</p>
<ol>
<li>
<p>可以将OpenFeign的实践代码放入Item-service本身，将这部分当做item-service的一个模块，将ItemClient设置为对外的一个功能接口，当需要使用时直接用模块坐标，通过pom导入即可使用。</p>
<p>当这样子，会把项目结构复杂化，会把原来一个简单的模块变得更加复杂。</p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus插件使用</title>
    <url>/2025/03/07/%E6%8F%92%E4%BB%B6/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Mybatis-Plus"><a class="header-anchor" href="#Mybatis-Plus"></a>Mybatis-Plus</h1>
<p>使用 Mybatis-Plus 简化数据库单表操作</p>
<h2 id="基本的-CRUD"><a class="header-anchor" href="#基本的-CRUD"></a>基本的 CRUD</h2>
<h3 id="依赖引入"><a class="header-anchor" href="#依赖引入"></a>依赖引入</h3>
<p>MybatisPlus提供了starter，实现了自动Mybatis以及MybatisPlus的自动装配功能，坐标如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个starter包含对mybatis的自动装配，因此完全可以替换掉Mybatis的starter。</p>
<p>最终，想要使用 MP 项目需要的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义-Mapper-接口"><a class="header-anchor" href="#自定义-Mapper-接口"></a>自定义 Mapper 接口</h3>
<p>MP 提供了基础的 BaseMapper 接口，其中已经实现了单表的 CRUD</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503070908706.png" alt="image-20250307090814512" style="zoom:67%;" />
<p>只要自定义的 Mapper 实现了 BaseMapper ，就无需自己实现单表的 CRUD</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;Lucy&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">        user.setBalance(<span class="number">200</span>);</span><br><span class="line">        user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">        user.setCreateTime(LocalDateTime.now());</span><br><span class="line">        user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectByIds</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setBalance(<span class="number">20000</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">5L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用注解"><a class="header-anchor" href="#常用注解"></a>常用注解</h2>
<p>自定义 Mapper 在继承 BaseMapper 时会指定一个泛型，这个泛型是与数据库对应的 PO，MP 是根据 PO 实体的信息来推断出表的信息，从而生成 SQL 的。</p>
<p>默认情况下：</p>
<ul>
<li>MP 会把 PO 实体的类名驼峰转下划线作为表名，例如 <code>MpUser</code> 会映射到数据库的 <code>mp_user</code></li>
<li>MP 会把 PO 实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li>
<li>MP 会把名字为 id 字段作为主键</li>
</ul>
<h3 id="TableName"><a class="header-anchor" href="#TableName"></a>@TableName</h3>
<ul>
<li>描述：表名注解，标识实体类对应的表</li>
<li>使用位置：实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TableName注解除了指定表名以外，还可以指定很多其它属性：</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>必须指定</strong></th>
<th><strong>默认值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>表名</td>
</tr>
<tr>
<td>schema</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>schema</td>
</tr>
<tr>
<td>keepGlobalPrefix</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td>
</tr>
<tr>
<td>resultMap</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td>
</tr>
<tr>
<td>autoResultMap</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td>
</tr>
<tr>
<td>excludeProperty</td>
<td>String[]</td>
<td>否</td>
<td>{}</td>
<td>需要排除的属性名 @since 3.3.1</td>
</tr>
</tbody>
</table>
<h3 id="TableId"><a class="header-anchor" href="#TableId"></a>TableId</h3>
<ul>
<li>描述：主键注解，标识实体类中的主键字段</li>
<li>使用位置：实体类的主键字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TableId</code>注解支持两个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>属性</strong></th>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>必须指定</strong></th>
<th style="text-align:left"><strong>默认值</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String</td>
<td style="text-align:left">否</td>
<td style="text-align:left">“”</td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">Enum</td>
<td style="text-align:left">否</td>
<td style="text-align:left">IdType.NONE</td>
<td style="text-align:left">指定主键类型</td>
</tr>
</tbody>
</table>
<p><code>type</code>支持的类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>值</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AUTO</td>
<td style="text-align:left">数据库 ID 自增</td>
</tr>
<tr>
<td style="text-align:left">NONE</td>
<td style="text-align:left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td>
</tr>
<tr>
<td style="text-align:left">INPUT</td>
<td style="text-align:left">insert 前自行 set 主键值</td>
</tr>
<tr>
<td style="text-align:left">ASSIGN_ID</td>
<td style="text-align:left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td>
</tr>
<tr>
<td style="text-align:left">ASSIGN_UUID</td>
<td style="text-align:left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td>
</tr>
<tr>
<td style="text-align:left">ID_WORKER</td>
<td style="text-align:left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td>
</tr>
<tr>
<td style="text-align:left">UUID</td>
<td style="text-align:left">32 位 UUID 字符串(please use ASSIGN_UUID)</td>
</tr>
<tr>
<td style="text-align:left">ID_WORKER_STR</td>
<td style="text-align:left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td>
</tr>
</tbody>
</table>
<p>这里比较常见的有三种：</p>
<ul>
<li><code>AUTO</code>：利用数据库的id自增长</li>
<li><code>INPUT</code>：手动生成id</li>
<li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li>
</ul>
<h3 id="TableField"><a class="header-anchor" href="#TableField"></a>TableField</h3>
<ul>
<li>普通字段注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(is_married&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;`concat`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String concat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：</p>
<ul>
<li>成员变量名与数据库字段名不一致</li>
<li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符。</li>
<li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：``</li>
</ul>
<p>支持的其它属性如下：</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>必填</strong></th>
<th><strong>默认值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>数据库字段名</td>
</tr>
<tr>
<td>exist</td>
<td>boolean</td>
<td>否</td>
<td>true</td>
<td>是否为数据库表字段</td>
</tr>
<tr>
<td>condition</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的，<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java">参考(opens new window)</a></td>
</tr>
<tr>
<td>update</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>字段 update set 部分注入，例如：当在version字段上注解update=“+1” 表示更新时会 set version=version+1 （该属性优先级高于 el 属性）</td>
</tr>
<tr>
<td>insertStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td>举例：NOT_NULL insert into table_a(<if test="columnProperty != null">column</if>) values (<if test="columnProperty != null">#{columnProperty}</if>)</td>
</tr>
<tr>
<td>updateStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td>举例：IGNORED update table_a set column=#{columnProperty}</td>
</tr>
<tr>
<td>whereStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td>举例：NOT_EMPTY where <if test="columnProperty != null and columnProperty!=''">column=#{columnProperty}</if></td>
</tr>
<tr>
<td>fill</td>
<td>Enum</td>
<td>否</td>
<td>FieldFill.DEFAULT</td>
<td>字段自动填充策略</td>
</tr>
<tr>
<td>select</td>
<td>boolean</td>
<td>否</td>
<td>true</td>
<td>是否进行 select 查询</td>
</tr>
<tr>
<td>keepGlobalFormat</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否保持使用全局的 format 进行处理</td>
</tr>
<tr>
<td>jdbcType</td>
<td>JdbcType</td>
<td>否</td>
<td>JdbcType.UNDEFINED</td>
<td>JDBC 类型 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td>typeHandler</td>
<td>TypeHander</td>
<td>否</td>
<td></td>
<td>类型处理器 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td>numericScale</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>指定小数点后保留的位数</td>
</tr>
</tbody>
</table>
<h2 id="常见配置"><a class="header-anchor" href="#常见配置"></a>常见配置</h2>
<p><a href="https://baomidou.com/reference/">使用配置 | MyBatis-Plus</a></p>
<p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p>
<ul>
<li>实体类的别名扫描包</li>
<li>全局id类型</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置（由此可以看出，MP 只是对 mybatis 的增强，还是支持原本的 mybatis 功能）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure>
<h2 id="条件构造器"><a class="header-anchor" href="#条件构造器"></a>条件构造器</h2>
<h2 id="处理枚举、JSON-类型字段"><a class="header-anchor" href="#处理枚举、JSON-类型字段"></a>处理枚举、JSON 类型字段</h2>
<h2 id="MybatisPlus-实现分页"><a class="header-anchor" href="#MybatisPlus-实现分页"></a>MybatisPlus 实现分页</h2>
]]></content>
      <tags>
        <tag>插件</tag>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解收集</title>
    <url>/2025/03/01/Spring/spring%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="Spring-注解收集"><a class="header-anchor" href="#Spring-注解收集"></a>Spring 注解收集</h1>
<p><code>@RestControllerAdvice</code></p>
<p><code>@RestControllerAdvice</code> 注解用于定义<strong>全局异常处理器</strong>。它结合了 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code>，使得在处理控制器异常时，可以直接返回 JSON 或 XML 格式的响应。这个注解通常用于捕获和处理应用程序中的异常，并将其转换为适当的 HTTP 响应。</p>
<ul>
<li><code>@ControllerAdvice</code>:
<ul>
<li>这是一个 Spring 提供的注解，用于定义全局的异常处理、数据绑定、数据预处理等。</li>
<li>它可以应用于所有控制器，帮助开发者集中管理控制器的全局配置。</li>
</ul>
</li>
<li><code>@ResponseBody</code>:
<ul>
<li>这是一个 Spring MVC 提供的注解，用于将控制器的方法返回值直接写入 HTTP 响应体中。</li>
<li>通常用于 RESTful Web 服务，返回 JSON 或 XML 格式的数据，而不是视图页面。</li>
</ul>
</li>
</ul>
<p><code>@ConditionalOnProperty</code> 注解的作用是根据配置文件中的属性值来决定是否启用某个 Spring 组件。具体来说：</p>
<ul>
<li><code>prefix</code>：属性的前缀。</li>
<li><code>name</code>：属性的名称。</li>
<li><code>havingValue</code>：属性的期望值。</li>
</ul>
<p>例如在代码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;bilibili&quot;, name = &quot;exception-handler&quot;, havingValue = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>
<p>表示只有当配置文件中 <code>bilibili.exception-handler</code> 的值为 <code>true</code> 时，<code>GlobalExceptionHandler</code> 类才会被加载到 Spring 容器中。</p>
<p><code>CrossOrigin</code>用来解决跨域问题，且是服务端进行解决</p>
<p><code>@Data</code> 是 Lombok 提供的一个注解，用于简化 Java 类的开发。它的作用是自动生成常见的类方法，减少了样板代码。具体来说，<code>@Data</code> 注解会自动为类生成以下方法：</p>
<ol>
<li><strong>Getter</strong>：为所有字段生成 getter 方法。</li>
<li><strong>Setter</strong>：为所有非 <code>final</code> 字段生成 setter 方法。</li>
<li><strong>toString()</strong>：生成 <code>toString()</code> 方法，包含类中所有字段。</li>
<li><strong>equals()</strong>：生成 <code>equals()</code> 方法，比较两个对象的字段是否相等。</li>
<li><strong>hashCode()</strong>：生成 <code>hashCode()</code> 方法，根据对象的字段计算 hash 值。</li>
<li><strong>RequiredArgsConstructor</strong>：生成一个包含所有 <code>final</code> 字段和标记为 <code>@NonNull</code> 的字段的构造函数。</li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 集成 Swagger 3.x 版本使用学习</title>
    <url>/2025/03/04/Spring/Swagger3.x%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Spring-集成-Swagger-3-x-版本使用学习"><a class="header-anchor" href="#Spring-集成-Swagger-3-x-版本使用学习"></a>Spring 集成 Swagger 3.x 版本使用学习</h1>
<h2 id="POM导入"><a class="header-anchor" href="#POM导入"></a>POM导入</h2>
<blockquote>
<p>由于Java17以上版本使用的Spring框架为3.x版本，因此需要使用新版本的Swagger以完成api文档接口</p>
</blockquote>
<p>首先是POM文件的导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-doc-last-new-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>#注意，此处和swagger2的依赖名有区别，需要进行区分。</span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;knife4j-last-new-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="资源包中yaml的配置"><a class="header-anchor" href="#资源包中yaml的配置"></a>资源包中yaml的配置</h2>
<p>然后是在资源包当中进行依赖的配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Swagger配置</span></span><br><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">api-docs:</span></span><br><span class="line">    <span class="comment"># 是否开启文档功能</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># swagger后端请求地址</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/v3/api-docs</span></span><br><span class="line">  <span class="attr">swagger-ui:</span></span><br><span class="line">    <span class="comment"># 是否开启ui功能</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 自定义swagger前端请求路径</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/swagger-ui.html</span></span><br><span class="line">  <span class="comment"># 包扫描路径</span></span><br><span class="line">  <span class="attr">packages-to-scan:</span> <span class="string">com.sky.controller</span></span><br><span class="line">  <span class="comment"># 请求参数使用对象包装时以分散的参数生成api文档</span></span><br><span class="line">  <span class="attr">default-flat-param-object:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="comment"># 开启增强配置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 开启生产环境屏蔽（如果是生产环境，需要把下面配置设置true）</span></span><br><span class="line">  <span class="comment"># production: true</span></span><br><span class="line">  <span class="attr">setting:</span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh_cn</span></span><br></pre></td></tr></table></figure>
<h2 id="常用注解发送变化"><a class="header-anchor" href="#常用注解发送变化"></a>常用注解发送变化</h2>
<p>在新版本的Swagger当中，常用注解发生了改变</p>
<blockquote>
<p>因为原本的swagger使用的是springfox为基础，而新架构的swagger是集成到Springboot框架当中的，使用的是springdoc依赖，因此注解会发生改变</p>
</blockquote>
<table>
<thead>
<tr>
<th>注解名</th>
<th>作用区域</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tag</td>
<td>作用于类，用于描述类的作用</td>
</tr>
<tr>
<td>Operation</td>
<td>作用于方法，用于描述方法的作用和形参列表</td>
</tr>
<tr>
<td>Scheme</td>
<td>作用于字段，用于描述字段的含义和作用</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Tag <strong>配置文档标题及归类，就是在Controller上配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解：<span class="meta">@Tag</span> 可以用于对接口进行分类和归类，便于开发人员组织和管理 API 文档</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：name：表示标签的名称，必填属性，也得注意多个Controller上的name不要写一样的，这样就会把它们归类在一起。</span><br><span class="line">        ②：description：表示标签的描述信息，非必填属性。</span><br><span class="line">        ③：externalDocs：用于指定URL地址文档信息来追加描述接口的信息。非必填属性。</span><br><span class="line">        示例：</span><br><span class="line">            <span class="meta">@Tag(</span></span><br><span class="line"><span class="meta">                    name = &quot;StudentControllerAPI&quot;,</span></span><br><span class="line"><span class="meta">                    description = &quot;学生控制器接口&quot;,</span></span><br><span class="line"><span class="meta">                    externalDocs = @ExternalDocumentation(</span></span><br><span class="line"><span class="meta">                            description = &quot;这是一个接口文档介绍&quot;,</span></span><br><span class="line"><span class="meta">                            url = &quot;https://www.cnblogs.com/antLaddie/&quot;))</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Operation <strong>配置文档下的每一个接口信息，就是Controller里的每一个RequestMapping</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解：<span class="meta">@Operation</span>用于对API操作（即方法）进行描述和标记。就是我们熟知的Controller下的一个个请求的方法上。</span><br><span class="line">    具体可以参考 io.swagger.v3.oas.annotations。</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：summary：用于简要描述API操作的概要。</span><br><span class="line">        ②：description：用于详细描述API操作的描述信息。</span><br><span class="line">        ③：parameters：用于指定API操作的参数列表，包括路径参数、请求参数、请求头部等。可以使用<span class="meta">@Parameter</span>注解进一步定义参数。</span><br><span class="line">        ④：operationId：用于指定API操作的唯一标识符，可以用于生成客户端代码或文档等。</span><br><span class="line">            说明：第三方工具使用operationId来唯一标识此操作。（具体我也没用过）</span><br><span class="line">        ⑤：requestBody：用于定义API操作的请求体，可以使用<span class="meta">@RequestBody</span>注解进一步定义请求体。</span><br><span class="line">            说明：这里的<span class="meta">@RequestBody</span>注解是<span class="meta">@io</span>.swagger.v3.oas.annotations.parameters.RequestBody包里的</span><br><span class="line">        ⑥：responses：用于定义 API 操作的响应列表，包括成功响应和错误响应。可以使用<span class="meta">@ApiResponse</span>注解进一步定义响应。</span><br><span class="line">        ⑦：security：用于对API操作进行安全控制，可以使用<span class="meta">@SecurityRequirement</span>注解进一步定义安全需求。（后面说）</span><br><span class="line">        ⑧：deprecated：表示该API操作已经过时或不推荐使用。</span><br><span class="line">        <span class="meta">@Operation(</span></span><br><span class="line"><span class="meta">                summary = &quot;根据Id查询学生信息&quot;,</span></span><br><span class="line"><span class="meta">                description = &quot;根据ID查询学生信息，并返回响应结果信息&quot;,</span></span><br><span class="line"><span class="meta">                parameters = &#123;</span></span><br><span class="line"><span class="meta">                        @Parameter(name = &quot;id&quot;, description = &quot;学生ID&quot;, required = true, example = &quot;1&quot;)</span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                responses = &#123;</span></span><br><span class="line"><span class="meta">                        @ApiResponse(</span></span><br><span class="line"><span class="meta">                                responseCode = &quot;200&quot;,</span></span><br><span class="line"><span class="meta">                                description = &quot;响应成功&quot;,</span></span><br><span class="line"><span class="meta">                                content = @Content(</span></span><br><span class="line"><span class="meta">                                        mediaType = &quot;application/json&quot;,</span></span><br><span class="line"><span class="meta">                                        schema = @Schema(</span></span><br><span class="line"><span class="meta">                                                title = &quot;AjaxResul和StudentVO组合模型&quot;,</span></span><br><span class="line"><span class="meta">                                                description = &quot;返回实体，AjaxResult内data为StudentVO模型&quot;,</span></span><br><span class="line"><span class="meta">                                                anyOf = &#123;AjaxResult.class, StudentVO.class&#125;)</span></span><br><span class="line"><span class="meta">                                )</span></span><br><span class="line"><span class="meta">                        )</span></span><br><span class="line"><span class="meta">                &#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Scheme <strong>配置请求接口参数信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解：<span class="meta">@Schema</span> 是用于描述数据模型的基本信息和属性，具体可以参考“io.swagger.v3.oas.annotations.media”</span><br><span class="line">    具体属性：</span><br><span class="line">        ①：description：用于描述该类或属性的作用。</span><br><span class="line">        ②：name：指定属性名。该属性只对属性有效，对类无效。</span><br><span class="line">        ③：title：用于显示在生成的文档中的标题。</span><br><span class="line">        ④：requiredMode：用于指定该属性是否必填项。枚举Schema.RequiredMode内可选值如下：</span><br><span class="line">            默认AUTO：可有可无；REQUIRED：必须存在此字段(会加红色*)；NOT_REQUIRED：不需要存在此字段</span><br><span class="line">        ⑤：accessMode：用于指定该属性的访问方式。</span><br><span class="line">            包括AccessMode.READ_ONLY（只读）、AccessMode.WRITE_ONLY（只写）、AccessMode.READ_WRITE（读写）</span><br><span class="line">        ⑥：format：用于指定该属性的数据格式。例如：日期格式、时间格式、数字格式。</span><br><span class="line">        ⑦：example：为当前的属性创建一个示例的值，后期测试可以使用此值。</span><br><span class="line">        ⑧：deprecated：用于指定该属性是否为已过时的属性，默认为<span class="literal">false</span>。</span><br><span class="line">        ⑨：defaultValue：用于指定该属性的默认值。</span><br><span class="line">        ⑩：implementation：用于显示为该类或属性引入具体的实体路径，这代表当前指定的类或者属性将参考引入的实体。</span><br><span class="line">            就是说有个实体类，这个类里面有个teacher属性，这时里面的teacher属性可以指定具体的实体类，如下：</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="meta">@Schema(description = &quot;老师信息&quot;,implementation = Teacher.class)</span></span><br><span class="line">                <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">    其它属性：</span><br><span class="line">        ①：type：用于指定数据类型（Data Type）或者元素类型（Element Type）</span><br><span class="line">            基本类型：取值为相应的 Java 类型名，例如 <span class="type">int</span>、<span class="type">long</span>、<span class="type">float</span>、<span class="type">double</span>、<span class="type">boolean</span> 等。</span><br><span class="line">            包装类型：与基本类型相同，取值为相应的Java包装类型名，例如Integer、Long、Float、Double、Boolean等。</span><br><span class="line">            字符串类型：取值为string。</span><br><span class="line">            数组类型：取值为 array。对于数组类型，还可以使用 schema 属性指定其元素类型的 Schema 信息。</span><br><span class="line">            对象类型：不用指定type，可以通过implementation属性引入。</span><br><span class="line">            枚举类型：取值为<span class="keyword">enum</span>。对于枚举类型，还需要使用enumAsRef属性指定是否将其定义为一个独立的引用类型。</span><br><span class="line">            其它类型：不用指定type，可以通过implementation属性引入。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Schema</span>注解：提供了四个属性来描述复杂类型，分别是allOf、anyOf、oneOf和not。</span><br><span class="line">    这四个属性可以用于组合不同的JSON Schema以描述一个复杂类型，具体如下：</span><br><span class="line">    ①：allOf: 表示当前schema是多个其它schema的并集。</span><br><span class="line">        例如，如果一个Java类型同时实现了两个接口，那么可以使用allOf来表示这个Java类型继承了这两个接口的所有属性和方法。</span><br><span class="line">    ②：anyOf: 表示当前schema可以匹配其中任意一个schema，其本身也是一个组合体，可以嵌套使用。</span><br><span class="line">        例如，一个返回类型可能是多个Java类型中的任意一个，可以使用anyOf来描述这种情况。</span><br><span class="line">    ③：oneOf: 表示当前schema只能匹配其中一个schema，其本身也是一个组合体，可以嵌套使用。</span><br><span class="line">        例如，一个Java类型只能是多个子类型中的任意一个，可以使用oneOf来描述这种情况。</span><br><span class="line">    ④：not: 表示当前Schema不能匹配某个schema。</span><br><span class="line">        例如，一个Java类型不能是某个子类型，可以使用not来描述这种情况。</span><br><span class="line">    但是总感觉这个Swagger无法满足我特定要求的实体，具体解决如下：</span><br><span class="line">        比如我现在有个AjaxResult类（code，msg，data），其中data为Object或其它类型，这时我返回的数据里data为其它类型的</span><br><span class="line">        实体，所以我这里不理解如何返回的实体中，通过点击data而显示另外实体，我只能通过anyOf方式来实现（加上注解）</span><br><span class="line">        <span class="meta">@ApiResponse(</span></span><br><span class="line"><span class="meta">                responseCode = &quot;200&quot;,</span></span><br><span class="line"><span class="meta">                description = &quot;响应成功&quot;,</span></span><br><span class="line"><span class="meta">                content = @Content(</span></span><br><span class="line"><span class="meta">                        mediaType = &quot;application/json&quot;,</span></span><br><span class="line"><span class="meta">                        schema = @Schema(</span></span><br><span class="line"><span class="meta">                                description = &quot;返回实体，AjaxResult内data为StudentVO模型&quot;,</span></span><br><span class="line"><span class="meta">                                anyOf = &#123;AjaxResult.class, StudentVO.class&#125;)</span></span><br><span class="line"><span class="meta">                )</span></span><br><span class="line"><span class="meta">        )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Configuration配置"><a class="header-anchor" href="#Configuration配置"></a>Configuration配置</h2>
<p>以黑马的苍穹外卖为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*需要导入的jar包*/</span></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Contact;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.License;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springdoc.core.models.GroupedOpenApi;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerOpenAiConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以GroupedOpenApi➕package路径来将不同类别的controller对象进行分组以生成API文档*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">adminOpenApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .packagesToScan(<span class="string">&quot;com.sky.controller.admin&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">userOpenApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .packagesToScan(<span class="string">&quot;com.sky.controller.user&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;准备生成接口文档...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>()</span><br><span class="line">                .name(<span class="string">&quot;蔡桂&quot;</span>)</span><br><span class="line">                .email(<span class="string">&quot;1468664118@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">License</span> <span class="variable">license</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">License</span>()</span><br><span class="line">                .name(<span class="string">&quot;Apache 2.0&quot;</span>)</span><br><span class="line">                .url(<span class="string">&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;</span>)</span><br><span class="line">                .identifier(<span class="string">&quot;Apache-2.0&quot;</span>)</span><br><span class="line">                .extensions(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                .title(<span class="string">&quot;苍穹外卖项目-API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .license(license);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id=""><a class="header-anchor" href="#"></a></h2>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>员工后台管理系统</title>
    <url>/2025/03/01/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%91%98%E5%B7%A5%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-JavaWeb/</url>
    <content><![CDATA[<h1 id="员工后台管理系统"><a class="header-anchor" href="#员工后台管理系统"></a>员工后台管理系统</h1>
<blockquote>
<p>本文档用于总结学习黑马的javaweb课程的知识点和内容，根据视频顺序进行总结</p>
</blockquote>
<h1 id="项目总览"><a class="header-anchor" href="#项目总览"></a>项目总览</h1>
<p>总览本项目，是一个实现了前后端发分离的单体架构项目。</p>
<p><strong>单体架构</strong>：即一个项目所需的所有功能组件：包括业务逻辑，功能和交互组件都集成在一个环境当中，最终上限部署时打包在一个war包当中，并运行在一个服务器上。</p>
<p>经典的单体架构技术选择为：Java➕Spring MVC</p>
<p>此处引出黑马javaweb选择的框架：SSM框架。</p>
<p><strong>SSM框架</strong>即为：Spring➕Spring MVC➕Mybatis，是一套标准的MVC模式：Model-View-Controller模式，模型、视图与控制器。</p>
<p><strong>MVC模式三大部分：</strong></p>
<ol>
<li>**Model 模型：**即实际功能与业务逻辑的实现区域，同时具备对数据的直接访问权。</li>
<li>**Controller 控制器：**负责进行事件的处理并作出事件的响应。</li>
<li>**View 视图：**提供给用户的可直观使用的交互场所，view可以通过用户的行为向控制器进行事件的传递并通过控制器间接与model进行交互</li>
</ol>
<p><strong>MVC的优缺：</strong></p>
<ol>
<li>低耦合度：每一层都职责分明，各层间采取接口的形式进行交互，某一层的改变不会影响其他层</li>
<li>复用性高：低耦合其中一个优势就是复用性的提高，例如逻辑上的一个功能模块：支付，既可以具体实现为微信支付，也可以具体实现为支付宝支付、银行卡支付……</li>
</ol>
<p>**SSM框架各大部件：**a</p>
<ol>
<li>
<p>**持久层：**Dao(mapper)层</p>
<ol>
<li>对数据库具体的操作语句放在这一层</li>
</ol>
</li>
<li>
<p>**业务层：**Service层</p>
<ol>
<li>
<p>Service负责实际的功能和业务逻辑，通过定义XXX_Service接口和对应的XXX_ServiceImplement来实现具体的功能</p>
</li>
<li>
<p>Service层向下直接和Dao层进行对接，</p>
<p>向上直接和Controller对接</p>
</li>
</ol>
</li>
<li>
<p>**表现层：**Controller(header)层</p>
<ol>
<li>负责具体的业务控制流程，即控制业务功能的调用</li>
</ol>
</li>
<li>
<p>**视图层：**View层</p>
<ol>
<li>与Controller层对接，负责将前端接收到的信号传递给Controller以完成对业务功能的调用。</li>
</ol>
</li>
</ol>
<p><strong>Spring：</strong></p>
<p>Spring中最重要的几个概念：</p>
<p><strong>DI(依赖注入):</strong></p>
<p>由spring框架主动创建被调用类的对象（存储在IOC容器当中），并将创建出的对象注入到我们所声明的对象当中，在用户的视角里即，一个注解➕一个为类对象的声明即可调用一个未实例化的类对象。</p>
<p><strong>IOC(控制反转)：</strong></p>
<p>控制反转即<strong>控制权的反转</strong>，这里的控制权指的是仅需调用某个类对象当中的方法而不使用该类对象本身时，将该类对象的生命周期的管理控制权，通过IOC将该控制权交给第三方，由第三方进行统一调度管理。</p>
<p>通过注解的方式，使用单例模式，为创建出的类对象进行装载</p>
<p><strong>AOP(切面编程)：</strong></p>
<p>在不改变原本代码模型的基础上，通过动态代理的技术，增加业务功能以满足需求。</p>
<p><strong>SpringBoot：</strong></p>
<p>基于Spring而进行升级的全新框架</p>
<p><strong>核心组件：</strong></p>
<p><strong>自动配置：</strong></p>
<p>会自动根据添加的jar依赖，进行Spring应用程序合理的默认配置</p>
<p><strong>起步依赖：</strong></p>
<p>将常见的库整合起来，而开发时仅仅需要引入一个“spring-xx-xx-starter”起步依赖，即可导入依赖，避免了不同依赖间版本冲突和引入大量依赖的繁琐。</p>
<p><strong>Mybatis：</strong></p>
<p>核心是<strong>SqlSession</strong>，Mybatis是对jdbc的封装，使得对于数据库的操作更加简单清晰。</p>
<h1 id="前端部分"><a class="header-anchor" href="#前端部分"></a>前端部分</h1>
<p>前端部分采用经典的模式：HTML➕CSS➕JavaScript➕Vue</p>
<ol>
<li>HTML负责网页的整体框架、元素与内容</li>
<li>CSS负责元素的样式、外观</li>
<li>JavaScript负责网页的行为，例如用户点击登录之后将登录信息打包以Json的形式发送到后端。</li>
</ol>
<p>通过编写HTML语句，将编写好的代码交给浏览器内核core进行处理，最终呈现出用户可使用的可视化网页。</p>
<p>但是现今市面上的浏览器内核各不相同，对于某些技术的支持也参差不齐，因此会出现同一段代码在不同浏览器当中呈现的效果不同的问题。</p>
<p><strong>HTML：</strong></p>
<p>超文本标记语言：通过使用各种不同的标签，在可以显示文字的基础上还可以定义图片、音频、视频等内容。</p>
<p><strong>CSS：</strong></p>
<p>Cascading style sheet：层叠样式表，用于控制html页面的样式。</p>
<h1 id="后端部分"><a class="header-anchor" href="#后端部分"></a>后端部分</h1>
<h2 id="Maven"><a class="header-anchor" href="#Maven"></a>Maven</h2>
<p>一款用于管理和构建Java项目的工具，基于项目对象模型(Project Object Model，简称POM)</p>
<p>可以做到：</p>
<ol>
<li>
<p>依赖的统一管理：</p>
<ol>
<li>仅需在pom文件中加入标签即可自动导入需要的依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>项目结构的统一构建</p>
<ol>
<li>
<p>使用maven工具构建项目，得到的项目都具有同样的目录结构</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011239503.png" alt="image-20240818160911157" style="zoom:50%;" /> 
</li>
</ol>
</li>
</ol>
<p><strong>Maven模型：</strong></p>
<ul>
<li>**项目对象模型：**Project Object Model，将每一个模块和项目抽象层一个对象模型，具备自己专属的坐标——jar包的唯一标识，用于定位资源的位置。</li>
<li>**依赖管理模型：**Dependency</li>
<li>**构建生命周期/阶段：**Build lifecycle &amp; phases</li>
</ul>
<p><strong>Maven坐标</strong>：</p>
<ol>
<li>maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置</li>
<li>使用坐标来定义或引入项目中需要的依赖</li>
</ol>
<ul>
<li>Maven坐标的组成：
<ul>
<li><strong>groupId</strong>：定义当前Maven项目隶属组织名称（一般为域名反写，如：com.itheima）</li>
<li><strong>artifactId</strong>：定义当前Maven项目名称（通常是模块名称）</li>
<li><strong>version</strong>：定义当前项目版本号</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011239773.png" alt="image-20240830150934607"></p>
<h3 id="依赖管理"><a class="header-anchor" href="#依赖管理"></a>依赖管理</h3>
<h4 id="依赖配置"><a class="header-anchor" href="#依赖配置"></a>依赖配置</h4>
<p>添加dependencies标签后，</p>
<p>使用dependency引入依赖坐标groupId，artifactId，version</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactid</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="依赖传递"><a class="header-anchor" href="#依赖传递"></a>依赖传递</h4>
<p>依赖会形成像子父类继承一样的关系，即具有传递性</p>
<ul>
<li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li>
<li>间接依赖：被依赖的资源如果配置了其他的依赖资源，这当前项目也会间接依赖其他资源</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011239319.png" alt="image-20240830151846969"></li>
</ul>
<p><strong>排除依赖</strong>：也可以主动断开依赖的资源，被排除的依赖无需指定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;</span><br><span class="line">	&lt;version&gt;</span><br><span class="line">	&lt;exclusions&gt; 被排除的依赖</span><br><span class="line">		&lt;exclusion&gt;</span><br><span class="line">			&lt;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;</span><br><span class="line">		&lt;/exclusions&gt;</span><br><span class="line">	&lt;exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="依赖范围"><a class="header-anchor" href="#依赖范围"></a>依赖范围</h4>
<p>依赖的默认使用范围是全局使用，但也可以通过<code>&lt;scope&gt; &lt;/scope&gt;</code>标签来设置其作用范围。</p>
<p>作用范围：</p>
<ul>
<li>主程序范围有效（main文件夹范围内）</li>
<li>测试程序范围有效（test文件夹范围内）</li>
<li>是否参与打包运行（package指令范围内）</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011239193.png" alt="image-20240830152431678"></p>
<h4 id="生命周期"><a class="header-anchor" href="#生命周期"></a>生命周期</h4>
<p>三套独立的生命周期</p>
<p><strong>clean</strong>：清理工作，移除上一次构建生成的文件</p>
<p><strong>default</strong>：</p>
<ul>
<li>核心工作，如：编译、测试、打包、安装、部署等</li>
<li><strong>compile</strong>：编译项目源代码</li>
<li><strong>test</strong>：使用合适的单元测试框架运行测试（junit）</li>
<li><strong>packag</strong>：将编译后的文件打包，如jar和war</li>
<li><strong>install</strong>：安装项目到本地仓库</li>
</ul>
<p><strong>site</strong>：生成报告、发布站点等</p>
<h2 id="后端使用技术概况"><a class="header-anchor" href="#后端使用技术概况"></a>后端使用技术概况</h2>
<ol>
<li>
<p><strong>IOC Inversion of Control 控制权反转</strong>：（是一种设计思想，而非具体的技术）</p>
<ul>
<li>
<p>在传统的Java程序中，一个对象的生成和回收的控制权掌握在程序员手中，程序员会依据所需去创建对象</p>
<p>但是在spring框架中，一个对象的创建的控制权交给框架实现，由IOC容器统一管理这些对象的生命周期和对象间的关系，从而实现所谓的控制权反转</p>
<p>使用IOC将原本组件间直接的依赖关系转换成组件——框架——组件的间接依赖关系，并由容器动态管理，进行了组件间的解耦</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-java">public class FXNewsProvider &#123;
   private IFXNewsListener newsListener = new DowJonesNewsListener();
   private IFXNewsPersister newPersistener = new DowJonesNewsPersister();
   public void getAndPersistNews() &#123;
      String[] newsIds = newsListener.getAvailableNewsIds();
      if(ArrayUtils.isEmpty(newsIds)) &#123;
         return;
      &#125;
      for(String newsId : newsIds) &#123;
         FXNewsBean newsBean = newsListener.getNewsByPK(newsId);
         newPersistener.persistNews(newsBean);
         newsListener.postProcessIfNecessary(newsId);
      &#125;
   &#125;
&#125;

</code></pre>
</li>
<li>
<p>在Java中，由于只存在类的概念而没有单独的函数，因此当我们需要调用某一个方法是通常需要去先创建一个对象，而后通过该对象进行方法的调用。</p>
<p>但是本质上我们需要的只是调用方法，对象是不得已才创建的，因此只要是一个可以调用方法的对象，那么无所谓是我们创建的还是其他地方创建的</p>
<p>在这种背景下，我们通过使用IOC容器，将对象的创建交给框架，框架只需要在我们用到这个对象时完成依赖注入，使对象可以正常使用即可</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DI Dependency Injection 依赖注入</strong>：</p>
<ul>
<li>DI是IOC的一种实现方式，通过将对象的依赖关系注入到对象中；而不是由对象自己创建对象，形成依赖关系——即：<strong>组件之间依赖关系</strong>由容器在运行期间根据各种注解决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。</li>
<li><strong>提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong></li>
</ul>
</li>
<li>
<p><strong>Spring AOP Aspect-Oriented Programming</strong></p>
<blockquote>
<p>Spring的另一大核心，面向切面编程，对OOP的一种补充</p>
</blockquote>
<ol>
<li>一种编程范式，通过在程序中插入一个切入点，在不修改源代码的前提下给程序动态统一的添加额外的功能</li>
<li>提供的几种类型的增强：
<ol>
<li><strong>前置增强(Before Advice)</strong>：</li>
<li><strong>后置增强(After Advice)</strong>：</li>
<li><strong>返回增强(After Returning Advice)</strong>：</li>
<li><strong>异常增强(After Throwing Advice)</strong>：</li>
<li><strong>环绕增强(Around Advice)</strong>：</li>
</ol>
</li>
<li>使用动态代理技术，临时在内存中创建一个AOP对象，并将目标对象的源代码拷贝过来，插入到指定的增强位置中，从而实现额外功能的添加。</li>
<li>核心概念：
<ol>
<li><strong>切面(Aspect)</strong>：相当于一个横切关注点的实例，包括了连接点和通知，可以通过配置文件、注解等方式定义切面。</li>
<li><strong>连接点(Joinpoint)</strong>：可以被切面插入的点，最常用的连接点包括方法调用、方法执行过程中的某个时点等</li>
<li><strong>通知(Advice)</strong>：连接点处执行的点，分为多种通知：前置、后置、环绕。</li>
<li><strong>切点(Poingcut)</strong>：用于定义哪些连接点上应用通知。切点通过表达式定义</li>
<li><strong>织入(Weaving)</strong>：将切面应用到目标对象并创建新的代理对象的过程，织入可以在运行时完成，也可以在编译时完成：编译期织入和运行期织入。</li>
<li><strong>目标对象(Target)</strong>：</li>
<li><strong>代理对象(Proxy)</strong>：</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>Spring AOP的两种动态代理：JDK动态代理和CGLIB动态代理</strong></p>
<ol>
<li>基于类型：JDK动态代理是基于接口的代理，CGLIB动态代理是基于类的代理。</li>
<li>代理对象的创建：JDK通过Java自带的 java.lang.reflect.Proxy 创建代理对象，该对象必须实现一个或多个接口。CGLIB通过字节码生成技术创建代理对象，无需目标类实现接口，直接继承目标类。</li>
<li>JDk运行时需要使用反射，性能较低；CGLIB通过生成字节码，避免反射，性能较优。</li>
<li>JDk只能代理目标对象的接口方法，不能代理其父类中的方法；CGLIB可以代理目标类及其父类中的方法。</li>
<li>JDK动态代理的核心是<code>InvocationHandler</code>接口和<code>Proxy</code>类；如果目标类没有实现接口，那么<code>SpringAOP</code>会选择使用<code>CGLIB</code>来动态代理目标类。</li>
<li><code>CGLIB</code>是一个代码生成的类库，可以在运动时动态生成某个类的子类，通过<strong>继承</strong>来实现动态代理，如果类被标记为<code>final</code>，则无法使用<code>CGLIB</code>做动态代理。</li>
</ol>
</li>
<li>
<p><strong>事务管理</strong>：</p>
<ol>
<li>确保一组操作的原子性，即要么全部成功，一起提交；如果某一项出现问题，则全部回滚，确保数据的一致性。</li>
<li>在涉及到多个数据库操作或需要保证数据一致性的业务中，事务管理非常重要的</li>
</ol>
</li>
<li>
<p><strong>全局异常处理</strong>：</p>
<ol>
<li>对后端程序中发生的所有异常都进行统一处理，提高项目的健壮性和可维护性</li>
<li>可以使用全局异常处理将异常信息进行记录，返回完整的错误信息给前端，避免系统因未处理异常而崩溃</li>
</ol>
</li>
<li>
<p><strong>过滤器</strong>：</p>
<ol>
<li>拦截请求或响应，对其进行处理或修改</li>
<li>在请求到达Controller之前或响应返回给客户端之前，可以使用过滤器进行一些预处理或后处理的操作。</li>
</ol>
</li>
<li>
<p><strong>拦截器</strong>：</p>
<ol>
<li>与过滤器功能基本一致，只不过拦截器更专注于对Controller的方法进行预处理和后处理</li>
<li>在业务逻辑处理前后执行一些通用的操作，如权限验证、日志记录等。</li>
</ol>
</li>
</ol>
<h3 id="SSM框架"><a class="header-anchor" href="#SSM框架"></a>SSM框架</h3>
<ol>
<li><strong>Controller层</strong>：
<ol>
<li>处理用户请求，，调用相应的业务逻辑，并返回视图或数据给客户端</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="Alioss使用及配置"><a class="header-anchor" href="#Alioss使用及配置"></a>Alioss使用及配置</h3>
]]></content>
      <tags>
        <tag>项目总结</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>智能面试刷题平台</title>
    <url>/2025/03/01/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E6%99%BA%E8%83%BD%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="智能面试刷题平台"><a class="header-anchor" href="#智能面试刷题平台"></a>智能面试刷题平台</h1>
<h2 id="观看过程中产生的问题"><a class="header-anchor" href="#观看过程中产生的问题"></a>观看过程中产生的问题</h2>
<ol>
<li>如果需要更新记录的顺序为：1~100 删除第50道题目，后续题目的序号要修改吗，如果不修改是否会影响展示，如果修改的话有哪些策略</li>
</ol>
<p>优化小结：</p>
<ol>
<li>减少网络调用次数</li>
<li>减少接口传输数据的体积</li>
<li>减少循环和计算</li>
<li>通过客户端计算减少服务端压力</li>
</ol>
]]></content>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 原理篇</title>
    <url>/2025/03/01/Spring/spring%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Spring-原理篇"><a class="header-anchor" href="#Spring-原理篇"></a>Spring 原理篇</h1>
<p>本文主要学习目标为：</p>
<ul>
<li>理解 Spring 常见的一些类是为了实现什么功能的，其内部是怎么实现的才可以达到期望效果。</li>
<li>理解 Spring 中常见的一些机制，如：bean 的生命周期、bean的后处理器、动态代理、aop等是如何实现的，为了更好使用和修改框架内容做铺垫</li>
<li>理解 Spring 框架的设计哲学，通过 Spring 应用的代理模式、模板方法模式、工厂模式等常见的设计模式，更好的理解何为设计模式以及设计模式的好处与其背后的思维。</li>
</ul>
<p>本文学习的参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_46447737/article/details/124838766?spm=1001.2014.3001.5502">深度学习Spring5底层原理(黑马学习随笔)_黑马深度讲解spring5底层原理笔记-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1P44y1N7QG/?cvid=18324623&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">黑马程序员Spring视频教程，深度讲解spring5底层原理_哔哩哔哩_bilibili</a></li>
</ul>
<h2 id="容器与-Bean"><a class="header-anchor" href="#容器与-Bean"></a>容器与 Bean</h2>
<h3 id="第一讲-BeanFactory-与-ApplicationContext"><a class="header-anchor" href="#第一讲-BeanFactory-与-ApplicationContext"></a>第一讲 BeanFactory 与 ApplicationContext</h3>
<h4 id="BeanFactory是什么："><a class="header-anchor" href="#BeanFactory是什么："></a>BeanFactory是什么：</h4>
<ul>
<li><code>ApplicationContext</code> 的父接口</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228523.png" alt="ConfigurableApplicationContext"></p>
<ul>
<li>
<p>spring的<strong>核心容器</strong>，主要的<code>ApplicationContext</code>实现都【组合】了其功能</p>
</li>
<li>
<p>BeanFactory实际上是ApplicationContext的成员变量</p>
</li>
<li>
<p>实际上是 beanFactory 管理容器，其中容器中的 single instance bean 都是由 <code>DefaultSingletonBeanRegistry</code> 的<code>singletonObject</code>变量进行管理</p>
</li>
<li>
<p>但 beanFactory 本身并不具备那么多的功能，都是通过实现了它的接口或类来进行功能的扩展，这也符合 java 的接口设计理念</p>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228085.png" alt="DefaultListableBeanFactory"></p>
<h4 id="BeanFactory的作用"><a class="header-anchor" href="#BeanFactory的作用"></a>BeanFactory的作用</h4>
<p>表面上只有getBean，实际上控制反转、基本的依赖注入、直至Bean的生命周期的各种功能，都由它的实现类提供</p>
<p>在 BeanFactory 接口内查看方法（ctrl+F12）</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021017916.png" alt="image-20250302101746832" style="zoom: 67%;" />
<p>查看ConfigurableApplicationContext类中BeanFactory的实际类型：</p>
<blockquote>
<p>控制反转<em>IOC</em>，基本的依赖注入，Bean的生命周期的各种功能都由其实现类 <code>DefaultListableBeanFactory</code> 提供</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A1.class, args);</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory1</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">System.out.println(beanFactory1.getClass());</span><br><span class="line">System.out.println(context);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021036752.png" alt="image-20250302103610678"></p>
<h4 id="ApplicationContext-比-BeanFactory-多扩展了什么："><a class="header-anchor" href="#ApplicationContext-比-BeanFactory-多扩展了什么："></a>ApplicationContext 比 BeanFactory 多扩展了什么：</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021042523.png" alt="ConfigurableApplicationContext"></p>
<p>看 ApplicationContext 实现了什么接口即可知道，分别是：</p>
<ul>
<li>MessageSource: 支持信息的国际化和包含参数的信息的替换</li>
<li>ResourcePatternResolver: 用于解析资源文件的策略接口</li>
<li>EnvironmentCapable: 环境信息，系统环境变量，<em>.properties、</em>.application.yml等配置文件中的值</li>
<li>ApplicationEventPublisher: 发布事件对象（用于代码解耦）</li>
</ul>
<p><code>ConfigurableApplicationContext interface</code>的继承/实现图谱</p>
<p><code>MessageSource</code>：Spring应用上下文的一个拓展接口，用于提供高效的上下文配置和控制功能</p>
<ul>
<li><strong>功能</strong>：
<ul>
<li>允许刷新、关闭和重新配置应用上下文（如 <code>refresh()</code> 和 <code>close()</code> 方法）。</li>
<li>提供了 <code>getBeanFactory()</code> 方法，用于获取底层的 <code>BeanFactory</code>，并允许对 Bean 工厂进行进一步配置。</li>
<li>支持 <code>addApplicationListener()</code> 添加事件监听器，用于监听应用上下文事件（如启动、关闭等）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>,<span class="literal">null</span>, Locale.SIMPLIFIED_CHINESE));</span><br><span class="line">System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>,<span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228078.png" alt="image-20241029201137782"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 国际化</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">i18n/messages</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>
<p>需注意，假如将 messages配置文件修改了路径，则需要额外在 <code>application.yml</code>当中专门进行配置，防止寻找不到messages.properties文件的位置</p>
<p><code>ResourcePatternResolver</code>：资源访问接口，用于解析文件、类路径资源等多种资源类型，并支持通配符（如 <code>*</code> 和 <code>?</code>）进行模式匹配。</p>
<ul>
<li>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>通过 <code>getResource(String location)</code> 方法，可以加载单一资源。</p>
</li>
<li>
<p>通过 <code>getResources(String locationPattern)</code> 方法，可以加载匹配特定模式的多个资源。</p>
</li>
<li>
<p>在 Spring 应用中，通常用于加载配置文件、XML、YAML 或属性文件等资源。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] resources =</span><br><span class="line">        context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationEventPublisher</code>：用于 Spring 应用事件的发布。</p>
<ul>
<li>
<p><strong>功能</strong>：</p>
</li>
<li>
<p>使用 <code>publishEvent()</code> 方法来发布应用事件，这些事件可以被 <code>ApplicationListener</code> 监听并做出相应的处理。</p>
</li>
<li>
<p>常用于触发某些特定的业务逻辑，例如用户注册事件、订单完成事件等，支持松耦合的事件驱动开发模式。</p>
</li>
</ul>
<p>事件的发布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件发布</span></span><br><span class="line">context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(context));</span><br></pre></td></tr></table></figure>
<p>对发布事件进行监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">    <span class="comment">//调试日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component2.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event: &#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EnviromentCapable</code>：环境访问接口，用于获取应用运行环境的信息。</p>
<ul>
<li><strong>功能</strong>：
<ul>
<li>提供了 <code>getEnvironment()</code> 方法，返回当前的 <code>Environment</code> 对象。</li>
<li><code>Environment</code> 包含了应用的属性信息（如系统环境变量、配置文件属性等），在开发和生产环境的配置管理中非常重要。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;maven_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011228782.png" alt="ConfigurableApplicationContext-1730200572243-1"></p>
<h3 id="第二讲-容器实现"><a class="header-anchor" href="#第二讲-容器实现"></a>第二讲 容器实现</h3>
<h4 id="BeanFactory-实现特点"><a class="header-anchor" href="#BeanFactory-实现特点"></a>BeanFactory 实现特点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="comment">//bean的定义(class，scope，初始化，销毁)</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">  BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(<span class="string">&quot;singleton&quot;</span>).getBeanDefinition();</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给BeanFactory添加一些常用的后处理器,将后处理器加到BeanFactory中</span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内置后处理器</span></span><br><span class="line"><span class="comment">//beanFactory后处理器主要功能，补充了一些bean定义</span></span><br><span class="line">beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().stream().forEach(beanFactoryPostProcessor -&gt; &#123;</span><br><span class="line">  beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Bean 后处理器 ，针对bean的生命周期的各个阶段提供扩展，例如 @Autowired @Resource   这里是建立BeanFactory和后处理器的联系</span></span><br><span class="line">beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提前准备好所有单例对象</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>学到了什么:</strong></p>
<ul>
<li><strong>beanFactory 不会做的事</strong></li>
</ul>
<blockquote>
<ol>
<li>不会主动调用BeanFactory后处理器</li>
<li>不会主动添加Bean后处理器</li>
<li>不会主动初始化单例</li>
<li>不会解析BeanFactory 还不会解析${}与#{}</li>
</ol>
</blockquote>
<ul>
<li><strong>bean后处理器会有排序的逻辑</strong></li>
</ul>
<h4 id="ApplicationContext的常见实现和用法"><a class="header-anchor" href="#ApplicationContext的常见实现和用法"></a>ApplicationContext的常见实现和用法</h4>
<p>四个ApplicationContext接口的实现类:</p>
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>AnnotationConfigApplicationContext</li>
<li>AnnotationConfigServletWebServerApplicationContext</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//较为经典的容器，基于classpath下xml格式的配置文件来创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassPathXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;b01.xml&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于磁盘路径下xml格式的配置文件来创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;src\\main\\resources\\b01.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//较为经典的容器，基于java配置类来实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">  <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//较为经典的容器，基于 java 配置类来创建，用于web环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Controller <span class="title function_">controller1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (request,response) -&gt; &#123;</span><br><span class="line">      response.getWriter().print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">(Bean1 bean1)</span>&#123;</span><br><span class="line">    <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    bean2.setBean1(bean1);</span><br><span class="line">    <span class="keyword">return</span> bean2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Bean1 bean1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bean1 = bean1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Bean1 <span class="title function_">getBean1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bean1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟-ClassPathXmlApplicationContext-的实现"><a class="header-anchor" href="#模拟-ClassPathXmlApplicationContext-的实现"></a>模拟 ClassPathXmlApplicationContext 的实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部实现</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;读取之后...&quot;</span>);</span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">reader.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;b01.xml&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（FileSystemXmlApplicationContext和ClassPathXmlApplicationContext的内部实现基本类似，导入xml文件方式不同）</p>
<p><strong>学到了什么:</strong></p>
<ul>
<li><strong>常见的ApplicationContext容器实现</strong></li>
<li><strong>内嵌容器、DispatcherServlet的创建方法、作用</strong></li>
</ul>
<h3 id="第三讲-Bean-的生命周期"><a class="header-anchor" href="#第三讲-Bean-的生命周期"></a>第三讲 Bean 的生命周期</h3>
<h4 id="Spring-bean-生命周期各个阶段"><a class="header-anchor" href="#Spring-bean-生命周期各个阶段"></a>Spring bean 生命周期各个阶段</h4>
<ul>
<li>构造</li>
<li>依赖注入</li>
<li>初始化</li>
<li>销毁</li>
</ul>
<p><strong>项目启动类代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A03Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A03Application.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义一个LifeCycleBean类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowire</span><span class="params">(<span class="meta">@Value(&quot;$&#123;CATALINA_HOME&#125;&quot;)</span> String home)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;依赖注入:&#123;&#125;&quot;</span>,home);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写自定义Bean的后处理器，对*<em>**lifeCycleBean**</em>*的生命周期过程进项扩展：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 销毁之前执行， 如@PreDestory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换原本的Bean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回null保持原有对象不变</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，这里如果返回false会跳过依赖注入阶段&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段，如@Autowired、@Value、@Resource&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之前执行，这里返回的对象会替换掉原本的bean，如@PostConstruct、@ConfigurationProperties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的bean，如代理增强&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码执行结果：</strong></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021049785.png" alt="image-20250302104923695"></p>
<h4 id="模板设计模式-对于不能确定的信息，可以把它抽象成接口，通过回调的方式对它的功能进行衔接和扩展"><a class="header-anchor" href="#模板设计模式-对于不能确定的信息，可以把它抽象成接口，通过回调的方式对它的功能进行衔接和扩展"></a>模板设计模式=&gt;对于不能确定的信息，可以把它抽象成接口，通过回调的方式对它的功能进行衔接和扩展</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">        beanFactory.addBeanPostProcessors(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">        beanFactory.addBeanPostProcessors(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">        beanFactory.getBean();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//模板方法 Template Method Pattern</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造&quot;</span> +bean);</span><br><span class="line">            System.out.println(<span class="string">&quot;依赖注入&quot;</span>+bean);</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.inject(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化&quot;</span>+bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessors</span><span class="params">(BeanPostProcessor processor)</span>&#123;</span><br><span class="line">            processors.add(processor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>;<span class="comment">//对依赖注入阶段的扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、常见后处理器以及-Autowired-注解后处理器执行分析"><a class="header-anchor" href="#四、常见后处理器以及-Autowired-注解后处理器执行分析"></a>四、常见后处理器以及 @Autowired 注解后处理器执行分析</h3>
<ul>
<li>通过上面对于 Bean 生命周期的研究，可以大致理解<strong>后处理器的作用</strong>：为Bean生命周期各个阶段提供扩展</li>
</ul>
<h4 id="常见的后处理器"><a class="header-anchor" href="#常见的后处理器"></a>常见的后处理器</h4>
<p>定义好四个bean，接下来用 GenericApplicationContext 容器来分别探究 @Autowired、@Value、@Resource、@PostConstruct、@PreDestroy 和 @ConfigurationProperties 这六个注解具体由哪个后处理器解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;@Autowired生效：&#123;&#125;&quot;</span>,bean2);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;@Resource 生效：&#123;&#125;&quot;</span>,bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHome</span><span class="params">(<span class="meta">@Value(&quot;$&#123;CATALINA_HOME&#125;&quot;)</span> String home)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;@Value生效：&#123;&#125;&quot;</span>,home);</span><br><span class="line">        <span class="built_in">this</span>.home = home;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;@PostConstruct生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;@PreDestroy生效 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bean1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bean2=&quot;</span> + bean2 +</span><br><span class="line">                <span class="string">&quot;, bean3=&quot;</span> + bean3 +</span><br><span class="line">                <span class="string">&quot;, home=&#x27;&quot;</span> + home + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;catalina&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHome</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> home;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHome</span><span class="params">(String home)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.home = home;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBase</span><span class="params">(String base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bean4&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;home=&#x27;&quot;</span> + home + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, base=&#x27;&quot;</span> + base + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注:】这里用 <code>GenericApplicationContext</code> 容器 来探究是因为其本身是一个【干净】的容器，默认不会添加任何后处理器，排除其他后处理器对测试结果的干扰</p>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A04Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//GenericApplicationContext是一个【干净的容器】,默认不会添加任何后处理器</span></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//用原始的方法注册三个bean</span></span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//添加解析@Value的解析器</span></span><br><span class="line">        context.getDefaultListableBeanFactory().setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        <span class="comment">//添加解析Autowired @Value 后处理器</span></span><br><span class="line">        context.registerBean(AutowiredAnnotationBeanPostProcessor.class );</span><br><span class="line">        <span class="comment">//添加解析@Resource @PostConstruct @PreDestroy 的后处理器</span></span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        <span class="comment">//添加解析@ConfigurationProperties的后处理器</span></span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//初始化容器</span></span><br><span class="line">        context.refresh();<span class="comment">//执行BeanFactory后处理器，添加bean后处理器，初始化所有单例</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(context.getBean(Bean4.class));</span><br><span class="line">        <span class="comment">//销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021055387.png" alt="image-20250302105525290"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bean4&#123;home=&#x27;D:\Tomcat\apache-tomcat-9.0.37&#x27;, base=&#x27;D:\Tomcat\apache-tomcat-9.0.37&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，我们可以得出结论：</p>
<ul>
<li>解析@Autowired注解的后处理器是 AutowiredAnnotationBeanPostProcessor</li>
<li>解析@Value注解的后处理器也是AutowiredAnnotationBeanPostProcessor，同时还需要</li>
<li>ContextAnnotationAutowireCandidateResolver处理器，否则无法读取@Value中的内容，继而抛出异常</li>
<li>解析@Resource、@PostConstruct、@PreDestroy注解的后处理器是CommonAnnotationBeanPostProcessor</li>
<li>解析@ConfigurationProperties 注解的处理器是ConfigurationPropertiesBindingPostProcessor</li>
</ul>
<h4 id="Autowired注解-后处理器执行分析"><a class="header-anchor" href="#Autowired注解-后处理器执行分析"></a>@Autowired注解 后处理器执行分析</h4>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AutowiredAnnotationBeanPostProcessor 运行分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigInAutowired</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean2</span>());<span class="comment">//不会走创建过程、依赖注入、初始化</span></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean3</span>());</span><br><span class="line">        beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        <span class="comment">//设置内嵌值得解析器，即$&#123;&#125;</span></span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//1.查找哪些属性、方法加了@Autowired，这称之为InjectionMetadata</span></span><br><span class="line">        <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        processor.setBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        <span class="comment">//System.out.println(bean1);</span></span><br><span class="line">        <span class="comment">//processor.postProcessProperties(null, bean1, &quot;bean1&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(bean1);</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">Method</span> <span class="variable">findAutowiringMetadata</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">        <span class="comment">//设置私有属性可以被访问</span></span><br><span class="line">        findAutowiringMetadata.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取bean1上加了@Value @Autowired注解的成员变量和方法参数信息</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) findAutowiringMetadata.invoke(processor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(metadata);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.调用InjectionMetadata来进行依赖注入，注入时按类型查找值</span></span><br><span class="line">        metadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line">        <span class="comment">//3.如何按类型查找值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Method</span> <span class="variable">setHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setHome&quot;</span>, String.class);</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setHome,<span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">19:27:43.907 [main] DEBUG com.boot.a04.Bean1 - @Value生效：D:\Tomcat\apache-tomcat-9.0.37</span><br><span class="line">19:27:43.909 [main] DEBUG com.boot.a04.Bean1 - @Autowired生效：com.atguigu.boot.a04.Bean2@20322d26</span><br><span class="line">Bean1&#123;bean2=com.atguigu.boot.a04.Bean2@20322d26, bean3=com.atguigu.boot.a04.Bean3@192b07fd, home=&#x27;D:\Tomcat\apache-tomcat-9.0.37&#x27;&#125;</span><br><span class="line">com.boot.a04.Bean3@192b07fd</span><br><span class="line">com.boot.a04.Bean2@20322d26</span><br><span class="line">19:27:43.909 [main] DEBUG org.springframework.core.env.PropertySourcesPropertyResolver - Found key &#x27;CATALINA_HOME&#x27; in PropertySource &#x27;systemEnvironment&#x27; with value of type String</span><br><span class="line">D:\Tomcat\apache-tomcat-9.0.37</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<ul>
<li>AutowiredAnnotationBeanPostProcessor 通过调用 postProcessProperties(PropertyValues pvs, Object bean, String beanName) 方法来完成对 @Autowired 注解的解析和注入</li>
<li>postProcessProperties(PropertyValues pvs, Object bean, String beanName) 中又调用私有方法findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs)</li>
<li>调用 InjectionMetadata 来进行依赖注入，注入时按类型查找值</li>
<li>注入时按照类型分为三种：成员变量注入、方法参数注入、方法参数注入(加@Value注解) 三种方法实现代码如上，简述其过程：InjectionMetadata 会把加 @Autowired 注解的属性（方法）BeanName（MethodName）拿到，再通过反射拿到属性（方法），然后将其封装成一个 DependencyDescriptor 对象，然后调用beanFactory.doResolveDependency 方法</li>
</ul>
<h3 id="第五讲-常见-BeanFactory-后处理器以及后处理器模拟实现"><a class="header-anchor" href="#第五讲-常见-BeanFactory-后处理器以及后处理器模拟实现"></a>第五讲 常见 BeanFactory 后处理器以及后处理器模拟实现</h3>
<p><strong>BeanFactory后处理器的作用</strong>：为BeanFactory提供扩展</p>
<h4 id="常见的BeanFactory后处理器"><a class="header-anchor" href="#常见的BeanFactory后处理器"></a>常见的BeanFactory后处理器</h4>
<p>探究 <strong>@Component</strong>、<strong>@ComponentScan、@Bean、@MapperScan</strong> 这四个注解分别是由哪个后处理器解析的**，**定义五个类，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;我被Spring管理了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot.a05.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db1&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A05Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        <span class="comment">//@ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        <span class="comment">//@MapperScan</span></span><br><span class="line">        context.registerBean(MapperScannerConfigurer.class,bd -&gt; &#123;</span><br><span class="line">            bd.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;com.atguigu.boot.a05.mapper&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<ul>
<li>
<p>解析 <strong>@Component、@ComponentScan</strong> 注解的BeanFactory后处理器是<strong>ConfigurationClassPostProcessor</strong></p>
</li>
<li>
<p>解析 <strong>@MapperScan</strong> 注解的BeanFactory后处理器是 <strong>MapperScannerConfigurer</strong></p>
</li>
</ul>
<h4 id="后处理器模拟实现"><a class="header-anchor" href="#后处理器模拟实现"></a>后处理器模拟实现</h4>
<p><strong>内部实现，自定义</strong> ComponentScanPostProcessor 类来解析 @ComponentScan 注解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line">            <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String basePackage : componentScan.basePackages()) &#123;</span><br><span class="line">                    System.out.println(basePackage);</span><br><span class="line">                    <span class="comment">//com.atguigu.boot.a05.component --&gt; classpath*:com/atguigu/boot/a05/component/**/*.class</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">                    System.out.println(path);</span><br><span class="line">                    <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                    Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                    <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        <span class="comment">//System.out.println(resource);</span></span><br><span class="line">                        <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                        System.out.println(<span class="string">&quot;类名:&quot;</span> + metadataReader.getClassMetadata().getClassName());</span><br><span class="line">                        <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">                        System.out.println(<span class="string">&quot;是否加@Component:&quot;</span> + annotationMetadata.hasAnnotation(Component.class.getName()));</span><br><span class="line">                        System.out.println(<span class="string">&quot;是否加@Component 派生注解:&quot;</span> + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span><br><span class="line"> </span><br><span class="line">                        <span class="comment">//抽取方法快捷键 Ctrl+Alt+V  如果直接加@Component或者间接加@Component的派生注解，就创建BeanDefinitionBuilder</span></span><br><span class="line">                        <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName()) ||</span><br><span class="line">                                annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line"> </span><br><span class="line">                            <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                                    .genericBeanDefinition(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                                    .getBeanDefinition();</span><br><span class="line"> </span><br><span class="line">                            <span class="comment">//查看接口的实现：Ctrl+Alt+B</span></span><br><span class="line">                            <span class="comment">//生成Bean名字</span></span><br><span class="line">                            <span class="comment">//if (configurableListableBeanFactory instanceof DefaultListableBeanFactory beanFactory) &#123;</span></span><br><span class="line">                                <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) configurableListableBeanFactory;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(bd, beanFactory);</span><br><span class="line">                                <span class="comment">//加入BeanFactory</span></span><br><span class="line">                                beanFactory.registerBeanDefinition(name, bd);</span><br><span class="line">                           <span class="comment">// &#125;</span></span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A05Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">       </span><br><span class="line">        context.registerBean(ComponentScanPostProcessor.class);</span><br><span class="line">        <span class="comment">//初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.atguigu.boot.a05.component</span><br><span class="line">classpath*:com/atguigu/boot/a05/component/**/*.class</span><br><span class="line">类名:com.atguigu.boot.a05.component.Bean2</span><br><span class="line">是否加@Component:true</span><br><span class="line">是否加@Component 派生注解:false</span><br><span class="line">类名:com.atguigu.boot.a05.component.Bean3</span><br><span class="line">是否加@Component:false</span><br><span class="line">是否加@Component 派生注解:true</span><br><span class="line">类名:com.atguigu.boot.a05.component.Bean4</span><br><span class="line">是否加@Component:false</span><br><span class="line">是否加@Component 派生注解:false</span><br><span class="line">21:46:59.470 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#x27;config&#x27;</span><br><span class="line">21:46:59.470 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#x27;bean2&#x27;</span><br><span class="line">21:46:59.471 [main] DEBUG com.atguigu.boot.a05.component.Bean2 - 我被Spring管理了...</span><br><span class="line">21:46:59.471 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#x27;bean3&#x27;</span><br><span class="line">21:46:59.471 [main] DEBUG com.atguigu.boot.a05.component.Bean3 - 我被Spring管理了...</span><br><span class="line">config</span><br><span class="line">com.atguigu.boot.a05.ComponentScanPostProcessor</span><br><span class="line">bean2</span><br><span class="line">bean3</span><br><span class="line">21:46:59.510 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Sat May 21 21:46:59 CST 2022</span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>
<p>内部实现，自定义 <strong>AtBeanPostProcessor</strong> 类来解析@Bean注解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取Config元数据信息</span></span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="comment">//不需要将类加载到JVM内存，效率比反射高</span></span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/atguigu/boot/a05/Config.class&quot;</span>));</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//获得被@Bean标注的方法信息</span></span><br><span class="line">            Set&lt;MethodMetadata&gt; methods = reader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line">            <span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"> </span><br><span class="line">                <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">                builder.setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config&quot;</span>);</span><br><span class="line">                <span class="comment">//设置自动装配模式</span></span><br><span class="line">                builder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">                <span class="keyword">if</span> (initMethod.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    builder.setInitMethodName(initMethod);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> builder.getBeanDefinition();</span><br><span class="line">                <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) configurableListableBeanFactory;</span><br><span class="line">                beanFactory.registerBeanDefinition(method.getMethodName(), bd);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A05Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">       </span><br><span class="line">        context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">com.atguigu.boot.a05.AtBeanPostProcessor</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br><span class="line">21:50:40.606 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Sat May 21 21:50:40 CST 2022</span><br><span class="line">21:50:40.608 [main] INFO com.alibaba.druid.pool.DruidDataSource - &#123;dataSource-1&#125; closed</span><br></pre></td></tr></table></figure>
<p>内部实现，自定义 <strong>MapperPostProcessor</strong> 类来解析 @Mapper 注解，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">            Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/atguigu/boot/a05/mapper/**/*.class&quot;</span>);</span><br><span class="line">            <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> reader.getClassMetadata();</span><br><span class="line">                <span class="keyword">if</span> (classMetadata.isInterface())&#123;</span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                            .addConstructorArgValue(classMetadata.getClassName())</span><br><span class="line">                            .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">bd2</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(classMetadata.getClassName()).getBeanDefinition();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(bd2, beanFactory);</span><br><span class="line">                    beanFactory.registerBeanDefinition(name, bd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A05Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line">        context.registerBean(MapperPostProcessor.class);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">com.atguigu.boot.a05.AtBeanPostProcessor</span><br><span class="line">com.atguigu.boot.a05.MapperPostProcessor</span><br><span class="line">mapper1</span><br><span class="line">mapper2</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br><span class="line">21:57:49.453 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Sat May 21 21:57:48 CST 2022</span><br><span class="line">21:57:49.453 [main] INFO com.alibaba.druid.pool.DruidDataSource - &#123;dataSource-1&#125; closed</span><br></pre></td></tr></table></figure>
<h3 id="Aware-接口和-InitializingBean-接口以及-Autowired-失效分析"><a class="header-anchor" href="#Aware-接口和-InitializingBean-接口以及-Autowired-失效分析"></a>Aware 接口和 InitializingBean 接口以及 @Autowired 失效分析</h3>
<h4 id="Aware接口和InitializingBean接口"><a class="header-anchor" href="#Aware接口和InitializingBean接口"></a>Aware接口和InitializingBean接口</h4>
<p><strong>Aware接口用于注入一些与容器相关信息</strong>，例如：</p>
<ul>
<li>
<p>BeanNameAware 注入bean的名字</p>
</li>
<li>
<p>BeanFactoryAware 注入BeanFactory容器</p>
</li>
<li>
<p>ApplicationContextAware 注入ApplicationContext容器</p>
</li>
<li>
<p>EmbeddedValueResolverAware ${}</p>
</li>
</ul>
<p>定义一个MyBean类，来演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;名字加&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;容器是&quot;</span>+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;使用@Autowired注入，容器是&quot;</span>+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;使用@PostConstruct初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Aware接口及InitializingBean接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A06Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line">        context.refresh();<span class="comment">//1.beanFactory后处理器 2.添加Bean后处理器 3.初始化单例</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">09:20:01.960 [main] DEBUG com.atguigu.boot.a06.MyBean - 名字加myBean</span><br><span class="line">09:20:01.963 [main] DEBUG com.atguigu.boot.a06.MyBean - 容器是org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Mon May 23 09:20:01 CST 2022</span><br><span class="line">09:20:01.963 [main] DEBUG com.atguigu.boot.a06.MyBean - 初始化...</span><br></pre></td></tr></table></figure>
<p>从结果推导可以得知：@Autowired 和 @PostConstruct 这两个注解并没有生效，然而 MyBean 其他三个方法都执行了，说明测试代码中，myBean 并没有经过 @Autowired 和 @PostConstruct 的后处理器</p>
<p>手动加上两个后处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A06Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line">        </span><br><span class="line">        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.refresh();<span class="comment">//1.beanFactory后处理器 2.添加Bean后处理器 3.初始化单例</span></span><br><span class="line">        context.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">09:56:46.050 [main] DEBUG com.atguigu.boot.a06.MyBean - 使用@Autowired注入，容器是org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Mon May 23 09:56:45 CST 2022</span><br><span class="line">09:56:46.050 [main] DEBUG com.atguigu.boot.a06.MyBean - 名字加myBean</span><br><span class="line">09:56:46.050 [main] DEBUG com.atguigu.boot.a06.MyBean - 容器是org.springframework.context.support.GenericApplicationContext@6ed3ef1, started on Mon May 23 09:56:45 CST 2022</span><br><span class="line">09:56:46.050 [main] DEBUG com.atguigu.boot.a06.MyBean - 使用@PostConstruct初始化</span><br><span class="line">09:56:46.050 [main] DEBUG com.atguigu.boot.a06.MyBean - 初始化...</span><br></pre></td></tr></table></figure>
<p>@Autowired能实现 b,c,d的功能，为啥要用Aware接口 简单的说:</p>
<ul>
<li>@Autowired的解析需要用到bean后处理器，属于扩展功能</li>
<li>Aware接口属于内置功能，不加任何扩展，Spring就能识别</li>
</ul>
<p><strong>某些情况下：扩展功能会失效，而内置功能不会失效</strong></p>
<p>例1：用Aware注入ApplicationContext成功，而@Autowired注入ApplicationContext失败</p>
<p>定义一个MyConfig1的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//添加beanFactory后处理器</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行processor1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A06Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;myConfig1&quot;</span>, MyConfig1.class);</span><br><span class="line">        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        context.refresh();<span class="comment">//1.beanFactory后处理器 2.添加Bean后处理器 3.初始化单例</span></span><br><span class="line">        context.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10:09:17.150 [main] DEBUG com.atguigu.boot.a06.MyConfig1 - 执行processor1</span><br></pre></td></tr></table></figure>
<p>例2：Java配置类再添加了BeanFactory后处理器后，你会发现用传统接口方式的注入和初始化依然成功，而 @Autowired 和 @PostConstruct 的注入和初始化失败</p>
<p>定义一个MyConfig2的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig2</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;注入ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//添加beanFactory后处理器</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行processor2&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A06Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;myConfig2&quot;</span>, MyConfig2.class);</span><br><span class="line">        context.refresh();<span class="comment">//1.beanFactory后处理器 2.添加Bean后处理器 3.初始化单例</span></span><br><span class="line">        context.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10:18:18.464 [main] DEBUG com.atguigu.boot.a06.MyConfig2 - 注入ApplicationContext</span><br><span class="line">10:18:18.464 [main] DEBUG com.atguigu.boot.a06.MyConfig2 - 初始化</span><br></pre></td></tr></table></figure>
<h4 id="配置类-Autowired-失效分析"><a class="header-anchor" href="#配置类-Autowired-失效分析"></a>配置类 @Autowired 失效分析</h4>
<p>Java 配置类不包含 BeanFactoryPostProcessor 的情况</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021113482.png" alt="image-20250302111300365"></p>
<p>Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效，而等到 BeanPostProcessor 加载好的时候，类已经被初始化完了，所以注解也就失效了。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021136556.png" alt="image-20250302113612410"></p>
<h2 id="AOP"><a class="header-anchor" href="#AOP"></a>AOP</h2>
<h3 id="十五-Spring选择代理"><a class="header-anchor" href="#十五-Spring选择代理"></a>十五 Spring选择代理</h3>
<p>在《十四讲》里提到，实现 aop 的两种方式是：jdk 代理和 cblib 代理，接下来要探究的是，spring 内部是如何选择代理方案的</p>
<p>首先回顾关于 AOP 的知识：切点、通知、切面，具体体现是：</p>
<ol>
<li>切点：execution 表达式，规定了哪些方法需要被增强</li>
<li>通知：具体实现增强功能的代码方法</li>
<li>切面：切点和通知组合成切面</li>
</ol>
<p>关于切面还可以细分为： aspect 和 advisor 两种。aspect 主要是<strong>多对</strong>通知和切点的组合；advisor 是更为底层的一种实现，粒度更细的切面，其中只包含<strong>一对</strong>切点和通知的组合。（实际上，aspect 的实现就是以 advisor 为基础的，每个 aspect 在实际运行时都会被拆解成多个 advisor。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aspect =</span><br><span class="line">        通知 <span class="number">1</span> （advice） + 切点 <span class="number">1</span>（pointcut）</span><br><span class="line">        通知 <span class="number">2</span> （advice） + 切点 <span class="number">2</span>（pointcut）</span><br><span class="line">        通知 <span class="number">3</span> （advice） + 切点 <span class="number">3</span>（pointcut）</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">advisor = 更细粒度的切面，包含一个通知和切点</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> moru</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/19 20:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A15</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 两个切面概念：</span></span><br><span class="line"><span class="comment">         *  aspect =</span></span><br><span class="line"><span class="comment">         *          通知 1 （advice） + 切点 1（pointcut）</span></span><br><span class="line"><span class="comment">         *          通知 2 （advice） + 切点 2（pointcut）</span></span><br><span class="line"><span class="comment">         *          通知 3 （advice） + 切点 3（pointcut）</span></span><br><span class="line"><span class="comment">         *          ...</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * advisor = 更细粒度的切面，包含一个通知和切点</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 备好切点（根据 AspectJ 表达式进行匹配）</span></span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 备好通知</span></span><br><span class="line">        <span class="type">MethodInterceptor</span> <span class="variable">advice</span> <span class="operator">=</span> invocation -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 3. 备好切面</span></span><br><span class="line">        <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">        <span class="comment">// 4. 创建代理</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1、当 proxyTargetClass = false, 目标实现了接口，使用 jdk 生成代理</span></span><br><span class="line"><span class="comment">            2、当 proxyTargetClass = false, 目标没有实现接口，使用 cglib 生成代理</span></span><br><span class="line"><span class="comment">            3、当 proxyTargetClass = true, 直接使用 cglib 实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Target1</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target1</span>();</span><br><span class="line"><span class="comment">//        Target2 target = new Target2();</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        factory.setTarget(target);</span><br><span class="line">        factory.addAdvisor(advisor);</span><br><span class="line">        factory.setInterfaces(target.getClass().getInterfaces());</span><br><span class="line">        factory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的代理类和目标类是平级关系，需要用接口进行类型转换</span></span><br><span class="line">        <span class="type">I1</span> <span class="variable">proxy</span> <span class="operator">=</span> (I1) factory.getProxy();</span><br><span class="line"><span class="comment">//        Target2 proxy = (Target2) factory.getProxy();</span></span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> <span class="keyword">implements</span> <span class="title class_">I1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target1 bar&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target2 foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在 spring 进行动态代理时，会优先使用 jdk 进行动态代理而不是 cglib，根据 ProxyFactory 的一个参数 proxyTargerClass 有三种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、当 proxyTargetClass = <span class="literal">false</span>, 目标实现了接口，使用 jdk 生成代理</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、当 proxyTargetClass = <span class="literal">false</span>, 目标没有实现接口，使用 cglib 生成代理</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、当 proxyTargetClass = <span class="literal">true</span>, 直接使用 cglib 实现</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为什么会优先选择 jdk 进行代理而不是 cglib：</p>
<ol>
<li>JDK 动态代理是 Java 标准库的一部分，兼容性更好。</li>
<li>JDK 动态代理在性能上通常优于 CGLIB，尤其是在代理接口方法时：
<ol>
<li>在早期版本的 Spring 和 Java 中，JDK 动态代理的性能通常优于 CGLIB 代理，尤其是在代理接口方法时。</li>
<li>CGLIB 是通过生成目标类的子类来实现代理的，涉及字节码生成和类加载，可能会比 JDK 动态代理更耗时。</li>
</ol>
</li>
<li>JDK 动态代理更符合面向接口编程的设计哲学。
<ol>
<li>JDK 动态代理是基于接口的代理，它要求目标类必须实现至少一个接口。这种方式更符合 Java 的设计哲学，即面向接口编程。</li>
<li>CGLIB 是通过继承目标类来生成代理的，如果目标类是 <code>final</code> 的，或者目标方法被声明为 <code>final</code>，CGLIB 就无法代理这些类或方法。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="十六-切点匹配"><a class="header-anchor" href="#十六-切点匹配"></a>十六 切点匹配</h3>
<p>Spring 内部实现切点匹配：</p>
<ol>
<li>execution 语句填入方法名，建立切点类</li>
<li>而后切点类内部调用 matches 来匹配是否需要增强，匹配成功返回 true，失败 false</li>
</ol>
<p>TODO：在 Spring 中，切点匹配有多种方式，具体哪种方式在遇到时再进行补充</p>
<p>下面分别解析 aspectj 和 @Transactional注解的切点匹配方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">					<span class="comment">// aspectj </span></span><br><span class="line"><span class="comment">//        AspectJExpressionPointcut pt1 = new AspectJExpressionPointcut();</span></span><br><span class="line"><span class="comment">//        pt1.setExpression(&quot;execution(* bar())&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(pt1.matches(T1.class.getMethod(&quot;foo&quot;), T1.class));</span></span><br><span class="line"><span class="comment">//        System.out.println(pt1.matches(T1.class.getMethod(&quot;bar&quot;), T1.class));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AspectJExpressionPointcut pt2 = new AspectJExpressionPointcut();</span></span><br><span class="line"><span class="comment">//        pt2.setExpression(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(pt2.matches(T1.class.getMethod(&quot;foo&quot;), T1.class));</span></span><br><span class="line"><span class="comment">//        System.out.println(pt2.matches(T1.class.getMethod(&quot;bar&quot;), T1.class));</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">// @Transactional 注解的切点匹配方式</span></span><br><span class="line">        <span class="type">StaticMethodMatcherPointcut</span> <span class="variable">pt3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodMatcherPointcut</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">                <span class="comment">// 检查方法上是否添加了 @Transactional 注解</span></span><br><span class="line">                <span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(method);</span><br><span class="line">                <span class="keyword">if</span> (annotations.isPresent(Transactional.class)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查类上或所实现的接口是否添加了 @Transactional 注解</span></span><br><span class="line">                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">                <span class="keyword">return</span> annotations.isPresent(Transactional.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">        System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line">        System.out.println(pt3.matches(T2.class.getMethod(<span class="string">&quot;foo&quot;</span>), T2.class));</span><br><span class="line">        System.out.println(pt3.matches(T3.class.getMethod(<span class="string">&quot;foo&quot;</span>), T3.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">        <span class="meta">@Transactional</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T3</span> <span class="keyword">implements</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第十七讲-Aspect-和-Advisor"><a class="header-anchor" href="#第十七讲-Aspect-和-Advisor"></a>第十七讲 Aspect 和 Advisor</h3>
<h4 id="创建代理器"><a class="header-anchor" href="#创建代理器"></a>创建代理器</h4>
<p>Aspect 是多个切点 + 通知的组合，而 Advisor 只能包含一个切点 + 通知，advisor 优先级高于 aspect。</p>
<p>定义两个 Target 类和对应的两种切面对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高级切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">        <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;aspect1 before...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@After(&quot;execution(* foo())&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;aspect1 after...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低级切面，由一个切点和一个通知组成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Advisor <span class="title function_">advisor3</span><span class="params">(MethodInterceptor advice3)</span> &#123;</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">            <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);</span><br><span class="line">            <span class="comment">// 设置切面执行顺序</span></span><br><span class="line">            advisor.setOrder(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> advisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MethodInterceptor <span class="title function_">advices</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;advice3 before...&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">                System.out.println(<span class="string">&quot;advice3 after...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;aspect1&quot;</span>, Aspect1.class);</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        AnnotationAwareAspectJAutoProxyCreator 后处理器</span></span><br><span class="line"><span class="comment">        实现了 BeanPostProcessor 接口</span></span><br><span class="line"><span class="comment">        创建 -&gt; (后处理器)依赖注入 -&gt; 初始化(后处理器 )</span></span><br><span class="line"><span class="comment">        1. 找到所有的切面对象</span></span><br><span class="line"><span class="comment">        2. 根据切面生成对应的代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看容器内有多少个 bean</span></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 findEligibleAdvisors 方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        findEligibleAdvisors 找到有【资格】的 Advisors 与目标类型相匹配的所有切面</span></span><br><span class="line"><span class="comment">        1. 一部分是低级切面，可以由自己编写，如例子中的 advisor3</span></span><br><span class="line"><span class="comment">        2. 一部分是高级切面，由 AnnotationAwareAspectJAutoProxyCreator 解析 @Aspect 注解后得到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    <span class="comment">// 获取能够配合 Target1 使用的切面</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target1.class, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">    advisors.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  		wrapIfNecessory</span></span><br><span class="line"><span class="comment">  			a. 内部调用 findEligibleAdvisors，只要返回集合不为空，表示需要创建代理</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target1</span>(), <span class="string">&quot;target1&quot;</span>, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">    System.out.println(o1.getClass());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target2</span>(), <span class="string">&quot;target2&quot;</span>, <span class="string">&quot;target2&quot;</span>);</span><br><span class="line">    System.out.println(o2.getClass());</span><br><span class="line"></span><br><span class="line">    ((Target1) o1).foo();</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17<span class="variable">$Aspect1</span>.before()]; perClauseKind=SINGLETON</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17<span class="variable">$Aspect1</span>.after()]; perClauseKind=SINGLETON</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda<span class="variable">$56</span>/132577100@2de23121]</span><br><span class="line">class org.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$<span class="variable">$b3f2ea12</span></span><br><span class="line">class org.springframework.aop.framework.autoproxy.A17<span class="variable">$Target2</span></span><br><span class="line">aspect1 before...</span><br><span class="line">advice3 before...</span><br><span class="line">target1 foo</span><br><span class="line">advice3 after...</span><br><span class="line">aspect1 after...</span><br></pre></td></tr></table></figure>
<p>在 Spring 中使用 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor，也是一个 Bean 后处理器，用来根据切面生成目标对象的代理对象。</p>
<ol>
<li>AnnotationAwareAspectJAutoProxyCreator 的作用
<ul>
<li>将高级 @Aspect 切面统一为低级 Advisor 切面</li>
<li>在合适的时机创建代理</li>
</ul>
</li>
<li>找到所有的切面对象，findEligibleAdvisors 找到有【资格】的 Advisors 与目标类型相匹配的所有切面
<ul>
<li>一部分是低级切面，可以由自己编写，如例子中的 advisor3</li>
<li>一部分是高级切面，由 AnnotationAwareAspectJAutoProxyCreator 解析 @Aspect 注解后得到</li>
</ul>
</li>
<li>wrapIfNecessary：
<ol>
<li>内部调用 findEligibleAdvisors，只要返回集合不空，则表示需要创建代理。</li>
<li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li>
</ol>
</li>
<li>根据切面生成对应的代理对象</li>
</ol>
<h4 id="代理对象创建时机"><a class="header-anchor" href="#代理对象创建时机"></a>代理对象创建时机</h4>
<blockquote>
<p>AnnotationAwareAspectJAutoProxyCreator 创建代理对象的执行时机：接口创建 -&gt; (*)依赖注入 -&gt; 初始化(*)</p>
</blockquote>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A17_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.close();</span><br><span class="line">        <span class="comment">// 创建 -&gt; (*) 依赖注入 -&gt; 初始化 (*)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@AspectJ</span> 注解，产生代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">annotationAwareAspectJAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AutowiredAnnotationBeanPostProcessor <span class="title function_">autowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@PostConstruct</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> CommonAnnotationBeanPostProcessor <span class="title function_">commonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Advisor <span class="title function_">advisor</span><span class="params">(MethodInterceptor advice)</span> &#123;</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MethodInterceptor <span class="title function_">advice</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"><span class="comment">//        public void foo() &#123;&#125;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        @Autowired</span></span><br><span class="line"><span class="comment">//        public void setBean2(Bean2 bean2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;Bean1 setBean2(bean2) class is: &quot; + bean2.getClass());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 setBean1(bean1) class is: &quot;</span> + bean1.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单向依赖的情况下</strong>：</p>
<ol>
<li>当代理对象的 foo() 方法存在时，测试结果为：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean1 init()</span><br><span class="line">Bean2()</span><br><span class="line">Bean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$<span class="variable">$90213ba6</span></span><br><span class="line">Bean2 init()</span><br><span class="line">14:28:54.371 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@182decdb, started on Sun Mar 02 14:28:54 CST 2025</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>当代理对象 foo() 方法不存在时，测试结果为：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean1 init()</span><br><span class="line">Bean2()</span><br><span class="line">Bean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1<span class="variable">$Bean1</span></span><br><span class="line">Bean2 init()</span><br><span class="line">14:25:37.043 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@182decdb, started on Sun Mar 02 14:25:36 CST 2025</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>结果分析，<strong>重点观察 Bean2 注入的 bean1 的类型</strong>：</p>
<ul>
<li>
<p>当代理对象的 foo() 方法存在时，会在 Bean1 初始化完成后创建代理对象，且 Bean2 注入的是 Bean1 的代理对象，即：<code>A17_1$Bean1$$EnhancerBySpringCGLIB$$90213ba6</code></p>
</li>
<li>
<p>当代理对象 foo() 方法不存在时，Bean1 初始化后不会生成代理对象，Bean2 注入的是 Bean1 的实例，即：<code>A17_1$Bean1</code></p>
</li>
</ul>
</li>
</ol>
<p><strong>循环依赖的情况下</strong>：</p>
<p>测试结果为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean2()</span><br><span class="line">Bean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$<span class="variable">$7d5963ec</span></span><br><span class="line">Bean2 init()</span><br><span class="line">Bean1 setBean2(bean2) class is: class org.springframework.aop.framework.autoproxy.A17_1<span class="variable">$Bean2</span></span><br><span class="line">Bean1 init()</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ul>
<li>实例创建后，在 Bean2 依赖注入之前创建代理对象，并暂存于二级缓存</li>
</ul>
<p>总结：</p>
<ol>
<li>创建时机：
<ol>
<li>初始化之后（无循环依赖）</li>
<li>实例创建后，依赖注入前（有循环依赖），并暂存于二级缓存</li>
</ol>
</li>
<li>依赖注入和初始化不应该被增强，仍应该施加于原始对象</li>
<li>不管是哪种时机，其实都是在Bean实例化之后才会创建代理对象【有可能是在Bean放入了缓存之后，也有可能直接就是在实例化之后初始化之前】</li>
</ol>
<h4 id="高级切面转低级切面，模拟实现"><a class="header-anchor" href="#高级切面转低级切面，模拟实现"></a>高级切面转低级切面，模拟实现</h4>
<p>定义一个切面类Aspect和目标类Target，这里主要演示@Before前置通知转换对应的低级通知，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A17_2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span>&#123;</span><br><span class="line">        <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">        <span class="comment">//高级切面类转低级切面类</span></span><br><span class="line">        List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123; <span class="comment">// 获取切面类所有的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123; <span class="comment">//解析每个方法是否有切点</span></span><br><span class="line">                <span class="comment">//解析切点</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">                <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">                pointcut.setExpression(expression);</span><br><span class="line">                <span class="comment">//通知类  第三个参数:切面的实例对象</span></span><br><span class="line">                <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">                <span class="comment">//切面</span></span><br><span class="line">                <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut,advice);</span><br><span class="line">                list.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">            System.out.println(advisor);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [AspectJMethodBeforeAdvice: advice method [A17_2<span class="variable">$Aspect</span>.before2()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [AspectJMethodBeforeAdvice: advice method [A17_2<span class="variable">$Aspect</span>.before1()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>
<p>@Before 前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息</p>
<ol>
<li>通知代码从哪儿来</li>
<li>切点是什么(这里为啥要切点, 后面解释)</li>
<li>通知对象如何创建, 本例共用同一个 Aspect 对象</li>
</ol>
</li>
<li>
<p><strong>类似的还有</strong></p>
<ol>
<li>AspectJAroundAdvice (环绕通知)</li>
<li>AspectJAfterReturningAdvice</li>
<li>AspectJAfterThrowingAdvice (环绕通知)</li>
<li>AspectJAfterAdvice (环绕通知)</li>
</ol>
</li>
</ol>
<h3 id="第十八讲-静态通知调用"><a class="header-anchor" href="#第十八讲-静态通知调用"></a>第十八讲 静态通知调用</h3>
<h4 id="不同通知统一转换成环绕通知（适配器模式——使用相应的适配器进行转换）"><a class="header-anchor" href="#不同通知统一转换成环绕通知（适配器模式——使用相应的适配器进行转换）"></a>不同通知统一转换成环绕通知（适配器模式——使用相应的适配器进行转换）</h4>
<p>定义切面类 Aspect 和目标类 Target</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span> &#123;</span><br><span class="line">  <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning(&quot;execution(* foo())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;execution(* foo())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterThrowing &quot;</span> + e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around(&quot;execution(* foo())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高级（Aspect）切面类转换成低级切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line"><span class="comment">// 1. 高级切面转低级切面类</span></span><br><span class="line">List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">    <span class="comment">// 解析切点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pointcut.setExpression(expression);</span><br><span class="line">    <span class="comment">// 通知类</span></span><br><span class="line">    <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">    <span class="comment">// 切面</span></span><br><span class="line">    <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">    list.add(advisor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(AfterReturning.class)) &#123;</span><br><span class="line">    <span class="comment">// 解析切点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(AfterReturning.class).value();</span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pointcut.setExpression(expression);</span><br><span class="line">    <span class="comment">// 通知类</span></span><br><span class="line">    <span class="type">AspectJAfterReturningAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(method, pointcut, factory);</span><br><span class="line">    <span class="comment">// 切面</span></span><br><span class="line">    <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">    list.add(advisor);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(Around.class)) &#123;</span><br><span class="line">    <span class="comment">// 解析切点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Around.class).value();</span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pointcut.setExpression(expression);</span><br><span class="line">    <span class="comment">// 通知类</span></span><br><span class="line">    <span class="type">AspectJAroundAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(method, pointcut, factory);</span><br><span class="line">    <span class="comment">// 切面</span></span><br><span class="line">    <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">    list.add(advisor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">  System.out.println(advisor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before1()]; aspect name &#x27;&#x27;]</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before2()]; aspect name &#x27;&#x27;]</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAfterReturningAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.afterReturning()]; aspect name &#x27;&#x27;]</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name &#x27;&#x27;]</span><br></pre></td></tr></table></figure>
<p>（前置/后置）通知统一转换成环绕通知（其实本质就是一个方法拦截器）MethodInterceptor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 无论ProxyFactory基于哪种方式创建代理，最后干活(调用advice)的是一个MethodInvocation对象</span></span><br><span class="line"><span class="comment">         *      a.因为advisor有多个，且一个套一个调用，因此需要一个调用链对象，即MethodInvocation</span></span><br><span class="line"><span class="comment">         *      b.MethodInvocation要知道advice有哪些，还要知道目标，调用次序如下：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *          将MethodInvocation 放入当前线程</span></span><br><span class="line"><span class="comment">         *          | -&gt; before1-------------------------------------- 从当前线程获取MethodInvocation</span></span><br><span class="line"><span class="comment">         *          |     | -&gt; before2-----------------------         |从当前线程获取MethodInvocation</span></span><br><span class="line"><span class="comment">         *          |     |                                 |         |</span></span><br><span class="line"><span class="comment">         *          |     |    | -&gt; target ------- 目标  advice2    advice1</span></span><br><span class="line"><span class="comment">         *          |     |                                 |         |</span></span><br><span class="line"><span class="comment">         *          |     | -&gt; after2------------------------         |</span></span><br><span class="line"><span class="comment">         *          |                                                 |</span></span><br><span class="line"><span class="comment">         *          | -&gt; after1----------------------------------------</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *       c.从上图看出，环绕通知才适合作为advice，因此其他before、afterReturning 都会被转换为环绕通知</span></span><br><span class="line"><span class="comment">         *       d.统一转换为环绕通知，体现的是设计模式中的适配器模式</span></span><br><span class="line"><span class="comment">         *          - 对外是为了方便使用要区分 before、afterReturning</span></span><br><span class="line"><span class="comment">         *          - 对内统一都是环绕通知，统一用MethodInterceptor</span></span><br><span class="line"><span class="comment">         *     此步获取所有执行时需要的advice(静态)</span></span><br><span class="line"><span class="comment">         *       a.即统一转换为MethodInterceptor 环绕通知，这体现在方法名中的Interceptors上</span></span><br><span class="line"><span class="comment">         *       b.适配如下：</span></span><br><span class="line"><span class="comment">         *          -   MethodBeforeAdviceAdapter 将@Before解析后的AspectJMethodBeforeAdvice适配为MethodBeforeAdviceInterceptor</span></span><br><span class="line"><span class="comment">         *          -   AfterReturningAdviceAdapter 将@AfterReturning解析后的AspectJAfterReturningAdvice适配为AfterReturningAdviceInterceptor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">proxyFactory.setTarget(target);</span><br><span class="line">proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE);<span class="comment">//准备把 MethodInvocation放入当前线程  如果不把它放入当前线程，则会报IllegalStateException异常，这是因为一些advice内部需要用到调用链对象</span></span><br><span class="line">proxyFactory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//获得环绕通知集合</span></span><br><span class="line">List&lt;Object&gt; methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), Target.class);</span><br><span class="line"><span class="keyword">for</span> (Object o : methodInterceptorList) &#123;</span><br><span class="line">  System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成的环绕通知结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor@68c4039c</span><br><span class="line">org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@ae45eb6</span><br><span class="line">org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@59f99ea</span><br><span class="line">org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor@27efef64</span><br><span class="line">org.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="无参数绑定通知链执行过程-责任链模式"><a class="header-anchor" href="#无参数绑定通知链执行过程-责任链模式"></a>无参数绑定通知链执行过程(责任链模式)</h4>
<p>创建并执行调用链（类似于责任链）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：代理对象，目标对象，目标对象中的方法，方法中对应的参数，目标类型，转换好的环绕通知</span></span><br><span class="line"><span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line"><span class="literal">null</span>, target,Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], Target.class, methodInterceptorList);</span><br><span class="line">methodInvocation.proceed();<span class="comment">//一层一层调用目标</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before1</span><br><span class="line">before2</span><br><span class="line">around...before</span><br><span class="line">target foo</span><br><span class="line">around...after</span><br><span class="line">afterReturning</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>
<p>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知</p>
<p>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice（） 将其他通知统一转换为 MethodInterceptor 环绕通知</p>
<ol>
<li>MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor</li>
<li>AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor</li>
<li>这体现的是适配器设计模式</li>
</ol>
</li>
<li>
<p>所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可</p>
</li>
<li>
<p>结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用</p>
</li>
</ol>
<h4 id="模拟实现MethodInvocation"><a class="header-anchor" href="#模拟实现MethodInvocation"></a>模拟实现MethodInvocation</h4>
<p>定义目标类Target，两个通知类Advice1和Advice2，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Target.foo()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice1</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Advice1.before()&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();<span class="comment">//调用下一个通知或者目标</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Advice1.after()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Advice2.before()&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();<span class="comment">//调用下一个通知或者目标</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Advice2.after()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义MyInvocation类，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyInvocation</span> <span class="keyword">implements</span> <span class="title class_">MethodInvocation</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line">  <span class="keyword">private</span> Object[] args;</span><br><span class="line">  <span class="comment">//环绕通知集合</span></span><br><span class="line">  List&lt;MethodInterceptor&gt; methodInterceptorList;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyInvocation</span><span class="params">(Object target, Method method, Object[] args, List&lt;MethodInterceptor&gt; methodInterceptorList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    <span class="built_in">this</span>.method = method;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">    <span class="built_in">this</span>.methodInterceptorList = methodInterceptorList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;<span class="comment">//调用每一个环绕通知，调用目标</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; methodInterceptorList.size()) &#123;</span><br><span class="line">      <span class="comment">//调用目标，返回并结束递归</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逐一调用通知，count + 1</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> methodInterceptorList.get(count++ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> methodInterceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getThis</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> AccessibleObject <span class="title function_">getStaticPart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此处责任链的递归的实现方式</strong>：proceed() 方法调用链中下一个环绕通知，每个环绕通知内部继续调用 proceed()，调用到没有更多通知了, 就调用目标方法</p>
<h4 id="代理对象调用流程（以-JDK-动态代理实现为例）"><a class="header-anchor" href="#代理对象调用流程（以-JDK-动态代理实现为例）"></a>代理对象调用流程（以 JDK 动态代理实现为例）</h4>
<ul>
<li>
<p>从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi</p>
</li>
<li>
<p>首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</p>
</li>
<li>
<p>进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</p>
</li>
<li>
<p>进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</p>
</li>
<li>
<p>目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强</p>
</li>
<li>
<p>环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强</p>
</li>
<li>
<p>环绕通知1返回最终的结果</p>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503021755119.png" alt="image-20250302175554933"></p>
<h3 id="第十九讲-动态通知调用"><a class="header-anchor" href="#第十九讲-动态通知调用"></a>第十九讲 动态通知调用</h3>
<h2 id="MVC"><a class="header-anchor" href="#MVC"></a>MVC</h2>
<h3 id="第廿讲-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"><a class="header-anchor" href="#第廿讲-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"></a>第廿讲 RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</h3>
<h4 id="DispatcherServlet-的初始化时机以及初始化时干了什么"><a class="header-anchor" href="#DispatcherServlet-的初始化时机以及初始化时干了什么"></a>DispatcherServlet 的初始化时机以及初始化时干了什么</h4>
<p>定义 MyConfig 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ServerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">//内嵌web容器工厂</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建DispatcherServlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注册DispatcherServlet，Spring MVC的入口</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span><br><span class="line"><span class="params">                                                                               WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registrationBean.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A20</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A20.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>初始化时机：（DispatcherServlet 的对象是在 spring 容器中创建加载的）DispatcherServlet 是在第一次被访问时执行初始化, 也可以通过配置修改为 Tomcat 启动后就初始化</li>
<li>在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 HandlerMapping、HandlerAdapter 等，并逐一调用它们的初始化</li>
</ol>
<p>一个重要的初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.initMultipartResolver(context);	<span class="comment">// 初始化文件上传解析器</span></span><br><span class="line">  <span class="built_in">this</span>.initLocaleResolver(context);	<span class="comment">// 根据请求解析用户的区域（Locale），本地化信息（配合国际化）</span></span><br><span class="line">  <span class="built_in">this</span>.initThemeResolver(context);	<span class="comment">// 已经弃用</span></span><br><span class="line">  <span class="built_in">this</span>.initHandlerMappings(context);	<span class="comment">// 路径映射：将 HTTP 请求映射到对应的处理器（Controller 方法）</span></span><br><span class="line">  <span class="built_in">this</span>.initHandlerAdapters(context);	<span class="comment">// 适配器模式，统一调用不同类型的处理器方法（如 @Controller、HttpRequestHandler）</span></span><br><span class="line">  <span class="built_in">this</span>.initHandlerExceptionResolvers(context);	<span class="comment">// 统一处理控制器抛出的异常，生成错误响应或视图</span></span><br><span class="line">  <span class="built_in">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">  <span class="built_in">this</span>.initViewResolvers(context);</span><br><span class="line">  <span class="built_in">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestMapppingHandlerMapping-基本用途"><a class="header-anchor" href="#RequestMapppingHandlerMapping-基本用途"></a>RequestMapppingHandlerMapping 基本用途</h4>
<p>主要功能：进行请求的路径映射，即将请求匹配到对应的 controller 方法</p>
<p>RequestMapppingHandlerMapping 初始化时就把 controller 类中的所有如：GetMapping、PostMapping 等加载好，而后在请求到来时可以直接做映射</p>
<h4 id="RequestMapppingHandlerAdapter-基本用途"><a class="header-anchor" href="#RequestMapppingHandlerAdapter-基本用途"></a>RequestMapppingHandlerAdapter 基本用途</h4>
<p>主要功能：调用控制器方法</p>
<p>RequestMapppingHandlerAdapter 类内的 invokeHandlerMethod 方法是 protected，无法直接调用，创建一个继承RequestMapppingHandlerAdapter 的子类 MyRequestMappingHandlerAdapter，重写 invokeHandlerMethod() 方法，扩大修饰符范围为 public</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RequestMappingHandlerAdapter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WebConfig配置类中继续加入MyRequestMappingHandlerAdapter,具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码中获取容器中自己添加的 MyRequestMappingHandlerAdapter，调用invokeHandlerMethod方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/test2&quot;</span>);</span><br><span class="line">request.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;moru&quot;</span>);</span><br><span class="line"><span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line"><span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> handlerMapping.getHandler(request);</span><br><span class="line">System.out.println(chain);</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//HandlerAdapter 作用: 调用控制器方法</span></span><br><span class="line"><span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> context.getBean(MyRequestMappingHandlerAdapter.class);</span><br><span class="line">handlerAdapter.invokeHandlerMethod(request,response, (HandlerMethod) chain.getHandler());</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 测试 test2</span></span><br><span class="line">[DEBUG] 08:59:11.076 [main] com.itheima.a20.Controller1         - test2(moru) </span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，@RequestParam 注解标记的参数被解析了，这是因为 RequestMappingHandlerAdapter 有很多预先加载好的参数解析器和返回值解析器，测试代码如下：</p>
<p>查看handlerAdapter里的参数解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 所有参数解析器&quot;</span>);</span><br><span class="line">handlerAdapter.getArgumentResolvers().forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 所有返回值解析器&quot;</span>);</span><br><span class="line">handlerAdapter.getReturnValueHandlers().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>打印信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 所有参数解析器</span></span><br><span class="line">org.springframework.web.method.annotation.RequestParamMethodArgumentResolver@31500940</span><br><span class="line">org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolver@1827a871</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver@48e64352</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 所有返回值解析器</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler@5ed190be</span><br><span class="line">org.springframework.web.method.annotation.ModelMethodProcessor@402f80f5</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ViewMethodReturnValueHandler@5bbc9f97</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>RequestMappingHandlerAdapter 初始化时，会准备 HandlerMethod 调用时需要的各个组件，如：</strong></p>
<ul>
<li>HandlerMethodArgumentResolver 解析控制器方法参数</li>
<li>HandlerMethodReturnValueHandler 处理控制器方法返回值</li>
</ul>
<h4 id="自定义参数处理器"><a class="header-anchor" href="#自定义参数处理器"></a>自定义参数处理器</h4>
<p>自定义 @Token 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义token注解</span></span><br><span class="line"><span class="comment">//经常需要用到请求头中的token信息，用下面注解来标注由那个参数来获取他</span></span><br><span class="line"><span class="comment">//token=令牌</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span> <span class="comment">//加在方法的参数上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//注解在运行期都有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Token &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义 @Token 参数解析器 TokenArgumentResolver，实现 HandlerMethodArgumentResolver 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//是否支持某个参数 true表示支持某个参数，可以解析  parameter:封装方法中的参数信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">token</span> <span class="operator">=</span> parameter.getParameterAnnotation(Token.class);</span><br><span class="line">        <span class="keyword">return</span> token != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> webRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WebConfig配置类的MyRequestMappingHandlerAdapter中设置自定义参数解析器 ，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">TokenArgumentResolver</span> <span class="variable">tokenArgumentResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenArgumentResolver</span>();</span><br><span class="line">  <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">  <span class="comment">//设置自定义参数解析器</span></span><br><span class="line">  List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  argumentResolvers.add(tokenArgumentResolver);</span><br><span class="line">  handlerAdapter.setCustomArgumentResolvers(argumentResolvers);</span><br><span class="line">  <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<p>Controller 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test3</span><span class="params">(<span class="meta">@Token</span> String token)</span> &#123;</span><br><span class="line">  log.info(<span class="string">&quot;test3(&#123;&#125;)&quot;</span>, token);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;/test3&quot;</span>);</span><br><span class="line">request.addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;token info&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 测试 test3</span><br><span class="line">[INFO ] 08:59:11.080 [main] com.itheima.a20.Controller1         - test3(token info) </span><br></pre></td></tr></table></figure>
<h4 id="自定义返回值解析器"><a class="header-anchor" href="#自定义返回值解析器"></a>自定义返回值解析器</h4>
<p>自定义 @Yml 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Yml &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义加了 @Yml 注解的返回值处理器 YmlReturnValueHandler，实现 HandlerMethodReturnValueHandler 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YmlReturnValueHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">        <span class="type">Yml</span> <span class="variable">yml</span> <span class="operator">=</span> returnType.getMethodAnnotation(Yml.class);</span><br><span class="line">        <span class="keyword">return</span> yml != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//returnValue:返回值   webRequest:既有原始的请求，也有原始的响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.转换返回结果为 yaml 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>().dump(returnValue);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.将yaml字符串写入响应</span></span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getNativeResponse(HttpServletResponse.class);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().print(str);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//3.设置请求已经处理完毕</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WebConfig配置类的MyRequestMappingHandlerAdapter中设置自定义返回值解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">TokenArgumentResolver</span> <span class="variable">tokenArgumentResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenArgumentResolver</span>();</span><br><span class="line">  <span class="type">YmlReturnValueHandler</span> <span class="variable">ymlReturnValueHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YmlReturnValueHandler</span>();</span><br><span class="line">  <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">  <span class="comment">//设置自定义参数解析器</span></span><br><span class="line">  List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  argumentResolvers.add(tokenArgumentResolver);</span><br><span class="line">  handlerAdapter.setCustomArgumentResolvers(argumentResolvers);</span><br><span class="line">  <span class="comment">//设置自定义返回值处理器</span></span><br><span class="line">  List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  returnValueHandlers.add(ymlReturnValueHandler);</span><br><span class="line">  handlerAdapter.setCustomReturnValueHandlers(returnValueHandlers);</span><br><span class="line">  <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<p>Controller 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="meta">@Yml</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">  log.info(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/test4&quot;</span>);</span><br><span class="line"><span class="comment">//检查响应</span></span><br><span class="line"><span class="type">byte</span>[] content = response.getContentAsByteArray();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[INFO ] 08:59:11.081 [main] com.itheima.a20.Controller1         - test4 </span><br><span class="line">!!com.itheima.a20.Controller1<span class="variable">$User</span> &#123;age: 18, name: 张三&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第廿一讲-参数解析器"><a class="header-anchor" href="#第廿一讲-参数解析器"></a>第廿一讲 参数解析器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析每个参数值</span></span><br><span class="line"><span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">  <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">  <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">  composite.addResolvers(</span><br><span class="line">    <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">    <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">    <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">    <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">    <span class="comment">// 解析 @Value</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">    <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">    <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="comment">// json 数据解析</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">    <span class="comment">// 解析 @ModelAttribute，且可以省略</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>【注】：解析 json 的解析器和 @ModelAttribute 解析器（可以省略版）的顺序不可调换，因为如果不是先进行 json 解析，采用了 @ModelAttribute 解析器（可以省略版）会采用该解析器，但是无法正确解析 json 数据</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>苍穹外卖</title>
    <url>/2025/03/01/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%8D%95%E4%BD%93/</url>
    <content><![CDATA[<h1 id="苍穹外卖"><a class="header-anchor" href="#苍穹外卖"></a>苍穹外卖</h1>
<blockquote>
<p>一个项目的复习就和设计一个项目一样，分别从：</p>
<ol>
<li>项目背景</li>
<li>项目的功能模块</li>
<li>在项目功能模块中所应用的技术栈</li>
<li>个人对于技术栈的总结与学习体会感悟</li>
<li>总结项目开发收获</li>
</ol>
</blockquote>
<h2 id="项目背景"><a class="header-anchor" href="#项目背景"></a>项目背景</h2>
<ol>
<li>本项目是一个单体项目，分为PC管理员端和小程序用户端，主要实现的业务功能是完成一个外卖系统，</li>
<li>PC管理员端：可以通过账号登录PC端，进行包括：员工管理、菜品管理、分类管理、套餐管理、订单管理和店铺管理等操作的实现。</li>
<li>小程序端：微信用户可以通过微信登录的方式，通过小程序进行：店铺运营状态、菜品的预览、套餐的预览、添加购物车、下单、取消订单、查看历史订单、订单支付、查询订单状态、根据历史订单直接下单等功能</li>
</ol>
]]></content>
      <tags>
        <tag>项目总结</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马商场</title>
    <url>/2025/03/01/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%BB%91%E9%A9%AC%E5%95%86%E5%9C%BA-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="黑马商场"><a class="header-anchor" href="#黑马商场"></a>黑马商场</h1>
<h2 id="什么是微服务"><a class="header-anchor" href="#什么是微服务"></a>什么是微服务</h2>
<ol>
<li>随着项目的不断扩展，可以通过对原本项目按照服务内容进行项目的拆分，每一个功能模块单独运行在自己的进程中，模块间使用轻量级通信机制建立连接。</li>
<li>传统的软件的架构大多数都是独立系统堆砌，这样子建立的系统的可拓展性太差，存在牵一发而动全身的问题，维护成本过高。</li>
</ol>
<h2 id="微服务与单体架构对比："><a class="header-anchor" href="#微服务与单体架构对比："></a>微服务与单体架构对比：</h2>
<ol>
<li>
<p>由于笔者目前只接触过单体架构这种与微服务不一样的架构，因此与单体架构进行对比</p>
</li>
<li>
<p>单体架构所有的模块代码都耦合在一起，单个项目的代码量大，假如此时只需要对一个模块的一个功能进行迭代，但是因为这个模块耦合在整个单体架构中，所以不得不将整个项目停下，在迭代好后再重新启动。</p>
<p>微服务架构每一个模块都被抽离成一个单独的项目，一个大项目里包含有许多小项目，单个小项目代码量明显降低，且耦合度低，安全性高</p>
</li>
<li>
<p>单体架构只使用一个数据库，存储方式单一，容易出现单点故障</p>
<p>微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。（单体架构也可以实现，但是比较麻烦）</p>
</li>
<li>
<p>单体架构所有的模块开发所使用的技术一样。</p>
<p>微服务每个模块都可以使用不同的开发技术，开发模式更灵活。</p>
</li>
</ol>
<h2 id="远程调用"><a class="header-anchor" href="#远程调用"></a>远程调用</h2>
<blockquote>
<p>由于将项目进行拆分，导致原本在同一线程下的各个模块可以直接调用的操作无法实现，需要通过通信机制来进行模块间的连接，以实现模块间的互相调用，由于使用到了通信机制（通常是http请求）因此叫做远程调用。</p>
</blockquote>
<h3 id="OpenFeign"><a class="header-anchor" href="#OpenFeign"></a>OpenFeign</h3>
<h2 id="服务的治理"><a class="header-anchor" href="#服务的治理"></a>服务的治理</h2>
<blockquote>
<p>将每一个模块注册到注册中心，以便于观察每个服务的运行状态</p>
</blockquote>
<h3 id="nacos"><a class="header-anchor" href="#nacos"></a>nacos</h3>
<h2 id="网关-gateway"><a class="header-anchor" href="#网关-gateway"></a>网关 gateway</h2>
<h2 id="配置管理"><a class="header-anchor" href="#配置管理"></a>配置管理</h2>
<p>使用nacos实现</p>
<h2 id="服务保护"><a class="header-anchor" href="#服务保护"></a>服务保护</h2>
<h3 id="雪崩问题："><a class="header-anchor" href="#雪崩问题："></a>雪崩问题：</h3>
<ol>
<li>由于单个服务的故障导致引发链式灾难，进而使得整个项目崩溃
<ol>
<li>服务相互调用，服务提供者出现故障或阻塞</li>
<li>服务调用者没做好异常处理，导致自身故障</li>
<li>调用链中的所有服务级联失败，导致集群故障</li>
</ol>
</li>
<li>解决思路：
<ol>
<li>尽量避免服务出现故障或阻塞</li>
</ol>
</li>
</ol>
<h3 id="服务保护方案"><a class="header-anchor" href="#服务保护方案"></a>服务保护方案</h3>
<ol>
<li><strong>请求限流</strong>（流量整型）：限制流量在服务可以处理的范围，避免突发流量导致的故障</li>
<li><strong>线程隔离</strong>（舱壁模式）：限定每一个业务能够使用的线程数量，将故障业务隔离，避免故障扩散。</li>
<li><strong>服务熔断</strong>：由断路器统计请求的异常比例或慢调用比例，超出阈值则熔断该业务，拦截该接口的请求。</li>
<li><strong>失败处理</strong>：熔断期间，所有请求快速失败，但失败时不抛出异常，而是进入fallback逻辑（返回默认数据或友好提示）</li>
</ol>
<h4 id="保护技术"><a class="header-anchor" href="#保护技术"></a>保护技术</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011226359.png" alt="image-20240922184706978"></p>
<h3 id="Sentinel"><a class="header-anchor" href="#Sentinel"></a>Sentinel</h3>
<h4 id="请求限流"><a class="header-anchor" href="#请求限流"></a>请求限流</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227719.png" alt="image-20240923133631762"></p>
<h4 id="线程隔离"><a class="header-anchor" href="#线程隔离"></a>线程隔离</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227786.png" alt="image-20240923133703690"></p>
<h4 id="服务熔断"><a class="header-anchor" href="#服务熔断"></a>服务熔断</h4>
<ol>
<li>对超出QPS上限的请求进行<strong>降级处理</strong></li>
<li>当某个模块的延迟突然升高，响应时间变长，且会占用到其他正常的业务的资源导致其他业务出现高延迟，则应该立即停用不健康的模块接口，进行<strong>降级处理</strong>，避免影响到当前项目的服务体验，这种做法就是 <strong>熔断</strong>。</li>
</ol>
<h3 id="分布式事务"><a class="header-anchor" href="#分布式事务"></a>分布式事务</h3>
<h4 id="数据库ACID四大特性"><a class="header-anchor" href="#数据库ACID四大特性"></a>数据库ACID四大特性</h4>
<ol>
<li><strong>原子性 atomic</strong></li>
<li><strong>一致性 consistency</strong></li>
<li><strong>隔离性 isolation</strong></li>
<li><strong>持久性 durability</strong></li>
</ol>
<h4 id="什么是分布式事务"><a class="header-anchor" href="#什么是分布式事务"></a>什么是分布式事务</h4>
<p>在一个分布式系统中，当一个业务涉及到多个服务合作完成，且每个服务都有各自的事务，则同属于一个业务的多个事务必须同时成功或失败，这些事务就是<strong>分布式事务</strong>，其中每个服务的事务就是一个<strong>分支事务</strong>，整个业务称为<strong>全局事务</strong>。（为了保证数据的一致性和操作的原子性）</p>
<h3 id="Seata框架"><a class="header-anchor" href="#Seata框架"></a>Seata框架</h3>
<p>Seata事务管理三个重要角色：</p>
<ol>
<li><strong>TC （Transaction Coordinator）-事务协调者</strong>：维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li><strong>TM （Transaction Manager）-事务管理器</strong>：定义全局事务的范围，开始全局事务，提交或回滚全局事务。</li>
<li><strong>RM （Resource Manager） -资源管理器</strong>：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态。</li>
</ol>
<h3 id="Seata的两种模式："><a class="header-anchor" href="#Seata的两种模式："></a>Seata的两种模式：</h3>
<p><strong>XA模式</strong>：两阶段工作</p>
<ol>
<li>
<p>一阶段：</p>
<ol>
<li>RM注册分支事务到TC</li>
<li>RM执行分支业务sql但不提交</li>
<li>RM报告执行状态到TC</li>
</ol>
</li>
<li>
<p>二阶段：</p>
<ol>
<li>
<p>TC检测各分支事务执行</p>
<p>如果都成功，通知所有RM提交事务</p>
<p>如果有至少一个失败，通知所有RM回滚事务</p>
</li>
<li>
<p>RM接受TC指令，提交或回滚事务</p>
</li>
</ol>
</li>
<li>
<p>优点：</p>
<ol>
<li>事务具有强一致性，满足ACID原则</li>
<li>常用数据库都支持，实现简单，且没有代码入侵</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>一阶段需要上锁独占数据库资源，等待二阶段结束才可以释放，性能差</li>
<li>依赖于关系型数据库实现事务</li>
</ol>
</li>
</ol>
<p><strong>模式实例图</strong>：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503032113631.png" alt="image-20241007133720162" style="zoom: 50%;" /> 
<p><strong>AT模式</strong>：</p>
<blockquote>
<p>关键是进行了快照保存，一旦出现错误，直接使用快照进行回滚</p>
</blockquote>
<ol>
<li>一阶段RM的工作：
<ol>
<li>注册分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ol>
</li>
<li></li>
</ol>
<p><strong>模式示例图</strong>：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503181100719.png" alt="image-20241007155906690" style="zoom:50%;" /> 
<h2 id="RabbitMQ"><a class="header-anchor" href="#RabbitMQ"></a>RabbitMQ</h2>
<p>rabbitMQ登录时遇到身份验证弹窗解决方案：</p>
<p><a href="https://blog.csdn.net/m0_61399406/article/details/132536144#:~:text=%E5%85%B3%E4%BA%8E%22%E7%99%BB%E5%BD%95r">登录rabbitMQ管理界面时浏览器显示要求进行身份验证，与此站点连接不安全解决办法_登录以访问此站点 要求进行身份验证-CSDN博客</a></p>
<p>⚠️⚠️⚠️注意⚠️⚠️⚠️</p>
<p>在新创建完一个用户后，需要为其添加对应的虚拟机操作权限</p>
<p><a href="https://blog.csdn.net/weixin_41977631/article/details/106560748">Linux下rabbitmq创建用户并设置权限_rabbitmq的guest用户已拥有所有权限,但还是不能创建交换机,怎么设置guest用户的远-CSDN博客</a></p>
<h3 id="MQ（Message-Queue）"><a class="header-anchor" href="#MQ（Message-Queue）"></a>MQ（Message Queue）</h3>
<p>本质就是一个队列，遵循FIFO原则，队列中存放的数据是msg</p>
<p>主要用途是：不同进程process/线程thread间的通信</p>
<p><strong>AMQP advanced message queuing protocol</strong>：信息队列的一个协议</p>
<p>对于一个MQ系统来说，可以有两种模式：简单模式和发布订阅模式</p>
<p><strong>简单模式</strong>：使用默认交换机，一个消息只能被消费一次，消费者之间是竞争关系</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227902.png" alt="image-20241008131925667"></p>
<p><strong>发布订阅模式</strong>：通过指定交换机，可以用多个队列实现一个消息被多个消费者消费，消费者之间共享消息</p>
<h3 id="交换机的概念"><a class="header-anchor" href="#交换机的概念"></a>交换机的概念</h3>
<p>RabbitMQ消息传递模型的核心思想是：生产者生产的消息不会直接发生到队列中，因为事实上生产者本身是不知道生产出的消息应该要传递到哪些队列的</p>
<p>生产者只会将消息发送到交换机(exchange)，交换机只负责：接收来自生产者的消息；将消息推送入信息队列中</p>
<p><strong>交换机的作用：</strong> 生产者向broker（rabbitmq服务器）发送消息，交换机通过生产者绑定的路由键，将消息推送到不同的消息队列中。而消费者，只绑定队列，从队列中获取消息。</p>
<p><strong>交换机需要明确知道如何处理消息</strong>，处理信息的方式由信息队列的类型来决定</p>
<p>交换机就相当于一个具有路由规则的路由程序，每一个消息都有一个路由键（route key）</p>
<h3 id="四种交换机类型："><a class="header-anchor" href="#四种交换机类型："></a>四种交换机类型：</h3>
<ol>
<li>
<p><strong>direct 直接，定向路由</strong>：每一个queue都与Exchange设置一个bindingkey</p>
<ul>
<li>
<p>工作模式图解</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227028.png" alt="image-20241008173123159"></p>
</li>
<li>
<p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明交换机、队列、路由键绑定</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"><span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment">puvlic class RabbitConfig &#123;</span></span><br><span class="line"><span class="comment">	/**</span></span><br><span class="line"><span class="comment">	 * 创建直连交换机</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">createExchange</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;testE&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span> (<span class="string">&quot;testQ&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过路由键绑定交换机和队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">createBinding</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">// 交换机名字；是否持久化；是否自动删除</span></span><br><span class="line">		<span class="keyword">return</span> BindingBuilder</span><br><span class="line">		.bind(<span class="built_in">this</span>.createQueue())</span><br><span class="line">		.to(<span class="built_in">this</span>.createExchange())</span><br><span class="line">		.with(<span class="string">&quot;testR&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;testE&quot;</span>, <span class="string">&quot;testR&quot;</span>, msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>topic 主题</strong>：与direct区别是，topic可以使用通配符的方式对路由键进行绑定，更加灵活的对消息进行路由</p>
<ul>
<li>
<p>工作模式图解</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227485.png" alt="image-20241008173442176"></p>
</li>
<li>
<p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRabbitMqConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic_queue_A&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic_queue_B&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Topic交换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topic_exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeQueueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueA()).to(exchange()).with(<span class="string">&quot;*.*.routeKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeQueueB</span><span class="params">(Queue topicQueueB, TopicExchange exchange)</span> &#123;</span><br><span class="line">        <span class="comment">//将队列和交换机绑定, 并设置用于匹配键：routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueB()).to(exchange()).with(<span class="string">&quot;routeKey.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;topic_exchange&quot;</span>, <span class="string">&quot;routeKey.test.routeKey&quot;</span>, </span><br><span class="line">	</span><br><span class="line">	msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>headers 标题</strong>：暂无，</p>
</li>
<li>
<p><strong>fanout 扇出</strong>：会将接收到的消息进行广播</p>
<ul>
<li>
<p>工作模式图解</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011227358.png" alt="image-20241008173247059"></p>
</li>
<li>
<p>MQ配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueA&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueB&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueueC</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queueC&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;exchangeFanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeC</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueueC()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProduceMsg</span> &#123;</span><br><span class="line">	<span class="meta">@Autowire</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">		<span class="comment">// 消息唯一标识</span></span><br><span class="line">	 	CorrelationData correlationData= <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">	 	correlationData.setId(msg.getId());</span><br><span class="line">		rabbitTemplate.converAndSend(<span class="string">&quot;exchangeFanout&quot;</span>, <span class="string">&quot;&quot;</span>, msg, correlationData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumeMsg</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 消费者监听队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;testQ&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">		<span class="comment">// ......业务逻辑消费消息；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>临时队列</strong>：</p>
<ul>
<li>
<p>队列的名称对我们来说至关重要，我们需要指定消费者去消费哪个队列的消息。</p>
</li>
<li>
<p>每当我们连接到 RabbitMQ 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。<br>
注意：一旦我们断开了消费者的连接，队列将被自动删除。</p>
</li>
<li>
<p>创建临时队列的方式如下:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>
<p><strong>绑定 bindings</strong>：</p>
<p>将 exchange和特定的queue建立桥梁进行绑定</p>
<p>java代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue, String exchange, String routingKey)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>同步通讯</li>
<li>异步通讯</li>
</ol>
<h3 id="消息可靠性问题"><a class="header-anchor" href="#消息可靠性问题"></a>消息可靠性问题</h3>
<h4 id="sender的可靠性"><a class="header-anchor" href="#sender的可靠性"></a>sender的可靠性</h4>
<p><strong>发送者重连</strong>：</p>
<p>springAMQP的重连机制是阻塞式的，会影响其他业务的性能，如果对业务性能要求较高，</p>
<p>要么<strong>禁用</strong>重连机制</p>
<p>要么<strong>异步</strong>线程执行消息发送代码</p>
<p><strong>发送者确认</strong>：</p>
<p><code>Publisher Confirm</code>和<code>Publisher Return</code>两种机制，开启后，MQ发送消息会返回确认结果给发送者</p>
<p>返回结果情况如下：</p>
<ol>
<li>消息投递到MQ，但路由失败，会通过<code>PublisherReturn</code>返回路由异常原因，然后通过<code>PublisherConfirm</code>返回<em>ACK</em>，告知投递成功</li>
<li>临时消息投递到MQ，并且入队成功，返回<em>ACK</em>，告知投递成功</li>
<li>持久消息投递到MQ，并且入队成功完成持久化，返回<em>ACK</em>，告知投递成功</li>
<li>其他情况返回<em>NACK</em>，告知投递失败</li>
</ol>
<h4 id="MQ的可靠性"><a class="header-anchor" href="#MQ的可靠性"></a>MQ的可靠性</h4>
<h4 id="consumer-的可靠性"><a class="header-anchor" href="#consumer-的可靠性"></a>consumer 的可靠性</h4>
<h4 id="延迟消息"><a class="header-anchor" href="#延迟消息"></a>延迟消息</h4>
]]></content>
      <tags>
        <tag>项目总结</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题</title>
    <url>/2025/03/01/%E7%AE%97%E6%B3%95/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h1 id="LeetCode刷题记录"><a class="header-anchor" href="#LeetCode刷题记录"></a>LeetCode刷题记录</h1>
<h2 id="2549-统计桌面上的不同数字"><a class="header-anchor" href="#2549-统计桌面上的不同数字"></a>[2549] 统计桌面上的不同数字</h2>
<h3 id="题目"><a class="header-anchor" href="#题目"></a>题目</h3>
<p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>109</code> 天内，每天都要执行下述步骤：</p>
<ul>
<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>
<li>然后，将这些数字放在桌面上。</li>
</ul>
<p>返回在 <code>109</code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一旦数字放在桌面上，则会一直保留直到结束。</li>
<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：最开始，5 在桌面上。 </span><br><span class="line">第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 </span><br><span class="line">再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3 </span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">因为 3 % 2 == 1 ，2 也出现在桌面上。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 </span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a class="header-anchor" href="#Solution"></a>Solution</h3>
<h4 id="解法思路一："><a class="header-anchor" href="#解法思路一："></a>解法思路一：</h4>
<p>本题目本质其实相当于找质数;</p>
<p>对于变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in [0,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>,需要查找在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y \in [0,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span>当中可以满足式子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>y</mi><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x~mod~y==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的y并使用一个HashSet(为了方便去重)进行记录,最后返回HashSet的个数即可;其实最终会发现撤了除了1的所有数字都出现过一次.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		set.add(n);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i%j==<span class="number">1</span>)&#123;</span><br><span class="line">					set.add(j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="解题思路二"><a class="header-anchor" href="#解题思路二"></a>解题思路二?</h4>
<h2 id="322-零钱兑换"><a class="header-anchor" href="#322-零钱兑换"></a>[322]零钱兑换</h2>
<blockquote>
<p>动态规划</p>
</blockquote>
<h3 id="题目-v2"><a class="header-anchor" href="#题目-v2"></a>题目</h3>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<h3 id="题目思路"><a class="header-anchor" href="#题目思路"></a>题目思路</h3>
<ol>
<li>
<p>首先，找零问题无法使用<strong>贪心</strong>解决，因为贪心算法永远需要从最大或最小的硬币面额开始，且无法进行回退，解集的不完整，得到的局部最优解最终并不一定可以组成全局最优解，而在找零问题中，很明显，存在并不从coins最大面额进行凑零的解集，因而不能使用<strong>贪心算法</strong>。</p>
</li>
<li>
<p>采取<strong>动态规划</strong>进行解决：动态规划算法可以得出在不断加入新面额的硬币的情况下得到的新的最优解，因而可以得到最优解集，进而在最优解集当中得到最优解。</p>
</li>
</ol>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] coins = &#123;<span class="number">186</span>,<span class="number">419</span>,<span class="number">83</span>,<span class="number">408</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">6249</span>;      </span><br><span class="line">        System.out.println(coinChange(coins,amount));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 排序得出数组内最小的零钱面额；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minCoin</span> <span class="operator">=</span> Arrays.stream(coins).min().orElse(Integer.MIN_VALUE);</span><br><span class="line">			  <span class="comment">// 得出伪最差解（因为存在amount/minCoin为小数的情况，因而是伪最差解）</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">maxResult</span> <span class="operator">=</span> amount/minCoin;</span><br><span class="line">        <span class="comment">//建立dp数组进行动态规划；</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//先对第一行初始情况进行初始化，全部定为最差情况，进而在动态递推的过程中使用较优解			 //进行替换</span></span><br><span class="line">        Arrays.fill(dp, maxResult+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当零钱为0时，解为0，确定一个确定的优解，进而递推出剩余的优解</span></span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp过程：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin:coins)&#123;</span><br><span class="line">          	<span class="comment">//此处从得到的硬币面额开始递推，因为小于硬币面额的显然不会出现比原来更优的解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coin;j&lt;=amount;j++)&#123;</span><br><span class="line">              	<span class="comment">//在当前零钱面额下，每当引入一种新的硬币面额，减去这种硬币面额，并在前面已经存在的解当中查找是否已存在优解，如果存在即说明可以在优解的前提下加一得到当前零钱面额的优解；如果不存在则为最差解。（建议状态转移过程需要画个图进行理解）</span></span><br><span class="line">                dp[j] =Math.min(dp[j],dp[j-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;maxResult ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-删除有序数组中的重复项"><a class="header-anchor" href="#26-删除有序数组中的重复项"></a>[26]删除有序数组中的重复项</h2>
<h3 id="题目-v3"><a class="header-anchor" href="#题目-v3"></a><code>题目</code></h3>
<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<h3 id="题目思路-v2"><a class="header-anchor" href="#题目思路-v2"></a>题目思路</h3>
<p>本题需要采用原地算法</p>
<h4 id="原地算法-in-place-algorithm-："><a class="header-anchor" href="#原地算法-in-place-algorithm-："></a>原地算法(in-place algorithm)：</h4>
<ol>
<li>常见的案例就是如本题，在不使用超过O(1)的额外空间的基础上，完成对数组重复元素的删除。</li>
</ol>
<p>本题原地删除采用快慢指针的方式，其中一个指针pre一直沿着数组往下走，另一个指针last负责将pre所经过的元素中的第一次出现的元素提取出来并形同栈一样压入数组前面pre已经遍历过的空间。</p>
<h3 id="代码实现："><a class="header-anchor" href="#代码实现："></a>代码实现：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] != nums[i])&#123;</span><br><span class="line">                nums[++p] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ++p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="27-移除元素"><a class="header-anchor" href="#27-移除元素"></a>[27]移除元素</h2>
<h3 id="题目-v4"><a class="header-anchor" href="#题目-v4"></a>题目</h3>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h3 id="题目思路-v3"><a class="header-anchor" href="#题目思路-v3"></a>题目思路</h3>
<blockquote>
<p>本体与[26]题相似，同样用到了原地删除的方法，但是略有细节上的不同，本体要求的是指定删除的所有元素，而[26]题则是删除重复元素，因此在[26]我们使用的是++p，因为当前元素不需要删除，但是在本体则是使用p++，因为当前元素如果是符合val的话，则需要进行删除。</p>
</blockquote>
<h3 id="代码"><a class="header-anchor" href="#代码"></a>代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; nums.length; p++)</span><br><span class="line">            <span class="keyword">if</span>(nums[p] != val) &#123;</span><br><span class="line">                nums[cur++] = nums[p];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="704-二分查找"><a class="header-anchor" href="#704-二分查找"></a>[704] 二分查找</h2>
<blockquote>
<p>本题目的目的是为了初步了解、熟悉和掌握二分查找，并未进行高级的应用</p>
</blockquote>
<h3 id="题目-v5"><a class="header-anchor" href="#题目-v5"></a>题目</h3>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h3 id="题目思路-v4"><a class="header-anchor" href="#题目思路-v4"></a>题目思路</h3>
<p>二分查找核心即为通过不断比较有序数组的中间下标对应的值与target的大小关系，不断缩小target在数组中的可能存在的区间范围，因而可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的复杂度</p>
<h3 id="解题代码"><a class="header-anchor" href="#解题代码"></a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[len-<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid +<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置"><a class="header-anchor" href="#35-搜索插入位置"></a>[35]搜索插入位置</h2>
<blockquote>
<p>本题应用到了[704]所学的二分查找算法，通过二分寻找到待插入元素的可以被插入的位置，假如当最后的nums[mid]小于val，则说明val需要插入到mid+1的位置，假如nums[mid]的值大于val，则需要将val插入到mdi这个位置，并将mid之后的元素右移一个单元。</p>
</blockquote>
<h3 id="题目-v6"><a class="header-anchor" href="#题目-v6"></a>题目</h3>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h3 id="解题代码-v2"><a class="header-anchor" href="#解题代码-v2"></a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid-<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-两数相加"><a class="header-anchor" href="#1-两数相加"></a>[1]两数相加</h2>
<h3 id="题目-v7"><a class="header-anchor" href="#题目-v7"></a>题目</h3>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h3 id="解题思路："><a class="header-anchor" href="#解题思路："></a>解题思路：</h3>
<p>本题为模拟题，但并不意味着没有什么可学习的地方，为了使得代码简洁且清晰明了，我们需要结合计算机组成原理当中的行波进位加法器的原理来进行加法的模拟，一个进位(即前一位进过来的位)，与输入1和输入2，共同构成本位的值，同时根据本位的值再重新为进位赋值，将其作为下一个位的进位传递下去。</p>
<h3 id="解题代码如下"><a class="header-anchor" href="#解题代码如下"></a>解题代码如下</h3>
<h4 id="屎山版本"><a class="header-anchor" href="#屎山版本"></a>屎山版本</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">answer</span> <span class="operator">=</span> l3;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="keyword">while</span>(tmp1!=<span class="literal">null</span>)&#123;</span><br><span class="line">        num1++;</span><br><span class="line">        tmp1 = tmp1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tmp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        num2++;</span><br><span class="line">        tmp2 = tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Integer.min(num1,num2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minNum-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> l1.val+l2.val;</span><br><span class="line">        </span><br><span class="line">        l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            l3.val += sum;</span><br><span class="line">            l3.val = l3.val % <span class="number">10</span>;</span><br><span class="line">            l3.next.val++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l3.val += sum;</span><br><span class="line">            <span class="keyword">if</span>(l3.val&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                l3.next.val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l3 = l3.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l3.val += l1.val+l2.val;</span><br><span class="line">    <span class="keyword">if</span>(l3.val&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">        l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1&lt;num2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1; i &lt; num2; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l3.next == <span class="literal">null</span>)</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                l3 = l3.next;</span><br><span class="line">                l3.val+= l2.next.val;</span><br><span class="line">                <span class="keyword">if</span>(l3.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                    l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num2; i &lt; num1; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l3.next == <span class="literal">null</span>)</span><br><span class="line">                   l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                l3 = l3.next;</span><br><span class="line">                l3.val+= l1.next.val;</span><br><span class="line">                <span class="keyword">if</span>(l3.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                    l3.val = l3.val%<span class="number">10</span>;</span><br><span class="line">                    l3.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp3</span> <span class="operator">=</span> answer;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行波进位加法器思想修改版本"><a class="header-anchor" href="#行波进位加法器思想修改版本"></a>行波进位加法器思想修改版本</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">null</span> || l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显可以看出，带有正确的思想和原理去进行模拟，可以得到一个更为优良的解法和代码。</p>
<h2 id="7-整数反转"><a class="header-anchor" href="#7-整数反转"></a>[7]整数反转</h2>
<h3 id="题目-v8"><a class="header-anchor" href="#题目-v8"></a>题目</h3>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>``-2^31 &lt;= x &lt;= 2^31 - 1`</li>
</ul>
<h3 id="题目思路-v5"><a class="header-anchor" href="#题目思路-v5"></a>题目思路</h3>
<p>本题为纯数学问题，而后将一个个截取出来的每一位都加载到一个新的数字当中。</p>
<h3 id="代码解答"><a class="header-anchor" href="#代码解答"></a>代码解答</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(x);</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            reversed = reversed * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reversed &gt; Integer.MAX_VALUE || reversed &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果超出范围，返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>) (-<span class="number">1</span> * reversed);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="type">int</span>) reversed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-字符串转换整数-atoi"><a class="header-anchor" href="#8-字符串转换整数-atoi"></a>[8]字符串转换整数(atoi)</h2>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231,  231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>
</ul>
<h2 id="239-滑动窗口最大值"><a class="header-anchor" href="#239-滑动窗口最大值"></a>[239] <a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></h2>
<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    if (nums == null || k &lt;= 0) &#123;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    int[] ans = new int[n - k + 1];</span><br><span class="line">    int count = 0;</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + 1) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">    </span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            ans[count++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a class="header-anchor" href="#56-合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2>
<h3 id="题目思路-v6"><a class="header-anchor" href="#题目思路-v6"></a>题目思路</h3>
<p>本题核心是，通过 sort 方法先将每一个区间的左边界进行排序，这样就将问题简化成只需要对比<strong>上一个区间的右边界与下一个区间的左边界</strong>的大小即可知道需要合并与否了</p>
<h3 id="代码解答-v2"><a class="header-anchor" href="#代码解答-v2"></a>代码解答</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="comment">// 如果数组大小为 0，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据区间的左边界继续排序</span></span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> [] interval1,<span class="type">int</span> [] interval2)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ans.size() == <span class="number">0</span> || ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(ans.size() - <span class="number">1</span>)[<span class="number">1</span>],R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a class="header-anchor" href="#25-K-个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2>
<p>一道经典的双指针问题，处理链表问题时，经常性需要一个人造头指针来辅助处理问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 创建一个人造头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> h , post = h; <span class="comment">// pre 是待翻转区域的上界，post 是待翻转区域的下界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(post.next != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;k &amp;&amp; post != <span class="literal">null</span>;++i)&#123;post = post.next;&#125; <span class="comment">// 找到待翻转区域的下界</span></span><br><span class="line">      <span class="keyword">if</span>(post == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">// 说明当前小组不足 k 个，已经到了末端</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next; <span class="comment">// 因为一开始 pre 指向的是伪头</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">nextStart</span> <span class="operator">=</span> post.next; <span class="comment">// 需要翻转后还能找到之后的节点</span></span><br><span class="line">      post.next = <span class="literal">null</span>;</span><br><span class="line">      pre.next = reverse(start);</span><br><span class="line">      start.next = nextStart;</span><br><span class="line">      pre = start;</span><br><span class="line">      post = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode <span class="title function_">reverse</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">      cur.next = tail;</span><br><span class="line">      tail = cur;</span><br><span class="line">      cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a class="header-anchor" href="#148-排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2>
<h3 id="使用归并排序："><a class="header-anchor" href="#使用归并排序："></a>使用归并排序：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">// 归并排序</span></span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMiddle(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(mid);</span><br><span class="line">    <span class="keyword">return</span> merge(left,right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode <span class="title function_">merge</span><span class="params">(ListNode left,ListNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">      left.next = merge(left.next,right);</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      right.next = merge(left,right.next);</span><br><span class="line">      <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序需要先找到中间部分</span></span><br><span class="line">  ListNode <span class="title function_">findMiddle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy, fast = dummy;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用数组映射"><a class="header-anchor" href="#使用数组映射"></a>使用数组映射</h3>
<h2 id="98-验证二叉搜索树"><a class="header-anchor" href="#98-验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2>
<h3 id="递归"><a class="header-anchor" href="#递归"></a>递归</h3>
<p>通过递归判断当前节点是左节点需要小于头节点，是右节点需要大于头节点，否则都返回 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vaildBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">vaildBST</span><span class="params">(TreeNode cur , <span class="type">long</span> lower,<span class="type">long</span> upper)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur.val &lt;= lower || cur.val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> vaildBST(cur.left,lower,cur.val) &amp;&amp; vaildBST(cur.right,cur.val,upper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历验证"><a class="header-anchor" href="#中序遍历验证"></a>中序遍历验证</h3>
<p>如果是一颗 BST 那么一定是一个单调递增的序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 队列模拟栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">inorder</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 把所有左孩子压入栈，出栈顺序是从下往上</span></span><br><span class="line">            <span class="keyword">while</span>(root!= <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到最底下的左孩子</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= inorder) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            <span class="comment">// 得到左孩子，在下一轮进行判断</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第-K-小的元素"><a class="header-anchor" href="#230-二叉搜索树中第-K-小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></h2>
<h3 id="中序遍历，记录遍历个数即可"><a class="header-anchor" href="#中序遍历，记录遍历个数即可"></a>中序遍历，记录遍历个数即可</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> , ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = stack.pop();</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span>(count == k) ans = root.val;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图"><a class="header-anchor" href="#199-二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2>
<p>使用层序遍历而后取每一层的最后一个节点</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2>
<p>前序遍历数组的第一个元素总是当前子树的根节点</p>
<p>中序遍历获取到根节点之后可以将数组分为左右两个子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="comment">// 记录中序遍历当中值对应的下标，在通过前序遍历获得后可以获取到当前节点的左右子树</span></span><br><span class="line">      map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> build(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TreeNode <span class="title function_">build</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> pre_left, <span class="type">int</span> pre_right,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre_left &gt; pre_right)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历中当前根节点的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pre_root</span> <span class="operator">=</span> pre_left;</span><br><span class="line">    <span class="comment">// 中序遍历中当前根节点的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">in_root</span> <span class="operator">=</span> map.get(preorder[pre_root]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_root]);</span><br><span class="line">    <span class="comment">// 获取左子树节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size4left</span> <span class="operator">=</span> in_root - in_left;</span><br><span class="line">    root.left = build(preorder, inorder, pre_left + <span class="number">1</span>, pre_left + size4left, in_left, in_root - <span class="number">1</span>);</span><br><span class="line">    root.right = build(preorder, inorder, pre_left + size4left + <span class="number">1</span>, pre_right, in_root + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他优秀写法，先构建最小的左子树，而后逐步向上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build((<span class="type">long</span>) Integer.MAX_VALUE+<span class="number">1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">long</span> stop, <span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; inorder.length &amp;&amp; inorder[i] !=stop)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[p++]);</span><br><span class="line">            root.left = build(root.val,preorder,inorder);</span><br><span class="line">            ++i;</span><br><span class="line">            root.right = build(stop,preorder,inorder);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="437-路径总和-III"><a class="header-anchor" href="#437-路径总和-III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2>
<h3 id="前缀和解法"><a class="header-anchor" href="#前缀和解法"></a>前缀和解法</h3>
<p>类似于<a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a>，统计出有值为 xxx 的和的个数，而后可以知道答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">    <span class="comment">// 首先创建一个哈希表来收集前缀和(由于不知道到底 val 有多大，因此不开辟一个数组而是使用哈希表)</span></span><br><span class="line">    Map&lt;Long,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    cnt.put(<span class="number">0L</span>,<span class="number">1</span>); <span class="comment">// 将 0 存放入哈希表中，为防止根节点开始即为 targetSum 的情况没统计到，因此放进去</span></span><br><span class="line">    dfs(root,<span class="number">0L</span>,targetSum,cnt);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">long</span> sum,<span class="type">int</span> target,Map&lt;Long,Integer&gt; cnt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sum+=node.val;</span><br><span class="line">    ans += cnt.getOrDefault(sum-target,<span class="number">0</span>);</span><br><span class="line">    cnt.merge(s,<span class="number">1</span>,Integer::sum);</span><br><span class="line">    dfs(node.left,sum,target,cnt);</span><br><span class="line">    dfs(node.right,sum,target,cnt);</span><br><span class="line">    cnt.merge(s,-<span class="number">1</span>,Integer::sum);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a class="header-anchor" href="#198-打家劫舍"></a>[198] <a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2>
<h3 id="动态规划入门"><a class="header-anchor" href="#动态规划入门"></a>动态规划入门</h3>
<p>四个解题步骤：</p>
<ul>
<li>定义子问题</li>
<li>写出子问题的递推关系</li>
<li>确定 DP 数组的计算顺序</li>
<li>空间优化（选择）</li>
</ul>
<h2 id="146-LRU-缓存"><a class="header-anchor" href="#146-LRU-缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">// key-node(val) 直接获取节点，可以在双向链表中进行操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer,DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            node.val = val;</span><br><span class="line">            move2Head(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key,val);</span><br><span class="line">            cache.put(key,newNode);</span><br><span class="line">            add2Head(newNode);</span><br><span class="line">            <span class="keyword">if</span>(cache.size()&gt;capacity)&#123;</span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tailNode</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(tailNode.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">move2Head</span><span class="params">(DLinkedNode node)</span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        add2Head(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 淘汰尾节点</span></span><br><span class="line">    <span class="comment">// 添加到头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add2Head</span><span class="params">(DLinkedNode node)</span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.post = head.post;</span><br><span class="line">        head.post.prev = node;</span><br><span class="line">        head.post = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 末尾淘汰</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">tailNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(tailNode);</span><br><span class="line">        <span class="keyword">return</span> tailNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用方法：移除节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span>&#123;</span><br><span class="line">        node.prev.post = node.post;</span><br><span class="line">        node.post.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DLinkedNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode post;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯问题"><a class="header-anchor" href="#回溯问题"></a>回溯问题</h2>
<p>当前操作</p>
<p>子问题</p>
<p>边界设定</p>
<h3 id="排列型-46-全排列"><a class="header-anchor" href="#排列型-46-全排列"></a>排列型 <a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3>
<p>该问题是经典的排列型回溯问题，需要将问题转换为，下标 0 ~ n 的某个下标 i 填入的是要求的 nums 中的哪个数，通过遍历实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">// 要有一个记录答案的数组</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums)&#123;</span><br><span class="line">// 创建y</span><br><span class="line">List&lt;Integer&gt; path = Arrays.asList(new Integer[nums.length])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="经典算法"><a class="header-anchor" href="#经典算法"></a>经典算法</h1>
<p><a href="https://oi-wiki.org/">算法思路：OI Wiki</a></p>
<h2 id="高精度计算-大整数计算"><a class="header-anchor" href="#高精度计算-大整数计算"></a>高精度计算&amp;大整数计算</h2>
<p>高精度的计算实际上是用<strong>数组存储</strong>和<strong>模拟运算</strong></p>
<p>翻转存储数字，为了保证个位在数组的同一个位置</p>
<h3 id="高精度加法"><a class="header-anchor" href="#高精度加法"></a>高精度加法</h3>
<p><strong>输入格式</strong></p>
<p>两行输入。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mo>=</mo><msup><mn>10</mn><mn>500</mn></msup></mrow><annotation encoding="application/x-tex">a,b &lt;= 10^{500}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">500</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>输出格式</strong></p>
<p>输出一行，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>的值</p>
<h4 id="实现思路"><a class="header-anchor" href="#实现思路"></a>实现思路</h4>
<p>将数字进行翻转存储，让个位位于数组的0号位，方便对数字数组进行处理</p>
<p>在翻转存储之后，根据贴近生活当中正常的加减法的运算方式进行模拟</p>
<h4 id="核心代码"><a class="header-anchor" href="#核心代码"></a>核心代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="type">int</span> la,lb,lc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[], <span class="type">int</span> C[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lc;i++)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    la = a.<span class="built_in">size</span>(),lb = b.<span class="built_in">size</span>(),lc = c.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = la - <span class="number">1</span>; ~i ; i--) A[la<span class="number">-1</span>-i] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lb - <span class="number">1</span>; ~i ; i--) B[lb<span class="number">-1</span>-i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">add</span>(A,B,C);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lc - <span class="number">1</span>; ~i; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="贪心和动态规划算法"><a class="header-anchor" href="#贪心和动态规划算法"></a>贪心和动态规划算法</h2>
<h3 id="贪心算法"><a class="header-anchor" href="#贪心算法"></a>贪心算法</h3>
<p>贪心算法在解决找零钱问题时，为了能够找到最优解，对硬币面额进行了限制：</p>
<p><strong>即任意两个面额之间的比率是整数倍关系。</strong></p>
<p>在上述条件下，贪心算法在每一步选择中都可以选择当前面额最大的硬币，这样可以确保每次选择的硬币面额尽可能大。</p>
<p>假设硬币的面额集合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>3</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>c</mi><mi>n</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\{c_1, c_2, c_3, \ldots, c_n\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">({</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">})</span></span></span></span>，并且满足贪心选择性质，那么在找零钱问题中，当需要找零金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 时，贪心算法可以这样工作：</p>
<ol>
<li>从硬币面额集合中选取面额最大的硬币，假设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i \leq n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>扣除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 后剩余的金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k - c_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>重复以上步骤，直到剩余金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p>由于硬币面额之间的比率是整数倍关系，贪心算法每次都选择当前面额最大的硬币，因此可以确保每次选择的硬币面额尽可能大。这样，贪心算法得到的解是一个局部最优解，而且由于贪心选择性质的特性，这个局部最优解也是全局最优解。</p>
<p>因此，硬币面额满足贪心选择性质时，贪心算法能够得到最优解的原因在于每次选择的硬币面额都是局部最优的，且这些局部最优解的组合也构成了全局最优解。</p>
<h2 id="KMP算法"><a class="header-anchor" href="#KMP算法"></a>KMP算法</h2>
]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</url>
    <content><![CDATA[<h1 id="14章-静电场"><a class="header-anchor" href="#14章-静电场"></a>14章 静电场</h1>
<h2 id="14-1-电荷-库仑定律"><a class="header-anchor" href="#14-1-电荷-库仑定律"></a>14-1 电荷 库仑定律</h2>
<h3 id="1-电荷量子化"><a class="header-anchor" href="#1-电荷量子化"></a>1. 电荷量子化</h3>
<ol>
<li>
<p>种类：正电荷、负电荷</p>
</li>
<li>
<p>性质：同性相斥、异性相吸</p>
</li>
<li>
<p>单位：库伦（C）</p>
</li>
<li>
<p>量子化： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo>±</mo><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">q=\pm ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">±</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span></span></span></span></p>
<p>​			   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mn>1.602</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>19</mn></mrow></msup></mrow><annotation encoding="application/x-tex">e=1.602\times10^{-19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1.602</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">19</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ol>
<h3 id="2-电荷守恒定律："><a class="header-anchor" href="#2-电荷守恒定律："></a>2. 电荷守恒定律：</h3>
<p>不管系统中的电荷如何迁移，孤立系统的电荷的代数和保持不变（自然界的基本守恒定律之一）</p>
<h4 id="3-库仑定律："><a class="header-anchor" href="#3-库仑定律："></a>3. 库仑定律：</h4>
<ul>
<li>
<p>真空中两个静止点电荷 相互作用力<strong>F</strong>的大小与这两个点电荷所带电荷 量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的乘积成正比， 与它们之间的距离<strong>r</strong>的平 方成反比</p>
</li>
<li>
<p>点电荷：抽象模型</p>
</li>
<li>
<p>库仑力大小为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><mfrac><mrow><msub><mi>q</mi><mn>1</mn></msub><msub><mi>q</mi><mn>2</mn></msub></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">F = \frac{1}{4\pi{\epsilon}_0}\frac{q_1q_2}{r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2902em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 方向:同号相斥,异号相吸</p>
</li>
<li>
<p>真空电容率: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mn>0</mn></msub><mo>=</mo><mn>8.85</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>12</mn></mrow></msup><msup><mi>C</mi><mn>2</mn></msup><mo>⋅</mo><msup><mi>m</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\epsilon_0 = 8.85\times10^{-12} C^2\cdot m^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8.85</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>两个以上的静止点电荷采用<strong>静电力的叠加原理</strong>:</p>
<ul>
<li>作用于每一个电荷上的总静电力等于其他点电荷单独存在时作 用于该电荷的静电力的矢量和。</li>
<li>
<img src="E:\DeskTable\博客学习截图传输\image-20231011095200807.png" alt="image-20231011095200807" style="zoom:67%;" />
</li>
</ul>
</li>
</ul>
<h2 id="14-2-电场-电场强度"><a class="header-anchor" href="#14-2-电场-电场强度"></a>14-2 电场 电场强度</h2>
<h3 id="1-静电场"><a class="header-anchor" href="#1-静电场"></a>1. 静电场</h3>
<img src="E:\DeskTable\博客学习截图传输\image-20231011095349585.png" alt="image-20231011095349585" style="zoom:50%;" />
<h3 id="2-电场强度"><a class="header-anchor" href="#2-电场强度"></a>2. 电场强度</h3>
<ul>
<li>
<p>电场中某点处的电场强度等于位于该点处的单位试验电荷 所受的力，其<strong>方向为正电荷受力方向</strong>.</p>
</li>
<li>
<p>电场强度大小:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mi>F</mi><msub><mi>q</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">E=\frac{F}{q_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3534em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>单位: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>⋅</mo><msup><mi>C</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N \cdot C^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⋅</mo><msup><mi>m</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">V \cdot m^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>电荷在电场中受力: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>q</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">F=qE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">qE</span></span></span></span></p>
</li>
</ul>
<h3 id="3-点电荷电场强度"><a class="header-anchor" href="#3-点电荷电场强度"></a>3. 点电荷电场强度</h3>
<p>知识点和高中相似</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><mfrac><mrow><mi>Q</mi><msub><mi>q</mi><mn>0</mn></msub></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">F = \frac{1}{4\pi{\epsilon}_0}\frac{Qq_0}{r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3695em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mi>F</mi><msub><mi>q</mi><mn>0</mn></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><mfrac><mi>Q</mi><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">E = \frac{F}{q_0} = \frac{1}{4\pi{\epsilon}_0}\frac{Q}{r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3534em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3695em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h3 id="4-电场强度叠加原理"><a class="header-anchor" href="#4-电场强度叠加原理"></a>4. 电场强度叠加原理</h3>
<p>4-1 点电荷<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">q_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ,在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处的总电场强度:</p>
<ul>
<li>与静电力的叠加原理类似,某个电荷之外的其他电荷在该电荷的电场等于每一个电场强度的矢量和:</li>
<li>$\vec{E} = \sum_i \vec{E_i} $</li>
</ul>
<p>4-2 连续电荷在某一点的总电场强度:</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011100812868.png" alt="image-20231011100812868" style="zoom:50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>q</mi></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac><mover accent="true"><msub><mi>e</mi><mi>r</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{E} = \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3773em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>	$\vec{E} = \int d \vec{E} = \int \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r} $</p>
<p>体密度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>q</mi></mrow><mrow><mi>d</mi><mi>V</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho = \frac{dq}{dV}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <img src="E:\DeskTable\博客学习截图传输\image-20231011101609517.png" alt="image-20231011101609517" style="zoom:50%;" /></p>
<p>面密度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>q</mi></mrow><mrow><mi>d</mi><mi>S</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sigma = \frac{dq}{dS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <img src="E:\DeskTable\博客学习截图传输\image-20231011101549342.png" alt="image-20231011101549342" style="zoom: 50%;" /></p>
<p>线密度: $ \lambda = \frac{dq}{dl} $ <img src="E:\DeskTable\博客学习截图传输\image-20231011101526062.png" alt="image-20231011101526062" style="zoom: 50%;" /></p>
<h3 id="5-外电场对电偶极子的力矩和取向作用"><a class="header-anchor" href="#5-外电场对电偶极子的力矩和取向作用"></a>5. 外电场对电偶极子的力矩和取向作用</h3>
<img src="E:\DeskTable\博客学习截图传输\image-20231011101656283.png" alt="image-20231011101656283" style="zoom:150%;" />
<p>相距很近,等量异号的点电荷系:</p>
<p>​	电距: $\vec{P} = q \vec{l} $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011102016383.png" alt="image-20231011102016383" style="zoom: 67%;" />
<p>匀强电场中:</p>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011102128247.png" alt="image-20231011102128247"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>F</mi><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><msub><mi>F</mi><mo>+</mo></msub><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msub><mi>F</mi><mo>−</mo></msub><mo>⃗</mo></mover><mo>=</mo><mi>q</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>−</mo><mi>q</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\vec{F} = \vec{F_+} + \vec{F_-} = q\vec{E} - q\vec{E} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1747em;vertical-align:-0.2083em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1747em;vertical-align:-0.2083em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>q</mi><msub><mi>r</mi><mn>0</mn></msub><mi>E</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mi>p</mi><mi>E</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">M = q r_0 E \sin{\theta} = pE\sin{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">pE</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><mi>p</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>θ</mi><mo>=</mo><mi>π</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\vec{M} = \vec{p} \times \vec{E} \left\{
\begin{array}{l}
\theta = 0 \\
\theta = \pi
\end{array}
\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">p</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>		<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\vec{M} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<h2 id="14-3-电场强度通量-高斯定理"><a class="header-anchor" href="#14-3-电场强度通量-高斯定理"></a>14-3 电场强度通量 高斯定理</h2>
<h3 id="1-电场线"><a class="header-anchor" href="#1-电场线"></a>1. 电场线</h3>
<p>为了直观可视化描述电场</p>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011103714950.png" alt="image-20231011103714950"></p>
<ul>
<li>曲线上每一点切线方向为该点电场方向</li>
<li>通过垂直于电场方向单位面积的电场线的条数为该电场强度的大小      <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mo>=</mo><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>N</mi></mrow><mrow><mi>d</mi><msub><mi>S</mi><mo lspace="0em" rspace="0em">⊥</mo></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">|\vec{E}| = E = \frac{dN}{dS_{\perp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2163em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.331em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0576em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<p>多种点电荷电场线,与高中无异</p>
<h4 id="特性"><a class="header-anchor" href="#特性"></a>特性</h4>
<ol>
<li>始于正电荷,终于负电荷(来自无穷远,去向无穷远) 在没有电荷的地方不中断</li>
<li>没有电荷的地方任意两条电场线不相交</li>
<li>电场线不闭合</li>
<li>电场线密集——电场强度较大；电场线稀疏——电场强度较小</li>
</ol>
<h3 id="2-电场强度通量"><a class="header-anchor" href="#2-电场强度通量"></a>2. 电场强度通量</h3>
<p>通过电场中某一个面的电场线数叫做通过这个面的电场强度通量</p>
<ul>
<li>
<p>匀强电场:</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 与平面垂直</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>e</mi></msub><mo>=</mo><mi>E</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\Phi_e = ES</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">ES</span></span></span></span> <img src="E:\DeskTable\博客学习截图传输\image-20231011104246049.png" alt="image-20231011104246049"  /></p>
</li>
<li>
<p>$\vec{E} $ 与平面夹角为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span><br>
$\Phi_e = ES \cos{\theta} $	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>e</mi></msub><mo>=</mo><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\Phi_e = \vec{E} \cdot \vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> <img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011104550268.png" alt="image-20231011104550268"></p>
</li>
</ul>
</li>
<li>
<p>非均匀电场</p>
<ul>
<li>
<p>$ d \vec{S} = dS \cdot \vec{e_n}$</p>
</li>
<li>
<p>$ d\Phi_e = \vec{E} \cdot d \vec{S} $</p>
</li>
<li>
<p>$ \Phi_e = \int d \Phi_e = \int_S E \cos{\theta} dS $</p>
</li>
<li>
<p>$ \Phi_e = \int_S \vec{E} \cdot d\vec{S} $</p>
</li>
<li>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011105921724.png" alt="image-20231011105921724"></p>
</li>
<li>
<p>S为封闭曲面时:</p>
<ul>
<li>
<p>$\theta_1 &lt; \frac{\pi}{2} , d\Phi_{e1} &gt; 0 $</p>
</li>
<li>
<p>$ \theta_2 &gt; \frac{\pi}{2}, d\Phi_{e2} &lt; 0$</p>
</li>
<li>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011105912608.png" alt="image-20231011105912608"></p>
</li>
</ul>
</li>
<li>
<p>闭合曲面的电场强度通量</p>
<ul>
<li>$ d\Phi_e = \vec{E} \cdot d \vec{S} $</li>
<li>$ \oint_S \vec{E} \cdot d \vec{S} = \oint_S E \cos{\theta} dS $</li>
<li><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011105852809.png" alt="image-20231011105852809"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-高斯定理"><a class="header-anchor" href="#3-高斯定理"></a>3. 高斯定理</h3>
<p>在真空中,通过任一闭合曲面的电场强度通量, 等于该曲面所包围的所有电荷的代数和除以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\epsilon_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （与面外电荷无关，闭合曲面称为高斯面）</p>
<p>$ \Phi_e = \oint_S \vec{E} \cdot d \vec{S} = \frac{1}{\epsilon_0} \sum^n_{i=1} q_i^{in}$</p>
<p>由<strong>库仑定律</strong>和<strong>电场强度叠加原</strong>理可以导出<strong>高斯定理</strong></p>
<ul>
<li>
<p>闭合面外的电荷对通过闭合 面的电场强度通量没有贡献，但是对闭合面上各点的电场强度是有贡献的，即闭合面上各点的电场强度是由闭合面内、外所有电 荷共同激发的</p>
</li>
<li>
<p>高斯定理将静电场与场源电荷联系了起来，揭示了静电场是有源场这一普遍性质(静电场有源无旋)</p>
</li>
</ul>
<h3 id="4-高斯定理的应用"><a class="header-anchor" href="#4-高斯定理的应用"></a>4. 高斯定理的应用</h3>
<p>应用条件:</p>
<ol>
<li>
<p>静电场必须具有一定的对称性</p>
</li>
<li>
<p>根据对称性选择高斯面</p>
</li>
<li>
<p>高斯面上的场强处处相等或者分区域相等;</p>
<p>部分高斯面上的通量为零,部分高斯面上的场强相等</p>
</li>
<li>
<p>先使用高斯定理求出电场强度通量,而后用高斯定理,配合闭合曲面大小求出电场强度</p>
</li>
</ol>
<h2 id="14-4-静电场的环路定理-电势"><a class="header-anchor" href="#14-4-静电场的环路定理-电势"></a>14-4 静电场的环路定理 电势</h2>
<h4 id="1-静电场力所做的功"><a class="header-anchor" href="#1-静电场力所做的功"></a>1. 静电场力所做的功</h4>
<p>点电荷的电场</p>
<p>$dA = q_0 \vec{E} \cdot \vec{l} = q_0E \cdot dl \cdot \cos{\theta} $</p>
<p>​	  $=q_0 \frac{q}{4 \pi \epsilon_0 r^2} \cdot dl \cdot \cos{\theta} $</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>l</mi><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mi>d</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">dl \cos{\theta} = dr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>A</mi><mo>=</mo><mfrac><mrow><msub><mi>q</mi><mn>0</mn></msub><mi>q</mi></mrow><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub><msup><mi>r</mi><mn>2</mn></msup></mrow></mfrac><mi>d</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">dA = \frac{q_0q}{4 \pi \epsilon_0 r^2} dr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1926em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mrow><msub><mi>q</mi><mn>0</mn></msub><mi>q</mi></mrow><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><msubsup><mo>∫</mo><msub><mi>r</mi><mi>A</mi></msub><msub><mi>r</mi><mi>B</mi></msub></msubsup><mfrac><mrow><mi>d</mi><mi>r</mi></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac><mo>=</mo><mfrac><mrow><msub><mi>q</mi><mn>0</mn></msub><mi>q</mi></mrow><mrow><mn>4</mn><mi>π</mi><msub><mi>ϵ</mi><mn>0</mn></msub></mrow></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><msub><mi>r</mi><mi>A</mi></msub></mfrac><mo>−</mo><mfrac><mn>1</mn><msub><mi>r</mi><mi>B</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A= \frac{q_0q}{4 \pi \epsilon_0} \int^{r_B}_{r_A} \frac{dr}{r^2} = \frac{q_0q}{4 \pi \epsilon_0}(\frac{1}{r_A} - \frac{1}{r_B})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3362em;vertical-align:-0.4561em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4561em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2904em;vertical-align:-0.4453em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mathnormal mtight">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4453em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2904em;vertical-align:-0.4453em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4453em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<p>所做的功<strong>A</strong> 仅和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的始末位置有关,与路径无关(积分与路径无关)</p>
<p>即可得:</p>
<p>$ \vec{E} = \sum \vec{E_i} $ (点电荷的组合)</p>
<p>$ A = \int_l q_0 \vec{E} \cdot d \vec{l} = \sum_i q_0 \cdot \int_l \vec{E_i} \cdot d \vec{l} $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011121105020.png" alt="image-20231011121105020" style="zoom: 67%;" />
<h4 id="2-静电场的环路定理"><a class="header-anchor" href="#2-静电场的环路定理"></a>2. 静电场的环路定理</h4>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011123130536.png" alt="image-20231011123130536"></p>
<p>$ q_0 \int_{ABC} \vec{E} \cdot d \vec{l} = q_0 \int_{ADC} \cdot d \vec{l} $</p>
<p>$ q_0(\int_{ABC} \vec{E} \cdot d \vec{l} - \int_{ADC} \vec{E} \cdot d \vec{l}) = 0 $</p>
<p>静电场是保守场,沿闭合路径一周,电场力做功为零</p>
<h1 id="16章-稳恒磁场"><a class="header-anchor" href="#16章-稳恒磁场"></a>16章 稳恒磁场</h1>
<h2 id="16-1"><a class="header-anchor" href="#16-1"></a>16-1</h2>
<h3 id="1-电流电流密度"><a class="header-anchor" href="#1-电流电流密度"></a>1. 电流	电流密度</h3>
<h4 id="1-1形成电流的条件："><a class="header-anchor" href="#1-1形成电流的条件："></a>1.1形成电流的条件：</h4>
<ul>
<li>
<p>在导体内有可以自由移动的电荷（载流子）</p>
</li>
<li>
<p>在导体内要维持一个电场，或者在导体两端要存在有电势差\</p>
</li>
</ul>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231011192022160.png" alt="image-20231011192022160"></p>
<p>电流强度：通过截面<strong>S</strong>的电荷随时间的变化率</p>
<p>$I = \frac{dq}{dt} $</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>q</mi><mo>=</mo><mi>q</mi><mi>n</mi><mi>u</mi><mi>d</mi><mi>t</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">dq = qnudtS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">tS</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 载流子电荷</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 载流子浓度</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 载流子漂移速度 	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 电子漂移速度的大小</li>
</ul>
<p>$dI = qnudS_{\perp} = qnudS \cos{theta} = qn \vec{u} \cdot d \vec{S} = \vec{j} \cdot \textbf{d} \vec{S} $</p>
<p>电流密度矢量大小: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>I</mi></mrow><mrow><mi>d</mi><msub><mi>S</mi><mo lspace="0em" rspace="0em">⊥</mo></msub></mrow></mfrac><mo>=</mo><mi>q</mi><mi>n</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">j = \frac{dI}{d S_{\perp}} = qnu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.331em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0576em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span></span></span></span> 方向为该点正电荷运动方向,单位: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><msup><mi>m</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">A \cdot m^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>通过任意曲面的电流: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><msub><mo>∫</mo><mi>S</mi></msub><mover accent="true"><mi>j</mi><mo>⃗</mo></mover><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">I = \int_S \vec{j} \cdot d \vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2983em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span><span style="top:-3.2285em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="1-2-电流的连续性方程稳恒电流条件"><a class="header-anchor" href="#1-2-电流的连续性方程稳恒电流条件"></a>1.2 电流的连续性方程	稳恒电流条件</h4>
<p>单位时间内通过闭合曲面向外流出的电荷，等于此时间内闭合曲面内电荷的减少量.</p>
<p>电流密度矢量点乘闭合曲面面积矢量微元即是此刻在该处曲面的电流的微元</p>
<p>$ dI = \vec{j} \cdot d \vec{S}$ $I = \oint_S \vec{j} \cdot d \vec{S} = \frac{dq_外}{dt} = -\frac{dq_内}{dt} $</p>
<p>某一时刻,单位闭合曲面 <em>S</em> 内,流入的电荷量与流出的电荷量相互抵消——即闭合曲面 <em>S</em> 内部的电荷不随时间的变化而变化，则</p>
<p>$ \frac{d q_内}{dt} = 0$</p>
<p>稳恒电流	$ \oint_S \vec{j} \cdot d \vec{S} = 0$</p>
<p>导体内的电流密度不随时间变化的电流</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231011201203610.png" alt="image-20231011201203610" style="zoom:50%;" />
<p>由基尔霍夫第一定律:	$ -I+I_1+I_2=0 $</p>
<ol>
<li>在稳恒电流情况下，导体中电荷分布不随时间变化形成恒定电场</li>
<li>稳恒电场与<mark>静电场具有相似性质</mark>（高斯定理和环路定理），同时稳恒电场引入了电势概念</li>
<li>稳恒电场存在<mark>能量的转换</mark>（很正常，带电体在电场内会做功或者被做功，则必然伴随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>势能</mtext><mo>⇌</mo><mtext>动能</mtext></mrow><annotation encoding="application/x-tex">势能 \rightleftharpoons 动能</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord cjk_fallback">势能</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇌</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">动能</span></span></span></span>）</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>I</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">U = IR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>ρ</mi><mfrac><mi>l</mi><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">R = \rho \frac{l}{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord mathnormal">ρ</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h4 id="1-3-欧姆定律的微分形式"><a class="header-anchor" href="#1-3-欧姆定律的微分形式"></a>1.3 欧姆定律的微分形式</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20231012000103917.png" alt="image-20231012000103917" style="zoom:67%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>U</mi></mrow><mi>R</mi></mfrac></mrow><annotation encoding="application/x-tex">dI = \frac{dU}{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 	$R = \frac{\rho dl}{dS} $</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>I</mi><mo>=</mo><mfrac><mn>1</mn><mi>ρ</mi></mfrac><mfrac><mrow><mi>d</mi><mi>U</mi></mrow><mrow><mi>d</mi><mi>l</mi></mrow></mfrac><mi>d</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">dI = \frac{1}{\rho} \frac{dU}{dl} dS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3612em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>I</mi></mrow><mrow><mi>d</mi><mi>S</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>ρ</mi></mfrac><mfrac><mrow><mi>d</mi><mi>U</mi></mrow><mrow><mi>d</mi><mi>l</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>ρ</mi></mfrac><mi>E</mi><mo>=</mo><mi>σ</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">\frac{dI}{dS} = \frac{1}{\rho} \frac{dU}{dl} = \frac{1}{\rho} E = \sigma E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3612em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>j</mi><mo>⃗</mo></mover><mo>=</mo><mfrac><mrow><mi>d</mi><mi>I</mi></mrow><mrow><mi>d</mi><mi>S</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>ρ</mi></mfrac><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>=</mo><mi>σ</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{j} = \frac{dI}{dS} = \frac{1}{\rho} \vec{E} = \sigma \vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.137em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span><span style="top:-3.2285em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4474em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></p>
<p>非静电力：能不断分离正负电荷使正电荷逆静电场力方向运动</p>
<p>电源：提供非静电力的装置</p>
<p>非静电电场强度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> : 为单位正电荷所受的非静电力.</p>
<p>$A_非 = \int^+_- q \vec{E_k} \cdot d \vec{l} $</p>
<p>电动势的定义：单位正电荷从负极通过电源内部移到正极时非静电力所做的功.</p>
<p>电动势是电路中电荷流动的驱动力</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231012081945376.png" alt="image-20231012081945376" style="zoom:50%;" />
<p>计算电动势的两种不同描述:</p>
<ol>
<li>
<p>基于电荷在已知电场中的移动</p>
<ul>
<li>这个公式表示了电场 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 在电荷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 移动的路径上执行的功，然后将这个功除以电荷的大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，得到电动势 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>。这是电动势的一种定义方式，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 是电场力，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 是电荷移动路径上的微小位移，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mo lspace="0em" rspace="0em">+</mo><mo lspace="0em" rspace="0em">−</mo></msubsup></mrow><annotation encoding="application/x-tex">\int_{+}^{-}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3804em;vertical-align:-0.4142em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4142em;"><span></span></span></span></span></span></span></span></span></span> 表示要对电荷从一个点移动到另一个点的路径上进行积分。</li>
<li>$ \epsilon = \frac{A_非}{q} = \int^+_- \vec{E_k} \cdot d \vec{l}$</li>
</ul>
</li>
<li>
<p>考虑电荷周围存在其他电场情况</p>
<ul>
<li>这个公式表示电场 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 和一个额外电场 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 一起对电荷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 执行的功的总和。在这里，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 是由于电荷本身产生的电场，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 可能是由外部因素产生的电场，如其他电荷或电场源。这个公式采用了环路积分的形式，表示对电荷沿着闭合路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 移动时，电场 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 执行的总功。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><msub><mo>∮</mo><mi>l</mi></msub><mo stretchy="false">(</mo><mover accent="true"><msub><mi>E</mi><mi>k</mi></msub><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\epsilon = \oint_l (\vec{E_k} + \vec{E}) \cdot d \vec{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3221em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1303em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2163em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ol>
<h2 id="16-2-磁场和磁感应强度"><a class="header-anchor" href="#16-2-磁场和磁感应强度"></a>16-2 磁场和磁感应强度</h2>
<h3 id="1-磁感应强度"><a class="header-anchor" href="#1-磁感应强度"></a>1. 磁感应强度</h3>
<h4 id="1-1磁感应强度的定义"><a class="header-anchor" href="#1-1磁感应强度的定义"></a>1.1磁感应强度的定义:</h4>
<p>当正电荷垂直于特定直线运动时，受力<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>F</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{F_{max}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>F</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{F_{max}} \times \vec{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 方向定义为该点的$ \vec{B}$ 的方向.</p>
<p>磁感强度大小: $B=\frac{F_{max}}{qv} $</p>
<p>运动电荷在磁场中受力(洛伦兹力),受力大小为:<br>
$ \vec{F} = q \vec{v} \times \vec{B}$</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231012083921021.png" alt="image-20231012083921021" style="zoom:50%;" />
<p>单位:特斯拉 $ 1T = 1 N \cdot (A \cdot m)^{-1}$</p>
<h4 id="1-2-磁感线-有旋无源"><a class="header-anchor" href="#1-2-磁感线-有旋无源"></a>1.2 磁感线(有旋无源)</h4>
<ol>
<li>理想模型,规定:曲线上每一点的切线方向就是该点的磁感强度<em>B</em>的方向,曲线的疏密程度表示该点的磁感强度<em>B</em>的大小.</li>
</ol>
<img src="E:\DeskTable\博客学习截图传输\image-20231012084013228.png" alt="image-20231012084013228" style="zoom:67%;" />
<ol start="2">
<li>性质:
<ul>
<li>与电流套连</li>
<li>闭合曲线</li>
<li>方向与电流成右手螺旋关系</li>
</ul>
</li>
</ol>
<h2 id="16-3-毕奥-萨伐尔定律-磁生电"><a class="header-anchor" href="#16-3-毕奥-萨伐尔定律-磁生电"></a>16-3 毕奥-萨伐尔定律(磁生电)</h2>
<h3 id="1-电流元在空间产生的磁场"><a class="header-anchor" href="#1-电流元在空间产生的磁场"></a>1. 电流元在空间产生的磁场</h3>
<img src="E:\DeskTable\博客学习截图传输\image-20231012091229844.png" alt="image-20231012091229844" style="zoom:50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>B</mi><mo>=</mo><mfrac><msub><mi>μ</mi><mn>0</mn></msub><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mfrac><mrow><mi>I</mi><mi>d</mi><mi>l</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">dB = \frac{\mu_0}{4 \pi} \frac{I dl \sin{\theta}}{r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mop mtight"><span class="mtight">s</span><span class="mtight">i</span><span class="mtight">n</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>	$d\vec{B} = \frac{\mu_0}{4 \pi} \frac{I d\vec{l} \times \vec{r}}{r^3} $</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>0</mn></msub><mtext>为真空电导率</mtext><mo separator="true">,</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>=</mo><mn>4</mn><mi>π</mi><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup><mi>N</mi><mo>⋅</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\mu_0 为真空电导率,\mu_0 = 4 \pi \times 10^{-7} N \cdot A^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为真空电导率</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>任意载流导线在点 <strong>P</strong> 处的磁感强度</p>
<p>磁感强度叠加:	$\vec{B} = \int d \vec{B} = \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \vec{r}}{r^3} = \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \hat{r}}{r^2} $</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 表示磁场矢量，它是一个矢量，表示在某个点上的磁场强度和方向。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>d</mi><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\int d\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2724em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 表示对磁场矢量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 进行积分，通常表示对整个区域的磁场进行积分以获得某一点的总磁场。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mu_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是真空磁导率。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> 表示电流，它是电流环中的电流。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 表示磁场小微元，即微小部分的磁场，通常由微小电流元素产生。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 是位置矢量，表示观察点到电流元素的距离。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 表示电流元素的微小位移，即在电流环上的微小长度元素。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 表示矢量叉积，产生一个垂直于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 的磁场矢量。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 表示观察点到电流微元的距离大小。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 是单位矢量，指向观察点到电流元素的方向。</p>
<p>一个非零向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span>的 <strong>正规化向量</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 就是平行于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span>的单位向量： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>r</mi><mo>^</mo></mover><mo>=</mo><mfrac><mi>r</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>r</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{r} = \frac{r}{|| \vec{r} ||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2154em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord mtight">∣∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
</ol>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231016085221183.png" alt="image-20231016085221183"></p>
<p><img src="E:\DeskTable\博客学习截图传输\image-20231016085317033.png" alt="image-20231016085317033" style="zoom:50%;" />  <img src="E:\DeskTable\博客学习截图传输\image-20231016090631799.png" alt="image-20231016090631799" style="zoom: 33%;" /></p>
<p>载流导线<em>CD</em> 产生磁感强度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> ,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">I d\vec{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 在P点产生<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">d\vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> ,方向垂直于纸面向里(即所有电流元在P点产生的磁感强度小微元方向均相同):</p>
<p>又 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>B</mi><mo>=</mo><mfrac><mrow><msub><mi>μ</mi><mn>0</mn></msub><mi>I</mi><mi>d</mi><mi>l</mi><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow><mrow><mn>4</mn><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">dB = \frac{\mu_0 I dl \sin{\alpha}}{4 \pi r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mop mtight"><span class="mtight">s</span><span class="mtight">i</span><span class="mtight">n</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ,为了后续的计算,需要进行变量的统一,将线变量转换成角变量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>⁡</mo><mi>β</mi></mrow><mrow><mi>sin</mi><mo>⁡</mo><mi>β</mi></mrow></mfrac><mo>⇒</mo><mi>d</mi><mi>l</mi><mo>=</mo><mi>d</mi><msup><mrow><mi>sec</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mi>β</mi><mi>d</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">l = \frac{\cos{\beta}}{\sin{\beta}} \Rightarrow dl = d \sec^2{\beta} d\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4133em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">s</span><span class="mtight">i</span><span class="mtight">n</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">c</span><span class="mtight">o</span><span class="mtight">s</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">sec</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>  			<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>d</mi><mi>sec</mi><mo>⁡</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">r = d \sec{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sec</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></span> 		$\sin{\alpha} = \cos{\beta} = \frac{d}{r} $</p>
<p>$B = \int^{\beta_2}<em>{\beta_1} \frac{\mu_0}{4 \pi} \frac{I d \sec^2{\beta} \cos{\beta} d\beta }{d^2 \sec^2{\beta}} = \frac{\mu_0I}{4 \pi d} \int^{\beta_2}</em>{\beta_1} \cos{\beta} d\beta = \frac{\mu_0I}{4 \pi d}(\sin{\beta_2}-\sin{\beta_1}) $</p>
<p>​    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mfrac><mrow><msub><mi>μ</mi><mn>0</mn></msub><mi>I</mi></mrow><mrow><mn>4</mn><mi>π</mi><mi>d</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><msub><mi>α</mi><mn>1</mn></msub><mo>−</mo><mi>cos</mi><mo>⁡</mo><msub><mi>α</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= \frac{\mu_0I}{4 \pi d}(\cos{\alpha_1}-\cos{\alpha_2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092407037.png" alt="image-20231016092407037" style="zoom: 50%;" /> 
<p>电流和磁感强度成 <mark>右手螺旋定则</mark></p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092546084.png" alt="image-20231016092546084" style="zoom:40%;" />
<p><img src="E:\DeskTable\博客学习截图传输\image-20231016092604543.png" alt="image-20231016092604543" style="zoom:40%;" />  <img src="E:\DeskTable\博客学习截图传输\image-20231016092705072.png" alt="image-20231016092705072" style="zoom:40%;" /></p>
<h3 id="3-磁偶极矩"><a class="header-anchor" href="#3-磁偶极矩"></a>3. 磁偶极矩</h3>
<p>$ \vec{m} = IS \vec{e_n} $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231016092744912.png" alt="image-20231016092744912" style="zoom:50%;" /> 
<h1 id="17-带电粒子在电场和磁场中的运动"><a class="header-anchor" href="#17-带电粒子在电场和磁场中的运动"></a>17 带电粒子在电场和磁场中的运动</h1>
<h2 id="17-1-带电粒子在电场和磁场中所受的力"><a class="header-anchor" href="#17-1-带电粒子在电场和磁场中所受的力"></a>17-1 带电粒子在电场和磁场中所受的力</h2>
<p>电场力：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>F</mi><mi>e</mi></msub><mo>⃗</mo></mover><mo>=</mo><mi>q</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{F_e} = q\vec{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></p>
<p>磁场力(洛伦兹力): $\vec{F_m} = q \vec{v} \times \vec{B} $</p>
<p>运动电荷在电场和磁场中受的力: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>F</mi><mo>⃗</mo></mover><mo>=</mo><mi>q</mi><mover accent="true"><mi>E</mi><mo>⃗</mo></mover><mo>+</mo><mi>q</mi><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{F} = q\vec{E} + q \vec{v} \times \vec{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="1-带电粒子在均匀磁场中的运动举例"><a class="header-anchor" href="#1-带电粒子在均匀磁场中的运动举例"></a>1.带电粒子在均匀磁场中的运动举例</h3>
<h4 id="1-回旋半径和回旋频率"><a class="header-anchor" href="#1-回旋半径和回旋频率"></a>1. 回旋半径和回旋频率</h4>
<p><img src="E:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20231016100903128.png" alt="image-20231016100903128"></p>
<p>$\vec{v_0} \perp \vec{B} $	$q \vec{v_0} B = m \frac{v_0^2}{R} $	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mrow><mi>m</mi><msub><mi>v</mi><mn>0</mn></msub></mrow><mrow><mi>q</mi><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">R = \frac{mv_0}{qB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1926em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7115em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">qB</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>R</mi></mrow><msub><mi>v</mi><mn>0</mn></msub></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>m</mi></mrow><mrow><mi>q</mi><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T = \frac{2 \pi R}{v_0} = \frac{2 \pi m}{qB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">qB</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πm</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 		$ f=\frac{1}{T} = \frac{qB}{2 \pi m} $</p>
<h4 id="2-速度选择器"><a class="header-anchor" href="#2-速度选择器"></a>2. 速度选择器</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20231016101428001.png" alt="image-20231016101428001" style="zoom:50%;" /> 
<h4 id="3-质谱仪"><a class="header-anchor" href="#3-质谱仪"></a>3. 质谱仪</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20231016101510210.png" alt="image-20231016101510210" style="zoom:50%;" /> 
<h4 id="4-回旋加速器"><a class="header-anchor" href="#4-回旋加速器"></a>4. 回旋加速器</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20231016101533592.png" alt="image-20231016101533592" style="zoom:50%;" /> 
<h3 id="2-磁聚焦"><a class="header-anchor" href="#2-磁聚焦"></a>2. 磁聚焦</h3>
<p>洛伦兹力不做功</p>
<p>$ \vec{F_m} = q \vec{v} \times \vec{B} $ 	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><msub><mi>v</mi><mo lspace="0em" rspace="0em">∥</mo></msub><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msub><mi>v</mi><mo lspace="0em" rspace="0em">⊥</mo></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v} = \vec{v_{\parallel}} + \vec{v_{\perp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0692em;vertical-align:-0.3552em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>v</mi><mo lspace="0em" rspace="0em">⊥</mo></msub><mo>⃗</mo></mover><mo>=</mo><mfrac><mrow><mi>q</mi><mi>B</mi><mi>R</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\vec{v_{\perp}} = \frac{qBR}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">qBR</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>R</mi></mrow><mover accent="true"><msub><mi>v</mi><mo lspace="0em" rspace="0em">⊥</mo></msub><mo>⃗</mo></mover></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>R</mi><mi>m</mi></mrow><mrow><mi>q</mi><mi>B</mi><mi>R</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>m</mi></mrow><mrow><mi>q</mi><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T = \frac{2 \pi R}{\vec{v_{\perp}}} = \frac{2 \pi R m}{qBR} = \frac{2 \pi m}{qB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3232em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3534em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">qBR</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">qB</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πm</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>螺距: $ d = v_{\parallel} T= v \cos{\theta} (\frac{2 \pi m }{qB})$</p>
<h3 id="3-霍尔效应"><a class="header-anchor" href="#3-霍尔效应"></a>3. 霍尔效应</h3>
<img src="E:\DeskTable\博客学习截图传输\image-20231016102845418.png" alt="image-20231016102845418" style="zoom:67%;" />
<img src="E:\DeskTable\博客学习截图传输\image-20231016102813922.png" alt="image-20231016102813922" style="zoom:67%;" />
<h2 id="18-磁介质"><a class="header-anchor" href="#18-磁介质"></a>18 磁介质</h2>
<h3 id="18-1-磁介质及其分类"><a class="header-anchor" href="#18-1-磁介质及其分类"></a>18.1 磁介质及其分类</h3>
<p>磁介质中的磁感应强度：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>B</mi><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><msub><mi>B</mi><mn>0</mn></msub><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{B}=\vec{B_0} + \vec{B&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1163em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6779em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span>		<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msub><mi>μ</mi><mi>r</mi></msub><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B = \mu_r B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <img src="E:\DeskTable\博客学习截图传输\image-20231018104714589.png" alt="image-20231018104714589" style="zoom: 25%;" /></p>
<table>
<thead>
<tr>
<th style="text-align:center">磁介质种类</th>
<th style="text-align:center">种类</th>
<th style="text-align:center">温度</th>
<th style="text-align:center">相对磁导率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>r</mi></msub><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu_r &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center">铋 汞 铜 氢(气)</td>
<td style="text-align:center">293K 293K 293K</td>
<td style="text-align:center">1-16.6×10-5 1-2.9×10 -5 1-1.0×10-5 1-3.89×10-5</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>r</mi></msub><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu_r &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center">氧（液） 氧（气） 铝 铂</td>
<td style="text-align:center">90K 293K 293K 293K</td>
<td style="text-align:center">1+769.9×10 -5 1+334.9×10-5 1+1.65×10-5 1+26.0×10-5</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>r</mi></msub><mo>&gt;</mo><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu_r &gt;&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center">铸钢 铸铁 硅钢 坡莫合金</td>
<td style="text-align:center"></td>
<td style="text-align:center">2.2×10 3（最大值） 4×10 2（最大值） 7×10 2（最大值） 1×105（最大值）</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>r</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu_r = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td>
<td style="text-align:center">汞 铌</td>
<td style="text-align:center">小于4.15K 小于9.26K</td>
<td style="text-align:center">0 0</td>
</tr>
</tbody>
</table>
<h3 id="18-1-2-分子磁矩"><a class="header-anchor" href="#18-1-2-分子磁矩"></a>18.1.2 分子磁矩</h3>
<ol>
<li>
<p>从经典物理角度进行分析</p>
<p>经典理论：组成分子或原子中的电子，不仅存在绕原子核的轨道运动，还存在自旋运动。这两种运动都能产生磁效应。把分子或原子看作一个整体，分子或原子中各电子对外产生磁效应的总和，可等效于一个圆电流，称为“分子电流” 。分子电流的磁矩称为“分子磁矩” 。</p>
<p>电子具有的两种磁矩:</p>
<ol>
<li>
<p>电子轨道磁矩: $\vec{p_m} = -\frac{e}{2m} \vec{L} $</p>
</li>
<li>
<p>电子自旋磁矩: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>p</mi><mi>s</mi></msub><mo>⃗</mo></mover><mo>=</mo><mo>−</mo><mfrac><mi>e</mi><mi>m</mi></mfrac><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{p_s} = - \frac{e}{m} \vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3113em;vertical-align:-0.345em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ol>
</li>
<li>
<p>分子附加磁矩:当磁介质处于外磁场中时，每个分子产生与<mark>外磁场方向相反</mark>的附加磁矩</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018110837487.png" alt="image-20231018110837487" style="zoom: 33%;" />
</li>
</ol>
<h3 id="18-1-3-顺磁质和抗磁质的磁化"><a class="header-anchor" href="#18-1-3-顺磁质和抗磁质的磁化"></a>18.1.3 顺磁质和抗磁质的磁化</h3>
<ol>
<li>
<p>顺磁质	存在分子的固有磁矩<br>
(严格来说,顺磁质也具有抗磁矩,但是比固有磁矩小得多,因而忽略不计)<br>
<img src="E:\DeskTable\博客学习截图传输\image-20231018111601536.png" alt="image-20231018111601536" style="zoom: 33%;" /></p>
</li>
<li>
<p>抗磁质<br>
无外磁场时分子磁矩为零 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>m</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\vec{m} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">m</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span><br>
加外磁场后分子产生附加磁矩（与外磁场方向相反）<br>
抗磁质内磁场 $B =  B_0 -B &lt; B_0 $</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018112211691.png" alt="image-20231018112211691" style="zoom:33%;" /> 
</li>
<li>
<p>磁化电流和磁化强度</p>
<p>介质磁化以后，由于分子磁矩的有序排列，其宏观效果是在介质表面出现环形电流，这种电流称为&quot;磁化电流( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">I_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> )&quot;</p>
<p>长直螺线管为例:</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018112509239.png" alt="image-20231018112509239" style="zoom: 50%;" />
</li>
</ol>
<h3 id="18-2-磁介质中的安培环路定理"><a class="header-anchor" href="#18-2-磁介质中的安培环路定理"></a>18-2 磁介质中的安培环路定理</h3>
<p>2.1 有磁介质存在时的高斯定理</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∮</mo><mi>S</mi></msub><mover accent="true"><mi>B</mi><mo>⃗</mo></mover><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>=</mo><msub><mo>∮</mo><mi>S</mi></msub><mo stretchy="false">(</mo><mover accent="true"><msub><mi>B</mi><mn>0</mn></msub><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\oint_S \vec{B} \cdot d\vec{S} = \oint_S(\vec{B_0}+\vec{B&#x27;}) \cdot d\vec{S} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3221em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3221em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2163em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6779em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<p>2.2 有磁介质存在时的安培环路定理</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∮</mo><mover accent="true"><mi>B</mi><mo>⃗</mo></mover><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mo>∑</mo><mi>I</mi><mo>+</mo><mo>∑</mo><msub><mi>I</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mo>∑</mo><mi>I</mi><mo>+</mo><msub><mo>∮</mo><mi>L</mi></msub><mover accent="true"><mi>M</mi><mo>⃗</mo></mover><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\oint \vec{B} \cdot d \vec{l} = \mu_0(\sum I + \sum I_s) = \mu_0(\sum I + \oint_L \vec{M}\cdot d \vec{l})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2724em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3221em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2274em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>则有: $\oint_L(\frac{\vec{B}}{\mu_0} - \vec{M})\cdot d \vec{l} = \sum I $</p>
<p>定义&quot;磁场强度&quot; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>H</mi><mo>⃗</mo></mover><mo>=</mo><mfrac><mover accent="true"><mi>B</mi><mo>⃗</mo></mover><msub><mi>μ</mi><mn>0</mn></msub></mfrac><mo>−</mo><mover accent="true"><mi>M</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{H} = \frac{\vec{B}}{\mu_0} - \vec{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5515em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0704em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span><span style="top:-2.9663em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9663em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span>		由 $\vec{M} = \chi_m \vec{H} $</p>
<p>则有: $\vec{H} = \frac{\vec{B}}{\mu_0} - \vec{M} = \frac{\vec{B}}{\mu_0} - \chi_m \vec{H} $</p>
<p>$ \vec{B} = \mu_0(1+\chi_m) \vec{H} = \mu_0 \mu_r \vec{H} $</p>
<p>$\mu_r = 1+\chi_m $ 称为磁介质的&quot;相对磁导率&quot;</p>
<p>$\mu = \mu_0 \mu_r $ 称为磁导率</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∮</mo><mi>L</mi></msub><mover accent="true"><mi>B</mi><mo>⃗</mo></mover><mo>⋅</mo><mi>d</mi><mover accent="true"><mi>l</mi><mo>⃗</mo></mover><mo>=</mo><mi>μ</mi><mo>∑</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\oint_L \vec{B} \cdot d \vec{l} = \mu \sum I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3221em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord mathnormal">d</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></p>
]]></content>
      <tags>
        <tag>大学公共基础课</tag>
      </tags>
  </entry>
  <entry>
    <title>uml复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/UML%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="UML期末复习"><a class="header-anchor" href="#UML期末复习"></a>UML期末复习</h1>
<h2 id="复习重点："><a class="header-anchor" href="#复习重点："></a>复习重点：</h2>
<h3 id="考试题型："><a class="header-anchor" href="#考试题型："></a>考试题型：</h3>
<ol>
<li>
<p>·选择题 十个题目 一个三分 总共三十分</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926631.jpg" alt="71848f12752245f42ab5ebce023e42c" style="zoom:50%;" />  
</li>
<li>
<p>名词解释 五题，一题两分，总共十分 建议英文作答</p>
<ul>
<li>OOD</li>
<li>OOP</li>
</ul>
</li>
<li>
<p>简答题 两题 共十五分</p>
</li>
<li>
<p>建模题 两个题目 十五分</p>
<ol>
<li>
<p>定义一些类，画一个类图</p>
</li>
<li>
<p>定义一个用例，写出用例文本</p>
<ol>
<li>
<p>例子 重点了解：</p>
<ol>
<li>ATM机</li>
<li>银行业务</li>
<li>火车订票</li>
</ol>
</li>
<li>
<p>用例图的基本元素有4种：用例、参与者、关系和系统边界。</p>
</li>
<li>
<p>用例描述：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926651.png" alt="image-20240606094247177"></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926917.webp" alt="img" style="zoom:50%;" /> 
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>综合分析设计题 四个小题目 总共三十分</p>
<ol>
<li>
<p>例子：</p>
<ol>
<li>智能家居</li>
<li>汽车租赁</li>
<li>dd车</li>
</ol>
</li>
<li>
<p>第一题：用例模型，用例文本；领域模型（不写方法）</p>
</li>
<li>
<p>第二题：</p>
</li>
<li>
<p>第三题：</p>
</li>
<li>
<p>第四题：采用某一种模式，对状态图或类图做一个设计的修正</p>
</li>
</ol>
</li>
</ol>
<h3 id="考点："><a class="header-anchor" href="#考点："></a>考点：</h3>
<p>名词解释和简答</p>
<p>设计模式 patern：是一套被已命名的、多数人知晓的、经过验证的经验总结而出的软件开发模式。设计模式提供了一种通用的设计方案，帮助开发者在面对常见的设计问题时，能够快速找到合适的解决办法。视频7.39</p>
<p>什么是uml：UML（Unified Modeling Language，统一建模语言）是一种用于描述、构建、文档化系统制品的可视化语言</p>
<p>UP Unified Process，统一过程：一种构造面向对象系统的迭代软件开发过程。</p>
<p>RUP（Rational Unified Process）是对统一过程的精细化，RUP采用迭代、增量和面向对象的方法，以提高软件开发的效率和质量。</p>
<p>OOA（Object-Oriented Analysis，面向对象分析）此过程把现实需求转换成领域模型问题，强调在问题领域内发现和描述对象或概念</p>
<p>OOD（Object-Oriented Design，面向对象设计）此过程将领域模型转化成逻辑框架，强调定义软件对象以及它们之间的协作方式以实现需求。</p>
<p>OOP（Object-Oriented Programming，面向对象编程）此过程根据OOD的制品进行编码以实现需求。在面向对象编程中，程序被组织为对象的集合，每个对象都包含数据（属性）和行为（方法）。</p>
<ol>
<li>
<p><strong>里氏替换原则（Liskov Substitution Principle，LSP）</strong>：</p>
<ol>
<li>子类必须能够替换成它们的基类是核心原则。</li>
<li>子类型必须能够替换其基类型的任何地方，并且不会导致意外的行为。换句话说，任何基类的实例都应该可以被其子类的实例替换，而程序的行为不会受到影响。</li>
<li>这确保了基类和子类之间的一致性和互换性。</li>
</ol>
</li>
<li>
<p><strong>开闭原则（Open/Closed Principle，OCP）</strong>：</p>
<ol>
<li>软件实体（类、模块、函数等）应该对扩展是开放的，对修改是封闭的。这意味着应该通过扩展现有代码来添加新功能，而不是修改现有代码。</li>
</ol>
</li>
<li>
<p>**GRASP（General Responsibility Assignment Software Patterns，通用责任分配软件模式）**是一组设计模式，旨在帮助开发人员在面向对象设计过程中分配责任和定义类的行为。17章  P199 和 25章 P300</p>
<ol>
<li>九大类GRASP设计模型</li>
</ol>
<ul>
<li><strong>创建者（Creator）</strong>：
<ul>
<li>创建者模式帮助确定哪个类负责创建某类的新实例。将创建责任委派给称为具体工厂或抽象工厂的辅助类。创建者模式推荐将创建实例的责任委派给具有相关信息的类，以避免耦合度过高。</li>
<li>相关的模式或原则：
<ul>
<li>低耦合</li>
<li>具体工厂和抽象工厂</li>
</ul>
</li>
</ul>
</li>
<li><strong>信息专家（Information Expert）/ 专家（Expert）</strong>：重要
<ul>
<li>把责任分配给具有实现该责任所必须的信息的对象</li>
</ul>
</li>
<li><strong>低耦合（Low Coupling）</strong>：重要
<ul>
<li>低耦合模式帮助减少类之间的依赖关系。通过将依赖关系限制在少数必要的类之间，可以使系统更易于维护和修改。</li>
</ul>
</li>
<li><strong>高内聚（High Cohesion）</strong>：重要
<ul>
<li>高内聚模式帮助确保类的成员之间存在良好的关联，以便于实现类的目标。高内聚的类更易于理解和维护。</li>
</ul>
</li>
<li><strong>控制器（Controller）</strong>：重要
<ul>
<li>控制器模式帮助<strong>确定哪个类负责处理用户请求并调用适当的操作</strong>。控制器通常充当系统的中心协调者。</li>
</ul>
</li>
<li><strong>多态（Polymorphism）</strong>：
<ul>
<li>多态模式允许对象对同一消息作出不同的响应，提高了代码的灵活性和可扩展性。</li>
</ul>
</li>
<li><strong>纯虚构（Pure Fabrication）</strong>：
<ul>
<li>纯虚构模式帮助确定是否需要创建一个新的类来实现特定的功能，即使在现实世界中并不存在该类的概念。</li>
</ul>
</li>
<li><strong>间接性（Indirection</strong>：重要</li>
<li><strong>防止变异（protected variations）</strong>：</li>
<li>参见：开闭原则</li>
<li>不和陌生人说话</li>
</ul>
</li>
<li>
<p>GoF设计模式，一组设计模式，由一本书中提出，分为以下三大类</p>
<ul>
<li>
<p><strong>工厂模式（Factory Pattern）</strong>：抽象工厂模式的简化</p>
</li>
<li>
<p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：解决如何创造实现相同接口的一族相关的类 可以定义一个工厂接口 为每一族要创建的事物定义一个具体工厂类</p>
</li>
<li>
<p><strong>单例模式（Singleton Pattern）</strong>：解决单实例类的对象全局可见性和单点访问 可以对类定义静态方法以返回单实例 类似私有变量通过定义静态方法返回变量值</p>
</li>
<li>
<p><strong>适配器模式（Adapter Pattern）</strong>：解决不相容的接口问题，为具有不同接口的类似构件提供稳定接口</p>
<p>和哪些其他模式有关系：</p>
<ol>
<li>
<p>隐藏外部系统的资源适配器可以视为外观对象，即与外观模式相关，资源适配器使用单一对象封装了对子系统或系统的访问，这与外观模式的本质是一致的。</p>
<p>适配器可以用来适配外观模式中不同的子系统接口，从而使得外观模式可以为客户端提供一个简化的统一接口。</p>
</li>
<li>
<p>适配器与代理模式，适配器模式有时可以看作是代理模式的特殊形式，特别是当适配器用来代理一个目标对象，并将其接口适配为客户端期望的接口时。</p>
</li>
<li>
<p>适配器与策略模式，因为某些策略方案的接口可能并不适配与</p>
</li>
<li>
<p>在组合模式中，适配器可以用来统一处理叶子节点和容器节点的接口，使得客户端可以一致地对待组合中的所有对象。</p>
</li>
<li>
<p>支持防止变异</p>
</li>
</ol>
</li>
<li>
<p><strong>组合模式（Composite Pattern）</strong>：</p>
</li>
<li>
<p><strong>外观模式（Facade Pattern）</strong>：解决对一组完全不同的实现或接口需要公共统一接口的问题 可以使用外观对象封装子系统 外观对象提供唯一和统一的接口 并负责与子系统构件进行协作</p>
</li>
<li>
<p><strong>代理模式（Proxy Pattern）</strong>：</p>
</li>
<li>
<p><strong>观察者模式（Observer Pattern）</strong>：定义“订阅者”或“监听者”接口。订阅者实现接口，发布者可以动态关注某时间的订阅者，并在事件发生时通知它们</p>
</li>
<li>
<p><strong>状态模式（State Pattern）</strong>：状态模式跟类图和状态图有什么关系</p>
<ol>
<li>状态图允许一个对象内部状态发生改变的时候，改变它的行为能力，一个对象的状态发生改变，相应的行为发生改变，</li>
</ol>
</li>
<li>
<p>**策略模式（Strategy Pattern） **：重点</p>
<p>解决设计变化但相关的算法或政策 可以在单独的类中分别定义每种算法或政策策略 差不多就是多态+细化方法和类</p>
</li>
</ul>
</li>
<li>
<p><strong>Subsystem和package的区别是什么?</strong>：</p>
<p><strong>答案:</strong></p>
<ol>
<li>Subsystem具有行为，package不提供行为</li>
<li>Subsystem完全封装了内部实现，package没有完全封装。</li>
<li>Subsystem很容易被替换，package不一定能够容易的被替换。</li>
</ol>
</li>
</ol>
<h1 id="UML内容复习"><a class="header-anchor" href="#UML内容复习"></a>UML内容复习</h1>
<h2 id="课本的知识迭代方式："><a class="header-anchor" href="#课本的知识迭代方式："></a>课本的知识迭代方式：</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926597.png" alt="image-20240616094443039"></p>
<h2 id="什么是UML"><a class="header-anchor" href="#什么是UML"></a>什么是UML</h2>
<p>UML全称为：Unified Modeling Language，统一建模语言，是用来描述、构建和文档化系统制品的可视化语言。</p>
<h2 id="UML的三种透视图"><a class="header-anchor" href="#UML的三种透视图"></a>UML的三种透视图</h2>
<ol>
<li>概念透视图 Conceptual perspective</li>
<li>规格说明透视图 Specification perspective</li>
<li>实现透视图 Implementation perspective</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926696.png" alt="image-20240616090655810"></li>
</ol>
<h3 id="不同视图中“类”的含义"><a class="header-anchor" href="#不同视图中“类”的含义"></a>不同视图中“类”的含义</h3>
<p>Conceptual perspective 中称之为 domain concept 或 conceptual class，领域模型表示的就是conceptual perspective。</p>
<ol>
<li>Conceptual class：在概念透视图中使用。UP领域明显中包含概念类</li>
<li>Software class：表示软件构件在规格说明或实现透视图中的类</li>
<li>Implementation class：特定OO语言中的类</li>
</ol>
<h2 id="可视化建模的优点"><a class="header-anchor" href="#可视化建模的优点"></a>可视化建模的优点</h2>
<ol>
<li>提高沟通和理解</li>
<li>支持系统分析和设计</li>
<li>提高开发效率和质量</li>
<li>支持维护和拓展</li>
</ol>
<h2 id="OO"><a class="header-anchor" href="#OO"></a>OO</h2>
<h3 id="OO-面向对象"><a class="header-anchor" href="#OO-面向对象"></a>OO 面向对象</h3>
<p>指的是“对象”概念的编程范式，对象可以包含属性和方法，对象是类的实例，类定义了属性和方法</p>
<h3 id="OOA-面向对象分析analysis：专注于问题领域"><a class="header-anchor" href="#OOA-面向对象分析analysis：专注于问题领域"></a>OOA 面向对象分析analysis：专注于问题领域</h3>
<p>强调在问题领域内发现和描述对象（或概念）</p>
<h3 id="OOD-面向对象设计：专注于软件实现的分析"><a class="header-anchor" href="#OOD-面向对象设计：专注于软件实现的分析"></a>OOD 面向对象设计：专注于软件实现的分析</h3>
<p>强调定义软件对象以及它们如何协作以实现需求</p>
<h3 id="OOP-面向对象编程：使用对象和类将OOD的制品转化为可执行的代码"><a class="header-anchor" href="#OOP-面向对象编程：使用对象和类将OOD的制品转化为可执行的代码"></a>OOP 面向对象编程：使用对象和类将OOD的制品转化为可执行的代码</h3>
<h2 id="RUP-rational-unified-process-统一过程"><a class="header-anchor" href="#RUP-rational-unified-process-统一过程"></a>RUP rational unified process 统一过程</h2>
<h3 id="什么是UP"><a class="header-anchor" href="#什么是UP"></a>什么是UP</h3>
<p>UP是一种构造面向对象系统的迭代软件开发过程。最常用的是RUP</p>
<blockquote>
<p>重构 refactoring	持续集成 continuous integration</p>
</blockquote>
<p>强调<strong>迭代和增量式开发 iterative and incremental development</strong>，旨在通过一系列与定义的阶段来管理软件项目的各个方面</p>
<p>功能进行迭代升级，系统规模进行增量式增长</p>
<p>迭代开发需要得到快速反馈：来自用户、开发人员和测试的反馈</p>
<h3 id="UP项目的四个阶段："><a class="header-anchor" href="#UP项目的四个阶段："></a>UP项目的四个阶段：</h3>
<ol>
<li>初始阶段 inception phase</li>
<li>细化迭代 elaboration phase</li>
<li>构造阶段 construction phase</li>
<li>移交阶段 transition phase</li>
</ol>
<h3 id="主要特点："><a class="header-anchor" href="#主要特点："></a>主要特点：</h3>
<blockquote>
<p>discipline 科目——知识的分支	artifact 制品</p>
</blockquote>
<h2 id="敏捷开发-agile-development"><a class="header-anchor" href="#敏捷开发-agile-development"></a>敏捷开发 agile development</h2>
<p>应用时间定量的迭代和进化式开发，使用自适应计划，倡导增量交付并包含其他提倡敏捷性的价值和实践</p>
<h2 id="用例模型："><a class="header-anchor" href="#用例模型："></a>用例模型：</h2>
<p>use case model</p>
<p>撰写一个用例文本需要的东西：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011926626.png" alt="image-20240606142728372"></p>
<h2 id="UML的一些基本概念"><a class="header-anchor" href="#UML的一些基本概念"></a>UML的一些基本概念</h2>
<h3 id="事物"><a class="header-anchor" href="#事物"></a>事物</h3>
<h4 id="结构事物"><a class="header-anchor" href="#结构事物"></a>结构事物</h4>
<ol>
<li>类</li>
<li>接口</li>
<li>协作</li>
<li>用例</li>
<li>主动类</li>
<li>构件</li>
<li>节点</li>
</ol>
<h4 id="行为事物"><a class="header-anchor" href="#行为事物"></a>行为事物</h4>
<ol>
<li>交互</li>
<li>状态机</li>
<li>活动</li>
</ol>
<h4 id="分组事物"><a class="header-anchor" href="#分组事物"></a>分组事物</h4>
<ol>
<li>包</li>
</ol>
<h4 id="注销事物"><a class="header-anchor" href="#注销事物"></a>注销事物</h4>
<ol>
<li>注解</li>
</ol>
<p>用例就是需求，用例需要包含所有涉众关注点的事物</p>
<h2 id="九大种表示图"><a class="header-anchor" href="#九大种表示图"></a>九大种表示图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: UML Graph</span><br><span class="line">---</span><br><span class="line">classDiagram</span><br><span class="line">    UML图 &lt;|-- 结构图</span><br><span class="line">    UML图 &lt;|-- 行为图</span><br><span class="line">    </span><br><span class="line">    结构图 &lt;|-- 类图</span><br><span class="line">    结构图 &lt;|-- 对象图</span><br><span class="line">    结构图 &lt;|-- 组件图</span><br><span class="line">    结构图 &lt;|-- 部署图</span><br><span class="line">    </span><br><span class="line">    行为图 &lt;|-- 交互图</span><br><span class="line">    行为图 &lt;|-- 活动图</span><br><span class="line">    行为图 &lt;|-- 状态图</span><br><span class="line">    行为图 &lt;|-- 用例图</span><br><span class="line">    </span><br><span class="line">    交互图 &lt;|-- 顺序图</span><br><span class="line">    交互图 &lt;|-- 时序图</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="元模型"><a class="header-anchor" href="#元模型"></a>元模型</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249535.png" alt="image-20240607205850660"></p>
<h2 id="用例图"><a class="header-anchor" href="#用例图"></a>用例图</h2>
<ol>
<li>**用例图的组成元素：**参与者，参与者间的关系组成，用例，系统边界</li>
<li><strong>参与者 actors：</strong> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249617.png" alt="image-20240606135027508">
<ol>
<li>主要primary参与者：寻求服务的，首先做出动作</li>
<li>协助supporting参与者：提供服务的，响应主要参与者的动作，</li>
<li>幕后offstage参与者：不重要</li>
</ol>
</li>
<li><strong>用例 use cases：</strong>
<ul>
<li>一个椭圆➕用例名称<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249906.png" alt="image-20240606135116865"></li>
<li>用例就是一组相关的成功和失败场景的集合</li>
<li>场景 scenario：参与者和系统间的活动和交互，也可以叫做用例实例 use case instance</li>
</ul>
</li>
<li>**系统边界 system Board：**一个方形➕系统名称<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011249274.png" alt="image-20240606135148086"></li>
<li><strong>参与者间的关系 relationships：</strong>
<ol>
<li>关联：
<ol>
<li>表示形式：一根<strong>实线</strong>连在参与者和用例中间</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250788.png" alt="image-20240606135244204"></li>
</ol>
</li>
<li>泛化：
<ol>
<li>表示一个用例（子用例）继承自另一个用例（父用例），子用例继承了父用例的所有属性和行为，并可以增加新的行为或修改继承的行为。</li>
<li>表示形式：用一根带有空心三角形的实线连接</li>
<li>其实就是一种继承关系，子用例包含有父用例的功能，但是又可以有自己的特殊功能</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250687.png" alt="image-20240606135413057"></li>
</ol>
</li>
<li>包含：
<ol>
<li>表示形式：一根带箭头的虚线，同时虚线上写上《include》的标签</li>
<li>包含用例一定会执行，即在录入成绩时一定会执行保存成绩，但保存成绩不一定会启动录入成绩</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250911.png" alt="image-20240606135558542"></li>
</ol>
</li>
<li>拓展：
<ol>
<li>拓展关系用于描述一种可选的、条件性的行为。</li>
<li>表示形式：一根带箭头的虚线，同时虚线上写上《extend》的标签</li>
<li>拓展用例需要满足某种条件才会执行，如忘记密码功能是在登录时满足了条件“用户不记得密码”才会执行的</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250371.png" alt="image-20240606140037670"></li>
</ol>
</li>
</ol>
</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250529.png" alt="image-20240606140228153">
<ol>
<li>以上图中，教师和“录入成绩、修改成绩、删除成绩、查询成绩、登录”几个用例是关联关系，即教师可以进入这几个场景当中；</li>
<li>录入成绩、修改成绩 和 保存成绩时包含关系，因为每次录入成绩和修改成绩最终都需要将录入结果和修改结果保存，否则该操作无意义，则保存成绩一定会执行</li>
<li>登录 和 微信登录、手机登录 是泛化关系，就像父类和子类一样，子类继承有父类的特性，即无论是微信登录还是手机登录，本质都是一种登录操作，但是根据其具体场景又会有各自的特性</li>
<li>登录 和 忘记密码 是拓展关系，忘记密码是登录的拓展，但是忘记密码操作只有在满足“用户忘记了密码”这一条件时才会执行，则拓展不是一定执行的。</li>
</ol>
</li>
</ol>
<h3 id="用例种类："><a class="header-anchor" href="#用例种类："></a>用例种类：</h3>
<ol>
<li>具体用例：由参与者发起，完成了参与者所期望的完整行为</li>
<li>抽象用例：无法单独存在，必须作为其他用例的子功能用例</li>
<li>基础用例：包含有其他用例的用例/被其他用例拓展或泛化的用例</li>
<li>附加用例：被其他用例包含的、拓展/泛化了其他用例的用例</li>
</ol>
<h2 id="类图"><a class="header-anchor" href="#类图"></a>类图</h2>
<p>描述系统中的类，以及各个类之间的静态关系。</p>
<h3 id="组成元素"><a class="header-anchor" href="#组成元素"></a>组成元素</h3>
<ul>
<li>
<p>类：</p>
<ul>
<li>
<p>名称 必须有</p>
</li>
<li>
<p>属性 可见性 + 属性名称</p>
</li>
<li>
<p>操作</p>
</li>
<li>
<p>关键字</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250405.png" alt="image-20240607211351972"></p>
</li>
<li>
<p>构造型</p>
<p>也使用《》表示，如《stereotype》</p>
</li>
<li>
<p>特性：元素特征已命名的值</p>
</li>
</ul>
</li>
</ul>
<h3 id="类间的关系："><a class="header-anchor" href="#类间的关系："></a>类间的关系：</h3>
<h4 id="泛化（Generalization）"><a class="header-anchor" href="#泛化（Generalization）"></a>泛化（Generalization）</h4>
<ol>
<li>一种<strong>继承</strong>关系，表示一般与特殊的关系，<strong>指定了子类如何继承父类</strong>的所有特征和行为。</li>
<li>从特型指向泛型</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250156.png" alt="image-20240616112009375"></li>
</ol>
<h4 id="实现（Realization）"><a class="header-anchor" href="#实现（Realization）"></a>实现（Realization）</h4>
<ol>
<li>实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250167.png" alt="image-20240616112041542"></li>
</ol>
<h4 id="关联（Association）"><a class="header-anchor" href="#关联（Association）"></a>关联（Association）</h4>
<ol>
<li>
<p>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法；</p>
<ol>
<li>
<p>关联可以是双向的，也可以是单向的。</p>
<p>双向的关联可以有两个箭头或者没有箭头</p>
<p>单向的关联有一个箭头。</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250080.png" alt="image-20240616112056664"></p>
</li>
<li>
<p>指的是<code>类与类之间的联接</code>，<strong><code>它使一个类知道另一个类的属性和方法（实例变量体现）</code></strong>。A类依赖于B对象,并且<code>把B作为A的一个成员变量</code>, 则A和B存在关联关系.</p>
</li>
</ol>
</li>
</ol>
<h5 id="一对一"><a class="header-anchor" href="#一对一"></a>一对一</h5>
<p>一个A对象属于B对象，一个B对象属于A对象</p>
<h5 id="单向的一对多"><a class="header-anchor" href="#单向的一对多"></a>单向的一对多</h5>
<p>A类的一个实例可以关联到B类的多个实例，但是反过来不成立</p>
<p>例如：学校和学生，一个学校可以有很多个学生实例，但是一个学生只能有一个学校实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+-----------------+            +-----------------+</span><br><span class="line">|      School     |<span class="number">1</span>--------&gt;* |     Student     |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| - name: String  |            | - name: String  |</span><br><span class="line">| - address: String |          | - age: <span class="type">int</span>      |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| + getStudents() |            +-----------------+</span><br><span class="line">+-----------------+            </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**“1”**表示“学校”一方的一个实例。</p>
<p>**“*”**表示“学生”一方的多个实例。</p>
<h5 id="单向的多对一"><a class="header-anchor" href="#单向的多对一"></a>单向的多对一</h5>
<p>A类的多个实例可以关联到B类的一个实例，当反过来就不成立了</p>
<p>依旧是学生和学校的例子，只不过这一次箭头由学生指向学校</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+-----------------+            +-----------------+</span><br><span class="line">|     Student     |*--------&gt;<span class="number">1</span> |      School     |</span><br><span class="line">+-----------------+            +-----------------+</span><br><span class="line">| - name: String  |            | - name: String  |</span><br><span class="line">| - age: <span class="type">int</span>      |            | - address: String |</span><br><span class="line">| - school: School|            +-----------------+</span><br><span class="line">+-----------------+            </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="双向一对多、多对一"><a class="header-anchor" href="#双向一对多、多对一"></a>双向一对多、多对一</h5>
<ol>
<li>
<p>类关联，即几个类之间含有关联关系</p>
</li>
<li>
<p>关联类</p>
</li>
</ol>
<h4 id="聚合（Aggregation）"><a class="header-anchor" href="#聚合（Aggregation）"></a>聚合（Aggregation）</h4>
<ol>
<li>聚合是整体与部分的关系，且<strong>部分可以离开整体而单独存在</strong>。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</li>
<li>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250823.png" alt="image-20240616113555303"></li>
</ol>
<h4 id="组合（Composition）"><a class="header-anchor" href="#组合（Composition）"></a>组合（Composition）</h4>
<ol>
<li>组合是整体与部分的关系，但<strong>部分不能离开整体而单独存在</strong>。如公司和部门是整体和部分的关系，没有公司就不存在部门</li>
<li>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250857.png" alt="image-20240616113538539"></li>
</ol>
<h4 id="依赖（Dependency）"><a class="header-anchor" href="#依赖（Dependency）"></a>依赖（Dependency）</h4>
<ol>
<li>依赖是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖</li>
<li>依赖关系：指的是类与类之间的联接。依赖关系表示<code>一个类依赖于另一个类的定义</code>。一般而言，依赖关系在Java语言中体现为<code>成员变量、局域变量、方法的形参、方法返回值</code>，或者对<strong>静态方法的调用。</strong></li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250620.png" alt="image-20240616113641726"></li>
</ol>
<h2 id="对象图"><a class="header-anchor" href="#对象图"></a>对象图</h2>
<p>UML对象图只能在系统某一时间段存在</p>
<p>特定的时刻捕捉到静态的系统视图。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250396.png" alt="image-20240607203205694"></p>
<p>在名称处格式为：对象名称:类型</p>
<p>下面则为具体的属性的值</p>
<h2 id="顺序图（也称为时序图-序列图）"><a class="header-anchor" href="#顺序图（也称为时序图-序列图）"></a>顺序图（也称为时序图/序列图）</h2>
<h3 id="组成元素："><a class="header-anchor" href="#组成元素："></a>组成元素：</h3>
<ol>
<li>
<p>对象或参与者 Objects or Participants</p>
<ol>
<li>在图的顶部，矩形框表示</li>
</ol>
</li>
<li>
<p>生命线 lifeline</p>
<ol>
<li>从对象或参与者延伸出来的垂直<strong>虚线</strong>，表示对象在时间上的存在</li>
</ol>
</li>
<li>
<p>激活：在生命线上覆盖一段矩形长条，代表对象处于活动状态</p>
<ol>
<li>一条消息代表的事件激活了一个对象，直到事件结束再次进入休眠</li>
</ol>
</li>
<li>
<p>消息 Message</p>
<ol>
<li>对象间传递的消息
<ol>
<li>
<p>同步消息用实线实心三角箭头表示</p>
<p>（注意看激活）消息发生者会阻塞以等待返回消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250296.png" alt="image-20240607203756699"></p>
</li>
<li>
<p>异步消息用实线普通箭头表示 （注意看激活）</p>
<p>消息发送者不会阻塞，继续执行自己的事情，不在意返回消息</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250498.png" alt="image-20240607203805072"></p>
</li>
<li>
<p>返回消息用虚线普通箭头表示</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250064.png" alt="image-20240607204139502"></p>
</li>
<li>
<p>需要强调消息发送时间（消息发送时间不可忽略）的：将消息先向下走表示</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250103.png" alt="image-20240607204250317"></p>
</li>
<li>
<p>重入消息</p>
<p>相当于一种递归</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250653.png" alt="image-20240607204435728"></p>
</li>
<li>
<p>无触发和无接受消息</p>
<p>和系统外有关的消息，使用无触发和无接受</p>
</li>
<li>
<p>对象销毁</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250435.png" alt="image-20240607204811135"></p>
</li>
<li>
<p>执行控制逻辑：</p>
<ol>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250590.png" alt="image-20240607204857372"></p>
</li>
<li>
<p>条件分支：一个带有虚线的方框</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250889.png" alt="image-20240607205002423"></p>
</li>
<li>
<p>可选项：</p>
</li>
<li>
<p>循环：loop框和break框（只执行一次）</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250648.png" alt="image-20240607205052354"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>对象的创建</p>
</li>
</ol>
<h2 id="活动图"><a class="header-anchor" href="#活动图"></a>活动图</h2>
<p>与流程图几乎一模一样，活动图是流程图的一个扩充</p>
<p>有助于使工作流和业务过程可视化的图</p>
<p>是状态图的一种特殊形式</p>
<h4 id="组成元素-v2"><a class="header-anchor" href="#组成元素-v2"></a>组成元素</h4>
<ul>
<li>泳道：与执行对象挂钩，一个泳道代表一种执行对象
<ul>
<li>清楚明了地列出了流程中有哪些参与者</li>
<li>每一类参与者的职责划分明确</li>
</ul>
</li>
<li>开始节点</li>
<li>结束节点</li>
<li>事件:
<ul>
<li>矩形带三角<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250994.png" alt="image-20240607200419814"> 发送事件</li>
<li>矩形缺三角<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250365.png" alt="image-20240607200443625"> 接收事件</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250218.png" alt="image-20240607200512938"> 时间事件</li>
</ul>
</li>
<li>分叉和汇合</li>
<li>带箭头的实线：代表控制权的转移</li>
<li>分支和合并</li>
<li>事件机制</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011250962.png" alt="image-20240607200302461"></li>
</ul>
<h2 id="状态图"><a class="header-anchor" href="#状态图"></a>状态图</h2>
<h2 id="协作图"><a class="header-anchor" href="#协作图"></a>协作图</h2>
<p>显示对象间的动态合作关系。</p>
<h2 id="组件图"><a class="header-anchor" href="#组件图"></a>组件图</h2>
<p>组件和对象</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251129.png" alt="image-20240607205242219"></p>
<p>组件图 = 构件（Component）+接口（Interface）+关系（Relationship）+端口（Port）+连接器（Connector）。</p>
<p>组件图不描述该系统的功能，但它描述了使用这些功能的组件。</p>
<p>表示系统中构件与构件之间，类或接口与构件之间的关系图。</p>
<p>表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系。</p>
<p>由组件、接口和组件之间联系构成，描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。</p>
<h2 id="配置图"><a class="header-anchor" href="#配置图"></a>配置图</h2>
<p>用来建模系统的物理部署。</p>
<p>部署图由节点以及节点之间的关系组成。</p>
<h2 id="模型"><a class="header-anchor" href="#模型"></a>模型</h2>
<h3 id="领域模型"><a class="header-anchor" href="#领域模型"></a>领域模型</h3>
<h2 id="GRASP设计模式"><a class="header-anchor" href="#GRASP设计模式"></a>GRASP设计模式</h2>
<p>本质是一类OO设计原则</p>
<h3 id="创建者模式-Creator-Mode"><a class="header-anchor" href="#创建者模式-Creator-Mode"></a>创建者模式 Creator Mode</h3>
<ul>
<li>可以将创建 类A 实例的职责分配给 类B 的条件：
<ul>
<li>B 和 A 的关系是包含或组合</li>
<li>B记录A</li>
<li>B 使用 A 很多</li>
<li>B 具有可以初始化 A 的数据</li>
</ul>
</li>
</ul>
<h3 id="专家模式-Expert-Mode"><a class="header-anchor" href="#专家模式-Expert-Mode"></a>专家模式 Expert Mode</h3>
<p>给定键值，谁可以知道 类A 对象的相关信息</p>
<p>决定如何分配职责（给方法、字段等）的原则。</p>
<p>分配职责的原则是信息专家，即把职责分配 给具有完成此职责所需信息的 对象</p>
<h3 id="低耦合"><a class="header-anchor" href="#低耦合"></a>低耦合</h3>
<p>耦合：元素和其他元素的连接、感知以及依赖的程度的度量</p>
<p>实现低耦合的一个目的就是：减少 B类 因为 A类 发生变化而发生的变化</p>
<p>注：高耦合本身不是问题，出问题的是高耦合情况下，当耦合对象当中存在不稳定元素时，会影响整个系统</p>
<h3 id="控制器"><a class="header-anchor" href="#控制器"></a>控制器</h3>
<p>控制器对象是非用户界面，负责接收或处理系统事件的对象。</p>
<p>控制器模式的主要目的是<strong>处理系统事件</strong>，即用户的输入和外部系统的请求。控制器模式通过一个中介对象来协调这些事件，使得系统的其他部分能够专注于各自的职责。</p>
<p><strong>应用场景</strong>： 控制器模式通常在以下情况下使用：</p>
<ul>
<li>当系统接收到外部输入（如用户交互、API请求）时，需要一个对象来处理这些输入并协调系统的响应。</li>
<li>通过控制器对象来封装系统的入口点，确保系统的核心逻辑与输入处理分离。</li>
</ul>
<p>问题：哪个对象要处理输入系统事件？</p>
<p>解决方案：应该由用例控制器来处理用例所有的系统事件，也可以用在一个以上的用例。例如“创建用户”或“删除用户”的用例，可以用同一个类别，称为UserController，而不是用二个个别的用例控制器。</p>
<p>控制器需将需其他对象来完成的工作给对应对象。</p>
<h3 id="高内聚"><a class="header-anchor" href="#高内聚"></a>高内聚</h3>
<h4 id="特征"><a class="header-anchor" href="#特征"></a>特征</h4>
<p><strong>职责单一</strong>：</p>
<ul>
<li>一个高内聚的模块或类通常只负责一个主要功能或职责。这意味着它的所有方法和属性都围绕这个主要功能展开。</li>
</ul>
<p><strong>相关性强</strong>：</p>
<ul>
<li>模块或类内部的所有元素（如属性和方法）都应该高度相关，共同实现一个具体的功能。例如，订单类的所有方法和属性都与订单管理相关。</li>
</ul>
<p><strong>易于维护</strong>：</p>
<p><strong>低耦合</strong>：</p>
<h4 id="高内聚的优点"><a class="header-anchor" href="#高内聚的优点"></a>高内聚的优点</h4>
<ol>
<li>提高代码的可维护性、</li>
<li>可读性和</li>
<li>可重用性</li>
<li>减少复杂性。</li>
</ol>
<h3 id="多态"><a class="header-anchor" href="#多态"></a>多态</h3>
<p>当相关选择和行为随类型不同时，多态的操作可以相应的改变职责的分配</p>
<h3 id="纯虚构"><a class="header-anchor" href="#纯虚构"></a>纯虚构</h3>
<p>在现实领域不存在的的，但为了将某些特定功能抽离出来所设计的纯虚构的臆想的类，不存在领域模型中，只是为了方便开放而捏造的概念。</p>
<h4 id="纯虚构的对象可以分为两类："><a class="header-anchor" href="#纯虚构的对象可以分为两类："></a>纯虚构的对象可以分为两类：</h4>
<ul>
<li>通过表示解析 representational decomposition 所产生的选择：因为在系统的领域模型当中就已经明确有 ，所以进行了类对象的创建
<ul>
<li>侧重于系统的静态结构，通过分解系统来展示其组成部分以及这些部分之间的关系。</li>
<li>关注的是系统的各个组成部分如何组织在一起，形成一个完整的系统</li>
</ul>
</li>
<li>通过行为解析 behavioral decomposition 所产生的选择：因为在实现系统的过程中需要某一个类，但是该类的存在在现实领域模型中找不到依据，只是为了方便开发，将一系列行为或方法组织起来（十分类似于java的工具类）
<ul>
<li>侧重于系统的动态行为，通过分解系统的操作来展示其工作方式和交互过程。</li>
<li>关注系统的操作、事件和交互模式。</li>
</ul>
</li>
</ul>
<h3 id="间接性"><a class="header-anchor" href="#间接性"></a>间接性</h3>
<p>为了避免多个事物间直接耦合，将职责分配给中介对象，使其作为其他构件或服务之间的媒介。引入一层中间性和多态来降低系统组件之间的耦合度，增加系统的灵活性和可扩展性。</p>
<h3 id="防止变异-PV"><a class="header-anchor" href="#防止变异-PV"></a>防止变异 PV</h3>
<p>数据封装、接口、多态、间接性和标准化</p>
<p>Liskov替换原则 LSP</p>
<p>don’t talk to strangers ：不要历经远距离的对象结构路径去向远距离的间接对象发送信息，该规则的应用可以防止因结构变异而产生的变异</p>
<p>修改设计，使每个类只与其直接关联的对象交互。</p>
<h4 id="信息隐藏-information-hiding"><a class="header-anchor" href="#信息隐藏-information-hiding"></a>信息隐藏 information hiding</h4>
<p>等价于PV模式</p>
<h4 id="开放-封闭原则-Open-closed-Principle-OCP"><a class="header-anchor" href="#开放-封闭原则-Open-closed-Principle-OCP"></a>开放-封闭原则 Open-closed Principle OCP</h4>
<p>基本等价于PV模式和信息隐藏</p>
<p>“对xx封闭” 意思是 X变化时不会对客户产生影响。</p>
<h2 id="GoF设计模式"><a class="header-anchor" href="#GoF设计模式"></a>GoF设计模式</h2>
<h3 id="适配器"><a class="header-anchor" href="#适配器"></a>适配器</h3>
<blockquote>
<p>支持防止变异，因为adapter应用了接口和多态polymorphism的间接对象</p>
</blockquote>
<p>一种结构性设计模式，将类的接口转换成客户希望的另一个接口。可以使得原本由于接口不兼容不能一起工作的类可以一起工作</p>
<h4 id="使用场景"><a class="header-anchor" href="#使用场景"></a>使用场景</h4>
<ul>
<li>
<p><strong>接口不兼容</strong>：当你希望使用一个已经存在的类，但它的接口并不符合你的需求。</p>
</li>
<li>
<p><strong>复用已有的类</strong>：在不改变已有代码的情况下，使用新的接口复用已有的类。</p>
</li>
<li>
<p><strong>适配不同的接口</strong>：使得两个不兼容的接口可以一起工作。</p>
</li>
</ul>
<h4 id="组成部分"><a class="header-anchor" href="#组成部分"></a>组成部分</h4>
<ul>
<li>
<p>目的接口 Target Interface</p>
</li>
<li>
<p>现有接口 Adaptee 需要被适配的接口</p>
</li>
<li>
<p>适配器 Adapter 一个实现了目标接口的类，包含现有接口的实例，并在目标接口的方法中调用现有接口的方法</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251683.png" alt="image-20240608174207705"></p>
</li>
</ul>
<h3 id="抽象工厂模式-Abstract-Factory"><a class="header-anchor" href="#抽象工厂模式-Abstract-Factory"></a>抽象工厂模式 Abstract Factory</h3>
<p>对于抽象工厂的一种简化就是 简单/具体工厂。</p>
<p>在上面适配器模式的基础上，会引申出一个问题，由谁来创建这些适配器，显然，由领域对象来创建是不符合领域对象的职责的，因此需要找一个同样是纯虚构的概念类来创建这些适配器，并由领域对象来调用这个概念类以达到使用适配器的目的。</p>
<p>这个纯虚构的概念类就是“工厂”，也就是形成了所谓的工厂模式</p>
<h3 id="单例模式-Singleton"><a class="header-anchor" href="#单例模式-Singleton"></a>单例模式 Singleton</h3>
<blockquote>
<p>通常用于工厂或外观模式</p>
</blockquote>
<p>细想工厂模式，适配器由工厂来创建，但是谁来创建工厂，又如何使用工厂，总不能套娃地创建一个创建工厂的工厂吧。</p>
<p>在这里需注意，我们使用工厂的目的是为了方便调度适配器同时将创建适配器的职责分离出来，意味着在整个项目当中：</p>
<ol>
<li>我们其实只需要该工厂类的<strong>一个实例</strong>；</li>
<li>同时这个实例是不由其他领域内的类创建的</li>
<li>且这个实例在整个项目的任意位置都可以被访问和使用。</li>
</ol>
<p>由以上的要求实践出了单例模式</p>
<p>即在工厂类中定义一个该工厂类的静态实例，并在工厂内进行初始化。</p>
<p>关键思想是：在类中定义<strong>静态方法getInstance</strong>，提供工厂类的唯一实例。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251071.png" alt="image-20240616104214737"></p>
<p>下划线代表静态属性/方法</p>
<p>在类名处写上1表示只可以创建一个实例</p>
<p>对于单例模式有两种加载方式：</p>
<ol>
<li>lazy initialization 懒加载：等待需要时再初始化工厂</li>
<li>eager initialization 预先加载：在程序编译阶段就初始化工厂</li>
</ol>
<p>adaptor、factory、singleton三种模式应用于设计</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251461.png" alt="image-20240616104710871"></p>
<h3 id="策略-Strategy"><a class="header-anchor" href="#策略-Strategy"></a>策略 Strategy</h3>
<p>策略 的创建同样可以由工厂来实现。</p>
<p>如使用一个StrategyFactory负责创建所有的策略。</p>
<p><strong>策略模式</strong>是一种行为设计模式，允许在运行时选择算法的方式。通过定义一系列算法，将每个算法封装起来，并使它们可以互换，策略模式让算法独立于使用它们的客户端变化。</p>
<h4 id="UML表示"><a class="header-anchor" href="#UML表示"></a>UML表示</h4>
<p>策略模式的UML图通常包括以下部分：</p>
<ol>
<li><strong>Context（上下文）</strong>：维护一个对策略对象的引用。</li>
<li><strong>Strategy（策略）</strong>：这是一个接口，定义了所有支持的算法的公共方法。</li>
<li><strong>ConcreteStrategy（具体策略）</strong>：实现了策略接口的具体算法。</li>
</ol>
<h3 id="组合-Composite"><a class="header-anchor" href="#组合-Composite"></a>组合 Composite</h3>
<p><strong>组合模式</strong>是一种结构设计模式</p>
<p>组合模式通过将对象组合成树形结构，使得客户端可以一致地处理单个对象和组合对象。</p>
<p>为原子对象和组合对象定义同一个父类或同一个接口，并去具体实现不同的细节，但是就可以通过统一的方法来处理原子对象和组合对象</p>
<h3 id="外观-Faced"><a class="header-anchor" href="#外观-Faced"></a>外观 Faced</h3>
<p>对一组完全不同的实现或接口（如子系统中的实现和接口）需要公共、统一的接口。可能会与子系统内部 的大量事物耦合</p>
<p>对子系统定义唯一的接触点——外观对象封装子系统。该外观对象提供唯一和统一的接口，并负责与子系统构件进行协作。</p>
<h4 id="目的"><a class="header-anchor" href="#目的"></a>目的</h4>
<p>外观模式的主要目的是简化复杂系统的使用，使得客户端可以通过一个简单的接口访问复杂子系统的功能，而不需要了解子系统的内部细节。</p>
<h4 id="结构"><a class="header-anchor" href="#结构"></a>结构</h4>
<p>外观模式通常包括以下角色：</p>
<ul>
<li><strong>Facade</strong>：外观类，提供简单的接口调用子系统的功能。</li>
<li><strong>Subsystem Classes</strong>：子系统类，实际实现系统功能的类，客户端直接使用这些类可能会非常复杂。</li>
</ul>
<p>外观模式通过提供一个高层接口<strong>简化</strong>了复杂系统的<strong>使用</strong>。</p>
<p>一个系统中包含有多个子系统用来完成功能的实现，但是客户不需要关心子系统具体的实现，只需要得到一个系统给的总开关即可。</p>
<h3 id="观察者-Observer（发布-订阅（Publish-Subscribe））-委派事件模型"><a class="header-anchor" href="#观察者-Observer（发布-订阅（Publish-Subscribe））-委派事件模型"></a>观察者 Observer（发布-订阅（Publish-Subscribe））/ 委派事件模型</h3>
<p>它定义了对象间的一对多依赖关系，使得每当一个对象改变状态时，其相关依赖对象都会被<strong>自动通知并更新</strong>。</p>
<p>观察者模式常用于实现事件处理系统，例如GUI框架中的事件监听器，或者订阅发布系统。</p>
<h3 id="代理Proxy"><a class="header-anchor" href="#代理Proxy"></a>代理Proxy</h3>
<h3 id="命令-Command"><a class="header-anchor" href="#命令-Command"></a>命令 Command</h3>
<h3 id="状态-State"><a class="header-anchor" href="#状态-State"></a>状态 State</h3>
<h2 id="课本逐章笔记："><a class="header-anchor" href="#课本逐章笔记："></a>课本逐章笔记：</h2>
<h3 id="绪论"><a class="header-anchor" href="#绪论"></a>绪论</h3>
<p>课本内容：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251765.png" alt="image-20240419090210330" style="zoom:50%;" /> 
<h3 id="UML"><a class="header-anchor" href="#UML"></a>UML</h3>
<p>UML：一种标准的图形表示法，统一建模语言-Unified modeling language，描述、构造和文档化系统制品的可视化语言。</p>
<p>UML不过是将面向对象的思想进行图形化的工具，学习重点关注的还是：对象的设计思想————“OOA/D”</p>
<p>三种应用：</p>
<ol>
<li>作为草图</li>
<li>作为蓝图————相对详细的设计图
<ol>
<li>逆向工程：对现有代码结构进行可视化</li>
<li>代码生成：</li>
</ol>
</li>
<li>作为编程语言</li>
</ol>
<h4 id="OOA-D原则与模式："><a class="header-anchor" href="#OOA-D原则与模式："></a>OOA/D原则与模式：</h4>
<ol>
<li>职责驱动设计-<strong>reponsibility-driven design</strong></li>
<li>将一些经典的设计问题的解决方案提炼出来作为经典的“设计模式<strong>pattern</strong>”</li>
</ol>
<h4 id="用例："><a class="header-anchor" href="#用例："></a>用例：</h4>
<p>OOD需要进行先决条件————需求分析-<strong>requirement analysis</strong>，再需求分析中通常包含用例-<strong>use case</strong>的编写。</p>
<h4 id="迭代开发、敏捷模式、敏捷UP"><a class="header-anchor" href="#迭代开发、敏捷模式、敏捷UP"></a>迭代开发、敏捷模式、敏捷UP</h4>
<p>迭代开发过程</p>
<h4 id="敏捷模式："><a class="header-anchor" href="#敏捷模式："></a>敏捷模式：</h4>
<p>强调以UML作为草图的应用的方式，最普通的使用UML的方法。</p>
<h4 id="三种透视图："><a class="header-anchor" href="#三种透视图："></a>三种透视图：</h4>
<ol>
<li>概念透视图</li>
<li>规格说明（软件）透视图：用UML图来描述软件的抽象物或具有规格说明和接口的构件</li>
<li>实现（软件）透视图：描述特定技术的软件实现</li>
</ol>
<p>在UML当中，矩形框被称为<strong>类-class</strong>。</p>
<p>在领域模式中的UML框被称为领域概念-domain concept或概念类-conceptual class，</p>
<p>OO开发中最重要的能力是软件对象职责的划分</p>
<p>分析：强调对问题和需求的调查研究，但并不是可使用的解决方案</p>
<p>设计：强调满足需求的概念上的解决方案，但并非其实现。最终设计的具体实现表达了完整的设计</p>
<p>面向对象分析：在问题领域内发现和描述对象，抽象出所面对问题当中存在的对象</p>
<p>面向对象设计：定义对象以及对象属性，定义对象间的协作方式以及实现需求</p>
<h3 id="定义领域模式"><a class="header-anchor" href="#定义领域模式"></a><strong>定义领域模式</strong></h3>
<blockquote>
<p>该模型是对真实世界中概念和想象的可视化，也称为“概念对象模型”</p>
</blockquote>
<p>面向对象分析的结果表示为领域模型-domain model</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251938.png" alt="image-20240419091413982" style="zoom:50%;" /> 
<blockquote>
<p>模型描述了分析出的对象、对象间的关联关系和对象的属性与行为</p>
</blockquote>
<h3 id="定义交互图"><a class="header-anchor" href="#定义交互图"></a><strong>定义交互图</strong></h3>
<ol>
<li>
<p>顺序图-sequence diagram：</p>
<blockquote>
<p>uml一种交互图</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251146.png" alt="image-20240419091807866"></p>
</li>
</ol>
<h3 id="定义设计类图"><a class="header-anchor" href="#定义设计类图"></a><strong>定义设计类图</strong></h3>
<p><strong>design class diagram</strong>：有效表示类定义的静态视图</p>
<h3 id="迭代、进化和敏捷"><a class="header-anchor" href="#迭代、进化和敏捷"></a>迭代、进化和敏捷</h3>
<blockquote>
<p>相对于顺序或“瀑布-waterfall”生命周期，迭代和进化式开发-iterative and evolutionary development对部分系统及早地引入编程和测试，并进行重复。</p>
</blockquote>
<h3 id="UP模型–Unified-process-model"><a class="header-anchor" href="#UP模型–Unified-process-model"></a>UP模型–Unified process model</h3>
<blockquote>
<p>UP模型具有良好的兼容性，十分灵活开放，同时鼓励引进其他迭代方法中有效的实践。</p>
<p>UP可以将普遍认可的最佳实践结起来。</p>
</blockquote>
<p><strong>软件开发过程-software development process</strong>描述了构造、部署以及维护软件的方式。</p>
<p><strong>统一过程UP</strong>：一种构造面向对象系统的迭代软件开发过程，</p>
<p><strong>Rational UP-Rational Unified Process RUP</strong>是对统一过程的详细精化。</p>
<h3 id="其他迭代方法："><a class="header-anchor" href="#其他迭代方法："></a>其他迭代方法：</h3>
<ol>
<li>极限编程-<strong>Extreme Programming XP</strong></li>
<li>Scrum</li>
<li>重构-refactoring</li>
<li>持续集成-continuous integration</li>
<li>动态系统开发方法-DSDM Dynamic Systems Development Methodogy</li>
<li>ASD-Adaptive ware Development</li>
</ol>
<h3 id="迭代与进化式开发"><a class="header-anchor" href="#迭代与进化式开发"></a>迭代与进化式开发</h3>
<h4 id="迭代开发-iterative-development"><a class="header-anchor" href="#迭代开发-iterative-development"></a>迭代开发-iterative development</h4>
<ol>
<li>UP与大多数其他现代方法中的重要实践。</li>
<li>迭代的生命周期基于对经过多次迭代的系统进行持续扩张和精化，并以循环反馈和调整为核心驱动力。</li>
<li>随时间推移，系统进行了增量式地发展和完善，因而该方法也成为<strong>迭代和增量式开发</strong>-iterative and incremental development</li>
<li>也因为反馈和调整使规格说明和设计不断进化，所以这种方式也称为<strong>迭代和进化式开发</strong>-iterative and evolutionary development</li>
<li>迭代产出的是最终系统的子集，对这些子集进行整合得到最终的产品</li>
</ol>
<h3 id="瀑布生命周期"><a class="header-anchor" href="#瀑布生命周期"></a>瀑布生命周期</h3>
<blockquote>
<p>瀑布（或顺序）生命周期过程，试图在编程之前就定义所有或大部分的需求。</p>
</blockquote>
<h3 id="风险驱动和客户驱动"><a class="header-anchor" href="#风险驱动和客户驱动"></a>风险驱动和客户驱动</h3>
<p>风险驱动迭代开发更为明确地包含了以<strong>架构为中心- architecture-centric迭代开发的实践。</strong></p>
<h3 id="敏捷方法及其观点"><a class="header-anchor" href="#敏捷方法及其观点"></a>敏捷方法及其观点</h3>
<p>具备进化式精化的计划、需求和设计的短时间定量迭代</p>
<h3 id="敏捷建模"><a class="header-anchor" href="#敏捷建模"></a>敏捷建模</h3>
<p>建模的目的主要是为理解，而非文档</p>
<p>建模的真正行为应该是能够对理解问题或解决方案做出帮助。</p>
<h3 id="UP阶段"><a class="header-anchor" href="#UP阶段"></a>UP阶段</h3>
<ol>
<li>初始-Inception：大体上的构想、业务案例、范围和模糊评估</li>
<li>细化-Elaboration：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估</li>
<li>构造-Construction：对遗留下来的风险较低和比较简单的元素进行了迭代实现，准备部署</li>
<li>移交-Transition：进行beta测试和部署</li>
</ol>
<h3 id="案例研究"><a class="header-anchor" href="#案例研究"></a>案例研究</h3>
<h3 id="迭代开发-迭代学习"><a class="header-anchor" href="#迭代开发-迭代学习"></a>迭代开发+迭代学习</h3>
<ol>
<li>第一次迭代中介绍一组核心的分析设计主题和表示法</li>
<li>第二次迭代展开介绍新理念、UML表示法和模式</li>
<li>第三次…</li>
</ol>
<h3 id="初始不是需求阶段"><a class="header-anchor" href="#初始不是需求阶段"></a>初始不是需求阶段</h3>
<blockquote>
<p>初始阶段是建立项目共同设想和基本范围的比较简短的起始步骤。</p>
<p>初始阶段的目标并不是定义所有需求</p>
<p>初始阶段作为 UP的第一个阶段也不需要完成所有需求或建立可靠预算和计划。以上内容是在细化的过程中逐步完成的</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251050.png" alt="image-20240419170436795"></p>
<h3 id="进化式需求"><a class="header-anchor" href="#进化式需求"></a>进化式需求</h3>
]]></content>
      <tags>
        <tag>统一建模语言-uml</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>电工学笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%94%B5%E5%B7%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 align = center> 电工学 </h1>
<h2 id="2-5-结点电压法"><a class="header-anchor" href="#2-5-结点电压法"></a>2.5 结点电压法</h2>
<h3 id="2-5-0-基本概念："><a class="header-anchor" href="#2-5-0-基本概念："></a>2.5.0 基本概念：</h3>
<h2 id="2-7-戴维宁定理和诺顿定理"><a class="header-anchor" href="#2-7-戴维宁定理和诺顿定理"></a>2.7 戴维宁定理和诺顿定理</h2>
<h3 id="2-7-0-基本概念："><a class="header-anchor" href="#2-7-0-基本概念："></a>2.7.0 基本概念：</h3>
<h4 id="二端网络："><a class="header-anchor" href="#二端网络："></a>二端网络：</h4>
<p>有源——有电源</p>
<p>无源——无电源</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920171844352.png" alt="image-20230920171844352" style="zoom:50%;" />
<p><strong>采取的均是等效思想，等效出的电路图对于外部电路效果相同，但是内部并不一定相同</strong></p>
<h4 id="无源二端网络："><a class="header-anchor" href="#无源二端网络："></a>无源二端网络：</h4>
<p>因没有电源，只需将各部分支路的电阻通过电阻串并联的规律进行等效变换、化简为一个电阻，再与二端网络之外的电阻放在电路图当中进行讨论即可</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920171932963.png" alt="image-20230920171932963" style="zoom:50%;" />
<h4 id="有源二端网络："><a class="header-anchor" href="#有源二端网络："></a>有源二端网络：</h4>
<p>两个定理重点讨论的对象</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920172618732.png" alt="image-20230920172618732" style="zoom:50%;" />
<p>相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">R_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>而言，不管<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mtext>和</mtext><msub><mi>R</mi><mn>1</mn></msub><mtext>和</mtext><msub><mi>R</mi><mn>2</mn></msub><mtext>和</mtext><msub><mi>I</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">E和R_1和R_2和I_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有多么复杂，都可以视作一个大电源。则易于进行电路的分析。</p>
<p>无论是恒压源还是恒流源均可，对于外部电路的分析而言并无太大区别，重要的是将复杂的电路进行简单化。</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920172810819.png" alt="image-20230920172810819" style="zoom:50%;" />
<img src="E:\DeskTable\博客学习截图传输\image-20230920173220030.png" alt="image-20230920173220030" style="zoom:50%;" />
<h3 id="2-7-1-戴维宁定理："><a class="header-anchor" href="#2-7-1-戴维宁定理："></a>2.7.1 戴维宁定理：</h3>
<p>任何一个有源二端线性网络都可以用一个电压源来等效代替——电动势为E、内阻为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>求出E和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的方法</p>
<img src="E:\DeskTable\博客学习截图传输\image-20230920173739240.png" alt="image-20230920173739240" style="zoom: 67%;" />
<h2 id="14半导体器件"><a class="header-anchor" href="#14半导体器件"></a>14半导体器件</h2>
<h3 id="14-1-半导体的导电特性"><a class="header-anchor" href="#14-1-半导体的导电特性"></a>14.1 半导体的导电特性</h3>
<p>半导体的导电特性：</p>
<ol>
<li>热敏性：当环境温度升高时，导电能力显著增强</li>
<li>光敏性：当受到光照时, 导电能力明显变化</li>
<li>掺杂性：往纯净的半导体中掺入某些杂质,导电能力明显改变</li>
</ol>
<h4 id="14-1-1-本征半导体"><a class="header-anchor" href="#14-1-1-本征半导体"></a>14.1.1 本征半导体</h4>
<ol>
<li>
<p>完全纯净的、具有晶体结构的半导体，称为本征半导体。</p>
</li>
<li>
<p>本征半导体的导电机理：价电子在获得一定能量(温度升高或受光照)后, 即可挣脱原子核的束缚，成为<mark>自由电子</mark>(带负电), 同时共价键中留下一个空位，称为<mark>空穴</mark>（带正电）。这一现象称为本征激发。</p>
<ol>
<li>当半导体两端加上外电压时，在半导体中将出现两部分电流
<ol>
<li>自由电子作定向运动 →电子电流</li>
<li>价电子递补空穴 →空穴电流</li>
</ol>
</li>
<li>自由电子和空穴都称为载流子。</li>
<li>自由电子和空穴成对地产生的同时, 又不断复合。在一定温度下，载流子的产生和复合达到动态平衡，半导体中载流子便维持一定的数目。</li>
</ol>
<p>温度愈高，晶体中产 生的自由电子便愈多。</p>
<p>注意:</p>
<ol>
<li>本征半导体中载流子数目极少, 其导电性能很差；</li>
<li>温度愈高，载流子的数目愈多,半导体的导电性能也就愈好。所以，温度对半导体器件性能影响很大。</li>
</ol>
</li>
<li>
<p>在外电场的作用下, 空穴<mark>吸引相邻原子</mark>的价电子来填补，而在该原子中出现一个空穴，其结果相当于空穴的运动(相当于正电荷的移动)。</p>
</li>
</ol>
<h4 id="14-1-2-N型半导体和-P-型半导体"><a class="header-anchor" href="#14-1-2-N型半导体和-P-型半导体"></a>14.1.2 N型半导体和 P 型半导体</h4>
<p>在本征半导体中<mark>掺入微量的杂质</mark> (某种元素) , 形成杂质半导体。</p>
<p>无论N型或P型半导体都是中性的，<mark>对外不显电性</mark>。</p>
<ol>
<li>
<p>N型</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018092454281.png" alt="image-20231018092454281" style="zoom:50%;" />
<ol>
<li>掺入五价元素,掺杂后自由电子数目大量增加，自由电子导电成为这种半导体的主要导电方式，称为电子半导体或N型半导体。</li>
<li>在N 型半导体中<mark>自由电子是多数载流子</mark>，空穴是少数载流子。</li>
</ol>
</li>
<li>
<p>P型</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231018092508259.png" alt="image-20231018092508259" style="zoom:50%;" />
<ol>
<li>掺入三价元素,掺杂后空穴数目大量增加，空穴导电成为这种半导体的主要导电方式，称为空穴半导体或 P 型半导体。</li>
<li>在P 型半导体中<mark>空穴是多数载流子,</mark> 自由电子是少数载流子。</li>
</ol>
</li>
</ol>
<h3 id="14-2-PN结及其导电性"><a class="header-anchor" href="#14-2-PN结及其导电性"></a>14.2 PN结及其导电性</h3>
<h4 id="14-2-1-PN结的形成"><a class="header-anchor" href="#14-2-1-PN结的形成"></a>14.2.1 PN结的形成</h4>
<img src="E:\DeskTable\博客学习截图传输\image-20231018092821475.png" alt="image-20231018092821475" style="zoom: 25%;" /> 
<ol>
<li>
<p>形成空间电荷区,空间电荷区也称 PN 结</p>
</li>
<li>
<p>扩散的结果使空间电荷区变宽。</p>
</li>
<li>
<p>内电场越强，漂移运动越强，而漂移使空间电荷区变薄。</p>
</li>
<li>
<p>扩散和漂移这一对相反的运动最终达到动态平衡，空间电荷区的厚度固定不变。</p>
</li>
</ol>
<h4 id="14-2-2-PN结的单向导电性"><a class="header-anchor" href="#14-2-2-PN结的单向导电性"></a>14.2.2  PN结的单向导电性</h4>
<h3 id="14-3-二极管"><a class="header-anchor" href="#14-3-二极管"></a>14.3 二极管</h3>
<h3 id="14-4-稳压二极管"><a class="header-anchor" href="#14-4-稳压二极管"></a>14.4 稳压二极管</h3>
<h3 id="14-5-双极型晶体管"><a class="header-anchor" href="#14-5-双极型晶体管"></a>14.5 双极型晶体管</h3>
<h3 id="14-6-光电器件"><a class="header-anchor" href="#14-6-光电器件"></a>14.6 光电器件</h3>
]]></content>
      <tags>
        <tag>大学公共基础课</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="离散数学"><a class="header-anchor" href="#离散数学"></a>离散数学</h1>
<h2 id="逻辑和证明"><a class="header-anchor" href="#逻辑和证明"></a>逻辑和证明</h2>
<h3 id="1-命题逻辑"><a class="header-anchor" href="#1-命题逻辑"></a>1. 命题逻辑</h3>
<p><code>proposition</code> <code>命题</code> <strong>prop</strong></p>
<p>逻辑关系:</p>
<p><strong>1.否定、合取、析取、条件、双条件（同或）、异或、条件否定、与非、或非</strong></p>
<p>条件语句</p>
<p><code>implication</code> <code>蕴含</code> <strong>implies</strong></p>
<p>$P \rightarrow Q \Leftrightarrow \neg P \or Q $</p>
<h3 id="2-命题的等价"><a class="header-anchor" href="#2-命题的等价"></a>2. 命题的等价</h3>
<h4 id="2-1-Tautology-and-Contradiction"><a class="header-anchor" href="#2-1-Tautology-and-Contradiction"></a>2.1 Tautology and Contradiction</h4>
<h4 id="2-2-常见的等价语句"><a class="header-anchor" href="#2-2-常见的等价语句"></a>2.2 常见的等价语句</h4>
<p>Identity：$p \and T \Leftrightarrow p $</p>
<p>Domination：</p>
<h2 id="9-Relations"><a class="header-anchor" href="#9-Relations"></a>9.Relations</h2>
<p>自反性：关系矩阵的主<a href="https://zhidao.baidu.com/search?word=%E5%AF%B9%E8%A7%92%E7%BA%BF&amp;fr=iknow_pc_qb_highlight">对角线</a>上元素全部为1<br>
反自反：关系矩阵的主对角线上元素全部为0<br>
对称性：关系矩阵关于主对角线对称<br>
反对称：关系矩阵关于主对角线不对称或者非主对角线上元素全部为0<br>
传递性：这个得用矩阵的乘法，很难直接看出来</p>
<img src="E:\DeskTable\博客学习截图传输\image-20231019102750160.png" alt="image-20231019102750160" style="zoom:67%;" /> 
<h4 id="9-3-Representing-Relations"><a class="header-anchor" href="#9-3-Representing-Relations"></a>9.3 Representing Relations</h4>
<p>集合 A = { a , b , c , d }</p>
<p>关系 R = { &lt; a , b &gt; , &lt; b , a &gt; , &lt; b , c &gt; , &lt; c , d &gt; }</p>
<ol>
<li>求关系 R 的自反闭包 r ( R ) , 对称闭包 s ( R ) , 传递闭包 t ( R )</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011920471.png" alt="img" style="zoom:67%;" /> 
<ol start="2">
<li>求自反闭包 : 就是给每个顶点加上环 :</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011920371.png" alt="在这里插入图片描述" style="zoom:67%;" /> 
<ol start="3">
<li>求对称闭包 : 将 顶点间单向边改成双向边 , 不管顶点间双向边和顶点间没有边的情况 ;</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011920194.png" alt="在这里插入图片描述"></p>
<h3 id="图论三大证明方法"><a class="header-anchor" href="#图论三大证明方法"></a>图论三大证明方法</h3>
<ol>
<li>构造法</li>
<li></li>
</ol>
<h2 id="欧拉图"><a class="header-anchor" href="#欧拉图"></a>欧拉图</h2>
<h3 id="一、定义"><a class="header-anchor" href="#一、定义"></a>一、定义</h3>
<p><strong>欧拉路径：<strong>图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 上有一条经过所有顶点、所有边的</strong>简单路径</strong>（边不重复，点可以重复）</p>
<p><strong>欧拉回路：<strong>图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 上有一条经过所有顶点、所有边的</strong>简单回路</strong>（边不重复，点可以重复）</p>
<p>**欧拉图：<strong>有欧拉回路的连通</strong>无向图 **</p>
<p><strong>欧拉有向图：<strong>有欧拉回路的连通</strong>有向图</strong></p>
<h2 id="二、定理"><a class="header-anchor" href="#二、定理"></a><strong>二、定理</strong></h2>
<p>**定理1：**设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 是连通无向图。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 是欧拉图，当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的结点都为<mark>偶结点</mark> 。</p>
<p>**定理2：**设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">⟩</mo><mtext>为</mtext></mrow><annotation encoding="application/x-tex">G =⟨V,E,φ⟩ 为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">φ</span><span class="mclose">⟩</span><span class="mord cjk_fallback">为</span></span></span></span>连通无向图，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v_1,v_2∈V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 有一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的欧拉路径当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 恰有两个奇结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<p><strong>定理3:</strong> 设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 为弱连通有向图。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 是欧拉有向图，当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 所有结点的出度等于入度。</p>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="操作系统突击复习"><a class="header-anchor" href="#操作系统突击复习"></a>操作系统突击复习</h1>
<h1 id="Introduction"><a class="header-anchor" href="#Introduction"></a>Introduction</h1>
<p>早期引入批处理系统通过减少人工操作的时间，以提高处理效率</p>
<h1 id="进程"><a class="header-anchor" href="#进程"></a>进程</h1>
<h2 id="Process"><a class="header-anchor" href="#Process"></a>Process</h2>
<h3 id="Definition"><a class="header-anchor" href="#Definition"></a>Definition</h3>
<p><strong>进程的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次活动</strong></p>
<p>当进程被创建时，会给予进程一个不重复的独一无二的PID。</p>
<p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h3 id="Process-和-Program-的不同"><a class="header-anchor" href="#Process-和-Program-的不同"></a>Process 和 Program 的不同</h3>
<p><strong>程序 (Program):</strong></p>
<ul>
<li>是一系列集合指令，是一个静态概念；</li>
<li>永久存在，直到被删除；</li>
<li>一个程序可以被多个进程执行。</li>
</ul>
<p><strong>进程 (Process):</strong></p>
<ul>
<li>
<p>描述并发、动态的概念；</p>
</li>
<li>
<p>进程包括程序、数据和进程控制块 (PCB)；</p>
</li>
<li>
<p>是暂时的，会随进程的终止而消失；</p>
</li>
<li>
<p>进程可以创建其他进程；</p>
</li>
<li>
<p>进程可以调用多个程序。</p>
</li>
<li>
<p>进程是CPU调度的基本单位</p>
</li>
</ul>
<h2 id="Process-States"><a class="header-anchor" href="#Process-States"></a>Process States</h2>
<ul>
<li>三种基本状态：
<ul>
<li>运行 running state</li>
<li>就绪 ready state</li>
<li>阻塞 blocked state</li>
<li>三种基本状态的转换</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916117.png" alt="image-20240611092655834"></p>
<ul>
<li>其他状态
<ul>
<li>New state</li>
<li>Exit state</li>
</ul>
</li>
<li>挂起
<ul>
<li>阻塞挂起状态</li>
<li>就绪挂起状态</li>
</ul>
</li>
</ul>
 <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916530.png" alt="image-20240610172240806" style="zoom:50%;" /> 
<h2 id="PCB"><a class="header-anchor" href="#PCB"></a>PCB</h2>
<p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h2 id="Thread"><a class="header-anchor" href="#Thread"></a>Thread</h2>
<p>一个进程内的执行顺序流</p>
<h3 id="Thread-和-process-的异同"><a class="header-anchor" href="#Thread-和-process-的异同"></a>Thread 和 process 的异同</h3>
<h4 id="不同："><a class="header-anchor" href="#不同："></a>不同：</h4>
<ul>
<li><strong>资源分配角度</strong>：
<ul>
<li>进程是资源分配的基本单位,所有与该进程有关的资源分配情况均记录在进程控制块PCB中,进程也是分配主存的基本单位,它拥有一个完整的虚拟地址空间。</li>
<li>而线程与<strong>资源分配无关</strong>,它属于某一个进程,并与该进程内的<strong>其它线程一起共享</strong>进程的资源。</li>
</ul>
</li>
<li><strong>地址空间</strong>：
<ul>
<li>不同的进程拥有不同的虚拟地址空间,</li>
<li>而同一进程中的多个线程共享同一地址空间。</li>
</ul>
</li>
<li><strong>进程间切换和线程间切换开销不同</strong>：
<ul>
<li>进程调度的切换将涉及到有关资源指针的保存及进程地址空间的转换等问题。</li>
<li>而线程的切换将不涉及资源指针的保存和地址空间的变化。</li>
<li>线程切换的开销要比进程切换的开销小得多。</li>
</ul>
</li>
<li><strong>调度者的不同</strong>：
<ul>
<li>进程的调度与切换都是由操作系统内核完成</li>
<li>而线程则既可由操作系统内核完成,也可由用户程序进行。</li>
</ul>
</li>
</ul>
<h4 id="相同"><a class="header-anchor" href="#相同"></a>相同</h4>
<ul>
<li>**都具有创建的功能：**进程可以动态创建进程。被进程创建的线程也可以创建其它线程。</li>
<li>**有相似的生命周期：**进程有创建、执行、消亡的生命周期。线程也有类似的生命周期。</li>
</ul>
<h3 id="线程的实现-implementation"><a class="header-anchor" href="#线程的实现-implementation"></a>线程的实现 implementation</h3>
<p><strong>三种实现方式：</strong></p>
<ul>
<li><strong>用户级：</strong>
<ul>
<li>线程完全处于用户空间中，内核不知道有该线程存在</li>
<li>用户级线程管理由用户级线程库完成</li>
<li>高效：线程切换<strong>不需要内核权限</strong>，用户级线程<strong>创建和管理速度快</strong>。</li>
<li>问题：如果内核是单线程的，那么任何执行阻塞系统调用的用户级线程都将导致整个进程阻塞。</li>
</ul>
</li>
<li>内核级
<ul>
<li>内核支持:内核在内核空间中执行线程创建、调度和管理。</li>
<li>没有线程库，内核提供API</li>
<li>内核维护进程和线程的上下文</li>
<li>线程切换需要内核</li>
<li>线程是Scheduler的基本单位。</li>
<li>缺点是：资源花销太大</li>
</ul>
</li>
<li>混合实现</li>
</ul>
<h2 id="进程间通信-IPC"><a class="header-anchor" href="#进程间通信-IPC"></a>进程间通信 IPC</h2>
<h3 id="进程同步和互斥"><a class="header-anchor" href="#进程同步和互斥"></a>进程同步和互斥</h3>
<p>对多个相关进程在执行次序上的协调,用于保证这种关系的相应机制称为进程同步。</p>
<p>相互合作的一组并发进程在一些关键点上可能需要互相等待与互通消息,相互制约的等待与互通消息称为进程同步。</p>
<ul>
<li>
<p>进程间竞争 race：</p>
<ul>
<li>防止竞争的出现关键在于禁止多个进程同时读写共享数据。</li>
</ul>
</li>
<li>
<p>互斥 Mutual exclusion：确保一个进程使用某共享资源时，其他进程无法访问这个变量</p>
</li>
</ul>
<h3 id="临界资源和临界区"><a class="header-anchor" href="#临界资源和临界区"></a>临界资源和临界区</h3>
<ul>
<li>**临界资源：**一次仅允许一个进程访问的资源称之为临界资源</li>
</ul>
<h3 id="临界区"><a class="header-anchor" href="#临界区"></a>临界区</h3>
<p>**临界区：**程序中访问临界资源的部分称为临界区域或临界段</p>
<p><strong>临界区四个性质要求：</strong></p>
<ol>
<li><strong>没有两个进程同时</strong>处于临界区域</li>
<li>没有对cpu的速度或数量做任何假设</li>
<li>任何在<strong>临界区域外运行的进程</strong>都<strong>不能阻塞</strong>另一个进程</li>
<li>没有进程必须<strong>永远等待</strong>才能进入其临界区域</li>
</ol>
<h3 id="实现互斥"><a class="header-anchor" href="#实现互斥"></a>实现互斥</h3>
<h4 id="禁用中断"><a class="header-anchor" href="#禁用中断"></a>禁用中断</h4>
<ul>
<li>在进入临界区后禁用所有中断，并在离开临界区之前重新启用它们。</li>
<li>禁用中断后，不会发生时钟中断，因为CPU只有在时钟中断时才可以进行进程的切换，禁用后就不会发生切换了。</li>
</ul>
<h4 id="锁变量：使用一个简单的锁变量来表示临界区是否被占用。"><a class="header-anchor" href="#锁变量：使用一个简单的锁变量来表示临界区是否被占用。"></a>锁变量：使用一个简单的锁变量来表示临界区是否被占用。</h4>
<ol>
<li>
<p>两个(或更多)进程可以同时进入它们的临界区。这可能违反性质1。</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916889.png" alt="image-20240619221903004"></p>
<p>这些执行序列需要是原子的。原子性意味着代码在执行期间不能被中断。</p>
</li>
</ol>
<ul>
<li>进程在进入临界区之前检查该变量：</li>
<li>如果它没有被锁定，则设置它为锁定状态并进入临界区；</li>
<li>如果被锁定，则等待。该方法存在忙等待问题，并且容易出现竞争条件。</li>
</ul>
<h4 id="严格的轮换法："><a class="header-anchor" href="#严格的轮换法："></a>严格的轮换法：</h4>
<p>用于两个进程之间的互斥。进程交替进入临界区。一个进程完成后设置一个标志，允许另一个进程进入临界区。</p>
<ul>
<li>
<p>缺点是会导致不必要的等待，即使一个进程不需要进入临界区，另一个进程也必须等待。</p>
</li>
<li>
<p>这个方法可能违反性质3——任何在<strong>临界区域外的进程不能</strong>阻塞另一个进程</p>
<p>由于进程必须严格交替进入它们的临界区，因此想要连续两次进入其临界区的进程将被阻塞，直到另一个进程决定进入(和离开)其临界区。</p>
</li>
</ul>
<h4 id="Peterson算法："><a class="header-anchor" href="#Peterson算法："></a>Peterson算法：</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916946.png" alt="image-20240619222146871"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916285.png" alt="image-20240619222634630"></p>
<p>互斥：</p>
<p>当且仅当其他进程不希望进入临界区；</p>
<p>当且仅当其他进程想要进入，但轮到你；</p>
<p>一个进程可以两次进入它的临界区。</p>
<p>在临界区域外运行的进程不能阻塞另一个进程。</p>
<h4 id="Test-and-Set-Lock-TSL-："><a class="header-anchor" href="#Test-and-Set-Lock-TSL-："></a>Test-and-Set Lock (TSL)：</h4>
<ul>
<li>
<p>硬件必须支持一个特殊的指令，tsl，它在一个原子动作中做两件事:<br>
TSL register，flag</p>
<ul>
<li>copy a value in memory (flag) to a CPU register</li>
<li>set flag to 1.</li>
</ul>
</li>
<li>
<pre><code class="language-c">// 伪代码
boolean lock = false;

boolean TestAndSet(boolean *target) &#123;
    boolean rv = *target;
    *target = true;
    return rv;
&#125;

while (true) &#123;
    while (TestAndSet(&amp;lock));
    critical_section();
    lock = false;
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Sleep and Wakeup：</span><br><span class="line"></span><br><span class="line">当一个进程不能进入临界区时，它会进入sleep状态（其实就是blocked），直到另一个进程唤醒wake up它。该方法避免了忙等待问题。</span><br><span class="line"></span><br><span class="line">#### 互斥导致的忙等待： </span><br><span class="line"></span><br><span class="line">1. Peterson算法 和 TSL方法 会造成忙等待，即执行入口代码的进程会一直处于一个紧循环的状态，消耗CPU周期，一般般测试某些条件是否成立，直到为真</span><br><span class="line">2. 如果使用简单的优先级调度来调度进程，着忙等待会导致优先级反转的问题 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 信号量和PV操作</span><br><span class="line"></span><br><span class="line">信号量的作用：</span><br><span class="line"></span><br><span class="line">1. 互斥访问临界资源</span><br><span class="line">2. 处理同步问题</span><br><span class="line"></span><br><span class="line">信号量的值包括：</span><br><span class="line"></span><br><span class="line">- 0 表示没有保存唤醒</span><br><span class="line">- 正值:一个或多个唤醒正在等待中</span><br><span class="line"></span><br><span class="line">信号量是一个结构体变量，变量属性包括：</span><br><span class="line"></span><br><span class="line">- COUNT：整型变量</span><br><span class="line">  - 初始值表示资源的数量</span><br><span class="line">  - 当S.count&lt;0后，count的绝对值等于等待资源的进程数；</span><br><span class="line">  - 计数信号量：0...N（初始化为N）</span><br><span class="line">  - 二元信号量：0,1（初始化为1）</span><br><span class="line">- Q：存放被阻塞进程PID的queue</span><br><span class="line"></span><br><span class="line">对于信号量的两种操作 P 和 V</span><br><span class="line"></span><br><span class="line">信号量的操作具有原子性</span><br><span class="line"></span><br><span class="line">- P /wait /down ：用来获取资源且count自减</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    P(S):</span><br><span class="line">    	S.count--;</span><br><span class="line">    	if(S.count&lt;0)&#123;</span><br><span class="line">    		block(P);</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>V /signal /up ：用来释放资源且count自增</p>
<ul>
<li>
<pre><code>v(s):
	S.count++
	if(S.count&lt;=0)&#123;
		wakeup(P) for some process P in S.Q;
	&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 等于0的目的是，在count==-1时，我们是先自增，在进行释放，所以需要让count等于0时仍释放资源；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二元信号量</span><br><span class="line"></span><br><span class="line">一种最简单的信号量</span><br><span class="line"></span><br><span class="line">Mutex被用于互斥，一个变量具有两种状态：Lock 和Unlock</span><br><span class="line"></span><br><span class="line">- 二元信号量初始值为1</span><br><span class="line">- 在访问临界区之前进行 P 操作</span><br><span class="line">- 在访问临界区之后进行 V 操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于N个并行进程来说：互斥信号量的取值范围是：1 ~ 1-N</span><br><span class="line"></span><br><span class="line">### 生产者消费者问题</span><br><span class="line"></span><br><span class="line">![image-20240611105623704](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916477.png) </span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916020.png&quot; alt=&quot;image-20240611105632543&quot; style=&quot;zoom: 80%;&quot; /&gt;  </span><br><span class="line"></span><br><span class="line">当缓冲区大小大于1时，必须专门设置一个互斥信号量来保证互斥访问缓冲区</span><br><span class="line"></span><br><span class="line">当缓冲区大小为1时，有可能不需要设置互斥信号量就可以互斥访问缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916640.png&quot; alt=&quot;image-20240611105032126&quot; style=&quot;zoom: 50%;&quot; /&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>设置汽车启动与否信号量 start=0</p>
<p>设置售票员开关门信号量 open=0</p>
<p>P(start)<br>
启动车辆<br>
正常行驶<br>
到站停车<br>
V(open)</p>
<p>关门<br>
V(start)<br>
售票<br>
P(open)<br>
开门</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 哲学家问题</span><br><span class="line"></span><br><span class="line">![image-20240611105756523](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916554.png) </span><br><span class="line"></span><br><span class="line">![image-20240611105809072](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916286.png) </span><br><span class="line"></span><br><span class="line">![image-20240619224401269](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916287.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240619224341265](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916263.png) </span><br><span class="line"></span><br><span class="line">## Reader and Writers Problem</span><br><span class="line"></span><br><span class="line">![image-20240611141105820](https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916001.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore db = 1;</span><br><span class="line">int rs = 0;</span><br><span class="line"></span><br><span class="line">void reader()&#123;</span><br><span class="line"></span><br><span class="line">	while(true)&#123;</span><br><span class="line">		down(&amp;mutex);</span><br><span class="line">		rs++;</span><br><span class="line">		if(rs == 1) down(&amp;db);</span><br><span class="line">		up(&amp;mutex);</span><br><span class="line">	</span><br><span class="line">		reading();</span><br><span class="line">	</span><br><span class="line">		down(&amp;mutex);</span><br><span class="line">		rs--;</span><br><span class="line">		if(rs == 0) up(&amp;db);</span><br><span class="line">		up(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer()&#123;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">        down(&amp;db);</span><br><span class="line">        wirting();</span><br><span class="line">        up(&amp;db);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程调度算法-Process-Scheduling-Algorithm"><a class="header-anchor" href="#进程调度算法-Process-Scheduling-Algorithm"></a>进程调度算法 Process Scheduling Algorithm</h2>
<h3 id="批处理系统（Batch-Systems）"><a class="header-anchor" href="#批处理系统（Batch-Systems）"></a>批处理系统（Batch Systems）</h3>
<h4 id="先来先服务（First-Come-First-Served-FCFS）FIFO："><a class="header-anchor" href="#先来先服务（First-Come-First-Served-FCFS）FIFO："></a>先来先服务（First Come First Served, FCFS）FIFO：</h4>
<ul>
<li><strong>特点</strong>：按到达顺序调度进程，第一个到达的进程先执行，直到完成。</li>
<li><strong>优点</strong>：简单易实现，调度公平。</li>
<li><strong>缺点</strong>：可能导致长时间等待，容易产生“<strong>Convoy Effect</strong>”护航效应：处理时间短的进程在长的进程后面（一组短进程被一个长进程阻塞）。</li>
<li>平均等待时间：所有进程的等待时间相加再除以进程数量</li>
</ul>
<h4 id="最短作业优先（Shortest-Job-First-SJF）："><a class="header-anchor" href="#最短作业优先（Shortest-Job-First-SJF）："></a>最短作业优先（Shortest Job First, SJF）：</h4>
<ul>
<li>需要提前知道运行时间</li>
<li>No-Preemptive非抢占式：如果所有进程同时到达，则为最优；但是当所有进程并非同时到达时，则不一定是最优的</li>
<li>Preemptive抢占式：则可以更优，因为不会有CPU的浪费。</li>
<li><strong>特点</strong>：优先调度预计运行时间最短的进程，非抢占式。</li>
<li><strong>优点</strong>：平均等待时间最短，有效提高系统吞吐量。</li>
<li><strong>缺点</strong>：需要准确预测作业时间，可能导致“<strong>饥饿</strong>”问题（长作业得不到调度）。</li>
</ul>
<h3 id="交互式系统（Interactive-Systems）"><a class="header-anchor" href="#交互式系统（Interactive-Systems）"></a>交互式系统（Interactive Systems）</h3>
<h4 id="轮转调度（Round-Robin-RR）："><a class="header-anchor" href="#轮转调度（Round-Robin-RR）："></a>轮转调度（Round Robin, RR）：</h4>
<ul>
<li><strong>特点</strong>：所有进程按时间片轮流执行，每个进程在每轮中最多执行一个时间片。</li>
<li><strong>优点</strong>：简单，公平，适合时间片较短的交互式系统，响应时间较好。</li>
<li><strong>缺点</strong>：时间片选择不当会影响性能，过短增加上下文切换开销，过长则响应变慢。</li>
</ul>
<h4 id="优先级调度（Priority-Scheduling）："><a class="header-anchor" href="#优先级调度（Priority-Scheduling）："></a>优先级调度（Priority Scheduling）：</h4>
<ul>
<li><strong>特点</strong>：根据进程的优先级调度，优先级高的进程先执行，可以是抢占式或非抢占式。</li>
<li><strong>优点</strong>：能保证高优先级的关键任务及时处理。</li>
<li><strong>缺点</strong>：可能导致低优先级进程“<strong>饥饿</strong>”，需要引入老化机制防止饥饿。</li>
<li><strong>优先级设置依据</strong>:
<ul>
<li>进程的开销 Cost to user</li>
<li>进程的重要性 Importance of user</li>
<li>进程的类型 Process type</li>
<li>对资源的要求 Requirement to resource</li>
<li>Aging</li>
<li>最近的CPU使用时间比例 Percentage of CPU time used in last X hours.</li>
</ul>
</li>
</ul>
<h4 id="多队列调度"><a class="header-anchor" href="#多队列调度"></a>多队列调度</h4>
<p>通过设置优先级和时间片不同的队列，并事先将进程进行优先级分类，进程进入相应的优先级队列中进行调度。</p>
<h4 id="多级反馈队列调度（Multi-Queue-Multi-level-Feedback-Queue）："><a class="header-anchor" href="#多级反馈队列调度（Multi-Queue-Multi-level-Feedback-Queue）："></a>多级反馈队列调度（Multi Queue &amp; Multi-level Feedback Queue）：</h4>
<ul>
<li>优先级和轮循的混合</li>
<li><strong>特点</strong>：将进程按优先级或特性分配到不同队列，每个队列使用不同的调度策略。多级反馈队列允许进程在不同队列间移动，以动态调整优先级。</li>
<li>优先级从高到低为：第一级、第二级、第三级、…</li>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916512.png" alt="image-20240611160619733" style="zoom:80%;" /> 
</li>
<li>当低级的队列正在执行时，如果此时高级的队列来了进程，高级队列内的进程进行抢占，先执行完高优先级队列中的进程再重新执行低优先级的队列中的进程，同时被抢占的处于低优先级的队列的进程重新放回队列的队首。在最低级队列仍然没有消耗完所需运行时间，则重新回到最低级的队列重新再分配时间片</li>
<li>第一级队列：FIFO原则
<ul>
<li>分配第一级队列的时间片，用完后</li>
<li>如果完成着完成</li>
<li>如果没有完成着进入下一级队列的队尾</li>
</ul>
</li>
<li>第二级队列：
<ul>
<li>执行队列内的进程</li>
</ul>
</li>
<li>第三级队列：</li>
<li><strong>优点</strong>：灵活，适应性强，能平衡短进程响应和长进程的公平性。</li>
<li><strong>缺点</strong>：复杂度高，实现困难，需要精心调整参数。</li>
</ul>
<h4 id="保证调度（Guaranteed-Scheduling）："><a class="header-anchor" href="#保证调度（Guaranteed-Scheduling）："></a>保证调度（Guaranteed Scheduling）：</h4>
<ul>
<li><strong>特点</strong>：确保所有进程在一段时间内得到一定比例的CPU时间，通常使用比例分配算法。</li>
<li><strong>优点</strong>：公平，避免饥饿现象。</li>
<li><strong>缺点</strong>：实现复杂，需精确控制资源分配。</li>
</ul>
<h4 id="彩票调度（Lottery-Scheduling）："><a class="header-anchor" href="#彩票调度（Lottery-Scheduling）："></a>彩票调度（Lottery Scheduling）：</h4>
<ul>
<li><strong>特点</strong>：给每个进程分配一定数量的“彩票”，调度时随机抽取一张彩票，拥有该彩票的进程获得CPU时间。</li>
<li><strong>优点</strong>：灵活性高，容易实现公平性和资源分配的动态调整。</li>
<li><strong>缺点</strong>：不确定性，可能导致短期内调度不均衡。</li>
</ul>
<h4 id="公平共享调度（Fair-Sharing-Scheduling）："><a class="header-anchor" href="#公平共享调度（Fair-Sharing-Scheduling）："></a>公平共享调度（Fair Sharing Scheduling）：</h4>
<ul>
<li><strong>特点</strong>：将CPU时间按用户或用户组公平分配，确保每个用户获得相同的资源份额。</li>
<li><strong>优点</strong>：适合多用户系统，确保每个用户公平使用资源。</li>
<li><strong>缺点</strong>：可能导致进程级别的调度不公平，复杂度较高。</li>
</ul>
<p>每种调度算法都有其适用的场景和局限性。选择合适的调度算法可以有效提高系统的性能和用户体验。批处理系统主要关注作业吞吐量和等待时间，而交互式系统更注重响应时间和用户体验。</p>
<h1 id="存储管理"><a class="header-anchor" href="#存储管理"></a>存储管理</h1>
<h2 id="存储管理："><a class="header-anchor" href="#存储管理："></a>存储管理：</h2>
<h3 id="位图"><a class="header-anchor" href="#位图"></a>位图</h3>
<p>The smaller the allocation unit, the larger the bitmap.</p>
<p>使用0标识空闲的内存块，每当有新进程到达，寻找符合进程需求大小的连续0空间</p>
<p>位图是一种简单的数组，每个元素对应内存中的一个固定大小的块（称为一个单位或块）。数组中的每个元素是一个位（bit），表示对应的内存块是否已分配。</p>
<h3 id="链表"><a class="header-anchor" href="#链表"></a>链表</h3>
<p>链表中的每个节点表示一个hole(free segment)或者process(allocated segment)，包含该块的起始地址、大小以及指向下一个节点的指针。</p>
<h2 id="存储放置策略"><a class="header-anchor" href="#存储放置策略"></a>存储放置策略</h2>
<h3 id="First-Fit"><a class="header-anchor" href="#First-Fit"></a>First Fit</h3>
<p>原理：找到的第一个满足请求要求的空闲块就进行分配</p>
<p>问题：留下许多小的空闲块，导致碎片化问题</p>
<h3 id="Next-Fit"><a class="header-anchor" href="#Next-Fit"></a>Next Fit</h3>
<p>原理：每次从上一次分配结束的位置继续搜索空闲块，找到的第一个满足的即分配，而不是从头开始。</p>
<p>问题：整体性能比First Fit略差，可能造成中间部分碎片化问题</p>
<h3 id="Best-Fit"><a class="header-anchor" href="#Best-Fit"></a>Best Fit</h3>
<p>**原理：**遍历所有空闲块，找到满足要求大小的最小的空闲块进行分配</p>
<p>**缺点：**遍历空闲块耗费时间太多，开销太大；还是会可能出现碎片化问题，且可能产生许多小的不可用的碎片。</p>
<h3 id="Worst-Fit"><a class="header-anchor" href="#Worst-Fit"></a>Worst Fit</h3>
<p>**原理：**遍历所有空闲块，找到最大的空闲块进行分配</p>
<p>**缺点：**可能浪费了大的空闲块，降低了利用率</p>
<h3 id="Quick-Fit"><a class="header-anchor" href="#Quick-Fit"></a>Quick Fit</h3>
<p><strong>原理</strong>：维护一些常见大小请求的单独空闲块列表，当有内存请求时，直接从相应的列表中分配内存块。</p>
<p><strong>优点</strong>：分配速度非常快，因为直接从列表中获取空闲块。</p>
<p><strong>缺点</strong>：当需要合并空闲块时，操作可能会比较复杂和耗时。</p>
<h2 id="虚拟内存的实现"><a class="header-anchor" href="#虚拟内存的实现"></a>虚拟内存的实现</h2>
<p>MMU负责将虚拟地址转化为物理地址</p>
<h3 id="页式"><a class="header-anchor" href="#页式"></a>页式</h3>
<p>查页表将虚拟地址转换成物理地址</p>
<p>最常见</p>
<p>**MMU memory management unit:**将虚拟地址转换成物理地址</p>
<p>操作系统维护一张由虚拟地址映射到物理地址的map表</p>
<p>引用未映射的页面会导致CPU向操作系统发送trap——page fault</p>
<p>页表 page table：虚拟地址和物理地址间的映射关系表</p>
<p>virtual address分成：page number 和 page offset</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916618.png" alt="image-20240612102741723"></p>
<p>page offset就是页内偏移量，即页的大小</p>
<h4 id="页表一个项的组成"><a class="header-anchor" href="#页表一个项的组成"></a>页表一个项的组成</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916475.png" alt="image-20240612103022865"></p>
<h4 id="TLB-Translation-Look-aside-Buffers"><a class="header-anchor" href="#TLB-Translation-Look-aside-Buffers"></a>TLB Translation Look-aside Buffers</h4>
<p>存储在cache中的虚存表，用来查找</p>
<p>TLB表结构</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916918.png" alt="image-20240612115006473"></p>
<h4 id="多级页表"><a class="header-anchor" href="#多级页表"></a>多级页表</h4>
<p>稀疏的地址空间和更容易分页</p>
<p>将一个32位逻辑地址分为：20bits的页号和12bits的页内offset</p>
<p>其中再把20bits的页号进一步分为10bits的页号和10bits的页偏移量</p>
<p>由于每个级别都存储在内存中的单独表中，因此在四级分页中将逻辑地址转换为物理地址可能需要进行五次内存访问。</p>
<p>优点：</p>
<ul>
<li>缩减页表大小</li>
<li>可以不把不需要的页表放在内存中</li>
</ul>
<h4 id="倒页表-Inverted-Page-Tables"><a class="header-anchor" href="#倒页表-Inverted-Page-Tables"></a>倒页表 Inverted Page Tables</h4>
<p><strong>原理：</strong></p>
<ul>
<li>
<p>一个PTE对应一个物理页；</p>
</li>
<li>
<p>物理页码用作表的索引；</p>
</li>
<li>
<p>哈希(Vpage, pid)到page#</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>小页表的大地址空间</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>
<p>查找很困难</p>
</li>
<li>
<p>管理哈希链的开销等</p>
</li>
</ul>
<h3 id="段式"><a class="header-anchor" href="#段式"></a>段式</h3>
<h3 id="段页式"><a class="header-anchor" href="#段页式"></a>段页式</h3>
<h3 id="获取策略"><a class="header-anchor" href="#获取策略"></a>获取策略</h3>
<h2 id="页表存在的问题"><a class="header-anchor" href="#页表存在的问题"></a>页表存在的问题</h2>
<h3 id="使用单个页表使用一组寄存器来组成："><a class="header-anchor" href="#使用单个页表使用一组寄存器来组成："></a>使用单个页表使用一组寄存器来组成：</h3>
<ol>
<li>优点：简单易实现</li>
<li>缺点：
<ol>
<li>如果页表很大，则十分昂贵</li>
<li>并且要每次切换页表都需要载入整个页表，性能差</li>
</ol>
</li>
</ol>
<h3 id="将页表放在内存——只用一个寄存器指针指向这个页表"><a class="header-anchor" href="#将页表放在内存——只用一个寄存器指针指向这个页表"></a>将页表放在内存——只用一个寄存器指针指向这个页表</h3>
<ol>
<li>优点：易于切换，开销小</li>
<li>读取表项时会有一个或多个内存引用</li>
</ol>
<h2 id="TLB-Translation-Look-aside-Buffers-Associative-Memory"><a class="header-anchor" href="#TLB-Translation-Look-aside-Buffers-Associative-Memory"></a>TLB Translation Look-aside Buffers/Associative Memory</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011916124.png" alt="image-20240619233109821"></p>
<p>有效位，虚拟页号，修改位（脏位），保护位，物理页框</p>
<p>TLB中每一个项是PTE page table entry</p>
<p>TLB失效：在TLB中找不到需要的PTE或有效位为0</p>
<p>则：载入页项进入TLB，软件执行页错误处理方法，重启CPU等待重新取页</p>
<h2 id="多级页表-v2"><a class="header-anchor" href="#多级页表-v2"></a>多级页表</h2>
<p>好处：</p>
<ol>
<li>减小表的大小。</li>
<li>不在内存中保留不需要的页表</li>
</ol>
<h2 id="页置换算法"><a class="header-anchor" href="#页置换算法"></a>页置换算法</h2>
<p>目标：降低页错误率；减少页错误的延迟</p>
<p>流程：</p>
<ol>
<li>
<p>Find location of page on disk<br>
查找页在磁盘上的位置</p>
</li>
<li>
<p>Find a free page frame<br>
在内存寻找一个空闲页</p>
<ol>
<li>If there is a free page frame then use it<br>
如果找到了直接将新的页加载进去即可</li>
<li>Otherwise, select a victim frame using the page replacement algorithm<br>
如果没有，使用页置换算法去选择一个页框进行替换</li>
</ol>
</li>
<li>
<p>Write the selected page to the disk if necessary and update any necessary tables<br>
如果有需要，还要将被替换的页写入disk，更新一些必要的表项</p>
</li>
<li>
<p>Read the requested page from the disk.<br>
从disk读取请求的页</p>
</li>
<li>
<p>Restart the user process.</p>
<p>重新启动用户进程。</p>
</li>
</ol>
<h3 id="算法："><a class="header-anchor" href="#算法："></a>算法：</h3>
<h4 id="最优算法-不可能实现-The-Optimal-Algorithm-OPT-or-MIN"><a class="header-anchor" href="#最优算法-不可能实现-The-Optimal-Algorithm-OPT-or-MIN"></a>最优算法-不可能实现 The Optimal Algorithm (OPT or MIN)</h4>
<p>Replace the page that will not be used again the farthest time in the future.<br>
替换将来最远时间内不会再次使用的页面。</p>
<p>该算法不可能实现，因为无法知道未来的页的引用情况；</p>
<h4 id="FIFO-First-in-First-Out-Algorithm"><a class="header-anchor" href="#FIFO-First-in-First-Out-Algorithm"></a>FIFO (First-in First-Out) Algorithm</h4>
<p>Replace the page that has been in primary memory the longest<br>
替换在主内存中存在时间最长的页</p>
<p>被引用的页进入一个队列当中，当队列满了以后，每当来一个新的页，则队头出列，新的页进入队尾</p>
<p><strong>优点</strong>：易于实现</p>
<p><strong>缺点</strong>：在内存中存在时间最长（但是可能最常被使用）的页可能被替换</p>
<p><strong>Belady现象</strong> ：只出现在 FIFO 当中</p>
<p>随着页框的增多，page fault 反而会增加，算法的性能会下降</p>
<h4 id="Second-Chance-Algorithm：对FIFO进行修正"><a class="header-anchor" href="#Second-Chance-Algorithm：对FIFO进行修正"></a>Second Chance Algorithm：对FIFO进行修正</h4>
<p>Variant of FIFO<br>
FIFO的变体</p>
<p><strong>引入 R bit</strong>：如果 R = 0，将页置换；如果 R = 1，将 R 置零，而后将页放在队尾，相当于这个页是重新被载入到页queue当中</p>
<p><strong>优点</strong>：改善了FIFO的性能，减少了不必要的页面替换。</p>
<p><strong>缺点</strong>：实现较复杂，需要额外的硬件支持。</p>
<h4 id="Clock-Algorithm"><a class="header-anchor" href="#Clock-Algorithm"></a>Clock Algorithm</h4>
<p>Better implementation of second chance<br>
更好地实施 第二次机会算法</p>
<p><strong>原理</strong>：</p>
<p>时钟算法的核心思想是通过一个循环队列和指针来模拟时钟指针的移动，从而管理页面的替换。每个页面都有一个使用位（Use Bit）：</p>
<ol>
<li><strong>使用位为1</strong>：表示该页面最近被访问过，给予它第二次机会。</li>
<li><strong>使用位为0</strong>：表示该页面没有被访问过，优先考虑替换该页面。</li>
</ol>
<p><strong>操作步骤</strong>：</p>
<ol>
<li>页面被访问时，其使用位置1。</li>
<li>当需要替换页面时，操作系统检查指针所指向的页面：
<ul>
<li>如果使用位为0，替换该页面。</li>
<li>如果使用位为1，清零使用位并将指针移动到下一个页面，然后继续检查。</li>
</ul>
</li>
<li>重复上述过程，直到找到一个使用位为0的页面并进行替换。</li>
</ol>
<h4 id="NRU-Not-Recently-Used-Algorithm"><a class="header-anchor" href="#NRU-Not-Recently-Used-Algorithm"></a>NRU (Not Recently Used) Algorithm</h4>
<p>Enhanced second chance<br>
增加第二次机会</p>
<p>周期性地(在每个时钟间隔(20msec))清除R位。(即R = 0)。</p>
<ol>
<li><strong>Class 0</strong>：使用位为0，修改位为0。</li>
<li><strong>Class 1</strong>：使用位为0，修改位为1。</li>
<li><strong>Class 2</strong>：使用位为1，修改位为0。</li>
<li><strong>Class 3</strong>：使用位为1，修改位为1。</li>
</ol>
<p>在进行页面替换时，NRU算法优先淘汰属于 Class 0的页面，然后是 Class 1、Class 2和最后是 Class 3。目的是尽量保留长时间没有被使用且没有被修改过的页面，减少对经常使用或被修改的页面的替换频率。</p>
<p><strong>操作步骤</strong>：</p>
<ol>
<li>
<p><strong>初始化</strong>：将所有页面的使用位和修改位清零。</p>
</li>
<li>
<p><strong>页面访问</strong>：当页面被访问时，设置其使用位为1。</p>
</li>
<li>
<p><strong>页面修改</strong>：当页面被修改时，设置其修改位为1。</p>
</li>
<li>
<p><strong>页面替换</strong>：当需要替换页面时，按照Class的优先级进行替换：</p>
<ul>
<li>首先替换Class 0中的页面。</li>
<li>如果Class 0没有页面，则替换Class 1中的页面。</li>
<li>如果Class 1没有页面，则替换Class 2中的页面。</li>
<li>如果Class 2没有页面，则替换Class 3中的页面。</li>
</ul>
</li>
</ol>
<h4 id="LRU-Least-Recently-Used-Algorithm"><a class="header-anchor" href="#LRU-Least-Recently-Used-Algorithm"></a>LRU (Least Recently Used) Algorithm</h4>
<p>Replace the page that has not been used for the longest time<br>
替换最长时间没有被使用的页</p>
<p>优先淘汰最长时间没有被访问过的页面，以此来减少页面错误率。</p>
<p>LRU算法维护一个页面访问顺序的队列，每当页面被访问时，将该页面移动到队列的末尾。当需要替换页面时，选择队列头部的页面进行替换，即替换最久未被访问的页面。</p>
<p><strong>操作步骤</strong>：</p>
<ol>
<li><strong>页面访问</strong>：当页面被访问时，将该页面移动到队列的末尾。</li>
<li><strong>页面替换</strong>：当需要替换页面时，选择队列头部的页面进行替换，即替换最久未被访问的页面。</li>
</ol>
<p>LRU算法的实现可以通过以下几种方式来完成：</p>
<ul>
<li><strong>使用链表</strong>：维护一个双向链表，链表中的节点表示页框，每当页面被访问，将其移动到链表的末尾。当需要替换页面时，选择链表头部的节点进行替换。</li>
<li><strong>使用散列表和堆</strong>：利用散列表存储页框和其在队列中的位置信息，利用最小堆（Min-Heap）来维护页面的访问顺序。每次页面被访问时，更新其在堆中的位置，需要替换页面时，选择堆顶的页面进行替换。</li>
</ul>
<p>硬件方案二:</p>
<p>对于有 n 个页面帧的机器，保持 n x n 位的矩阵。</p>
<p>当页面帧K被引用时：</p>
<ol>
<li>将第K行设置为全1。</li>
<li>设K列全为0。</li>
<li>二进制值最小的行就是LRU页面。</li>
</ol>
<h4 id="NFU-Not-Frequently-Used-Algorithm"><a class="header-anchor" href="#NFU-Not-Frequently-Used-Algorithm"></a>NFU (Not Frequently Used) Algorithm</h4>
<p>Replace the page that is used least often, simulated LRU<br>
替换使用频率最少的页，模拟LRU</p>
<p>在每个时钟中断时，R位被添加到与每个页面相关的计数器中。</p>
<ul>
<li>当发生页错误时，将替换具有最低计数器的页。</li>
<li>问题:NFU永远不会忘记，所以很久以前引用的页面频率可能有最高的计数器。</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917475.png" alt="image-20240615110322734"></p>
<h4 id="Aging-Algorithm"><a class="header-anchor" href="#Aging-Algorithm"></a>Aging Algorithm</h4>
<p>Modified NFU</p>
<p>老化算法，模拟NFU</p>
<h4 id="Working-Set-Algorithm"><a class="header-anchor" href="#Working-Set-Algorithm"></a>Working Set Algorithm</h4>
<p>Keep in memory those pages that the process is actively using</p>
<p>当出现 page fault 时，查找不在工作集中的页并将其排除。</p>
<p>为每一个页都维护一个上一次调用时间 LTU 和一个 R 位，R位 Reference bit 用来表示页面的访问状态，即页面是否被访问过。</p>
<p><strong>访问页面时</strong>：</p>
<ul>
<li>如果页面被访问，更新页面的 LTU（设置为当前时间）和 R 位（设置为1）。</li>
<li>如果页面没有被访问，只更新 R 位为1。</li>
</ul>
<p><strong>周期性更新</strong>：</p>
<ul>
<li>定期检查所有页面的 R 位。</li>
<li>如果页面的 R 位为1，表示页面在最近的一段时间内被访问过，可以保留在当前工作集中，重置 R 位为0。</li>
<li>如果页面的 R 位为0，表示页面较长时间未被访问，可能不属于当前工作集，可以考虑置换出去。</li>
</ul>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917860.png" alt="image-20240615112652039" style="zoom:80%;" />  
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917514.png" alt="image-20240615132707682"></p>
<h4 id="WS-Clock-Algorithm"><a class="header-anchor" href="#WS-Clock-Algorithm"></a>WS Clock Algorithm</h4>
<p>The modified working set algorithm based on clock algorithm</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917358.png" alt="image-20240615133923108"></p>
<h2 id="页大小"><a class="header-anchor" href="#页大小"></a>页大小</h2>
<h3 id="Small-page-size"><a class="header-anchor" href="#Small-page-size"></a>Small page size</h3>
<h4 id="Advantages"><a class="header-anchor" href="#Advantages"></a>Advantages</h4>
<ul>
<li>
<p>less internal fragmentation<br>
更少的内部碎片</p>
</li>
<li>
<p>less unused program in memory<br>
减少内存中未使用的程序</p>
</li>
</ul>
<h4 id="Disadvantages"><a class="header-anchor" href="#Disadvantages"></a>Disadvantages</h4>
<ul>
<li>programs need many pages, larger page tables<br>
一个程序需要很多个页，页表太大</li>
</ul>
<h1 id="文件系统"><a class="header-anchor" href="#文件系统"></a>文件系统</h1>
<h2 id="文件访问"><a class="header-anchor" href="#文件访问"></a>文件访问</h2>
<h3 id="顺序访问"><a class="header-anchor" href="#顺序访问"></a>顺序访问</h3>
<ul>
<li>从头开始读取</li>
<li>不能跳转，可以倒带或后退</li>
<li>当介质是磁带时很方便</li>
</ul>
<p>顺序访问是一种按照顺序逐个访问文件内容的方式。从文件的开头开始，依次读取或写入数据，直到文件末尾。这种访问方式通常适用于文本文件或者需要按照顺序处理数据的场景。</p>
<h3 id="随机访问"><a class="header-anchor" href="#随机访问"></a>随机访问</h3>
<ul>
<li>可以从任意位置开始读取</li>
<li>Two methods are used for specifying where to start reading.
<ul>
<li>read and then move file marker</li>
<li>move file marker (seek), then read (UNIX, Windows)</li>
</ul>
</li>
</ul>
<p>随机访问允许程序员以任意顺序访问文件中的数据。这意味着可以跳转到文件中的任何位置读取或写入数据，而不必按照顺序逐步读取。</p>
<h2 id="目录"><a class="header-anchor" href="#目录"></a>目录</h2>
<p>用于组织和管理文件的一种结构。目录中可以包含文件和其他目录。</p>
<ol>
<li>文件系统有目录或文件夹来跟踪文件。</li>
<li>目录是包含文件名和文件位置之间对应关系的文件</li>
<li>目录项包含有关文件的信息，即它的属性</li>
<li>目录项在创建它们所描述的文件时创建，在删除文件时删除</li>
</ol>
<h3 id="目录结构"><a class="header-anchor" href="#目录结构"></a>目录结构</h3>
<p>一级目录：root拥有所有的文件</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917039.png" alt="image-20240615141108351" style="zoom:50%;" /> 
<p>二级目录：有一个root目录和一个user目录</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917829.png" alt="image-20240615141139500" style="zoom:67%;" /> 
<p>多级目录：有一个root目录和任意数量的子目录</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917902.png" alt="image-20240615141333276" style="zoom:50%;" /> 
<p>在文件目录树中，叶子节点是文件</p>
<p>文件系统定义块大小</p>
<ol>
<li>
<p>块大小= 2 *扇区大小</p>
</li>
<li>
<p>连续的扇区被分配到一个块中</p>
</li>
</ol>
<p>文件系统将磁盘视为一个块阵列</p>
<ol>
<li>
<p>必须为文件分配块吗</p>
</li>
<li>
<p>必须管理磁盘上的可用空间</p>
</li>
</ol>
<h2 id="文件系统的实现"><a class="header-anchor" href="#文件系统的实现"></a>文件系统的实现</h2>
<h3 id="连续分配"><a class="header-anchor" href="#连续分配"></a>连续分配</h3>
<p>将每个文件存储为连续的数据块</p>
<p>目录中记录的是 文件的 start 和 length</p>
<h4 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h4>
<ul>
<li>易于实现</li>
<li>读能力的表现很好</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>外部碎片问题：</li>
</ul>
<h4 id="外部碎片"><a class="header-anchor" href="#外部碎片"></a>外部碎片</h4>
<p>是指内存或存储设备上零散的、不可利用的空闲空间。</p>
<h4 id="内部碎片"><a class="header-anchor" href="#内部碎片"></a>内部碎片</h4>
<p>已分配的内存或存储空间内部未被使用的空间。</p>
<h3 id="链表分配"><a class="header-anchor" href="#链表分配"></a>链表分配</h3>
<p>将文件存储为磁盘块的链表，块可能分散在磁盘上的任何地方。</p>
<p>每个块的第一个字被用作指向下一个的指针。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917379.png" alt="image-20240615154514388" style="zoom: 80%;" /> 
<h4 id="优点"><a class="header-anchor" href="#优点"></a>优点</h4>
<ul>
<li>没有外部碎片</li>
<li>目录项简单（仅需要开始地址）</li>
<li>文件可以增加，只要有足够的空闲的块</li>
<li>有利于顺序访问</li>
</ul>
<h4 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h4>
<ul>
<li>随机访问速度慢</li>
<li>块中的数据量不是2的幂</li>
</ul>
<h4 id="FAT表"><a class="header-anchor" href="#FAT表"></a>FAT表</h4>
<p>从每个块中取出表指针word，并将它们放入索引表FAT(文件分配表)中。</p>
<p>尽量将FAT表存放在内存中以缩短查询硬盘</p>
<p>FAT表内存储的是下一个block的start地址：如文件某一项的start为217，则FAT表中217中存放的是下一个block的start地址：618，以此类推</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917154.png" alt="image-20240615163530220" style="zoom:67%;" /> 
<h4 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h4>
<ul>
<li>对于数据来说整个快都是可利用的</li>
<li>支持随机访问</li>
<li>目录项仅需要一个数组</li>
</ul>
<h4 id="缺点-v2"><a class="header-anchor" href="#缺点-v2"></a>缺点</h4>
<p>整个FAR必须同时在内存中</p>
<h3 id="Indexed-Allocation-I-Node"><a class="header-anchor" href="#Indexed-Allocation-I-Node"></a>Indexed Allocation I-Node</h3>
<p>将一个文件的所有块的指针集中到一个索引块当中，这个索引块相当于一个目录，存放文件的每一个块的首地址。</p>
<p>目录像普通文件一样存储</p>
<ul>
<li>
<p>目录项包含在数据块中</p>
</li>
<li>
<p>目录文件是目录条目的列表</p>
</li>
</ul>
<p>当文件被打开时，文件系统使用路径名来定位目录条目。</p>
<p>目录项提供查找磁盘块所需的信息。</p>
<ul>
<li>
<p>连续分配：整个文件的磁盘地址(连续块)</p>
</li>
<li>
<p>链表分配：第一个区块的编号(链表)</p>
</li>
<li>
<p>i节点分配：i-node数量(i-node)</p>
</li>
</ul>
<h2 id="目录的实现"><a class="header-anchor" href="#目录的实现"></a>目录的实现</h2>
<p>在MS-DOS/Windows中，使用连续分配的方式</p>
<p>在Unix中，使用 i-node 的方式</p>
<h3 id="长文件名的处理方式"><a class="header-anchor" href="#长文件名的处理方式"></a>长文件名的处理方式</h3>
<ol>
<li>
<p>固定长度</p>
<ol>
<li>通常为255chars</li>
<li>简单</li>
<li>浪费空间</li>
</ol>
</li>
<li>
<p>目录项包括固定和可变部分</p>
<ul>
<li>固定部分以项长度 entry len 开始，然后是属性 attribute</li>
<li>变量部分有文件名</li>
<li>优缺：
<ul>
<li>节省空间</li>
<li>当一个文件被删除时，一个可变大小的间隙被引入，下一个新进来的目录项可能没办法放入这个间隙里</li>
<li>单个目录项可能跨越多个页面，因此在读取文件名时可能发生页面错误</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目录项长度固定，有一个指针指向堆中的文件名，维护一个文件名堆</p>
</li>
</ol>
<h3 id="How-to-search-files-in-each-directory"><a class="header-anchor" href="#How-to-search-files-in-each-directory"></a>How to search files in each directory?</h3>
<ol>
<li>
<p>Linearly：遍历目录项，直到找到目标文件或扫描完所有目录项后未找到</p>
</li>
<li>
<p>Hash table：</p>
<ol>
<li>使用哈希函数将文件名映射到目录中的位置</li>
</ol>
</li>
<li>
<p>Cache the results of searches：用cache存储最近的搜索结果</p>
</li>
</ol>
<h2 id="共享文件"><a class="header-anchor" href="#共享文件"></a>共享文件</h2>
<p>共享文件技术可以允许文件出现在多个目录中，目录和共享文件之间的连接称为链接</p>
<p>这种文件系统是一个有向无环图</p>
<h3 id="出现的问题："><a class="header-anchor" href="#出现的问题："></a>出现的问题：</h3>
<ol>
<li>如果目录中包含磁盘地址，则当链接文件时，<strong>必须把 C 目录中的磁盘地址复制到 B 目录中</strong>。</li>
<li>如果 B 或者 C 随后又向文件中添加内容，则<strong>仅在执行追加的用户的目录中显示新写入的数据块</strong>。这种变更将会对其他用户不可见，从而破坏了共享的目的。</li>
</ol>
<h3 id="解决措施："><a class="header-anchor" href="#解决措施："></a>解决措施：</h3>
<h4 id="硬链接-hard-link"><a class="header-anchor" href="#硬链接-hard-link"></a>硬链接 hard link</h4>
<p>磁盘块地址不列入目录，而是把磁盘块放入一个小型数据结构（即inode）中。目录的目录项指向这个小型的数据结构</p>
<p><strong>指向相同的 inode</strong>：硬链接是指向相同 inode 的多个目录条目。这意味着它们共享同一个文件数据块和属性（如权限、大小、修改时间等）。</p>
<p><strong>文件内容共享</strong>：硬链接共享同一个文件内容。修改其中一个硬链接的内容，其他硬链接的内容也会相应改变。</p>
<p><strong>存储在同一文件系统</strong>：硬链接只能在同一文件系统内创建，不能跨文件系统。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917130.png" alt="image-20240615202621306" style="zoom:67%;" /> 
<h4 id="软链接-soft-symbolic-link"><a class="header-anchor" href="#软链接-soft-symbolic-link"></a>软链接 soft/symbolic link</h4>
<p>一个目录的目录项指向文件的 i节点，</p>
<p><strong>其他目录指向文件路径</strong>：软链接是一个独立的文件，包含指向另一个文件或目录的路径。它类似于快捷方式。</p>
<p><strong>链接数不变</strong>：创建软链接不会改变源文件的链接计数，因为软链接是一个独立的文件。</p>
<p><strong>可以跨文件系统</strong>：软链接可以跨越不同的文件系统创建。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917541.png" alt="image-20240615202608231" style="zoom:67%;" /> 
<h3 id="对比总结"><a class="header-anchor" href="#对比总结"></a>对比总结</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>硬链接 (Hard Link)</th>
<th>软链接 (Soft Link)</th>
</tr>
</thead>
<tbody>
<tr>
<td>指向目标</td>
<td>相同的 inode</td>
<td>目标文件或目录的路径</td>
</tr>
<tr>
<td>可链接对象</td>
<td>文件</td>
<td>文件和目录</td>
</tr>
<tr>
<td>链接计数</td>
<td>创建或删除硬链接会改变链接计数</td>
<td>创建或删除软链接不会改变链接计数</td>
</tr>
<tr>
<td>跨文件系统</td>
<td>否，只能在同一文件系统内</td>
<td>是，可以跨越不同的文件系统</td>
</tr>
<tr>
<td>悬空链接</td>
<td>无，文件内容总是可访问</td>
<td>有，如果目标文件被删除，软链接会变成悬空链接</td>
</tr>
<tr>
<td>文件内容共享</td>
<td>是，所有硬链接共享相同的文件内容</td>
<td>否，软链接只是一个指向目标文件的路径，修改软链接不影响目标文件</td>
</tr>
</tbody>
</table>
<h2 id="磁盘空间管理"><a class="header-anchor" href="#磁盘空间管理"></a>磁盘空间管理</h2>
<h3 id="位图法和链表法"><a class="header-anchor" href="#位图法和链表法"></a>位图法和链表法</h3>
<ol>
<li>位图需要的空间较少</li>
<li>只有当磁盘接近满时(即，只有很少的空闲块)，链表方案才会比位图方案需要更少的块</li>
</ol>
<p>我们可以保留第一个空闲块的地址和第一个块后面的空闲连续块的数目，而不是保留n个空闲磁盘地址的列表。</p>
<h2 id="文件系统的可靠性"><a class="header-anchor" href="#文件系统的可靠性"></a>文件系统的可靠性</h2>
<h3 id="备份"><a class="header-anchor" href="#备份"></a>备份</h3>
<p>为了防止误删，需要进行文件的恢复</p>
<p><strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p>
<p>一种<code>增量转储(incremental dumps)</code></p>
<p>最常见的增量转储：</p>
<ol>
<li><code>周期性</code>的做全面的备份，每天只对增量转储完成后发生变化的文件做单个备份。</li>
<li>只备份最近一次转储以来更改过的文件。极大的缩减了转储时间</li>
</ol>
<h3 id="两种转储方案"><a class="header-anchor" href="#两种转储方案"></a>两种转储方案</h3>
<p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。</p>
<ul>
<li><code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</li>
<li><code>逻辑转储(logical dump)</code>从一个或几个指定的目录开始，递归转储自指定日期开始后更改的文件和目录。因此，在逻辑转储中，转储磁盘上有一系列经过仔细识别的目录和文件，这使得根据请求轻松还原特定文件或目录可以实现。</li>
</ul>
<p>需要维持一个 inode 为索引的<code>位图(bitmap)</code>，每个 inode 包含了几位。随着算法的进行，位图中的这些位会被设置或清除。</p>
<h3 id="一致性"><a class="header-anchor" href="#一致性"></a>一致性</h3>
<p>如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p>
<p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。</p>
<h4 id="块的一致性"><a class="header-anchor" href="#块的一致性"></a>块的一致性</h4>
<p>为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。</p>
<p>第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917295.png" alt="image-20240620003755666"></p>
<p>missing block时：在freelist加上1即可</p>
<p>duplicate freelist block 冗余空闲块，在freelist数字为2时，将数字重置为1即可</p>
<p>duplicate data block 冗余的数据块，重新分配一个块，将冗余的块复制进新的块当中，并放进文件当中，将冗余的块释放</p>
<p>既在free list又在 file data 当中：则将freelist设置为0即可。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917831.png" alt="image-20240615225950918"></p>
<h4 id="文件的一致性"><a class="header-anchor" href="#文件的一致性"></a>文件的一致性</h4>
<h3 id="Unix中文件系统的介绍"><a class="header-anchor" href="#Unix中文件系统的介绍"></a>Unix中文件系统的介绍</h3>
<p>组织形式为从根开始的树</p>
<p>文件名最多14个字符，可以包含除/和NUL以外的任何ASCII字符</p>
<p>每个目录条目有两个字段</p>
<p>文件名，以及该文件的i-node的#(2字节)</p>
<p>文件系统中的文件数量限制为64K</p>
<p>多级inode：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917220.png" alt="image-20240620004838451"></p>
<h1 id="I-O"><a class="header-anchor" href="#I-O"></a>I/O</h1>
<h2 id="I-O软件的目的"><a class="header-anchor" href="#I-O软件的目的"></a>I/O软件的目的</h2>
<h3 id="设备独立性"><a class="header-anchor" href="#设备独立性"></a>设备独立性</h3>
<p>意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。无需为每一个特定的设备制定应用程序，而可以实现一套应用程序给每一种接入的I/O设备使用</p>
<h3 id="统一命名-uniform-naming"><a class="header-anchor" href="#统一命名-uniform-naming"></a>统一命名(uniform naming)</h3>
<p>设备的代号应该是一个整数或者是字符串，它们不应该依赖于具体的设备。</p>
<h3 id="错误处理"><a class="header-anchor" href="#错误处理"></a>错误处理</h3>
<p>通常情况下来说，错误应该交给<code>硬件</code>层面去处理。</p>
<h3 id="同步和异步传输"><a class="header-anchor" href="#同步和异步传输"></a>同步和异步传输</h3>
<p><strong>同步传输</strong>：数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。</p>
<p><strong>异步传输</strong>：数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。</p>
<p>同步和异步特点对比：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917464.png" alt="image-20240615233213566"></p>
<h3 id="缓冲-buffering"><a class="header-anchor" href="#缓冲-buffering"></a>缓冲 buffering</h3>
<p>从一个设备发出的数据不会直接到达最后的设备。</p>
<h3 id="共享和独占"><a class="header-anchor" href="#共享和独占"></a>共享和独占</h3>
<p>有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p>
<h2 id="三种控制I-O设备的方法"><a class="header-anchor" href="#三种控制I-O设备的方法"></a>三种控制I/O设备的方法</h2>
<h3 id="程序控制I-O-可编程I-O"><a class="header-anchor" href="#程序控制I-O-可编程I-O"></a>程序控制I/O &amp; 可编程I/O</h3>
<p>CPU 在等待时会采用</p>
<ol>
<li><code>轮询(polling)</code>去查看设备的状态寄存器去确定其状态：ready，busy，error；</li>
<li><code>忙等(busy waiting)</code> 的方式去等待 I/O ，浪费了CPU资源</li>
</ol>
<p>操作：</p>
<ul>
<li>CPU 请求 I/O 操作</li>
<li>I/O 模块执行响应</li>
<li>I/O 模块设置状态位</li>
<li>CPU 会定期检查状态位</li>
<li>I/O 不会直接通知 CPU 操作完成</li>
<li>I/O 也不会中断 CPU</li>
<li>CPU 可能会等待或在随后的过程中返回</li>
</ul>
<h3 id="中断驱动I-O"><a class="header-anchor" href="#中断驱动I-O"></a>中断驱动I/O</h3>
<p>鉴于上面可编程 I/O 的缺陷，我们提出一种改良方案，我们想要在 CPU 等待 I/O 设备的同时，能够做其他事情，等到 I/O 设备完成后，它就会产生一个中断，这个中断会停止当前进程并保存当前的状态。</p>
<p>由CPU主动询问I/O设备是否使用改为由I/O设备主动通知CPU自己准备就绪</p>
<h3 id="使用-DMA-的-I-O"><a class="header-anchor" href="#使用-DMA-的-I-O"></a>使用 DMA 的 I/O</h3>
<p>Directed Memory Access</p>
<p>CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。</p>
<p>也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。</p>
<h2 id="I-O的层次结构"><a class="header-anchor" href="#I-O的层次结构"></a>I/O的层次结构</h2>
<ol>
<li>用户级的I/O软件 用户空间 做I/O调用；匹配I/O；假脱机</li>
<li>与设备无关的I/O软件 内核空间 命名、保护、阻塞、缓冲、分配</li>
<li>设备驱动 内核空间 设置设备寄存器、检查状态</li>
<li>中断处理程序Interrupt Handlers 内核空间 I/O完成时唤醒驱动程序</li>
<li>硬件 执行I/O操作</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917266.png" alt="image-20240620011403292"></p>
<h3 id="中断处理程序"><a class="header-anchor" href="#中断处理程序"></a>中断处理程序</h3>
<p>当中断发生时，CPU保存少量状态并跳转到内存中固定地址的中断处理程序例程。</p>
<p>中断完成后，必须在软件中执行步骤</p>
<ol>
<li>保存未被中断硬件保存的regs</li>
<li>为中断服务过程设置上下文:TLB、MMU和页表等。</li>
<li>为中断服务程序建立堆栈</li>
<li>Ack中断控制器，重新启用中断</li>
<li>从保存到进程表的地方复制寄存器</li>
<li><strong>运行服务流程</strong></li>
<li>选择接下来要运行的进程。</li>
<li>为接下来要运行的进程设置MMU上下文</li>
<li>加载新的进程寄存器</li>
<li>开始运行新进程</li>
</ol>
<h3 id="设备驱动"><a class="header-anchor" href="#设备驱动"></a>设备驱动</h3>
<h4 id="功能："><a class="header-anchor" href="#功能："></a>功能：</h4>
<ol>
<li>接受来自OS其他部分（与设备无关的部分）的抽象读写请求
<ol>
<li>把抽象的术语转换成具体的术语</li>
</ol>
</li>
<li>根据需要初始化设备</li>
<li>检查设备当前是否正用于其他请求
<ol>
<li>如果是，将请求加入队列中,等待后续的处理。</li>
<li>如果此时设备是空闲的，驱动程序会检查硬件以了解请求是否能够被处理</li>
</ol>
</li>
<li>发出命令序列去控制设备</li>
<li>检查错误</li>
</ol>
<p>操作系统通常会将驱动程序归为 <code>字符设备 character device</code> 和 <code>块设备 block device</code></p>
<h3 id="与设备无关的I-O软件"><a class="header-anchor" href="#与设备无关的I-O软件"></a>与设备无关的I/O软件</h3>
<p>设备驱动程序和与设备无关的软件之间的界限因系统和设备而异</p>
<h4 id="功能：-v2"><a class="header-anchor" href="#功能：-v2"></a>功能：</h4>
<ol>
<li>
<p>设备驱动程序的统一接口</p>
<ol>
<li>好处：<br>
1.</li>
</ol>
</li>
<li>
<p>缓冲</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917841.png" alt="image-20240616002652933" style="zoom: 67%;" /> 
<ol>
<li>未缓冲的输入</li>
<li>用户空间缓冲</li>
<li>在内核中进行缓冲，然后复制到用户空间</li>
<li>内核中的双缓冲</li>
</ol>
</li>
<li>
<p>错误报告</p>
</li>
<li>
<p>分配和释放专用设备</p>
</li>
<li>
<p>提供与设备无关的块大小<br>
不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。<br>
该层可以隐藏不同磁盘的物理扇区大小，并可以为更高层(如文件系统)提供固定和统一的磁盘块大小</p>
</li>
</ol>
<h2 id="磁光盘"><a class="header-anchor" href="#磁光盘"></a>磁光盘</h2>
<p>磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p>
<p>在磁盘中，数据是<strong>随机访问</strong>的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，</p>
<p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917949.png" alt="image-20240616003252754" style="zoom: 67%;" />
<h3 id="格式化"><a class="header-anchor" href="#格式化"></a>格式化</h3>
<p>磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，</p>
<p>一个扇区的格式： <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917074.png" alt="image-20240616003606843"></p>
<p>前导码相当于是标示扇区的开始位置，还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。</p>
<p>数据区</p>
<p>ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，可以被用于恢复读错误</p>
<h3 id="柱面斜进-cylinder-skew："><a class="header-anchor" href="#柱面斜进-cylinder-skew："></a>柱面斜进 cylinder skew：</h3>
<p>低级格式化后的每个 0 扇区的位置都和前一个磁道存在<code>偏移</code>：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917584.png" alt="image-20240616003753435"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917332.png" alt="image-20240616003939044"></p>
<p>如果不采用这种方式，可能刚好磁头寻址到外侧，0 号扇区已经转过了磁头，所以需要旋转一圈才能等到它继续读取，通过柱面斜进的方式可以消除这一问题。</p>
<p>磁头也会存在<code>斜进(head skew)</code>，但是磁头斜进比较小。</p>
<p>计算柱面斜进：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917585.png" alt="image-20240616004859656" style="zoom:67%;" /> 
<p>硬盘每分钟7200转，则有一转需要的时间为：60*1000/7200 = 100/12 ms/转</p>
<p>每一转会扫过200片扇区，1/200 转/片 则每一片扇区所用时间为：100/12 * 1/200 = 1/24 ms/片</p>
<p>则说明每毫秒转过片数：24片/ms</p>
<h3 id="交叉"><a class="header-anchor" href="#交叉"></a>交叉</h3>
<ol>
<li>No interleaving</li>
<li>Single interleaving</li>
<li>Double interleaving</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917283.png" alt="image-20240620011716979"></p>
<h3 id="磁盘臂调度算法"><a class="header-anchor" href="#磁盘臂调度算法"></a>磁盘臂调度算法</h3>
<h4 id="FIFO"><a class="header-anchor" href="#FIFO"></a>FIFO</h4>
<h4 id="SSF-short-seek-first"><a class="header-anchor" href="#SSF-short-seek-first"></a>SSF short seek first</h4>
<p>每次找离自己最近的那个节点，一个贪心</p>
<h4 id="电梯调度"><a class="header-anchor" href="#电梯调度"></a>电梯调度</h4>
<h1 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h1>
<h2 id="资源"><a class="header-anchor" href="#资源"></a>资源</h2>
<p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p>
<h3 id="可抢占资源和不可抢占资源"><a class="header-anchor" href="#可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3>
<p><code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p>
<p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p>
<p>死锁与不可抢占资源有关，虽然抢占式资源也会造成死锁，不过这种情况的解决办法通常是在进程之间重新分配资源来化解。所以，我们的重点自然就会放在了不可抢占资源上。</p>
<h2 id="死锁-v2"><a class="header-anchor" href="#死锁-v2"></a>死锁</h2>
<p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p>
<h3 id="资源死锁："><a class="header-anchor" href="#资源死锁："></a>资源死锁：</h3>
<p>死锁进程结合中的每个进程都在等待另一个死锁进程已经占有的资源。但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒。</p>
<h3 id="资源死锁的条件"><a class="header-anchor" href="#资源死锁的条件"></a>资源死锁的条件</h3>
<p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>Mutual Exclusion 互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>Hold and Wait 保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>No Preemption 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>Circular Wait 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>四个条件同时成立，才可以发生死锁，缺一不可</p>
<p>如果一个资源分配图没有环，一定没有死锁</p>
<p>如果有环：</p>
<ol>
<li>如果每种资源仅有一个实例，则死锁</li>
<li>如果每种资源有多个实例，则不一定会死锁</li>
</ol>
<h2 id="四种解决方法"><a class="header-anchor" href="#四种解决方法"></a>四种解决方法</h2>
<h3 id="Ostrich-Algorithm-鸵鸟算法"><a class="header-anchor" href="#Ostrich-Algorithm-鸵鸟算法"></a>Ostrich Algorithm 鸵鸟算法</h3>
<p>忽视死锁的问题。</p>
<h3 id="死锁检测-Detection-与恢复"><a class="header-anchor" href="#死锁检测-Detection-与恢复"></a>死锁检测 Detection 与恢复</h3>
<p>不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。</p>
<p>构造两个数组：</p>
<ol>
<li>C 表示的是<code>当前分配矩阵(current allocation matrix)</code>，
<ol>
<li>Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量</li>
</ol>
</li>
<li>R 表示的是 <code>请求矩阵(request matrix)</code>
<ol>
<li>Rij 表示 Pi 所需要获得的资源 j 的数量</li>
</ol>
</li>
</ol>
<h4 id="通过抢占进行恢复"><a class="header-anchor" href="#通过抢占进行恢复"></a>通过抢占进行恢复</h4>
<p>可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>
<h4 id="通过回滚进行恢复"><a class="header-anchor" href="#通过回滚进行恢复"></a>通过回滚进行恢复</h4>
<ol>
<li>可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。</li>
<li>一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</li>
</ol>
<h4 id="杀死进程恢复"><a class="header-anchor" href="#杀死进程恢复"></a>杀死进程恢复</h4>
<ol>
<li>
<p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
</li>
<li>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
</li>
</ol>
<h3 id="避免死锁"><a class="header-anchor" href="#避免死锁"></a>避免死锁</h3>
<h4 id="单个资源的银行家算法"><a class="header-anchor" href="#单个资源的银行家算法"></a>单个资源的银行家算法</h4>
<p>Safe and Unsafe States</p>
<p>关键是使得每次分配完资源后，至少有一个人的need资源数量小于或等于空闲的资源数量</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011917963.png" alt="image-20240616014126355"></p>
<p>如图，（a）是安全状态，因为B的need为4-2=2小于3，意味着我可以填满他的Max，并让B顺利结束进程</p>
<p>从而找到一条进程依次结束退出的序列</p>
<p>！！！需要注意，进入不安全状态不意味着就一定会死锁，因为进程不一定会使用到MAX的资源，但是银行家算法按照最坏情况去考虑，确保不出现死锁</p>
<h4 id=""><a class="header-anchor" href="#"></a></h4>
<h3 id="死锁预防"><a class="header-anchor" href="#死锁预防"></a>死锁预防</h3>
<p>破坏死锁条件即可</p>
<h4 id="破坏互斥条件"><a class="header-anchor" href="#破坏互斥条件"></a>破坏互斥条件</h4>
<p>如果资源不被一个进程独占，则不会发生死锁。</p>
<ol>
<li>某些设备可以假脱机，如打印机
<ol>
<li>只有打印机守护进程使用打印机资源</li>
<li>打印机守护进程没有请求其他资源</li>
<li>因此打印机死锁消除</li>
</ol>
</li>
</ol>
<p>但是脱机空间是有限的，所以死锁还是有可能会发生，例如两个进程各自占用了一半的脱机空间</p>
<h4 id="破坏保持和等待的条件"><a class="header-anchor" href="#破坏保持和等待的条件"></a>破坏保持和等待的条件</h4>
<p>如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。</p>
<ol>
<li>一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束</li>
<li>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</li>
</ol>
<h4 id="破坏不可抢占条件"><a class="header-anchor" href="#破坏不可抢占条件"></a>破坏不可抢占条件</h4>
<p>这一条件可以通过强制抢占来打破</p>
<p>通过虚拟化的方式：还是假脱机，如 将打印机输出假脱机到磁盘</p>
<h4 id="破坏循环等待条件"><a class="header-anchor" href="#破坏循环等待条件"></a>破坏循环等待条件</h4>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数据库期末复习"><a class="header-anchor" href="#数据库期末复习"></a>数据库期末复习</h1>
<h2 id="CH1-DBMS"><a class="header-anchor" href="#CH1-DBMS"></a>CH1 DBMS</h2>
<p>相关数据的集合<br>
访问数据的程序集<br>
方便高效的使用环境</p>
<h3 id="文件系统来存储数据的缺点："><a class="header-anchor" href="#文件系统来存储数据的缺点："></a>文件系统来存储数据的缺点：</h3>
<ol>
<li>数据冗余和不一致性
<ul>
<li>多种文件格式：即同一个文件夹内存在多种存储数据的文件格式，其中存储的数据信息可能都相同只是因为文件格式不同导致了冗余</li>
<li>复制不同文件中的信息：不同文件之间进行数据查拷贝时，容易出现数据不一致的现象</li>
</ul>
</li>
<li>访问数据困难
<ul>
<li>需要编写一个新的程序来执行每一个新的任务：文件系统对于用户来说缺乏一个统一的接口来进行数据的访问和操作。</li>
</ul>
</li>
<li>数据隔离————多种文件和格式</li>
<li>完整性问题
<ul>
<li>完整性约束（例如，帐户余额&gt; 0）被“隐藏”在程序代码中，而不是被显式地声明</li>
<li>很难添加新的约束条件或更改现有的约束条件</li>
</ul>
</li>
<li>更新的原子性
<ul>
<li>失败可能会使数据库处于不一致的状态，并执行了部分更新</li>
</ul>
</li>
<li>由多个用户的并发访问
<ul>
<li>执行性能所需的并发访问权限</li>
<li>不受控制的并发访问可能会导致不一致</li>
</ul>
</li>
<li>安全问题
<ul>
<li>难以限制用户对数据的访问范围</li>
</ul>
</li>
</ol>
<h3 id="抽象层级-Abstraction-Levels"><a class="header-anchor" href="#抽象层级-Abstraction-Levels"></a>抽象层级 Abstraction Levels</h3>
<ul>
<li><strong>Physical Level</strong>物理层：描述在物理硬件层次上，一条数据记录是如何存储，涉及实际的存储介质和数据结构，比如硬盘、SSD、数据块等。</li>
<li><strong>Logical Level</strong>逻辑层：概念性地描述数据存储在数据库中，且阐明数据间的关系，关注的是数据的结构和组织方式</li>
<li><strong>View Level</strong>视图层：对逻辑层进行封装，仅仅暴露出用户可理解的视觉层面的应用程序，隐藏了数据类型的细节、也隐藏了数据信息（为了安全性）</li>
<li>图例：</li>
</ul>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251158.png" alt="image-20241102115006858" style="zoom: 50%;" />
<h3 id="Schemas-and-Instances-实例和模式"><a class="header-anchor" href="#Schemas-and-Instances-实例和模式"></a>Schemas and Instances 实例和模式</h3>
<blockquote>
<p>类似于编程语言中的类型和变量</p>
</blockquote>
<p><strong>Schemas 模式</strong>：对数据库的逻辑结构的定义，描述数据的组织方式，如table，filed，data type，constraint。相当于抽象类</p>
<p><strong>Instance 实例</strong>：数据库在某一特定时间的实例</p>
<p><strong>Physical Data Independence 物理数据独立性</strong>：指在数据库系统中，用户和应用程序不需要关注数据的物理存储方式或存储介质的变化，即使底层存储的实现发生变化，应用程序和用户依然可以按照原有的方式访问和操作数据。通俗来讲即是，只要有数据库的文件 xxx.db 即使换了一台电脑，在那台电脑上数据的存储在完全不同的物理硬件上，但是依旧可以像在原来的电脑上去操作数据库，而不需要担心物理硬件的改变会对数据库产生影响</p>
<h3 id="Data-Model-数据模型"><a class="header-anchor" href="#Data-Model-数据模型"></a>Data Model 数据模型</h3>
<ul>
<li><strong>Data（数据）</strong>：指的是需要存储和管理的信息。数据模型提供了描述这些数据的结构和类型的方法，例如数字、文本、日期等。</li>
<li><strong>Data relationships（数据关系）</strong>：指的是数据之间的关联或联系。数据模型定义了不同数据实体之间的关系，例如一对一、一对多或多对多的关系。这些关系帮助理解和组织数据的结构，使得数据能够相互关联。</li>
<li><strong>Data semantics（数据语义）</strong>：指的是数据的含义或解释。数据模型不仅描述数据的结构和关系，还定义了数据的业务含义，确保数据的使用者能够正确理解和使用这些数据。例如，一个“客户”实体的语义可以包括客户的姓名、地址和联系方式等信息。</li>
<li><strong>Data constraints（数据约束）</strong>：指的是对数据的限制或规则，以确保数据的有效性和一致性。数据模型定义了可以存储的数据类型、数据值的范围、唯一性约束等。这些约束确保了数据的完整性，防止无效或错误的数据被存储。</li>
</ul>
<h3 id="Relational-Model（关系模型）"><a class="header-anchor" href="#Relational-Model（关系模型）"></a>Relational Model（关系模型）</h3>
<p>关系模型的几个关键特征：</p>
<ol>
<li><strong>表（关系）</strong>：数据以表的形式存储，每个表由行和列组成。每一行代表一个数据记录（或元组），每一列代表一个属性（或字段）。表的结构是固定的，即每个表都有预定义的列及其数据类型。</li>
<li><strong>主键</strong>：每个表都有一个主键，用于唯一标识表中的每一行数据。主键确保每条记录的唯一性，通常由一个或多个字段组合而成。</li>
<li><strong>外键</strong>：外键是一个表中的一个字段，它引用另一个表的主键，从而建立两个表之间的关系。外键使得不同表之间的数据能够相互关联。</li>
<li><strong>数据完整性</strong>：关系模型通过定义约束（如主键约束、外键约束、唯一性约束等）来确保数据的完整性和一致性。这些约束防止了无效数据的插入和更新。</li>
<li><strong>关系操作</strong>：关系模型支持多种操作，包括选择（SELECT）、插入（INSERT）、更新（UPDATE）和删除（DELETE）。这些操作通常通过结构化查询语言（SQL）来实现。</li>
<li><strong>抽象性</strong>：关系模型提供了物理数据独立性，用户可以通过逻辑结构访问数据，而无需关心数据的物理存储细节。</li>
</ol>
<h3 id="DML-数据操作语言"><a class="header-anchor" href="#DML-数据操作语言"></a>DML 数据操作语言</h3>
<p>什么是<strong>Data Manipulation Language (DML)</strong>：被定义来用于访问和操作数据的一种语言</p>
<p><strong>DML的两类语言</strong></p>
<ul>
<li><strong>Procedural 过程式</strong>：用户指定需要哪些数据以及如何获取这些数据</li>
<li><strong>Declarative 声明式</strong>：用户指定需要哪些数据，而不指定如何获取这些数据，SQL即是声明式<strong>Declarative</strong></li>
</ul>
<h4 id="SQL"><a class="header-anchor" href="#SQL"></a>SQL</h4>
<p>例：查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> <span class="string">&#x27;22222</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>应用程序通常通过以下方式之一访问数据库：</p>
<ol>
<li>允许嵌入 SQL 的语言扩展 应用程序接口（例如 ODBC/JDBC）</li>
<li>允许将 SQL 查询发送到数据库</li>
</ol>
<h3 id="DDL-数据定义语言"><a class="header-anchor" href="#DDL-数据定义语言"></a>DDL 数据定义语言</h3>
<p>什么是<strong>Data Definition Language (DDL)</strong>：用于定义数据库模式的规范表示法</p>
<p><strong>DDL Compiler（DDL编译器）</strong>：DDL编译器是负责处理数据定义语言语句的组件。当用户使用DDL命令（如创建表、修改表结构等）时，DDL编译器会解析这些命令并生成相应的<strong>表模板</strong>。</p>
<p><strong>Table Templates（表模板）</strong>：表模板是对数据库表结构的定义，包括表名、列名、数据类型、约束等信息。DDL编译器会根据用户输入的DDL语句创建这些模板，表明数据将以何种结构存储。</p>
<p><strong>Data Dictionary（数据字典）</strong>：数据字典是数据库中的一个特殊存储区域，用于保存数据库的元数据（metadata）。</p>
<ul>
<li>元数据是关于数据的数据，它描述了数据库中数据的
<ul>
<li>数据库模式 database schema</li>
<li>完整性约束 integrity constraints，如：Primary key，Referential integrity</li>
<li>权限信息</li>
</ul>
</li>
</ul>
<p><strong>Metadata（元数据）</strong>：元数据包含有关数据的数据。例如，元数据可以包括表的名称、列的名称和数据类型、索引、约束、视图、存储过程等信息。这些信息帮助数据库管理系统和用户理解数据的组织方式和结构。</p>
<h3 id="数据库设计"><a class="header-anchor" href="#数据库设计"></a>数据库设计</h3>
<ul>
<li><strong>归一化理论</strong>
<ul>
<li>正式确定哪些设计不好，并对其进行测试</li>
</ul>
</li>
<li><strong>实体关系模型</strong></li>
</ul>
<h3 id="存储管理-storage-management"><a class="header-anchor" href="#存储管理-storage-management"></a>存储管理 storage management</h3>
<ul>
<li>存储管理器是一个程序模块，它提供存储在数据库中的</li>
<li>低级数据与提交给系统的应用程序和查询之间的接口。</li>
<li>存储管理器负责以下任务：
<ul>
<li>与文件管理器交互</li>
<li>高效存储、检索和更新数据</li>
</ul>
</li>
<li>需要解决的问题：
<ul>
<li>存储访问</li>
<li>文件组织</li>
<li>索引和散列</li>
</ul>
</li>
</ul>
<h3 id="查询处理-query-processing"><a class="header-anchor" href="#查询处理-query-processing"></a>查询处理 query processing</h3>
<ol>
<li>sql翻译</li>
<li>优化</li>
<li>执行</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251739.png" alt="Query Processing"></p>
<ul>
<li>评估给定查询的替代方法
<ul>
<li>等价表达式</li>
<li>每个操作都有不同的算法</li>
</ul>
</li>
<li>评估查询的好方法和坏方法之间的成本差异可能是巨大的</li>
<li>需要估算运营成本
<ul>
<li>很大程度上取决于数据库必须维护的关系的统计信息</li>
<li>需要估计中间结果的统计数据以计算复杂表达式的成本</li>
</ul>
</li>
</ul>
<h3 id="事务管理-transaction-management"><a class="header-anchor" href="#事务管理-transaction-management"></a>事务管理 transaction management</h3>
<ul>
<li>如果系统出现故障怎么办？</li>
<li>如果多个用户同时更新相同的数据怎么办？</li>
<li>事务是在数据库应用程序中执行单个逻辑功能的操作的集合</li>
<li>事务管理组件确保即使出现系统故障（例如电源故障和操作系统崩溃）和事务失败，数据库仍保持一致（正确）状态。</li>
<li>并发控制管理器控制并发事务之间的交互，以保证数据库的一致性。</li>
</ul>
<h3 id="数据库架构"><a class="header-anchor" href="#数据库架构"></a>数据库架构</h3>
<p>数据库系统的架构很大程度上取决于运行数据库的操作系统的架构</p>
<ul>
<li>集中</li>
<li>CS 架构(Client-Server)</li>
<li>并行（多处理器）</li>
<li>分布式</li>
</ul>
<h2 id="CH2-关系模型"><a class="header-anchor" href="#CH2-关系模型"></a>CH2 关系模型</h2>
<h3 id="关系-Relation"><a class="header-anchor" href="#关系-Relation"></a>关系 Relation</h3>
<h4 id="属性值-Attribute-types"><a class="header-anchor" href="#属性值-Attribute-types"></a>属性值 Attribute types</h4>
<ul>
<li>每个属性允许的值集合称为属性的域(domain)。</li>
<li>属性值（通常）要求是原子(atomic)的，即不可分割的。</li>
<li>特殊值 null 是每个域的成员。</li>
<li>null 值在许多操作的定义中引起了复杂性。</li>
</ul>
<h4 id="关系模式和实例-relation-and-instance"><a class="header-anchor" href="#关系模式和实例-relation-and-instance"></a>关系模式和实例 relation and instance</h4>
<ul>
<li>关系模式是关系数据库中表的结构定义，它规定了表的列名、数据类型和约束条件。描述了表的属性和属性间的关系</li>
<li>关系实例是关系模式的具体实例化，即表中的具体数据。是由行和列组成的二维表格，每行代表一条记录，每列代表一种属性</li>
<li>总之，关系模式定义了表的结构；关系实例则是实际存储在表中的数据</li>
</ul>
<blockquote>
<ul>
<li>
<p>例如：A1是属性名，D1是A1的取值范围，a1是A1中的一个元素</p>
</li>
<li>
<p>A1,A2,A3,…,An就是属性(attribute)</p>
</li>
<li>
<p>R=(A1,A2,…,An)</p>
<p>是一个关系模式(relation schema)</p>
<ul>
<li>例如 instrutor=(ID,name,dept_name,salary)</li>
</ul>
</li>
<li>
<p>对于给定的若干个集合D1,D2,…,Dn，一个关系r是D1×D2×…×Dn的子集</p>
</li>
</ul>
</blockquote>
<h3 id="数据库"><a class="header-anchor" href="#数据库"></a>数据库</h3>
<ul>
<li>一个数据库由多个关系组成</li>
</ul>
<p>例：关于一个大学的信息被分解成不同部分，学生、教师、教室、课程安排…</p>
<h3 id="键-Key"><a class="header-anchor" href="#键-Key"></a>键 Key</h3>
<ul>
<li>设 K⊆R，(其中 R 是一个关系模式，由多个属性组成)。</li>
<li>如果 K 的值足以唯一标识每个可能的关系 r® 中的元组，则 K 是 R 的<code>超键(superkey)</code>。
<ul>
<li>例如，{ID} 和 {ID,name}都是 instructor 关系的超键。</li>
</ul>
</li>
<li>如果 K 是最小的超键，则 K 是<code>候选键(candidate key)</code>。
<ul>
<li>例如，{ID} 是 Instructor 的候选键。</li>
</ul>
</li>
<li>其中一个候选键被选为<code>主键(primary key)</code>。
<ul>
<li>哪一个是主键？</li>
</ul>
</li>
<li>外键约束(Foreign key)：一个关系中的值必须出现在另一个关系中。
<ul>
<li>引用关系(Referencing relation)：包含外键的关系。</li>
<li>被引用关系(Referenced relation)：被外键引用的关系。</li>
</ul>
</li>
</ul>
<h3 id="关系查询语言-relational-query-languages"><a class="header-anchor" href="#关系查询语言-relational-query-languages"></a>关系查询语言 relational query languages</h3>
<ul>
<li>过程式 procedural &amp;非过程式/声明式 non-procedural/declarative</li>
<li>“纯”语言：
<ul>
<li><code>关系代数 relational algebra</code></li>
<li>元组关系演算 tuple relational calculus</li>
<li>域关系演算 domain relational calculus</li>
</ul>
</li>
<li>关系操作符 relational operators</li>
</ul>
<ol>
<li>σ 选择操作符</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011251963.png" alt="Selection of tuples"></p>
<ol start="2">
<li>⊓ 投影操作符</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252420.png" alt=" Selection of Columns (Attributes)"></p>
<ol start="3">
<li>X 笛卡尔积</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252013.png" alt="Joining two relations – Cartesian Product"></p>
<ol start="4">
<li>∪ 并运算</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252795.png" alt=" Union of two relations"></p>
<ol start="5">
<li>
<ul>
<li>差运算</li>
</ul>
</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252918.png" alt="Set difference of two relations"></p>
<ol start="6">
<li>∩ 交运算</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252947.png" alt=" Set Intersection of two relations"></p>
<blockquote>
<p>合并两个关系 - 自然连接</p>
<ul>
<li>假设 <em>r</em> 和 <em>s</em> 是分别基于模式 <em>R</em> 和 <em>S</em> 的关系。那么，关系 R 和 S 的“自然连接”是基于模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R ∪ S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的关系，过程如下：
<ul>
<li>对于 <em>r</em> 中的每个元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <em>s</em> 中的每个元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，考虑每对元组。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R∩S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中的每个属性上有相同的值，则将一个元组 t 添加到结果中。其中：
<ul>
<li>t 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​在 <em>r</em> 上有相同的值</li>
<li>t 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在 <em>s</em> 上有相同的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>简而言之，自然连接操作是基于两个关系中共同属性的值相等的元组进行并。结果是一个新的关系，包含了具有相同共同属性值的元组。</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252536.png" alt="Natural Join Example"></p>
<h4 id="关系代数总览"><a class="header-anchor" href="#关系代数总览"></a>关系代数总览</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252183.png" alt="Relational algebra"></p>
<h2 id="CH3-SQL"><a class="header-anchor" href="#CH3-SQL"></a>CH3 SQL</h2>
<h3 id="SQL-DDL"><a class="header-anchor" href="#SQL-DDL"></a>SQL DDL</h3>
<ul>
<li>SQL 数据定义语言 data-definition language ,DDL 允许指定关于关系的信息，包括：
<ul>
<li>每个关系的模式。</li>
<li>每个属性关联的值域。</li>
<li>完整性约束。</li>
<li>此外，我们稍后将看到，还可以包括其他信息，例如：
<ul>
<li>每个关系要维护的索引集合。</li>
<li>每个关系的安全性和授权信息。</li>
<li>每个关系在磁盘上的物理存储结构。</li>
</ul>
</li>
</ul>
</li>
<li>简而言之，SQL 的数据定义语言（DDL）提供了一种定义关系的信息的方式，包括关系模式、属性的值域以及与关系相关的完整性约束等。它还允许指定索引、安全性和授权信息以及关系在磁盘上的物理存储结构。</li>
</ul>
<h2 id="CH6-形式关系查询语言"><a class="header-anchor" href="#CH6-形式关系查询语言"></a>CH6 形式关系查询语言</h2>
<h3 id="分类"><a class="header-anchor" href="#分类"></a>分类</h3>
<p>关系代数（Relational Algebra）、元组关系演算（Tuple Relational Calculus）和域关系演算（Domain Relational Calculus）是用于关系数据库的不同查询语言和形式。它们的主要区别如下：</p>
<ol>
<li>关系代数（Relational Algebra）：<br>
关系代数是一种基于集合论的查询语言，用于操作关系数据库中的关系。它使用一组操作符，如选择（selection）、投影（projection）、连接（join）、并（union）、差（difference）等来执行关系操作。关系代数提供了一种形式化的方法来描述和操作关系数据库中的关系。</li>
<li>元组关系演算（Tuple Relational Calculus）：<br>
元组关系演算是一种基于逻辑的查询语言，用于描述关系数据库中的查询。它使用逻辑谓词（predicate）来描述所需的元组集合。元组关系演算的查询结果是满足指定谓词的关系中的元组集合。元组关系演算描述了所需的结果，而不是如何计算结果。</li>
<li>域关系演算（Domain Relational Calculus）：<br>
域关系演算也是一种基于逻辑的查询语言，用于描述关系数据库中的查询。它使用逻辑谓词来描述所需的属性集合。域关系演算的查询结果是满足指定谓词的关系中的属性集合。域关系演算描述了所需的属性，而不是如何计算结果。</li>
</ol>
<h3 id="关系代数-relational-algebra"><a class="header-anchor" href="#关系代数-relational-algebra"></a>关系代数 relational algebra</h3>
<ul>
<li>过程语言(Procedural language)</li>
<li>六个基本运算子：
<ul>
<li>查询(Selection)：σ</li>
<li>投影(Projection)：Π</li>
<li>集合并(Union)：∪</li>
<li>差集(Set difference)：−</li>
<li>笛卡尔积(Cartesian product)：×</li>
<li>重命名(Reanme)：ρ</li>
</ul>
</li>
</ul>
<h3 id="六大基本运算符"><a class="header-anchor" href="#六大基本运算符"></a>六大基本运算符</h3>
<h4 id="查询-select"><a class="header-anchor" href="#查询-select"></a>查询 select</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252770.png" alt="Selction操作"></p>
<ul>
<li>基本形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">σ_p(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></li>
<li>p称为选择谓词，可以由多个独立的命题通过∧,∨等符号连接</li>
<li>被定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">σ_p(r)= \{t∣t∈r~and~p(t)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)}</span></span></span></span></li>
<li>例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><munder accentunder="true"><mrow></mrow><mo stretchy="true">‾</mo></munder><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><msup><mo>=</mo><mi mathvariant="normal">&quot;</mi></msup><mi>P</mi><mi>h</mi><mi>y</mi><mi>s</mi><mi>i</mi><mi>c</mi><msup><mi>s</mi><mi mathvariant="normal">&quot;</mi></msup><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">σ_{dept \underline{} name}=^&quot;Physics^&quot;(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1706em;vertical-align:-0.3215em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.85em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">pt</span><span class="mord underline mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em;"><span style="top:-2.804em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.245em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3215em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">&quot;</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ys</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">&quot;</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="投影-project"><a class="header-anchor" href="#投影-project"></a>投影 project</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252631.png" alt="Project操作"></p>
<ul>
<li>基本形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>α</mi><mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Π_{\alpha_1,\alpha_2,...\alpha_n}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li>
<li>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是属性名称，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>是关系名称</li>
<li>由于关系是集合，因此从结果中删除了重复行</li>
<li>例如： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Π_{ID,name,salary}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="集合并-union"><a class="header-anchor" href="#集合并-union"></a>集合并 union</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011252044.png" alt="Union操作"></p>
<ul>
<li>基本形式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∪</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r∪s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li>
<li>定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∪</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>t</mi><mo>∈</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r∪s = \{ t|t \in r~or~t\in s  \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace nobreak"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∪</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r∪s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>需要满足两个条件：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo separator="true">,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r,s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span></span></span></span>必须具有相同的属性数量 arity</li>
<li>属性域必须兼容（例如：r的第k列和s的第k列处理相同类型的值）</li>
</ul>
</li>
<li>例如，查找 2009 年秋季学期或 2010 年春季学期或两者都教授的所有课程：
<ul>
<li>Π_{course_id}(σ_{semester="Fall" \and year=2009(section)} ∪  Π_{course_id}(σ_{semester="Spring"\and year=2010(section)}))</li>
</ul>
</li>
</ul>
<h4 id="差集-Set-difference"><a class="header-anchor" href="#差集-Set-difference"></a>差集 Set difference</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253318.png" alt="Set difference"></p>
<ul>
<li>基本形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r-s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li>
<li>定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>t</mi><mo mathvariant="normal">∉</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r-s = \{ t|t\in r~and~t\notin s \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span></li>
<li>和集合并一样，必须有一样的属性数量和兼容的属性域</li>
</ul>
<h4 id="笛卡尔积-Cartesian-Product"><a class="header-anchor" href="#笛卡尔积-Cartesian-Product"></a>笛卡尔积 Cartesian-Product</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253737.png" alt="Cartesian-Product"></p>
<ul>
<li>基本形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r \times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li>
<li>定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>×</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo separator="true">,</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>q</mi><mo>∈</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r \times s=\{ t,q|t\in r~and~q\in s\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span></li>
<li>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>的属性是不相交的（即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">R∩S=\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span>）。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>的属性相交，则必须使用重命名</li>
</ul>
<h4 id="重命名-Rename"><a class="header-anchor" href="#重命名-Rename"></a>重命名 Rename</h4>
<h4 id="自然连接-Natural-join"><a class="header-anchor" href="#自然连接-Natural-join"></a>自然连接 Natural-join</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253535.png" alt="Natural-Join"></p>
<ul>
<li>
<p>基本形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋈</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r\bowtie s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></p>
</li>
<li>
<p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>分别是基于模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的关系。那么，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">r\bowtie S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>是基于模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R∪S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的关系，获取方式如下：</p>
<p>考虑每对元组 t：</p>
<ul>
<li>如果来自<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>的元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和来自<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>的元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R∩S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的每个属性上具有相同的值，则将一个元组 t 添加到结果中，
<ul>
<li>其中t在r上具有与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同的值;</li>
<li>t在s上具有与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同的值。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>在没有公共属性的情况下会退化成笛卡尔积</p>
</li>
<li>
<p>如：</p>
</li>
</ul>
<p>R=(A,B,C,D) \\ S=(E,B,D) \\ \mit Result~schema \mit = (A,B,C,D,E) \\
r \bowtie s = \begin{matrix} \prod_{r.A,r.B,r.C,r.D,r.E(\sigma_{r.B=s.B\and r.D=s.D}(r\times s))} \end{matrix}
</p>
<h4 id="连接-Theta-join"><a class="header-anchor" href="#连接-Theta-join"></a>连接 Theta join</h4>
<ul>
<li>定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><msub><mo>⋈</mo><mi>θ</mi></msub><mi>s</mi><mo>=</mo><msub><mi>σ</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>r</mi><mo>×</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \bowtie_{\theta} s = \sigma_{\theta}(r \times s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.655em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⋈</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></li>
<li>例：假设一个顾客顾客要购买一个车模和一个船模，但不想为船花费比车更多的钱。那么可以有$ car \bowtie_{car_pirce&lt;Boat_price}boat$</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>为等号时，又称为相等连接 equi join(基于两个表中列的值相等)</li>
</ul>
<h4 id="外连接-outer-join"><a class="header-anchor" href="#外连接-outer-join"></a>外连接 outer join</h4>
<blockquote>
<p>有left outer join 左外连接，左连接和 right outer join 右外连接，右连接</p>
</blockquote>
<ul>
<li>一种扩展的连接操作，避免了信息的丢失。</li>
<li>首先计算连接操作，然后将一方关系中与另一方关系中的元组不匹配的元组添加到连接结果中。</li>
<li>使用空值（null）：
<ul>
<li>空值表示值是未知的或不存在的。</li>
<li>所有涉及空值的比较（粗略地说）根据定义都是 false。</li>
<li>我们将在后面详细研究与空值的比较的确切含义。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253989.png" alt="Outer Join –Example"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253637.png" alt="Outer Join –Example2"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253741.png" alt="Outer Join –Example3"></p>
<blockquote>
<p>空值(Null Values)</p>
<ul>
<li>某些属性的元组可能具有空值（null）。</li>
<li>空值表示一个未知的值或值不存在。
<ul>
<li>任何涉及空值的算术表达式的结果都是空值。</li>
<li>聚合函数简单地忽略空值（与 SQL 中类似）。</li>
<li>在去重和分组中，空值被视为任何其他值，并且假设两个空值是相同的（与 SQL 中类似）。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>Join 之解析</p>
<ul>
<li>连接主要由连接方向、连接类型组成</li>
<li>连接方向包括：左右内外</li>
<li>连接类型包括：自然连接、ON 子句和 HAVING 子句</li>
</ul>
</blockquote>
<h2 id="CH7-实体关系模型-Entity-Relationship-Model"><a class="header-anchor" href="#CH7-实体关系模型-Entity-Relationship-Model"></a>CH7 实体关系模型 Entity-Relationship Model</h2>
<h3 id="建模"><a class="header-anchor" href="#建模"></a>建模</h3>
<ul>
<li>
<p>一个数据库可以被抽象建模为：</p>
<ul>
<li>实体集合</li>
<li>实体间的关系</li>
</ul>
<blockquote>
<p>即若干个实体与这些实体间的关系组成的一个抽象概念</p>
</blockquote>
</li>
</ul>
<h3 id="实体集"><a class="header-anchor" href="#实体集"></a>实体集</h3>
<ul>
<li><strong>实体 entity</strong> 是存在的对象，并且可与其他对象区分开</li>
<li>实体具有属性 attribute</li>
<li><strong>实体集 entity set</strong> 是一组具有相同属性的同类实体的集合</li>
</ul>
<h3 id="关系集"><a class="header-anchor" href="#关系集"></a>关系集</h3>
<ul>
<li><strong>关系 relationship</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><msub><mi>e</mi><mn>1</mn></msub><mo>∈</mo><msub><mi>E</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo>∈</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t=(e_1,...,e_n),~e_1 \in E_1,...,e_n \in E_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，是一种多个实体间的联系</li>
<li><strong>关系集 relationship set</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msub><mi>E</mi><mn>1</mn></msub><mo>×</mo><msub><mi>E</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L \subseteq E_1 \times E_2 \times ... \times E_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​，是一种多个实体之间的数学关系，关系集本身也具有属性。</li>
</ul>
<p>关系用方框，关系集拥椭圆</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253537.png" alt="Attribute of  Relationship Sets"></p>
<h4 id="关系集的度-degree"><a class="header-anchor" href="#关系集的度-degree"></a>关系集的度 degree</h4>
<ul>
<li>二元关系涉及两个实体集，度为2</li>
<li>在数据库系统中，大多数关系集是二元的，可以通过间接产生关系</li>
<li>两个以上实体集之间的关系较为少见</li>
</ul>
<h4 id="属性"><a class="header-anchor" href="#属性"></a>属性</h4>
<ul>
<li>实体由一组属性表示，属性是实体集的所有成员（记录）所具有的描述性特征。</li>
<li>域 domain —— 每个属性允许的取值范围（值域）</li>
<li>属性类型：
<ul>
<li>简单simple 属性和复合composite 属性</li>
<li>单值single-valued 属性和多值multi-valued 属性</li>
<li>派生derived 属性：可以从其他属性计算得出的，如age可以根据prod_date和now_date计算得出。</li>
</ul>
</li>
</ul>
<h4 id="映射基数约束-Mapping-Cardinality-Constrants"><a class="header-anchor" href="#映射基数约束-Mapping-Cardinality-Constrants"></a>映射基数约束 Mapping Cardinality Constrants</h4>
<ul>
<li>
<p>表达通过关系集可以将另一个实体关联到的实体数量。</p>
</li>
<li>
<p>在描述二元关系集时最有用。</p>
</li>
<li>
<p>对于二元关系集，映射基数必须是以下类型之一：</p>
<ul>
<li>一对一</li>
<li>一对多</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253891.png" alt="Mapping Cardinalities"></p>
<ul>
<li>多对一</li>
<li>多对多</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011253136.png" alt="Mapping Cardinalities"></p>
</li>
</ul>
<h4 id="键-Keys"><a class="header-anchor" href="#键-Keys"></a>键 Keys</h4>
<ul>
<li>
<p>实体集和<strong>超键super-key</strong>是一组一个或多个属性，其值可以唯一确定关系中的一个实体（记录）</p>
</li>
<li>
<p>实体集的<strong>候选词candidate-key</strong>是最小的超键</p>
<p>如：</p>
<ul>
<li>teacher_id是指导教师的候选词</li>
<li>course_id是课程的候选词</li>
</ul>
</li>
<li>
<p>虽然可能存在多个候选词，但是选择其他一个候选词作为<strong>主键primary-key</strong></p>
</li>
</ul>
<p><strong>基数映射关系中的主键选择</strong></p>
<p><strong>一对一关系</strong>：选择主表（或主数据表）中的候选键作为主键，附表可以通过外键引用主表的主键。</p>
<p><strong>一对多关系</strong>：选择&quot;一&quot;方的候选键作为主键，&quot;多&quot;方的表通过外键引用&quot;一&quot;方的主键。</p>
<p><strong>多对多关系</strong>：通过创建关联表，通常使用关联表中两个外键的组合作为联合主键，或者使用单独的主键。</p>
<h4 id="冗余属性-redundant-attributes"><a class="header-anchor" href="#冗余属性-redundant-attributes"></a>冗余属性 redundant attributes</h4>
<p>假设我们有以下实体集和关系：</p>
<ul>
<li>instructor，包括属性 ID、姓名、部门名和薪水。</li>
<li>department，包括属性部门名、建筑和预算。</li>
<li>关系 inst_dept，关联 instructor 和 department。</li>
<li>实体 instructor 中的属性部门名是冗余的，因为已经存在一个明确的关系 inst_dept，将教师与部门关联起来。
<ul>
<li>该属性复制了关系中存在的信息，应从 instructor 中删除。</li>
<li>但是：在某些情况下，在转换回表格时，该属性可能会重新引入，我们将在后面看到</li>
</ul>
</li>
</ul>
<h3 id="E-R图"><a class="header-anchor" href="#E-R图"></a>E-R图</h3>
<p><img src="https://chiichen.github.io/assets/image-4-CSXuXJc3.png" alt="E-R图"></p>
<ul>
<li><strong>矩形</strong>表示实体集。</li>
<li><strong>菱形</strong>表示关系集。</li>
<li><strong>实体矩形</strong>内列出属性。</li>
<li><strong>下划线表示主键</strong>属性。</li>
</ul>
<p><strong>带有复合、多值和派生属性的实体集E-R图</strong></p>
<p><img src="https://chiichen.github.io/assets/image-5-GZhZidTi.png" alt="Entity With Composite, Multivalued, and Derived Attributes"></p>
<p><strong>带有属性的关系实体集</strong></p>
<p><img src="https://chiichen.github.io/assets/image-6-BkgRSeNn.png" alt="Relationship Sets with Attributes"></p>
<p><strong>带有三元关系 ternary-relationship的E-R图</strong></p>
<p><img src="https://chiichen.github.io/assets/image-14-CAvppGpr.png" alt="E-R Diagram with a Ternary Relationship"></p>
<p><strong>一个数据库的E-R图示例</strong>：</p>
<p><img src="https://chiichen.github.io/assets/image-16-C_jrNPoi.png" alt="E-R图示例"></p>
<h4 id="角色-Role"><a class="header-anchor" href="#角色-Role"></a>角色 Role</h4>
<ul>
<li>关系的实体集不一定是不同的</li>
<li>每个实体集的出现在关系中扮演一个“角色”。“course_id”和“prereq_id”这些标签被称为角色</li>
</ul>
<h4 id="基数约束-Cardinality-Constrants"><a class="header-anchor" href="#基数约束-Cardinality-Constrants"></a>基数约束 Cardinality Constrants</h4>
<ul>
<li>
<p>我们通过在关系集和实体集之间绘制有向线（→）表示“一”或无向线（——）表示“多”。来表达基数约束。</p>
</li>
<li>
<p>一对一关系：</p>
<p><img src="https://chiichen.github.io/assets/image-8-B7EFTDas.png" alt="One-to-One Relationship"></p>
</li>
<li>
<p>一对多关系：</p>
<p><img src="https://chiichen.github.io/assets/image-9-Dbhss_U0.png" alt="One-to-Many Relationship"></p>
</li>
<li>
<p>多对一关系：</p>
<p><img src="https://chiichen.github.io/assets/image-10-BTDbYSIm.png" alt="Many-to-One Relationships"></p>
</li>
<li>
<p>多对多关系：</p>
<p><img src="https://chiichen.github.io/assets/image-11-D8XTAE7M.png" alt="Many-to-Many Relationship"></p>
</li>
</ul>
<p>下图表示学生有且只有一名指导老师，而老师可以指导<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>…</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0…n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>名学生</p>
<p><img src="https://chiichen.github.io/assets/image-13-BuoQZq5b.png" alt="Alternative Notation for Cardinality Limits"></p>
<h3 id="强实体集"><a class="header-anchor" href="#强实体集"></a>强实体集</h3>
<ul>
<li>其实例的存在<strong>不依赖</strong>于任何其他实体类型的实例；有自己<strong>独立的主键</strong>，唯一性地标识它的每个实例。</li>
</ul>
<h3 id="弱实体集-weak-entity-sets"><a class="header-anchor" href="#弱实体集-weak-entity-sets"></a>弱实体集 weak entity sets</h3>
<blockquote>
<p>弱实体集每一条记录的产生必然依赖于已有的强实体集</p>
<p>弱实体集的主键都是组合主键（由其他实体集的主键组层）</p>
</blockquote>
<ul>
<li>其实例的存在<strong>依赖</strong>于其它实体类型的实例；其主键包括它所依赖的实体类型的主键。</li>
<li>没有主键的实体集</li>
<li><strong>弱实体集</strong>的存在依赖于**强实体集（也称为标识实体集）**的存在。弱实体集需要和强实体一起组合使用，才能唯一标识每个实例。</li>
<li><strong>通过部分键标识</strong>：弱实体集通常会有一个部分键（partial key），该键只能在与强实体关联时才能唯一标识实体实例。</li>
<li>标识联系 identifying relationship：
<ul>
<li>弱实体集 —&gt; 标识实体集</li>
<li>多对一关系</li>
<li>弱实体集完全参与关系</li>
</ul>
</li>
<li><strong>ER图中的表示</strong>：
<ul>
<li>弱实体集通常用<strong>双矩形框</strong>表示。</li>
<li>弱实体集与强实体之间的关系用<strong>双菱形框</strong>表示，表示依赖关系。</li>
<li>弱实体集的部分键用<strong>虚线矩形</strong>表示。</li>
</ul>
</li>
<li>弱实体集的鉴别器（或部分键）是区分弱实体集中所有实体的属性集。</li>
<li>弱实体集的主键由以下形式组成：（标识实体集的主键，弱实体集的鉴别器）</li>
<li>我们用<strong>虚线下划线标记弱实体集的鉴别器</strong>。</li>
<li>我们将弱实体的标识关系放在一个双菱形中。</li>
</ul>
<p><strong>以示例了解何为弱实体类</strong>：</p>
<p><strong>1、教务系统数据库设计</strong></p>
<p>业务需求是这样的：</p>
<p>一周有七天，每一天有11节。</p>
<p>则设计时，首先有三个实体（不管强或弱实体）：<code>Day、Week、Section</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 教务系统实体关系图</span><br><span class="line">---</span><br><span class="line">erDiagram</span><br><span class="line"></span><br><span class="line">	Week&#123;</span><br><span class="line">		int weekNum</span><br><span class="line">		Long id PK</span><br><span class="line">	&#125;</span><br><span class="line">	Day&#123;</span><br><span class="line">		int dayOfweek</span><br><span class="line">		Lond id PK</span><br><span class="line">	&#125;</span><br><span class="line">	Section&#123;</span><br><span class="line">		int sectionNum</span><br><span class="line">		Long id PK</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Week ||--o&#123; Day : &quot;has&quot;</span><br><span class="line">  Day ||--o&#123; Section :&quot;has&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h4 id="关系的种类"><a class="header-anchor" href="#关系的种类"></a><strong>关系的种类</strong></h4>
<p>E-R 图中最常见的关系类型是 <strong>一对一</strong>（1:1）、<strong>一对多</strong>（1:N） 和 <strong>多对多</strong>（M:N）。这些类型通过连线的标注来表示：</p>
<h5 id="一对一（1-1）"><a class="header-anchor" href="#一对一（1-1）"></a>一对一（1:1）</h5>
<ul>
<li>
<p>每个实体 A 只能与另一个实体 B 的一个实例相关联，反之亦然。</p>
</li>
<li>
<p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTITY_A ──────|── ENTITY_B</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例：</p>
<p>一个人有一个身份证</p>
<p>。</p>
<h5 id="一对多（1-N）"><a class="header-anchor" href="#一对多（1-N）"></a>一对多（1:N）</h5>
<ul>
<li>
<p>一个实体 A 可以与多个实体 B 的实例相关联，而实体 B 的每个实例只能与一个实体 A 相关联。</p>
</li>
<li>
<p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTITY_A ──────&lt;── ENTITY_B</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例：</p>
<p>一个部门有多个员工</p>
<h5 id="多对多（M-N）"><a class="header-anchor" href="#多对多（M-N）"></a>多对多（M:N）</h5>
<ul>
<li>
<p>实体 A 的多个实例可以与实体 B 的多个实例相关联。</p>
</li>
<li>
<p>图示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTITY_A ──────&lt;──&gt;── ENTITY_B</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例：</p>
<p>学生和课程的关系</p>
<p>（一个学生可以选修多门课程，而一门课程可以被多个学生选修）。</p>
<hr>
<h4 id="约束条件"><a class="header-anchor" href="#约束条件"></a>约束条件</h4>
<p>连线上可能标注一些约束条件，例如：</p>
<ul>
<li>
<p><strong>参与度</strong>：</p>
<ul>
<li>全部参与（Total Participation）：连线上用双线表示。
<ul>
<li>示例：所有员工都必须属于一个部门。</li>
</ul>
</li>
<li>部分参与（Partial Participation）：连线上用单线表示。
<ul>
<li>示例：某些员工可以没有项目参与。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>基数（Cardinality）</strong>：</p>
<ul>
<li>
<p>用数字或符号表示一个实体参与关系的数量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1..N 表示一对多</span><br><span class="line">1 表示一对一</span><br><span class="line">M..N 表示多对多</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="弱实体的连线"><a class="header-anchor" href="#弱实体的连线"></a>弱实体的连线</h4>
<ul>
<li><strong>弱实体</strong>：如果一个实体不能独立存在（依赖于另一个实体），它的连线通常连接到其“拥有”实体的主键，表示其依赖性。</li>
<li>通常，弱实体的连线会带有一个菱形（表示标识关系）。</li>
</ul>
<hr>
<h4 id="关系的属性"><a class="header-anchor" href="#关系的属性"></a>关系的属性</h4>
<ul>
<li>
<p>连线上的菱形代表关系，如果关系有属性，这些属性会与菱形相连。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STUDENT ────── ENROLLS ────── COURSE</span><br><span class="line">                   |</span><br><span class="line">                  DATE</span><br></pre></td></tr></table></figure>
<p>示例中，<code>DATE</code>是<code>ENROLLS</code>关系的属性。</p>
</li>
</ul>
<h2 id="CH8-关系数据库设计-relational-database-design"><a class="header-anchor" href="#CH8-关系数据库设计-relational-database-design"></a>CH8 关系数据库设计 relational database design</h2>
<h3 id="分解-decompose"><a class="header-anchor" href="#分解-decompose"></a>分解 decompose</h3>
<p><img src="https://chiichen.github.io/assets/image-2-DIfBlPe0.png" alt="Example"></p>
<ul>
<li>
<p>如果分解后无法重建原始信息，那么就是有损分解lossy decomposition，反之则无损分解Lossless-join decompose</p>
<p><img src="https://chiichen.github.io/assets/image-Bp1Kkm8r.png" alt="有损分解"></p>
<p><img src="https://chiichen.github.io/assets/image-1-wIOyu-C4.png" alt="无损分解"></p>
</li>
<li>
<p>所以我们需要一个理论来告诉我们怎么合理的分解关系。好的分解要做到：</p>
<ul>
<li>无损分解</li>
<li>依赖保存</li>
</ul>
</li>
<li>
<p>BCNF分解可以保证无损，3NF可以保证依赖保存，但是3NF无法保证没有冗余，因此需要在BCNF和3NF间权衡</p>
</li>
</ul>
<h3 id="第一范式-first-normal-form"><a class="header-anchor" href="#第一范式-first-normal-form"></a>第一范式 first normal form</h3>
<ul>
<li>如果一个域的元素被认为是不可分割的单元，则该域是原子的</li>
<li>非原子域的示例：
<ul>
<li>名称集合，复合属性</li>
<li>可以分解为部分的标识号，例如CS101</li>
</ul>
</li>
<li>如果关系模式 R 的所有属性的域都是原子的，则关系模式 R 符合第一范式</li>
<li>非原子值会使存储变得复杂，并导致数据的冗余（重复存储）
<ul>
<li>如：每个客户存储一组账户，每个账户都存储一组所有者</li>
</ul>
</li>
</ul>
<blockquote>
<p>原子性</p>
<ul>
<li>原子性实际上是与域的元素如何使用相关的属性。</li>
<li>例如，字符串通常被认为是不可分割的。</li>
<li>假设学生被赋予类似 SE0012 或 EE1127 的字符串形式的学号。</li>
<li>如果提取前两个字符来确定学院，那么学号的域就不是原子的。</li>
<li>这样做是一个坏主意：会导致信息被编码在应用程序而不是数据库中。</li>
</ul>
</blockquote>
<h3 id="第二范式-second-normal-form"><a class="header-anchor" href="#第二范式-second-normal-form"></a>第二范式 second normal form</h3>
<blockquote>
<p><strong>主键</strong>：能够唯一标识表中一行的字段或字段组合。</p>
<p><strong>非主属性</strong>：除了主键之外的其他字段。</p>
<p><strong>部分依赖</strong>：非主属性依赖于主键的一部分，而不是整个主键。</p>
</blockquote>
<ol>
<li>
<p>首先需要满足第一范式 1NF：表中所有字段值都是原子值，每个字段的值是不可再分的最小单位。</p>
</li>
<li>
<p>消除部分依赖：</p>
<ul>
<li>表中的所有非主属性必须完全依赖于主键PK，不能依赖于主键的一部分</li>
</ul>
<blockquote>
<p>部分依赖：在复合主键中，某些非主属性仅依赖于主键的一部分，而不是整个主键</p>
</blockquote>
</li>
</ol>
<ul>
<li>数据库表中不存在非关键字段对任一候选键的部分函数依赖，也即所有非关键字都完全依赖于任意一组候选关键字。</li>
<li>2NF 的违例只会出现在候选键由超过一个字段构成的表中，因为对单关键字字段不存在部分依赖问题。</li>
</ul>
<blockquote>
<p>例子</p>
<p>给定关系模式的函数依赖集合如下：</p>
<ol>
<li>学号课程名称姓名年龄成绩学分{(学号,课程名称)→(姓名,年龄,成绩,学分)}</li>
<li>课程名称学分{(课程名称)→(学分)}</li>
<li>学号姓名年龄{(学号)→(姓名,年龄)}</li>
</ol>
<p>在这个例子中，候选键只有一个，即学号课程名称(学号,课程名称)，因此主键也是学号课程名称(学号,课程名称)。</p>
<p>我们可以观察到，属性姓名、年龄和学分是部分依赖于主键的，而属性成绩成绩是完全依赖于主键的。由于存在部分依赖关系，这个关系模式不满足第二范式。</p>
<p>为了使关系模式满足第二范式，我们需要进行分解，将属性姓名姓名、年龄年龄和学分学分从主关系模式中分离出来，形成新的关系模式。最终的关系模式可能如下：</p>
<p>关系模式 1: 学号课程名称成绩(学号,课程名称,成绩)</p>
<p>关系模式 2: 课程名称学分(课程名称,学分)</p>
<p>关系模式 3: 学号姓名年龄(学号,姓名,年龄)</p>
<p>这样，每个关系模式都满足第二范式，并且保留了原始关系模式的函数依赖。</p>
</blockquote>
<h3 id="函数依赖-functional-dependencies"><a class="header-anchor" href="#函数依赖-functional-dependencies"></a>函数依赖 functional dependencies</h3>
<blockquote>
<p>函数依赖用于表明某些属性的值可以通过其他属性的值唯一确定。即可以通过决定因素确定被决定因素的值</p>
</blockquote>
<ul>
<li>
<p>在一个关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A,B,C,...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mclose">)</span></span></span></span>中，假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 是属性的子集：</p>
<ul>
<li>
<p>如果对于关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的任意两个元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t_1[X]=t_2[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>时，一定有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t_1[Y]=t_2[Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>，则称 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 函数确定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，记作：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>：称为决定因素 determinant</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>：称为被决定因素 dependent</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>换而言之，给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>值即可唯一确定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>的值</p>
</blockquote>
<ul>
<li>函数依赖是对合法关系集合的约束条件。</li>
<li>函数依赖是对键的概念的一种推广</li>
<li>定义：$\alpha \rightarrow \beta $ 等价于
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span> 的超码super-key</li>
<li>属性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 的取值决定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 的取值</li>
</ol>
</li>
<li>在函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 中，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>⊆</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta \subseteq \alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，我们就称它是<code>平凡trivial</code>的。因为对于任意的关系<em>R</em>它总是成立的。
<ul>
<li>例：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>I</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">ID,name \rightarrow ID</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 是平凡的 $name \rightarrow name $ 也是平凡的</li>
</ul>
</li>
<li>在函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>中，如果对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 的任何一个真子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">\alpha^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9425em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-2.9425em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo>↛</mo></mrow><annotation encoding="application/x-tex">\alpha^{&#x27;} \nrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9425em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-2.9425em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span></span></span></span> 那么就称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>有完全函数依赖</li>
<li>在函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>中，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>不完全函数依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>就称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>部分函数依赖</li>
</ul>
<h4 id="函数依赖与超键"><a class="header-anchor" href="#函数依赖与超键"></a>函数依赖与超键</h4>
<ul>
<li>
<p>当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>的超键</p>
</li>
<li>
<p>当且仅当满足以下条件时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>的候选键：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，并且对于任何<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>⊂</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\alpha \subset K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，都不满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>函数依赖允许我们表达无法使用超键来表示的约束。考虑以下模式：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo stretchy="false">(</mo><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>p</mi><msub><mi>t</mi><mi>n</mi></msub><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo separator="true">,</mo><mi>b</mi><mi>u</mi><mi>d</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">inst\_dept(ID,name,salary,dept_name,building,budget)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">pt</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ry</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">am</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>期望以下函数依赖成立：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mspace linebreak="newline"></mspace><mi>I</mi><mi>D</mi><mo>→</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">dept\_name \rightarrow building \\
ID \rightarrow building
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">pt</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span></p>
</li>
<li>
<p>但是不期望以下函数依赖成立</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">dept\_name \rightarrow salary
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">pt</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ry</span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<h4 id="函数依赖的作用"><a class="header-anchor" href="#函数依赖的作用"></a>函数依赖的作用</h4>
<p>我们使用函数依赖来进行以下操作：</p>
<ul>
<li>
<p>检验关系是否在给定的函数依赖集合下合法</p>
<ul>
<li>如果关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 在函数依赖集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 下是合法的，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 满足satisfy <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>指定对合法关系集的约束</p>
<ul>
<li>如果在关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 上的所有合法关系都满足函数依赖集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>，我们说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 在模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 上成立holds-on。</li>
</ul>
</li>
</ul>
<p>注：一个关系模式的特定实例可能满足一个函数依赖，即使该函数依赖不在所有合法实例上成立，例：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">instructor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span></span></span></span>关系模式的一个特定实例可能恰好满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>I</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">name \rightarrow ID</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>。</p>
<p>无损连接于分解 lossess-join decomposition</p>
<ul>
<li>对于关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R=(R_1,R_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的情况，我们要求对于满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∏</mo><msub><mi>R</mi><mn>1</mn></msub></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo>⋈</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∏</mo><msub><mi>R</mi><mn>2</mn></msub></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">r=\begin{matrix} \prod_{R_1}(r) \end{matrix} \bowtie \begin{matrix} \prod_{R_2}(r) \end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2398em;vertical-align:-0.3699em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8699em;"><span style="top:-3.0299em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3699em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2398em;vertical-align:-0.3699em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8699em;"><span style="top:-3.0299em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3699em;"><span></span></span></span></span></span></span></span></span></span></span>式子的所有可能的关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li>
<li>如果一个从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>分解成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的分解是无损的，那么式子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo>→</mo><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1 ∩ R_2 \rightarrow R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo>→</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_1 ∩ R_2 \rightarrow R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>至少有一个在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中。</li>
<li>上述是保证无损分解的充分条件。</li>
</ul>
<h4 id="函数依赖闭包"><a class="header-anchor" href="#函数依赖闭包"></a>函数依赖闭包</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>表示所有能从函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>中推出的函数依赖闭包</li>
<li>如果两个函数依赖集的闭包相等，则两个函数依赖集是等价的</li>
<li>可以通过反复应用 Armstrong 公理来找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>
<ul>
<li><strong>自反性</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的子集，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。</li>
<li><strong>扩充性</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，那么对于任意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mi>α</mi><mo>→</mo><mi>γ</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\gamma \alpha \rightarrow \gamma \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。</li>
<li><strong>传递性</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\beta \rightarrow \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>。</li>
</ul>
</li>
<li>以上三点规则是完备且合理的</li>
<li>附加规则：
<ul>
<li><strong>并集规则</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>成立且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>也成立。</li>
<li><strong>分解规则</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>成立。</li>
<li><strong>伪传递性规则</strong>：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>成立且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mi>β</mi><mo>→</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\gamma \beta \rightarrow \delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>成立，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>γ</mi><mo>→</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\alpha \gamma \rightarrow \delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></li>
</ul>
</li>
<li>附加规则是可以通过 armstrong 公理推导的。</li>
</ul>
<h4 id="属性集闭包-closure-of-attribute-sets"><a class="header-anchor" href="#属性集闭包-closure-of-attribute-sets"></a>属性集闭包 closure of attribute sets</h4>
<ul>
<li>定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>α</mi><mo>→</mo><mi>A</mi><mo>⊆</mo><msup><mi>F</mi><mo>+</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\alpha^+ = \{ A|(\alpha \rightarrow A \subseteq F^+\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，即通过函数依赖确定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>可以决定的所有属性</li>
</ul>
<p><img src="https://chiichen.github.io/assets/image-4-CH5gmXtS.png" alt="属性集闭包计算示例"></p>
<h4 id="属性闭包与函数依赖"><a class="header-anchor" href="#属性闭包与函数依赖"></a>属性闭包与函数依赖</h4>
<p>在基于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mo>↔</mo><mi>β</mi><mo>⊆</mo><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta \leftrightarrow \beta \subseteq \alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>关系，可以通过计算属性集闭包来计算函数依赖</p>
<h4 id="属性集闭包和超键"><a class="header-anchor" href="#属性集闭包和超键"></a>属性集闭包和超键</h4>
<p>在基于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>↔</mo><mi>R</mi><mo>⊆</mo><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha is superkey \leftrightarrow R \subseteq \alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，可以通过属性集闭包来判定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是不是超键</p>
<h4 id="属性集闭包和函数依赖闭包"><a class="header-anchor" href="#属性集闭包和函数依赖闭包"></a>属性集闭包和函数依赖闭包</h4>
<p>通过属性集闭包计算函数依赖闭包：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>←</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F^+ \leftarrow F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></li>
<li>对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>⊆</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\gamma \subseteq R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\gamma^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li>
<li>对于每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><msup><mi>γ</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">S \subseteq \gamma^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>←</mo><mo stretchy="false">{</mo><mi>γ</mi><mo>→</mo><mi>S</mi><mo stretchy="false">}</mo><mo>∪</mo><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+ \leftarrow \{\gamma \rightarrow S \} ∪ F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li>
<li>输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
<h3 id="规范化的目标"><a class="header-anchor" href="#规范化的目标"></a>规范化的目标</h3>
<ul>
<li>给定一个关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 和函数依赖集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>，判断关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 是否处于“良好”的形式</li>
<li>如果关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 不处于“良好”的形式，则将其分解为一组关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_1,R_2,...,R_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中每个关系模式都处于良好形式。</li>
<li>分解应该是无损连接lossless-join的——通过连接分解后的关系模式可以恢复到原始关系模式</li>
<li>最好的情况是分解应该是依赖保持的——在分解后的每个关系模式上仍然能够保持原始的函数依赖关系。</li>
</ul>
<h3 id="规范覆盖-Canonical-Cover"><a class="header-anchor" href="#规范覆盖-Canonical-Cover"></a>规范覆盖 Canonical Cover</h3>
<ul>
<li>
<p>规范覆盖canonical-cover是指函数依赖集中的一组“最小”等价函数依赖，它不包含冗余的依赖关系或冗余的依赖关系部分。函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>的规范覆盖记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">F_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它满足以下条件：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⇔</mo><msub><mi>F</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">F \Leftrightarrow F_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">F_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的每个函数依赖都不包含冗余属性</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">F_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的每个函数依赖的左侧是唯一的，不会存在相同的左侧，即没有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，只能是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \rightarrow \beta \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>​</li>
</ul>
</li>
<li>
<p>函数依赖集中的依赖关系可能存在冗余的依赖关系，可以从其他依赖关系中推导出来。例如，在集合{A-&gt;B,B-&gt;C,A-&gt;C}中，A-&gt;C就是冗余的</p>
</li>
<li>
<p>函数依赖的部分可能也是冗余的。例如，在右侧的依赖集合{A-&gt;B,B-&gt;C,A-&gt;CD}可以简化为{A-&gt;B,B-&gt;C,A-&gt;D}；在左侧的依赖集合{A-&gt;B,B-&gt;C,AC-&gt;D}可以简化为{A-&gt;B,B-&gt;C,A-&gt;D}。</p>
</li>
<li>
<p>直观地说，规范覆盖是等价于函数依赖集合F的一组“最小”函数依赖，它不包含冗余的依赖关系或冗余的依赖关系部分。规范覆盖的目的是简化函数依赖集合，使其更加简洁和有效。</p>
</li>
</ul>
<h4 id="计算规范覆盖"><a class="header-anchor" href="#计算规范覆盖"></a>计算规范覆盖</h4>
<ul>
<li>计算函数依赖集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>的规范覆盖步骤：
<ul>
<li>重复以下步骤：
<ol>
<li>使用并集规则（union rule）替换F中的任何函数依赖，例如将函数依赖α1-&gt;β1和α1-&gt;β2替换为α1-&gt;β1 β2。</li>
<li>查找具有冗余属性的函数依赖α-&gt;β，冗余属性可能存在于α或β中。注意：对冗余属性的测试是使用F_c而不是F进行的</li>
<li>如果找到冗余属性，则从α-&gt;β中删除它。</li>
</ol>
</li>
<li>直到F不再发生变化为止。</li>
</ul>
</li>
<li>需要注意的是，删除一些冗余属性后，可能会使并集规则再次适用，因此需要重新应用并集规则。</li>
<li>通过执行上述步骤，最终得到的函数依赖集合F_c就是原函数依赖集合F的规范覆盖。</li>
</ul>
<p><img src="https://chiichen.github.io/assets/image-9-BD14r9EV.png" alt="计算规范覆盖"></p>
<h3 id="冗余属性-extraneous-attributes"><a class="header-anchor" href="#冗余属性-extraneous-attributes"></a>冗余属性 extraneous attributes</h3>
<ul>
<li>冗余属性 extraneous-attribute 是指在给定的函数依赖集合中，某个属性在依赖关系中是冗余的，可以被删除而不影响函数依赖的表达。</li>
<li>例如，给定函数依赖集合F={A-&gt;C,AB-&gt;C}，我们要判断属性B是否是冗余的。通过删除属性B，得到新的依赖集合H={A-&gt;C}。如果满足F&lt;=&gt;H，那么属性B就是冗余的。</li>
<li>对于函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中的函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>x</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha x \rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">αx</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，如果删除属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>后得到的新的函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>满足F&lt;=&gt;(F-{<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">αx</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>})∪{<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>}，那么属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>就是冗余的。</li>
<li>需要注意的是，上述情况中，逆向的蕴含关系在每种情况下都是显而易见的，因为“更强”的函数依赖总是蕴含着“更弱”的函数依赖</li>
</ul>
<blockquote>
<p><strong>函数依赖强弱的定义</strong></p>
<ul>
<li>
<p>更强的函数依赖</p>
<p>：如果一个函数依赖的左侧属性集更大或者更具体，那么它的约束更强。例如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">AB \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 更强，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 包含了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，需要更多的条件（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 同时成立）来确定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>更弱的函数依赖</p>
<p>：如果一个函数依赖的左侧属性集更小或者更宽松，那么它的约束更弱。例如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">AB \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 更弱，因为只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 成立就能确定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，而不需要考虑 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</li>
</ul>
</li>
</ul>
<p><strong>蕴含关系</strong></p>
<p>函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>表示：如果属性集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>的值确定，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>的值也是确定的。</p>
<ul>
<li>如果我们有一个更强的依赖（例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">AB \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>），它的前提条件更严格，因此它一定能够保证更弱的依赖（例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>）的成立。</li>
<li>这是因为，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">AB \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 成立，那么满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的任何情况，也必然满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 中更宽松的条件。</li>
</ul>
</blockquote>
<h3 id="第三范式-3NF"><a class="header-anchor" href="#第三范式-3NF"></a>第三范式 3NF</h3>
<blockquote>
<p>满足第二范式，且不存在依赖传递，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。</p>
</blockquote>
<ul>
<li>在第二范式的基础上，数据库中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式</li>
<li>一个关系模式 R 在第三范式中，如果对 F 中的所有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，至少满足以下条件：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是R的super-key</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>⊆</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \subseteq \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>也是超键</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta \to \alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>中的每个属性 A 都包含在 R 的候选键中（注：每个属性可能在不同的候选键中）</li>
</ul>
</li>
</ul>
<blockquote>
<p>平凡函数依赖</p>
<p>非平凡函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X→Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 是非平凡的，指的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>​ 的子集。</p>
</blockquote>
<ul>
<li></li>
</ul>
<h3 id="BCNF范式-boyce-codd-normal-form"><a class="header-anchor" href="#BCNF范式-boyce-codd-normal-form"></a>BCNF范式 boyce-codd normal form</h3>
<ul>
<li>关系模式 R 在 BCNF 中，如果对于 R 中的存在的所有函数依赖关系 F，形式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>⊆</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\alpha \subseteq R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>⊆</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\beta \subseteq R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，至少满足以下条件之一：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>⊆</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \subseteq \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li>
<li>$\alpha $是R的super-key</li>
</ul>
</li>
<li></li>
</ul>
<blockquote>
<p>范式之间的关系</p>
<p>第一范式(1NF)<br>
非码的非平凡 | ↓ 消除非主属性对码的部分函数依赖<br>
第二范式(2NF)<br>
↓ 消除非主属性对码的传递函数依赖<br>
第三范式(3NF)<br>
↓ 消除主属性对码的部分和传递函数依赖<br>
BC 范式(BCNF)<br>
↓ 消除非平凡且非函数依赖的多值依赖<br>
第四范式(4NF)<br>
↓ 消除不是由候选码所蕴含的连接依赖<br>
第五范式(5NF)</p>
</blockquote>
<h2 id="CH10-存储和文件结构"><a class="header-anchor" href="#CH10-存储和文件结构"></a>CH10 存储和文件结构</h2>
<h3 id="物理存储媒介-physical-storage-media"><a class="header-anchor" href="#物理存储媒介-physical-storage-media"></a>物理存储媒介 physical storage media</h3>
<ul>
<li>
<p>磁盘</p>
<ul>
<li>1 block = 多个连续的 sector</li>
<li>1 个文件(哈希文件除外)= 多个连续的 block</li>
</ul>
</li>
<li>
<p>磁头与磁盘</p>
<ul>
<li>磁头往磁盘读写数据的最小单位是 sector</li>
</ul>
</li>
<li>
<p>内存与磁盘</p>
<ul>
<li>内存与磁盘交换信息的最小单位是 block</li>
</ul>
</li>
<li>
<p>开销=寻道时间 + 旋转时间 + 传输时间</p>
</li>
<li>
<p>数据库只关注:</p>
<ul>
<li>寻道次数</li>
<li>传输磁盘块个数</li>
</ul>
</li>
<li>
<p>设访问的磁盘块依次分别是: B1, B2</p>
<ul>
<li>
<p>寻道次数 : 如果 B1, B2 相邻, 则寻道 1 次</p>
</li>
<li>
<p>传输磁盘块的个数: 无论相邻与否, 都是 2.</p>
<p><img src="https://chiichen.github.io/assets/image-DlrztMBS.png" alt="磁盘结构示意图"></p>
</li>
</ul>
</li>
</ul>
<h3 id="缓冲管理-buffer-management"><a class="header-anchor" href="#缓冲管理-buffer-management"></a>缓冲管理 buffer-management</h3>
<ul>
<li>当程序需要从磁盘中获取一个块时，它会调用缓冲管理器。
<ul>
<li>如果该块已经在缓冲区中，则缓冲管理器会返回该块在主内存中的地址。</li>
<li>如果该块不在缓冲区中，缓冲管理器会执行以下操作：
<ul>
<li>在缓冲区中为该块分配空间。
<ul>
<li>如果需要，替换（抛弃）其他块，以为新块腾出空间。</li>
<li>仅当被替换的块在最近一次写入/从磁盘获取时被修改后，才将其写回磁盘。</li>
</ul>
</li>
<li>从磁盘中读取该块到缓冲区，并将该块在主内存中的地址返回给请求者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="缓冲替换策略-buffer-replacement-policies"><a class="header-anchor" href="#缓冲替换策略-buffer-replacement-policies"></a>缓冲替换策略 buffer-replacement-policies</h4>
<ul>
<li>大多数操作系统使用<code>最近最少使用（LRU）</code>策略替换块。</li>
<li>LRU 的思想是利用过去的块引用模式作为对未来引用的预测器。</li>
<li>查询具有明确定义的访问模式（例如顺序扫描），数据库系统可以利用用户查询中的信息来预测未来的引用。</li>
<li>对于涉及<strong>重复数据</strong>扫描的某些访问模式，LRU 可能是一个不好的策略。
<ul>
<li>例如：计算两个关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>的连接操作时，通过嵌套循环进行：
<ul>
<li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>的每个元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，</li>
<li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>的每个元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，</li>
<li>如果元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 匹配…</li>
</ul>
</li>
<li>在这种情况下，使用立即丢弃（Toss-immediate）策略更可取。</li>
</ul>
</li>
<li>固定的块(Pinned block) - 不能写回磁盘的内存块。</li>
<li>立即丢弃（Toss-immediate）策略 - 在处理完块的最后一个元组后，立即释放该块占用的空间。</li>
<li>最近使用（Most recently used (MRU) strategy）策略 - 系统必须固定当前正在处理的块。在处理完该块的最后一个元组后，取消固定该块，并使其成为最近使用的块。</li>
<li>缓冲管理器可以使用关于请求将引用特定关系的概率的统计信息。
<ul>
<li>例如，数据字典经常被访问。启发式方法：将数据字典块保留在主内存缓冲区中。</li>
</ul>
</li>
<li>缓冲管理器还支持强制输出块(forced output)以进行恢复的目的（有关更多信息，请参阅第 16 章）</li>
</ul>
<h3 id="文件组织-file-organization"><a class="header-anchor" href="#文件组织-file-organization"></a>文件组织 file-organization</h3>
<blockquote>
<p>数据库以文件集合的形式存储。每个文件是一系列记录，而记录则是一系列字段的序列。</p>
</blockquote>
<p>一个数据库被映射为多个不同的文件file，文件由OS来维护，永久存储在磁盘中</p>
<p>一个文件在逻辑上组织成记录的序列。每个文件分成定长的存储单元—— 块 block</p>
<p>block是存储分配和数据传输的基本单元，多数数据库默认使用4-8KB大小的块。当创建数据库时，可以指定块大小。</p>
<p>一个块可以包含多条记录。要求每条记录存储在单个块中，即：没有一条记录是部分包含在一个块中的，以加速数据访问。</p>
<p>关系数据库中，不同关系的元组通常具有不同的大小，记录可分为<strong>定长记录和变长记录</strong>。</p>
<h4 id="定长记录-fixed-length-records"><a class="header-anchor" href="#定长记录-fixed-length-records"></a>定长记录 fixed-length records</h4>
<ul>
<li>
<p>一种方法是：</p>
<ul>
<li>假设记录大小是固定的。</li>
<li>每个文件只包含一种特定类型的记录。</li>
<li>不同的文件用于不同的关系。</li>
</ul>
</li>
<li>
<p>这种情况最容易实现；稍后我们将考虑可变长度的记录</p>
<p><img src="D:%5CBlog%5Csource_posts%5C%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%5C%E6%95%B0%E6%8D%AE%E5%BA%93.assets%5Cimage-1-Co9_fsVz.png" alt="Fixed-Length Records"></p>
</li>
<li>
<p>用空闲链表来存储空余空间</p>
<p><img src="https://chiichen.github.io/assets/image-2-CyvBTO7J.png" alt="Free Lists"></p>
</li>
<li>
<p>从这个结构中删除一条记录很困难。删除的记录所占用的空间必须由文件的其它记录填充或者标记该空间为忽略。</p>
<ul>
<li>方法一：删除一条记录后，依次将后面的记录往前挪。<br>
缺点：需要额外的块访问操作。</li>
<li>方法二：将被删除的记录的存储空间用来存储新插入的记录。这就需要标记该空间。引入如下结构：
<ul>
<li>在文件的开始处，分配一定数量的字节作为文件头（file header）。</li>
<li>令文件头中除了文件的相关信息外，还包括被删除的第一条记录的地址。</li>
<li>在第一条被删除的记录处，来存储第二条被删除的记录的地址。以此类推。</li>
<li>==&gt;形成了有一个空闲列表（free list）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="变长记录-variable-length-records：slotted-page-structure"><a class="header-anchor" href="#变长记录-variable-length-records：slotted-page-structure"></a>变长记录 variable-length-records：slotted-page-structure</h4>
<p><img src="https://chiichen.github.io/assets/image-3-DOPpOuNL.png" alt="Slotted Page Structure"></p>
<ul>
<li>插槽页头(Slotted page header)包含以下内容：
<ul>
<li>记录条目的数量</li>
<li>块中空闲空间的结束位置</li>
<li>每个记录的位置和大小</li>
</ul>
</li>
<li>可以在页面内部移动记录，以保持它们的连续性，中间没有空白空间；页头中的条目必须更新。</li>
<li>指针不应直接指向记录，而应指向页头中记录对应的条目。</li>
</ul>
<h4 id="文件内的记录组织"><a class="header-anchor" href="#文件内的记录组织"></a>文件内的记录组织</h4>
<ul>
<li>
<p><code>堆（Heap）</code>- 记录可以放置在文件中的任何有空间的位置。</p>
</li>
<li>
<p><code>顺序（Sequential）</code>- 根据每个记录的搜索键值，按顺序存储记录。</p>
<p><img src="https://chiichen.github.io/assets/image-4-CBozuB4y.png" alt="顺序组织"></p>
<p><img src="https://chiichen.github.io/assets/image-5-_5H_oOZN.png" alt="顺序组织"></p>
</li>
<li>
<p><code>哈希（Hashing）</code>- 对每个记录的某个属性计算哈希函数；结果指定了记录应该放置在文件的哪个块中。</p>
</li>
<li>
<p>每个关系的记录可以存储在单独的文件中。在<code>多表聚集文件组织(multitable clustering file organization)</code>中，多个不同关系的记录可以存储在同一个文件中。</p>
</li>
<li>
<p>动机：将相关的记录存储在同一个块中，以最小化 I/O 操作</p>
<p><img src="https://chiichen.github.io/assets/image-6-ZLXExafy.png" alt="多表聚集文件组织(multitable clustering file organization)"></p>
<p><img src="https://chiichen.github.io/assets/image-7-bBX0JNym.png" alt="多表聚集文件组织(multitable clustering file organization)"></p>
</li>
</ul>
<h3 id="数据字典存储-data-dictionary-storage"><a class="header-anchor" href="#数据字典存储-data-dictionary-storage"></a>数据字典存储 data-dictionary-storage</h3>
<p>数据字典（也称为系统目录）存储元数据，即关于数据的数据，例如：</p>
<ul>
<li>关于关系的信息
<ul>
<li>关系的名称</li>
<li>每个关系的属性的名称和类型</li>
<li>视图的名称和定义</li>
<li>完整性约束</li>
</ul>
</li>
<li>用户和账户信息，包括密码</li>
<li>统计和描述性数据
<ul>
<li>每个关系中的元组数量</li>
</ul>
</li>
<li>物理文件组织信息
<ul>
<li>关系的存储方式（顺序/哈希/…）</li>
<li>关系的物理位置</li>
</ul>
</li>
<li>关于索引的信息（第 11 章中介绍）</li>
</ul>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="编译原理复习笔记"><a class="header-anchor" href="#编译原理复习笔记"></a>编译原理复习笔记</h1>
<h2 id="为什么要编译"><a class="header-anchor" href="#为什么要编译"></a>为什么要编译</h2>
<p>电脑只能执行机器语言</p>
<p>但高级编程语言易于给人类进行编辑与开发</p>
<p>因而需要将人类易于阅读的高级编程语言转换成机器语言</p>
<p>这个转换的过程就是编译</p>
<h2 id="什么是编译器"><a class="header-anchor" href="#什么是编译器"></a>什么是编译器</h2>
<p>一个编译器就是一个程序，可以将某种源语言转换成等价的另一种目标语言</p>
<h2 id="解释器-interpreter"><a class="header-anchor" href="#解释器-interpreter"></a>解释器 interpreter</h2>
<p>另一种常见的语言处理器，不通过翻译的方式生成目标程序</p>
<h2 id="编译器和解释器的异同"><a class="header-anchor" href="#编译器和解释器的异同"></a>编译器和解释器的异同</h2>
<h3 id="相同："><a class="header-anchor" href="#相同："></a>相同：</h3>
<p>都是语言实现系统</p>
<h3 id="不同："><a class="header-anchor" href="#不同："></a>不同：</h3>
<ol>
<li>编译器先翻译后执行，编译器做拓展性的预处理，大部分都是考编译器实现的</li>
<li>解释器边翻译边执行，解释器执行程序很少或没有预处理</li>
</ol>
<h3 id="JVM的原理："><a class="header-anchor" href="#JVM的原理："></a>JVM的原理：</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913059.png" alt="image-20240621080928578"></p>
<h2 id="语言处理系统全过程"><a class="header-anchor" href="#语言处理系统全过程"></a>语言处理系统全过程</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913271.png" alt="image-20240621075846648"></p>
<h2 id="编译器全过程"><a class="header-anchor" href="#编译器全过程"></a>编译器全过程</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011913424.png" alt="image-20240621080342776"></p>
<h3 id="各板块及其功能"><a class="header-anchor" href="#各板块及其功能"></a>各板块及其功能</h3>
<ol>
<li>词法分析：识别描述逻辑块</li>
<li>语法分析：识别逻辑之间如何相互有关系</li>
<li>语义分析：识别整个结构的意义</li>
<li>中间代码生成：设计一个可能符合的结构</li>
<li>中间代码优化：简化生成的目的结构</li>
<li>代码生成：产生目的结构</li>
<li>机器相关代码优化：优化最终结构</li>
</ol>
<p>编译器中间的四大流程又与</p>
<ol>
<li>Literal table 语法表；</li>
<li>Symbol table 符号表；</li>
<li>Error handler 错误处理器</li>
</ol>
<h1 id="词法分析-Lexical-analysis"><a class="header-anchor" href="#词法分析-Lexical-analysis"></a>词法分析 Lexical analysis</h1>
<h2 id="词素"><a class="header-anchor" href="#词素"></a>词素</h2>
<p>我们从原始程序中创建token的那一部分称为词 lexeme 词素</p>
<h2 id="Token"><a class="header-anchor" href="#Token"></a>Token</h2>
<p>是从源代码中读取出来的逻辑条目</p>
<p>Token可以复制，即存储一些特殊信息</p>
<h2 id="词法分析器任务"><a class="header-anchor" href="#词法分析器任务"></a>词法分析器任务</h2>
<ol>
<li>读入的源代码的输入字符，将其组成词素，生成并输出一个token序列，每一个token对应着一个词素</li>
<li>一个token由：token名和可选的属性值组成</li>
</ol>
<p>每一个字符都经过扫描转换成一个token 词法单元，如一个标识符 int a ，会被记录为：&lt;id,entry&gt; id是identify的抽象符号，entry指的是 标识符a 对应的条目号码。</p>
<h2 id="正则表达式-Regular-Expression"><a class="header-anchor" href="#正则表达式-Regular-Expression"></a>正则表达式 Regular Expression</h2>
<p>用来捕获一类描述</p>
<p>具有可读性</p>
<h3 id="串的术语"><a class="header-anchor" href="#串的术语"></a>串的术语</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914870.png" alt="image-20240621101823881"></p>
<h3 id="复合正则表达式"><a class="header-anchor" href="#复合正则表达式"></a>复合正则表达式</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914915.png" alt="image-20240621101905529"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914177.png" alt="image-20240621102021241"></p>
<p>还有正闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">R^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>​，即至少有一个R</p>
<p>一个正则表达式的例子：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914276.png" alt="image-20240621102049198"></p>
<p>alphabet 字母表</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914663.png" alt="image-20240621103430822"></p>
<h2 id="有限状态机"><a class="header-anchor" href="#有限状态机"></a>有限状态机</h2>
<h3 id="实现正则表达式RE"><a class="header-anchor" href="#实现正则表达式RE"></a>实现正则表达式RE</h3>
<p>RE可以使用有限状态机FA进行表示</p>
<h3 id="NFA-非确定的有限状态机"><a class="header-anchor" href="#NFA-非确定的有限状态机"></a>NFA 非确定的有限状态机</h3>
<p>非确定性有限状态机中,每个输入符号可以有多个状态转换,这意味着在任何给定时间,NFA可以处以多种状态之一</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914236.png" alt="image-20240621110132100"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914509.png" alt="image-20240621110104122"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914403.png" alt="image-20240621110124293"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914377.png" alt="image-20240621110118970"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914552.png" alt="image-20240621110150891"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914204.png" alt="image-20240621110201703"></p>
<h3 id="扫描的二义性"><a class="header-anchor" href="#扫描的二义性"></a>扫描的二义性</h3>
<p>最长匹配的词素来解决二义性问题</p>
<ol>
<li>Convert expressions to NFAs. 将正则表达式转换为NFA</li>
<li>Run all NFAs in parallel, keeping track of the last match.<br>
所有的NFA都并行运行,保持最后match的轨迹</li>
<li>When all automata get stuck, report the last match and restart the<br>
search at that point.<br>
所以的自动机都发生堵塞,报告最后的match,然后从这一点重新开始</li>
</ol>
<p>有多条可以匹配上的规则：设置优先级。通过选择优先级更高的匹配来打破平局</p>
<p>没有可以匹配上的规则：设置一台用于报错的状态机，但是优先级设置为最低，有一个通用规则来处理错误。</p>
<ol>
<li>如何将词素和标记关联起来
<ol>
<li>标记定义</li>
<li>扫描输入</li>
</ol>
</li>
<li>有多条扫描路径，如何选择
<ol>
<li>最长匹配优先</li>
<li>设置优先级</li>
</ol>
</li>
</ol>
<h3 id="DFA-确定的有限状态机"><a class="header-anchor" href="#DFA-确定的有限状态机"></a>DFA 确定的有限状态机</h3>
<p>在确定性有限状态机中,每个输入符号都只有唯一的状态转换,这样就意味着DFA只能处于一种状态;</p>
<p>每个状态对于一个确定的输入只能转换到一个新的状态，不可能存在多个状态或多种转换transition</p>
<p>在DFA的存在周期当中只能有一个state存在。</p>
<p>空集转换是不合法的</p>
<p>DFA仅需要线性时间即可匹配一个长度为 m 的字符串 O(m)的复杂度</p>
<h3 id="子集构造法"><a class="header-anchor" href="#子集构造法"></a>子集构造法</h3>
<p>将NFA中一类状态对应成DFA中的一个状态</p>
<p>将NFA中一类状态到另一类状态的转换对应到DFA中两个转换间的转换——</p>
<p>用DFA的一个状态来表示通过单个字符输入从某个状态可以到达的其他状态的集合</p>
<p>一个DFA的状态代表NFA的一个状态集合,DFA的转化就是NFA的状态集合之间的转化</p>
<ol>
<li>通过空转换可到达的所有状态组成的集合为同一个DFA中的一个状态 ε-closure</li>
<li>通过一步从空状态 非空转换可到达的所有状态组成的集合为一个状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">xxx</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​</li>
</ol>
<h3 id="最小化算法"><a class="header-anchor" href="#最小化算法"></a>最小化算法</h3>
<ol>
<li>消除多余状态</li>
<li>合并等价状态</li>
</ol>
<h1 id="语法分析-Syntax-analysis-Parsing"><a class="header-anchor" href="#语法分析-Syntax-analysis-Parsing"></a>语法分析 Syntax analysis(Parsing)</h1>
<p>语法分析后，得到一系列token，需要解释这些token的含义</p>
<p>恢复token原本描述的句子结构——即语法；token无法组成符合语法的顺序结构时，报错</p>
<h2 id="Context-free-Grammar-CFG（上下文无关文法）"><a class="header-anchor" href="#Context-free-Grammar-CFG（上下文无关文法）"></a>Context-free Grammar CFG（上下文无关文法）</h2>
<p>将文法规则转换成可以用来解析代码的方法</p>
<p>分为两种分析方法：Top-down parsing 和 Bottom-up parsing</p>
<blockquote>
<p>正则表达式对于词法的分析是线性的；使用ParsingTree对语法进行分析是递归的</p>
</blockquote>
<p><strong>CF展示信息和进行结构构造的能力强于RE，同时RE表达能力较弱，无法进行记忆与回溯，因而无法对语法进行分析</strong></p>
<p>语法分析最终的输出是一颗语法树，语法分析的目的也是构造一颗显式或隐式的语法树，语法树中每个节点都包含编译过程中reminder需要的对象</p>
<p>树的递归式结构符合语法递归式的定义结构</p>
<p>一个文法在编译原理当中即可视为一系列产生式的结合</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914566.png" alt="image-20240622152759993"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914973.png" alt="image-20240622152814903"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011914576.png" alt="image-20240622152928330"></p>
<h3 id="RE-和-CFG的对比"><a class="header-anchor" href="#RE-和-CFG的对比"></a>RE 和 CFG的对比</h3>
<p>CFG使用递归语句来实现RE中的闭包操作，即：<br>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915352.png" alt="image-20240622153128171"> 可以转换成右图： <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915897.png" alt="image-20240622153134704" style="zoom:50%;" /></p>
<p>CFG具有更广泛的表示形式</p>
<p>通过使用CFG进行推导即可知道token组成的句子符合文法，是否正确</p>
<p>句型 sentential form：既包含终结符又包含非终结符，即从开始符号 S 开始的</p>
<p>句子 sentence ：只包含终结符</p>
<ol>
<li>
<p>The root node is labeled with the start symbol S<br>
树的每一片叶子由空或者terminal进行标记</p>
</li>
<li>
<p>Each leaf node is labeled with a terminal or with ε<br>
每一个非叶子节点都代表一个非终结符</p>
</li>
<li>
<p>Each nonleaf node is labeled with a nonterminal</p>
</li>
<li>
<p>If a node with label A ∈ VN has n children with labels X1,X2,…,Xn<br>
(which may be terminals or nonterminals), then A → X1X2…Xn∈P</p>
</li>
</ol>
<p>一条推理derivation是由一系列产生式所得的句型 sentential forms：S ⇒ … ⇒ …</p>
<h3 id="最左推导-Leftmost-derivation"><a class="header-anchor" href="#最左推导-Leftmost-derivation"></a>最左推导 Leftmost derivation</h3>
<p>每一步中，最左的非终结符被置换推导，并进入到下一步中</p>
<p>分析树的先序遍历</p>
<h3 id="AST-Abstract-Syntax-Tree"><a class="header-anchor" href="#AST-Abstract-Syntax-Tree"></a>AST Abstract Syntax Tree</h3>
<p>将生成的Parsing Tree转换成AST</p>
<p>将分析树简化成抽象语法树，最终也只是将抽象语法树作为输入传递到下一个阶段当中</p>
<h2 id="二义性问题-Ambiguity"><a class="header-anchor" href="#二义性问题-Ambiguity"></a>二义性问题 Ambiguity</h2>
<p>同一个串出现了两颗语法树，即存在两种可匹配该句子的语法</p>
<p>正常来说，不同的推导过程最后会得到相同的语法树和抽象语法树</p>
<p>但是有些语法：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915767.png" alt="image-20240623010419663"> 会导致因为推导顺序的不同而出现不同的语法树</p>
<p>STring=“i-i*i”</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915421.png" alt="image-20240623010445883"></p>
<p>int - int - int</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915310.png" alt="image-20240623010914178"></p>
<h3 id="两种处理二义性的方法"><a class="header-anchor" href="#两种处理二义性的方法"></a>两种处理二义性的方法</h3>
<h4 id="添加规则Rule"><a class="header-anchor" href="#添加规则Rule"></a>添加规则Rule</h4>
<ol>
<li>添加优先级</li>
<li>左联系</li>
</ol>
<h4 id="重写文法"><a class="header-anchor" href="#重写文法"></a>重写文法</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915804.png" alt="image-20240623011243650"></p>
<p>左结合和右结合</p>
<ol>
<li>左结合</li>
</ol>
<h2 id="什么是预测性分析"><a class="header-anchor" href="#什么是预测性分析"></a>什么是预测性分析</h2>
<p>基于剩余的input，预测可能被使用的产生式</p>
<h3 id="两种预测性分析的方法"><a class="header-anchor" href="#两种预测性分析的方法"></a>两种预测性分析的方法</h3>
<p>一种递归向下分析</p>
<p>一种向前看一步 Look-ahead one token</p>
<h1 id="自顶向下"><a class="header-anchor" href="#自顶向下"></a>自顶向下</h1>
<h2 id="LL-1-文法-First和Follow-set"><a class="header-anchor" href="#LL-1-文法-First和Follow-set"></a>LL(1)文法 First和Follow set</h2>
<h3 id="First-set"><a class="header-anchor" href="#First-set"></a>First set</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915539.png" alt="image-20240623015518332"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915340.png" alt="image-20240623100137169"></p>
<h3 id="Follow-Set"><a class="header-anchor" href="#Follow-Set"></a>Follow Set</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915059.png" alt="image-20240623015531401"></p>
<h3 id="判断一个文法是否符合LL-1-文法"><a class="header-anchor" href="#判断一个文法是否符合LL-1-文法"></a>判断一个文法是否符合LL(1)文法</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915102.png" alt="image-20240623101056096"></p>
<p>有左公因子或左递归一定不是</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915482.png" alt="image-20240623105054041"></p>
<h2 id="递归向下分析"><a class="header-anchor" href="#递归向下分析"></a>递归向下分析</h2>
<h2 id="LL-1-分析（非递归分析）"><a class="header-anchor" href="#LL-1-分析（非递归分析）"></a>LL(1)分析（非递归分析）</h2>
<h2 id="分析表"><a class="header-anchor" href="#分析表"></a>分析表</h2>
<h1 id="自底向上"><a class="header-anchor" href="#自底向上"></a>自底向上</h1>
<p>规约/化简都是从左侧区域的最右边开始的</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915752.png" alt="image-20240623160909316"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915154.png" alt="image-20240623160948167"></p>
<p>所有的规约动作都只发生在左区域的最右部分</p>
<p>将分析栈中部分符号弹出匹配，并重新压入正确的非终结符，即将右部倒推回左部</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915305.png" alt="image-20240623161416454"></p>
<p>大多数时候查看栈顶无法满足规约需求，可能pop出更深的位置去进行规约</p>
<h2 id="LR分析器"><a class="header-anchor" href="#LR分析器"></a>LR分析器</h2>
<h3 id="寻找handle"><a class="header-anchor" href="#寻找handle"></a>寻找handle</h3>
<p>LR解析器维护状态（Sm）来跟踪我们在解析中的位置。状态总结了下面堆栈中包含的信息</p>
<p>存储“$S0X1S1……XmSm”，其中Xi是一个语法符号，而Si是一个状态。在每次推送一个符号后，新的状态号都会被推到解析堆栈中</p>
<h3 id="LR功能较弱的原因"><a class="header-anchor" href="#LR功能较弱的原因"></a>LR功能较弱的原因</h3>
<ol>
<li>LR (0)只接受没有正确上下文的语言</li>
<li>我们的移位/减少解析器只看句柄的左边，而不是向右边</li>
<li></li>
</ol>
<h2 id="SLR-1"><a class="header-anchor" href="#SLR-1"></a>SLR(1)</h2>
<h1 id="语义分析-Semantic-analysis"><a class="header-anchor" href="#语义分析-Semantic-analysis"></a>语义分析 Semantic analysis</h1>
<p>静态语义</p>
<p>动态语义</p>
<p>属性文法</p>
<p>语法自导翻译 SDD Syntax Directed Definitions</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011915068.png" alt="image-20240623200808980"></p>
<h2 id="综合属性和继承属性"><a class="header-anchor" href="#综合属性和继承属性"></a>综合属性和继承属性</h2>
<h3 id="综合属性的判断："><a class="header-anchor" href="#综合属性的判断："></a>综合属性的判断：</h3>
<p>非终结符可以有综合属性和继承属性，</p>
<p>文法开始符S没有继承属性</p>
<p>终结符只有综合属性，由词法程序提供</p>
<p>S属性文法是只含有综合属性的属性文法</p>
<p>一个属性文法称之为、L-属性文法，</p>
<p>如果属性来自于产生式的左部的，</p>
<p>且该属性的值是由右部的属性或其它属性的确定的，就是综合属性</p>
<h3 id="继承属性的判断"><a class="header-anchor" href="#继承属性的判断"></a>继承属性的判断</h3>
<p>如果属性来自于产生式的右部的</p>
<p>且由左边属性或右边属性任意文法符号确定（包括自己）</p>
<h2 id="综合属性和继承属性的计算：向上综合，向下继承"><a class="header-anchor" href="#综合属性和继承属性的计算：向上综合，向下继承"></a>综合属性和继承属性的计算：向上综合，向下继承</h2>
<h3 id="计算顺序："><a class="header-anchor" href="#计算顺序："></a>计算顺序：</h3>
<ol>
<li>先放上终结符的数值</li>
<li>综合：再自底向上地传递综合属性的值</li>
<li>继承：兄弟和父亲节点的继承属性一步步向下传递值</li>
</ol>
<h3 id="阐述语义功能"><a class="header-anchor" href="#阐述语义功能"></a>阐述语义功能</h3>
<p>观察每一个属性文法的公式，看看其把什么转化成了什么，最终是否有输出</p>
<h1 id="中间代码生成-Intermediate-code-generation"><a class="header-anchor" href="#中间代码生成-Intermediate-code-generation"></a>中间代码生成 Intermediate code generation</h1>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h1>
<h1 id="引言"><a class="header-anchor" href="#引言"></a>引言</h1>
<h2 id="1-2-Network-edge"><a class="header-anchor" href="#1-2-Network-edge"></a>1.2 Network edge</h2>
<p><strong>several type of access networks</strong></p>
<ul>
<li>residential access nets 住宅接入网</li>
<li>institutional access networks (school, company) 机构接入网</li>
<li>wireless access networks 无线接入网</li>
<li>bandwidth bit per second 带宽 bps</li>
</ul>
<p><strong>Physical media: twisted pair</strong></p>
<ul>
<li>Twisted copper wire / Twisted pair 双绞铜线</li>
<li>coax/coaxial cable 同轴电缆</li>
<li>fiber optic 光纤</li>
<li>radio 无线电</li>
</ul>
<h2 id="1-3-network-core"><a class="header-anchor" href="#1-3-network-core"></a>1.3 network core</h2>
<p>Difference of performance between Packet-switching &amp; circuit switching</p>
<ol>
<li>分组交换不适合实时服务，端到端的时延是可变和不可预测的</li>
<li>分组交换有着比电路交换更好的网络共享；</li>
<li>比电路交换更简单、有效，实现成本更低；</li>
</ol>
<h2 id="1-4-Performance"><a class="header-anchor" href="#1-4-Performance"></a>1.4 Performance:</h2>
<p>delay, loss and throughput in packet-switched networks</p>
<h3 id="四种时延：时延的大小不是一个常数，而是和拥塞程度有关"><a class="header-anchor" href="#四种时延：时延的大小不是一个常数，而是和拥塞程度有关"></a>四种时延：时延的大小不是一个常数，而是和拥塞程度有关</h3>
<ul>
<li><strong>传输时延</strong>：Transmission delay 取决于数据包的长度和传输速率。</li>
<li><strong>传播时延</strong>：Propagation delay 取决于传输媒介的传播速度和距离。</li>
<li><strong>排队时延</strong>：querying delay 取决于网络节点的<strong>队列长度</strong>、<strong>流量和服务质量</strong>。</li>
<li><strong>处理时延</strong>：processing delay 取决于设备的<strong>处理能力和负载</strong>情况。</li>
</ul>
<h4 id="特点："><a class="header-anchor" href="#特点："></a>特点：</h4>
<p><strong>传输时延</strong>：从packet的第一个bit开始到最后一个bit传送到链路所需要的时间</p>
<p>传输时延 = 数据包长度（比特）/ 传输速率（比特/秒）</p>
<p><strong>传播时延</strong>：数据在信道介质中的传播时间，即数据从发送端到接收端所需时间</p>
<p><strong>排队时延</strong>：数据在节点的输出队列中等待被发送的时间</p>
<p><strong>处理时延</strong>：数据在在网络节点中被路由器、交换机或终端设备处理所需时间</p>
<p>loss and throughput</p>
<h3 id="丢包："><a class="header-anchor" href="#丢包："></a>丢包：</h3>
<ul>
<li><strong>数据包丢失</strong>：在到达目的地之前丢弃或丢失的数据包。可能由于拥塞、错误或缓冲区溢出等原因造成。</li>
<li><strong>比特错误率（BER）</strong>：接收到的错误比特数与发送的总比特数的比率。反映了传输媒介的可靠性。</li>
</ul>
<h3 id="吞吐量："><a class="header-anchor" href="#吞吐量："></a>吞吐量：</h3>
<ul>
<li><strong>有效吞吐量</strong>：单位时间内传输的实际有用数据量，不包括协议开销和重传。反映了数据传输的有效速率。</li>
<li><strong>链路利用率</strong>：链路被使用来传输数据的时间百分比。反映了链路容量的有效利用程度。</li>
</ul>
<h3 id="对网络性能的影响"><a class="header-anchor" href="#对网络性能的影响"></a>对网络性能的影响</h3>
<ul>
<li><strong>延迟</strong>：高延迟会导致响应时间增加和实时通信性能下降。</li>
<li><strong>丢包</strong>：数据包丢失会降低数据传输的质量，影响网络的可靠性。</li>
<li><strong>吞吐量</strong>：较高的吞吐量表示网络容量和性能更好，允许在给定时间内传输更多的数据。</li>
</ul>
<h2 id="1-5-Protocol-layers-service-models"><a class="header-anchor" href="#1-5-Protocol-layers-service-models"></a>1.5 Protocol layers, service models</h2>
<p>Data encapsulation process and reassemble porcess of TCP/IP</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011918280.png" alt="image-20240613094945502"></p>
<h3 id="Protocols-in-each-layer-of-TCP-IP"><a class="header-anchor" href="#Protocols-in-each-layer-of-TCP-IP"></a>Protocols in each layer of TCP/IP</h3>
<p><strong>应用层（Application Layer）</strong>：</p>
<ul>
<li>HTTP（超文本传输协议）:Electronic mail 80</li>
<li>HTTPS（安全超文本传输协议）</li>
<li>FTP（文件传输协议）：Pile transfer 21</li>
<li>SMTP（简单邮件传输协议）25</li>
<li>POP3（邮局协议版本3）110</li>
<li>IMAP（Internet消息访问协议）</li>
<li>DNS（域名系统）53号</li>
<li>DHCP（动态主机配置协议）</li>
<li>Telnet():Remote termind access 23</li>
</ul>
<p><strong>传输层（Transport Layer）</strong>：</p>
<ul>
<li>TCP（传输控制协议）</li>
<li>UDP（用户数据报协议）</li>
<li>RTP():</li>
</ul>
<p><strong>网络层（Network Layer）</strong>：</p>
<ul>
<li>
<p>IP（Internet协议）</p>
</li>
<li>
<p>ICMP（Internet控制消息协议）</p>
</li>
<li>
<p>ARP（地址解析协议）</p>
<ul>
<li>ARP查询包封装在以太网帧（Ethernet frame）的数据字段中。通过这种方式，ARP请求能够在局域网中进行广播，从而解析目标设备的MAC地址。</li>
</ul>
</li>
<li>
<p>RARP（逆地址解析协议）</p>
</li>
<li>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
</li>
</ul>
<p><strong>数据链路层（Data Link Layer）</strong>：</p>
<ul>
<li>Ethernet（以太网）</li>
<li>ARP（地址解析协议）</li>
<li>PPP（点对点协议）</li>
<li>HDLC（高级数据链路控制）</li>
<li>Frame Relay（帧中继）</li>
</ul>
<h3 id="protocol-stacks-in-Internet"><a class="header-anchor" href="#protocol-stacks-in-Internet"></a>protocol stacks in Internet</h3>
<ol>
<li>application</li>
<li>transport：进程与进程间通信：TCP/UDP</li>
<li>network：从源主机到目的主机的数据报路由：IP，routing protocols</li>
<li>link：相邻网络节点间的数据传输</li>
<li>physical</li>
</ol>
<h1 id="应用层"><a class="header-anchor" href="#应用层"></a>应用层</h1>
<h2 id="2-1-Principles-of-network-applications"><a class="header-anchor" href="#2-1-Principles-of-network-applications"></a>2.1 Principles of network applications</h2>
<p>Application layer protocol and Underlying transport protocol and why?</p>
<p>(such as Web, SMTP, POP3,Telnet, HTTP, FTP )</p>
<p>How to design or judge an architecture of computer network</p>
<h2 id="2-2-Web-and-HTTP"><a class="header-anchor" href="#2-2-Web-and-HTTP"></a>2.2 Web and HTTP</h2>
<p>HTTP request message &amp; respond message<br>
HTTP 1.0 (non-persistent HTTP) &amp; HTTP 1.1 (persistent HTTP)<br>
Meaning of Response Status code (2xx : 成功,3xx : 重定向,4xx : 请求<br>
错误,和服务端无关, 5xx : 服务器错误,)</p>
<p>Function of cookie and cache</p>
<ol>
<li>reduce response time for client request 减少对客户请求的响应时间</li>
<li>reduce traffic on an institution’s access link.减少机构接入链路的流量。</li>
<li>Internet dense with caches: enables “poor” content providers to effectively deliver content (but so does P2P file sharing)<br>
互联网密集的缓存:使内容提供者能够有效地提供内容(但P2P文件共享也是如此)</li>
</ol>
<h2 id="2-3-FTP"><a class="header-anchor" href="#2-3-FTP"></a>2.3 FTP</h2>
<p>used for transferring files, based on <strong>TCP of transport layer</strong><br>
FTP client contacts FTP server at port 21 (for control), but opens 2nd TCP connectionto client at port 20 (for file) --control connection: “out of band”<br>
FTP客户端在端口21连接FTP服务器(用于控制FTP服务)，在端口20建立：控制连接:&quot; out of band &quot;用于控制FTP连接继续与否</p>
<h2 id="2-4-Electronic-Mail"><a class="header-anchor" href="#2-4-Electronic-Mail"></a>2.4 Electronic Mail</h2>
<p>SMTP: sending email to the receiver’s server (only 7-bit ASCII code text)<br>
POP3 and IMAP: receive email from receiver’s server</p>
<h2 id="2-5-DNS-域名系统"><a class="header-anchor" href="#2-5-DNS-域名系统"></a>2.5 DNS 域名系统</h2>
<p>应用层协议</p>
<h3 id="Funcation-of-DNS"><a class="header-anchor" href="#Funcation-of-DNS"></a>Funcation of DNS</h3>
<p>distributed database implemented in hierarchy of many name servers application-layer protocol host, router, name servers to communicate to resolve names<br>
分布式数据库实现了多层域名服务器的应用层协议主机、路由器、域名服务器之间的通信来解析域名</p>
<p>Layer architecture of DNS system</p>
<ol>
<li>防止单点故障</li>
<li>易于拓展</li>
<li>负载均衡</li>
</ol>
<h2 id="2-6-Peer-to-Peer-Applications"><a class="header-anchor" href="#2-6-Peer-to-Peer-Applications"></a>2.6 Peer-to-Peer Applications</h2>
<p>Comparing features of Client-server with P2P</p>
<ol>
<li>P2P具有自拓展性，因而对等方数量增多时不会降低性能；C/S拓展能力有限</li>
<li>P2P去中心化，C/S具有中心服务器</li>
<li>P2P网络健壮性好，不用担心单点故障，C/S存在单点故障的问题</li>
<li>P2P不易于集中管理；C/S可以进行集中式的管理</li>
<li>P2P减轻了服务器的计算压力，而C/S对服务器的性能要求较高</li>
<li></li>
</ol>
<h2 id="socket"><a class="header-anchor" href="#socket"></a>socket</h2>
<p>主机本地的应用程序创建的由操作系统控制的接口(“门”)，应用程序进程可以在其中向另一个应用程序进程发送和接收消息</p>
<h3 id="TCP-SOCKET："><a class="header-anchor" href="#TCP-SOCKET："></a>TCP-SOCKET：</h3>
<p>TCP是面向连接的协议，每个TCP连接通过以下四个要素唯一标识：</p>
<ol>
<li><strong>源IP地址</strong>：发送方的IP地址。 source IP address</li>
<li><strong>源端口号</strong>：发送方的端口号。 source port number</li>
<li><strong>目标IP地址</strong>：接收方的IP地址。 dest IP address</li>
<li><strong>目标端口号</strong>：接收方的端口号。 dest port number</li>
</ol>
<p>这些要素组成了一个四元组（source IP, source port, destination IP, destination port），它唯一标识了一个TCP连接。</p>
<p>TCP套接字需要使用四元组（源IP地址、源端口号、目标IP地址、目标端口号）来唯一标识一个连接。这是因为在同一个IP地址和端口号上，可以同时建立多个到不同目标的连接，每个连接都需要独立的状态维护。</p>
<h3 id="UDP-Socket"><a class="header-anchor" href="#UDP-Socket"></a>UDP-Socket</h3>
<p>UDP是无连接的协议，每个UDP通信通过以下两个要素唯一标识：</p>
<ol>
<li><strong>目标IP地址</strong>：接收方的IP地址。dest IP address</li>
<li><strong>目标端口号</strong>：接收方的端口号。 dest port number</li>
</ol>
<p>由于UDP不建立连接，每个数据报（datagram）是独立的，因此UDP套接字的标识只依赖于目的IP地址和端口号。</p>
<p>由于UDP是无连接和无状态的，套接字标识只需要包含目标IP地址和端口号即可。这是因为每个数据包是独立的，源IP地址和端口号不需要用来维持连接状态。</p>
<h1 id="传输层"><a class="header-anchor" href="#传输层"></a>传输层</h1>
<h2 id="3-1-Transport-layer-services"><a class="header-anchor" href="#3-1-Transport-layer-services"></a>3.1 Transport-layer services</h2>
<p>provide logical communication between app processes running on different hosts</p>
<p><strong>传输层的主要作用：</strong> 为运行在不同主机上的应用程序进程提供逻辑通信</p>
<h3 id="Differences-on-providing-data-transmission-services"><a class="header-anchor" href="#Differences-on-providing-data-transmission-services"></a>Differences on providing data transmission services</h3>
<ul>
<li>network layer: between end-to-end hosts</li>
<li>transport layer: between application processes</li>
</ul>
<h3 id="Features-of-TCP"><a class="header-anchor" href="#Features-of-TCP"></a>Features of TCP</h3>
<ol>
<li>Reliable data transfer 可靠数据传输</li>
<li>congestion control 拥塞控制</li>
<li>flow control 流控制</li>
<li>connection management  连接管理</li>
</ol>
<h3 id="Differences-of-TCP-UDP"><a class="header-anchor" href="#Differences-of-TCP-UDP"></a>Differences of TCP &amp; UDP</h3>
<ol>
<li>可靠性：TCP提供可靠数据传输服务，UDP提供的是不可靠的</li>
<li>有无连接：TCP是面向连接的，UDP是无连接的</li>
<li>分组结构：TCP头部至少有 20 bytes，最多可以有 60 bytes；UDP头部只有 8 bytes</li>
<li>流量和拥塞控制：TCP具有流量控制，拥塞控制等机制，UDP没有。</li>
<li></li>
</ol>
<h2 id="3-2-Multiplexing-and-demultiplexing"><a class="header-anchor" href="#3-2-Multiplexing-and-demultiplexing"></a>3.2 Multiplexing and demultiplexing</h2>
<h3 id="Functions-of-multiplexing-and-demultiplexing"><a class="header-anchor" href="#Functions-of-multiplexing-and-demultiplexing"></a>Functions of multiplexing and demultiplexing</h3>
<ol>
<li>复用: 从多个sockets中获取数据，并用header进行封装 (header后续用于解复用)多路复用就是一个封装的过程</li>
<li>解复用：将传输层收到的segments 传输到 correct socket 解复用就是一个解封装的过程</li>
</ol>
<h3 id="Port-number-length-16-bits"><a class="header-anchor" href="#Port-number-length-16-bits"></a>Port number (length-16 bits)</h3>
<p><strong>常用的一些port</strong>：TELNET:23; SMTP:25 ; POP3:110;HTTP: 80 ; FTP: 20/21; DNS：53</p>
<h2 id="使用了-TCP-UDP-作为传输协议的应用"><a class="header-anchor" href="#使用了-TCP-UDP-作为传输协议的应用"></a>使用了 TCP/UDP 作为传输协议的应用</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919575.png" alt="image-20240618212826989"></p>
<h2 id="3-3-Connectionless-transport-UDP"><a class="header-anchor" href="#3-3-Connectionless-transport-UDP"></a>3.3 Connectionless transport: UDP</h2>
<h3 id="UDP-format"><a class="header-anchor" href="#UDP-format"></a>UDP format</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919872.png" alt="image-20240619103942315"></p>
<p>4 bytes source + 4 bytes dest port + 4 bytes length + 4 bytes checksum检验和</p>
<p>校验和的计算：</p>
<ol>
<li>
<p>将整个报文段按照每 16 bits 为一个加数划分，不足16位的补0，再将这些加数全部加起来，如果有溢出则在末尾加上1。</p>
</li>
<li>
<p>假设现在有三个16位的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0110011001100000</span><br><span class="line">0101010101010101</span><br><span class="line">1000111100001100</span><br></pre></td></tr></table></figure>
<p>则：将三个数相加，溢出的第17位和后面的16位相加，可以得到：0100 1010 1100 0010</p>
</li>
<li>
<p>对得到的和取反：1011 0101 0011 1101</p>
</li>
<li>
<p>最后在接收方，将三个数字和checksum再相加一次，如果结果全为1，则没有出错。</p>
</li>
</ol>
<h3 id="UDP存在的原因："><a class="header-anchor" href="#UDP存在的原因："></a>UDP存在的原因：</h3>
<ol>
<li>无须建立连接，简单</li>
<li>分组的头部小</li>
<li>没有拥塞控制，UDP可以尽可能快速的传播</li>
</ol>
<h2 id="3-4-Principles-of-reliable-data-transfer"><a class="header-anchor" href="#3-4-Principles-of-reliable-data-transfer"></a>3.4 Principles of reliable data transfer</h2>
<h3 id="Principles-of-different-version-of-rdt-reliable-data-transfer-1-0、2-0、2-1、2-2、3-0"><a class="header-anchor" href="#Principles-of-different-version-of-rdt-reliable-data-transfer-1-0、2-0、2-1、2-2、3-0"></a>Principles of different version of rdt reliable data transfer(1.0、2.0、2.1、2.2、3.0)</h3>
<ul>
<li>每一版本的rdt都多解决了一种进程间通信可能出现的问题</li>
</ul>
<h4 id="rdt1-0-reliable-transfer-over-a-reliable-channel"><a class="header-anchor" href="#rdt1-0-reliable-transfer-over-a-reliable-channel"></a>rdt1.0 reliable transfer over a reliable channel</h4>
<p><strong>问题背景</strong>：假设底层通道是可靠的，即不会丢包、出错或乱序。</p>
<p><strong>解决问题</strong>：无特别的传输可靠性问题需要解决，只是简单的发送和接收数据。</p>
<p><strong>机制</strong>：直接发送数据，没有任何校验或确认机制。</p>
<h4 id="rdt2-0-channel-with-bit-errors"><a class="header-anchor" href="#rdt2-0-channel-with-bit-errors"></a>rdt2.0 channel with bit errors</h4>
<p><strong>问题背景</strong>：底层通道可能会引入比特错误（但不丢包）。</p>
<p><strong>解决问题</strong>：确保在存在比特错误的情况下，数据能够被正确接收。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>使用错误检测机制（如校验和）来检测错误。</li>
<li>接收方在接收到数据后发送确认（ACK）或否认（NAK）消息。</li>
<li>发送方在收到NAK时重传数据。</li>
</ul>
<p>解决措施：使用 ack 和 nak 接收方<strong>反馈机制和重传机制</strong></p>
<h4 id="rdt2-1-处理出错的ack和nak"><a class="header-anchor" href="#rdt2-1-处理出错的ack和nak"></a>rdt2.1 处理出错的ack和nak</h4>
<p><strong>问题背景</strong>：处理可能的比特错误，同时应对ACK和NAK本身可能出错的情况。</p>
<p><strong>解决问题</strong>：提供额外的机制来确保ACK和NAK的可靠传输。</p>
<p><strong>机制</strong>：</p>
<ul>
<li><strong>引入序列号</strong>来区分不同的分组（即使分组被重传）。</li>
<li>发送方在发送分组时附加序列号，接收方在ACK/NAK中也包含序列号。</li>
</ul>
<h4 id="rdt2-2"><a class="header-anchor" href="#rdt2-2"></a>rdt2.2</h4>
<p><strong>问题背景</strong>：改进rdt2.1，使其不依赖NAK，仅使用ACK。</p>
<p><strong>解决问题</strong>：进一步简化协议，只使用ACK来确认接收到的分组，重传丢失或出错的分组。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>使用ACK中的序列号来确认特定的分组。</li>
<li>接收方在收到错误或丢失的分组时，重复发送上次的ACK来触发发送方重传。</li>
</ul>
<h4 id="rdt3-0"><a class="header-anchor" href="#rdt3-0"></a>rdt3.0</h4>
<p><strong>问题背景</strong>：底层通道可能会丢包。</p>
<p><strong>解决问题</strong>：确保数据包在存在丢包的情况下也能够被正确接收。</p>
<p><strong>机制</strong>：</p>
<ul>
<li>引入<strong>超时和重传</strong>机制：<strong>发送方</strong>在发送数据包后启动定时器，如果在超时前没有收到ACK，则重传数据包。</li>
<li>继续使用序列号和ACK机制来确认数据包的接收。</li>
</ul>
<h3 id="Comparisons-of-sliding-window-protocols-GBN-SR"><a class="header-anchor" href="#Comparisons-of-sliding-window-protocols-GBN-SR"></a>Comparisons of sliding window protocols (GBN &amp; SR)</h3>
<h4 id="滑动窗口-SlideWindow-协议："><a class="header-anchor" href="#滑动窗口-SlideWindow-协议："></a>滑动窗口(SlideWindow)协议：</h4>
<p><strong>缓冲区</strong>：暂时存放已发送的分组，以备检错重发和超时重发；但是存放在发送缓冲区的分组不一定都是已发送的。缓冲区的大小决定了一次可以发送多少个未经确认的分组。</p>
<table>
<thead>
<tr>
<th>发送方窗口大小</th>
<th>接收方窗口大小</th>
<th>协议</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>stop-wait</td>
<td></td>
</tr>
<tr>
<td>N&gt;1</td>
<td>1</td>
<td>GBN go back n steps</td>
<td>累计确认</td>
</tr>
<tr>
<td>N&gt;1</td>
<td>M&gt;1</td>
<td>SR select_repeat</td>
<td>非累计确认</td>
</tr>
</tbody>
</table>
<p>Different of features</p>
<p>Size of sending windows &amp; receiving windows of GBN &amp; SR, and why?</p>
<h2 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h2>
<h3 id="TCP的标志位："><a class="header-anchor" href="#TCP的标志位："></a>TCP的标志位：</h3>
<p>标志位：</p>
<ul>
<li>
<p>URG：紧急指针，为1时表示紧急指针有效</p>
</li>
<li>
<p><strong>SYN</strong>：同步序号，用于建立连接，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p>
</li>
<li>
<p><strong>FIN</strong>：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li>
<p><strong>RST</strong>：重置连接标志，</p>
</li>
<li>
<p><strong>ACK</strong>：确认序号标志，为1时表示确认号ack有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
</ul>
<h3 id="重传"><a class="header-anchor" href="#重传"></a>重传</h3>
<ul>
<li>
<p>一直顺序到达：</p>
<p>暂缓发送ack，设置一个定时器，在定时器超时之前如果又来了一个新的顺序分组，则重启定时器，再次暂缓发送ack，直到超时；因为累计确认，则在超时发送的那个ack之前的那些分组都是确认过的了</p>
</li>
<li>
<p>乱序到达：</p>
<p>赶紧将需要的顺序最小的期待收到的发一个ack通知发送方重新发送</p>
</li>
<li>
<p>前面顺序，中间有一个乱序：</p>
<p>有一部分gap未到达：缺那部分发哪部分的ack通知重传</p>
</li>
<li>
<p>快速重传：三个冗余ack触发的重传，无须等待发送方的计时器超时</p>
<p>例如：[30,39] [40,44] [45,50] [51,60] [60,70]</p>
<p>其中除了[40,44]其他几个都已到达</p>
<p>[30,39] 发送第一个正常的ack_40；后面三个分组则会发送三个冗余的ack_40给发送方，从而触发快速重传机制</p>
</li>
</ul>
<h3 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h3>
<p>将本地空闲缓冲区的大小反馈发送方，告知其接下来可以发送数据的大小规模，则不会因为发送方发送过多，接收方处理能力无法跟上导致的数据被大量舍弃。</p>
<h3 id="连接管理（就是三次握手）"><a class="header-anchor" href="#连接管理（就是三次握手）"></a>连接管理（就是三次握手）</h3>
<p>Three way handshake</p>
<ol>
<li>客户端发送 TCP SYN segment 给服务器：该分组不含数据，用于初始化序号</li>
<li>服务器接收到 SYN（同步）segment后，响应一个 SYN ACK segment；同时服务器分配buffer——接受窗口、初始化序号</li>
<li>客户端收到 SYNACK，回复 ACK segment（这一个回复的ack分组可能携带数据）</li>
</ol>
<h2 id="TCP拥塞控制-Congestion-Control"><a class="header-anchor" href="#TCP拥塞控制-Congestion-Control"></a>TCP拥塞控制 Congestion Control</h2>
<p>网络有太多数据，超过了网络的处理能力</p>
<p>两种控制方法：</p>
<ol>
<li>端到端拥塞控制：
<ol>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件判断是否有拥塞</li>
<li>TCP采用的方式</li>
</ol>
</li>
<li>网络辅助的拥塞控制</li>
</ol>
<h3 id="Difference-between-flow-control-congestion-control"><a class="header-anchor" href="#Difference-between-flow-control-congestion-control"></a>Difference between flow control &amp; congestion control</h3>
<ul>
<li>Flow control of TCP-receive window (rwnd) -in the header of TCP<br>
流量控制使用的是反馈接收方的接受窗口大小进而调整发送速率，采用捎带机制带回</li>
<li>Congestion control of TCP - congestion window (cwnd)<br>
拥塞控制通过检测网络拥塞状态自调整拥塞窗口大小从而达到拥塞控制的目的</li>
<li>Size of sending windows need to meet满足 the requirements of flow control &amp; congestion control at the same time.<br>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919547.png" alt="image-20240619100307223"></li>
</ul>
<h3 id="如何判断是否拥塞："><a class="header-anchor" href="#如何判断是否拥塞："></a>如何判断是否拥塞：</h3>
<ol>
<li>
<p><strong>超时</strong>:</p>
</li>
<li>
<p><strong>三个冗余ACK</strong>:</p>
</li>
</ol>
<h3 id="如何控制发送方发送速率"><a class="header-anchor" href="#如何控制发送方发送速率"></a>如何控制发送方发送速率</h3>
<ul>
<li>
<p>维持一个拥塞窗口：CongWin</p>
</li>
<li>
<p>发送方限制已发送但未确认的数据量（的上限）</p>
</li>
<li>
<p>从而粗略控制发送方往网络中注入的速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">rate = \frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>SS slow start 慢启动阶段：加倍增加（每个RTT）</p>
</li>
<li>
<p>CA congestion avoidance避免阶段阶段：线性增加（每个RTT）</p>
</li>
<li>
<p>CongWin是动态的，可以感知到网络拥塞程度的函数</p>
<ul>
<li>超时：CongWin降为 1 MSS，进入SS阶段然后再倍增到 CongWin/2(每个RTT)，从而进入CA阶段</li>
<li>冗余ACK：CongWin降为CongWin/2，CA阶段</li>
<li>否则（即正常收到ACK）：CongWin跃跃欲试</li>
</ul>
</li>
</ul>
<h3 id="联合控制："><a class="header-anchor" href="#联合控制："></a>联合控制：</h3>
<ul>
<li>
<p>发送方已发送但未确认的数据量不超过接收窗口的空闲尺寸、也不超过拥塞窗口</p>
</li>
<li>
<p>可以同时满足拥塞控制和流量控制</p>
</li>
<li>
<p>$SendWin = min { CongWin,RecvWin } $</p>
</li>
</ul>
<h3 id="控制策略"><a class="header-anchor" href="#控制策略"></a>控制策略</h3>
<ul>
<li>慢启动 ss
<ul>
<li>连接刚建立：CongWin = 1 MSS</li>
<li>每收到一个确认，CongWin加倍增长，指数级增长——必然导致拥塞</li>
<li>超时后：重置为 1 MSS，而后加倍达到标记处(CongWin/2)，而后进行线性增长(一个个MSS增加)</li>
<li>冗余ACK后：重置为 CongWin/2</li>
</ul>
</li>
<li>AIMD：线性增长、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919365.png" alt="image-20240529221931664"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919405.png" alt="image-20240613201038705"></p>
<h3 id="拥塞控制各阶段转换图"><a class="header-anchor" href="#拥塞控制各阶段转换图"></a>拥塞控制各阶段转换图</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919265.png" alt="image-20240618203633975"></p>
<p>SS，CA，FR</p>
<ul>
<li><strong>MSS</strong>：最大报文段长度，<code>TCP</code>双方发送的报文段中，包含的数据部分的最大字节数；</li>
<li><strong>cwnd</strong>：拥塞窗口，<code>TCP</code>发送但还没有得到确认的报文的序号都在这个区间；</li>
<li><strong>RTT</strong>：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；</li>
<li><strong>ssthresh</strong>：慢启动阈值，慢启动阶段，若<code>cwnd</code>的大小达到这个值，将转换到拥塞避免模式；</li>
</ul>
<h3 id="TCP-Slow-Start-–figure-3-53-transmission-round-CongWin"><a class="header-anchor" href="#TCP-Slow-Start-–figure-3-53-transmission-round-CongWin"></a>TCP Slow Start –figure 3.53- transmission round/CongWin</h3>
<p>Two phase: Slow start, congestion avoidance</p>
<p>understand of TCP congestion control according to the figure</p>
<h1 id="网络层"><a class="header-anchor" href="#网络层"></a>网络层</h1>
<h2 id="4-1-Services-of-Network-Layer"><a class="header-anchor" href="#4-1-Services-of-Network-Layer"></a>4.1 Services of Network-Layer</h2>
<p>提供主机间的逻辑通信</p>
<ul>
<li>
<p>transport segment from sending to receiving host</p>
</li>
<li>
<p>发送方将分组封装到datagram中</p>
</li>
<li>
<p>接收方接受datagram，提取出segment传送到传输层</p>
</li>
<li>
<p>每一台主机或路由器当中都有网络层协议</p>
</li>
<li>
<p>网络层服务两个重要功能：转发与路由及其含义</p>
<ul>
<li>forwarding and routing and the meanings</li>
</ul>
</li>
</ul>
<p>路由器检查所有经过它的IP数据报的报头字段</p>
<p>router examines header fields in all IP datagrams passing through it</p>
<p><strong>转发</strong>：将分组从路由的输入端移动到正确的输出端，datagram经过路由器的过程：通过单一立交的过程</p>
<p><strong>路由</strong>：确定datagram从源端到目的端的路由。使用路由选择算法 规划从源到目的的路径</p>
<h2 id="4-2-Virtual-circuit-and-datagram-networks"><a class="header-anchor" href="#4-2-Virtual-circuit-and-datagram-networks"></a>4.2 Virtual circuit and datagram networks</h2>
<p>Features of Virtual Circuit &amp; datagram network</p>
<ol>
<li><strong>virtual-circuit network</strong> provides network-layer <strong>connection service 有连接的服务</strong></li>
<li><strong>datagram network</strong> provides network-layer <strong>connectionless service 无连接的服务</strong></li>
</ol>
<p>网络层的有连接和无连接具有互斥性，因为是网络层的有连接服务是基于网络核心的硬件组成的，因此有了有连接服务之后就不能有无连接了</p>
<p>从电路交换 到 报文交换 到 分组交换 ，异步程度不断增加，文件传输效率也不断增加。（分组可以采用管道增大吞吐量）</p>
<p>Which is used in Internet and why?</p>
<p>使用 datagram network 应用于因特网中</p>
<p>原因：</p>
<ol>
<li>datagram网络更为灵活</li>
<li>自适应能力强</li>
<li>具有错误恢复的能力</li>
</ol>
<p>Comparison of Virtual Circuit &amp; Circuit switching (</p>
<p>Same: 都使用了路由器 Using the same route</p>
<p>Diff:</p>
<p>宽带资源的预先分配问题 Bandwidth resources pre-allocated</p>
<p>电路交换的资源不共享</p>
<p>建立连接</p>
<p>电路交换传播速率恒定</p>
<p>实时场景</p>
<h2 id="4-3-What’s-Inside-a-Router"><a class="header-anchor" href="#4-3-What’s-Inside-a-Router"></a>4.3 What’s Inside a Router?</h2>
<p>交换结构-通过存储器，通过总线，通过互连网络</p>
<p>switching fabric结构 –via memory, via bus, via interconnection network</p>
<p>两个关键的路由器功能：</p>
<ul>
<li>run <strong>routing algorithms</strong>/protocol (RIP, OSPF, BGP)</li>
<li><strong>forwarding datagrams</strong> from incoming to outgoing link</li>
</ul>
<h2 id="4-4-IP-Internet-Protocol"><a class="header-anchor" href="#4-4-IP-Internet-Protocol"></a>4.4 IP: Internet Protocol</h2>
<h3 id="Format-of-IPv4-datagram-header"><a class="header-anchor" href="#Format-of-IPv4-datagram-header"></a>Format of IPv4 datagram (header)</h3>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919340.png" alt="image-20240619104639933" style="zoom:67%;" /> 
<p>对于过大的分组，需要进行分片，假如一个1000bytes的分组到来，但是单个datagram MTU为：400bytes，则需要对分组分成小的data再封装成IP的数据报</p>
<p>⚠️⚠️⚠️因为IP datagram 中 IP协议的header固定占有20bytes，则实际可以存放data的大小为 380bytes。</p>
<p>每个分片的数据部分必须是8字节的倍数（<strong>除最后一个分片外</strong>），因为IP分片的<strong>偏移量字段以8字节</strong>为单位。</p>
<p>则计算出距离380最近的那个8的倍数：376 每个offset大小为 376/8 = 47</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919554.png" alt="image-20240613213127409"></p>
<p>IPv4 addressing (length)</p>
<h3 id="CIDR-Classless-InterDomain-Routing-子网掩码（一种寻址方式）："><a class="header-anchor" href="#CIDR-Classless-InterDomain-Routing-子网掩码（一种寻址方式）："></a>CIDR Classless InterDomain Routing 子网掩码（一种寻址方式）：</h3>
<ul>
<li>
<p>子网的IP位和主机位是任意的，按照子网掩码进行划分。</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919366.png" alt="image-20240613213403557"></p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919069.png" alt="image-20240613213432670"></p>
</li>
<li>
<p>subnet mask/prefix (子网中可用的IP地址个数，子网主机号长度至少为2位)</p>
</li>
<li>
<p>E.p:</p>
<ul>
<li>CIDR address:206.13.01.48/25</li>
<li>being same to 206.13.01.48 ~ 255.255.255.128</li>
</ul>
</li>
<li>
<p>Calculations about broadcast address based on Ip address and its submask</p>
</li>
</ul>
<p>主机位全为1的IP地址为广播地址；</p>
<p>主机位全为0的IP地址是网关地址，子网地址，指示本网络</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919363.png" alt="image-20240619104833346"></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a class="header-anchor" href="#DHCP-Dynamic-Host-Configuration-Protocol"></a>DHCP Dynamic Host Configuration Protocol</h3>
<ul>
<li>
<p>功能：让主机在加入网络时可以动态地从网络服务器获取到IP address</p>
</li>
<li>
<p>具体过程：</p>
<ul>
<li>DHCP的步骤:</li>
<li>主机广播 dhcp discover msg</li>
<li>DHCP服务器响应 DHCP offer msg</li>
<li>主机使用 DHCP request msg 请求 IP address</li>
<li>DHCP服务器用 DHCP ack msg 发出IP地址</li>
</ul>
</li>
<li>
<p>Calculating of IPv4 address about a subnet partitioning &amp; Routing aggregation</p>
</li>
</ul>
<h2 id="NAT"><a class="header-anchor" href="#NAT"></a>NAT</h2>
<h3 id="使用NAT的原因："><a class="header-anchor" href="#使用NAT的原因："></a>使用NAT的原因：</h3>
<ul>
<li>range of addresses not needed from ISP: just one IP address for all devices<br>
不需要来自ISP的地址范围，只需要一个IP地址即可标识所有设备</li>
<li>can change addresses of devices in local network without notifying outside world<br>
在不影响外界的情况下修改本地网络中各个设备的地址哦</li>
<li>can change ISP without changing addresses of devices in local network<br>
可以任意修改ISP且不影响本地网络中各个设备的地址</li>
</ul>
<h3 id="如何实现："><a class="header-anchor" href="#如何实现："></a>如何实现：</h3>
<h4 id="Outgoing-Datagram"><a class="header-anchor" href="#Outgoing-Datagram"></a>Outgoing Datagram</h4>
<p>当一个数据报从内部网络（私有IP地址）发往外部网络（公共IP地址）时：</p>
<ul>
<li><strong>替换源IP地址和端口号</strong>：将每个出站数据报的源IP地址和端口号替换为NAT的公共IP地址和一个新的端口号。</li>
<li><strong>记录翻译信息</strong>：在NAT翻译表中记录每个（源IP地址，端口号）和（NAT IP地址，新端口号）之间的对应关系。</li>
</ul>
<h4 id="Incoming-Datagram"><a class="header-anchor" href="#Incoming-Datagram"></a>Incoming Datagram</h4>
<p>当一个数据报从外部网络返回内部网络时，</p>
<ul>
<li><strong>查找翻译信息</strong>：在NAT翻译表中查找与目标（NAT IP地址，端口号）对应的（源IP地址，端口号）。</li>
<li><strong>替换目标IP地址和端口号</strong>：将目标IP地址和端口号替换为翻译表中存储的原始源IP地址和端口号。</li>
</ul>
<p>内往外——将内部的IP地址转化为(通过路由器)NAT IP地址<br>
外往内——通过路由器的表格将NAT IP地址转化为内网里面的内部的地址</p>
<p>端口号是有限的,如果主机数量过多,那么就不能将端口作为定位主机的IP地址的一部分</p>
<p>Function of NAT &amp; why be helpful for IPv4</p>
<p>一个子网用一个具体的IP地址，子网内部用自己的IP地址，未区分不同的设备</p>
<p>可以改变子网内部的主机设备的地址而不影响外部网络</p>
<p>外部网络发送改变也不影响子网内主机设备的地址</p>
<h3 id="ICMP"><a class="header-anchor" href="#ICMP"></a>ICMP:</h3>
<p>Internet Control Message Protocol 网络控制信息协议<br>
用于主机和路由器之间在网络层的信息交流。</p>
<p><strong>ICMP数据包的结构</strong>：ICMP消息被封装在IP数据包中，并作为IP数据包的负载。ICMP本身没有专用的传输层协议类型，它直接在网络层上运行。</p>
<p><strong>IP头部</strong>：IP数据包头部中的协议字段（Protocol Field）值为1表示这个IP数据包的负载是一个ICMP消息。</p>
<p><strong>icmp主要用于错误信息的播报和ping服务</strong></p>
<p>When ICMP message arrives,source calculates RTT Traceroute does this 3 times<br>
当ICMP消息到达时，源计算RTT <strong>Traceroute</strong>这样做3次</p>
<h4 id="常见ICMP"><a class="header-anchor" href="#常见ICMP"></a>常见ICMP</h4>
<p><strong>回显请求（Echo Request）和回显应答（Echo Reply）</strong>：用于Ping操作，用于测试目标主机是否可达以及计算往返时间。</p>
<ul>
<li>回显请求：类型8，代码0。</li>
<li>回显应答：类型0，代码0。</li>
</ul>
<p><strong>目的不可达（Destination Unreachable）</strong>：当路由器或主机无法将数据包传递给目的地时发送。</p>
<ul>
<li>类型3，不同的代码值表示不同的不可达原因，例如网络不可达、主机不可达、端口不可达等。</li>
</ul>
<p><strong>时间超过（Time Exceeded）</strong>：当数据包的TTL（Time to Live）字段减到零时发送，通常用于<strong>Traceroute</strong>操作。</p>
<ul>
<li>类型11，代码0表示TTL超时，代码1表示分片重组超时。</li>
</ul>
<p><strong>重定向（Redirect）</strong>：当路由器发现通过另一条路径传输数据更有效时，通知主机更改其路由。</p>
<ul>
<li>类型5，不同的代码值表示不同的重定向原因。</li>
</ul>
<p><strong>Traceroute 原理</strong></p>
<ul>
<li>想要获得距离本机第 n 跳的路由器信息，则发送一个 TTL 为 n 的 IP 数据报 （数据报中包含具有不可达 UDP 端口号的 UDP 报文段），到达路由器之后，因为 TTL 为 0 ，路由器向请求端发送超时 ICMP 报文。</li>
<li>当到达目的主机，会返回端口不可达 ICMP 报文，终止探测过程</li>
</ul>
<h2 id="4-4-IP-Internet-Protocol-conti"><a class="header-anchor" href="#4-4-IP-Internet-Protocol-conti"></a>4.4 IP: Internet Protocol (conti-)</h2>
<h3 id="IPv6-datagram-format"><a class="header-anchor" href="#IPv6-datagram-format"></a>IPv6 datagram format</h3>
<h4 id="地址："><a class="header-anchor" href="#地址："></a>地址：</h4>
<ul>
<li>IPv6地址长度为128位，通常使用八组16进制数表示，每组由冒号分隔。例如：AD80:0000:0000:0000:ABAA:0000:00C2:0002。</li>
<li><strong>零压缩方法</strong>：零压缩用于缩短连续零的表示，但每个地址只能压缩一次。示例如下：
<ul>
<li>原地址：AD80:0000:0000:0000:ABAA:0000:00C2:0002</li>
<li>压缩后：AD80::ABAA:0000:00C2:0002</li>
</ul>
</li>
</ul>
<h3 id="IPv6相对于IPv4的变化（IPv6的优势）"><a class="header-anchor" href="#IPv6相对于IPv4的变化（IPv6的优势）"></a>IPv6相对于IPv4的变化（IPv6的优势）</h3>
<ol>
<li><strong>更大的地址空间</strong>：IPv6使用128位地址，支持大约3.4×10^38个唯一地址，解决了IPv4地址耗尽的问题。</li>
<li><strong>简化的报头</strong>：IPv6报头结构更简洁，<strong>固定为40字节</strong>，减少了路由器处理开销。</li>
<li><strong>自动配置</strong>：支持无状态地址自动配置（SLAAC），设备可以自动生成IPv6地址。</li>
<li><strong>内置的安全性</strong>：IPv6强制支持IPsec协议，提高了网络通信的安全性。</li>
<li><strong>改进的多播和任播</strong>：增强了多播和任播功能，提高了组播通信的效率。</li>
<li><strong>扩展头部机制</strong>：通过可选的扩展头部，增加了灵活性和功能扩展能力。</li>
<li><strong>消除了网络地址转换（NAT）</strong>：每个设备可以有一个唯一的公共IP地址，简化了网络架构。</li>
</ol>
<h2 id="4-5-Routing-algorithms"><a class="header-anchor" href="#4-5-Routing-algorithms"></a>4.5 Routing algorithms</h2>
<p>路由算法决定了网络层端到端的path</p>
<p>路由器中有一个本地转发表，决定了数据报在该router里的转发方向</p>
<h3 id="两种路由器算法"><a class="header-anchor" href="#两种路由器算法"></a>两种路由器算法</h3>
<ol>
<li>全局式：所有路由器知道完整的拓扑图以及相关的连接信息：<strong>Link State 链路状态算法</strong></li>
<li>分散式：路由器仅知道主机相连的邻居已经到达邻居的costs，以迭代、分布式的方式计算从最优路径：<strong>距离向量 Distance Vector 算法——DV算法</strong></li>
<li>根据路由器中路由的变化快慢有：
<ol>
<li>静态 static：一段时间内路由变化较慢</li>
<li>动态 dynamic：一段时间内路由变化快</li>
</ol>
</li>
<li>根据算法是负载敏感还是迟钝划分：
<ol>
<li>负载敏感算法 load-sensitive algorithm：链路费用动态地变化以反映底层链路当前的拥塞水平。</li>
<li>负载迟钝：某条链路的费用不显式反映出当前的拥塞水平，常见算法有：RIP、OSPF、BGP</li>
</ol>
</li>
</ol>
<p><strong>距离向量（Distance Vector）</strong>：例如 <strong>RIP（Routing Information Protocol）和 BGP （Border Gateway Protocol）</strong>。每个路由器根据收到的距离向量更新来计算到目的地的最佳路径，并将这些信息传播给相邻的路由器。</p>
<p><strong>路径向量（Path Vector）</strong>：例如 <strong>BGP（Border Gateway Protocol）</strong>。路径向量算法类似于距离向量，但是在路由选择时考虑了更多的因素，如 AS 路由策略和路径属性。</p>
<p><strong>拓扑图（Link State）</strong>：如 <strong>OSPF</strong>。每个路由器都维护一个拓扑图，并根据该图计算最短路径。</p>
<p><strong>洪泛（Flooding）</strong>：每个收到的路由器更新都被转发到所有邻居，直到达到目的地。</p>
<h3 id="LS-Link-State算法"><a class="header-anchor" href="#LS-Link-State算法"></a>LS Link State算法</h3>
<p>向所有路由器广播整个网络拓扑的信息，让每个路由器计算到其他路由器的汇聚树。</p>
<p>使用Dijkstra算法算出当前路由器到其他每一个路由器的最短路径 OSPF使用的就是这种算法</p>
<h3 id="层次路由"><a class="header-anchor" href="#层次路由"></a>层次路由</h3>
<p><strong>规模 scale</strong></p>
<p><strong>管理自知 administrative autonomy</strong></p>
<p>将router组织成一种regions，形成<strong>自治系统AS autonomous systems</strong></p>
<p>AS 通过 Gateway Router 网关路由器进行连接与相互访问，基于这种 AS 与 AS 间的路由设计出了BGP border gateway protocol</p>
<p>同一个系统中的路由运行同一种路由算法(LS或者DV的一种)</p>
<h3 id="内部网关算法-AS内部算法"><a class="header-anchor" href="#内部网关算法-AS内部算法"></a>内部网关算法 AS内部算法</h3>
<h4 id="RIP-Routing-Information-Protocol"><a class="header-anchor" href="#RIP-Routing-Information-Protocol"></a>RIP: Routing Information Protocol</h4>
<p>RIP advertisements RIP广播</p>
<p>原理是 DV算法，交换相邻节点的路由信息</p>
<p>使用UDP协议进行传输，重复传输</p>
<h4 id="OSPF-Open-Shortest-Path-First"><a class="header-anchor" href="#OSPF-Open-Shortest-Path-First"></a>OSPF: Open Shortest Path First</h4>
<p>原理是：Link State，因为知道了局部网络中所有的路由信息，因此可以采用该算法</p>
<h4 id="BGP"><a class="header-anchor" href="#BGP"></a>BGP</h4>
<p>应用了DV算法 进而推测出最佳路径</p>
<ul>
<li>
<p>eBGP 外部网关协议：AS 与 AS 间的可达性由eBGP获得</p>
</li>
<li>
<p>iBGP 内部网关协议：AS 内部的路由器的可达性信息，由iBGP进行传播</p>
</li>
</ul>
<p>BGP允许子网向其余的internet宣布自己的存在</p>
<p>一对路由器(BGP对等方)在TCP协议的基础上进行 routing info 的交换:</p>
<p>这就叫做 BGP session(BGP会话)</p>
<h5 id="两个重要的路径属性"><a class="header-anchor" href="#两个重要的路径属性"></a>两个重要的路径属性</h5>
<ul>
<li>AS-PATH: contains ASs through which prefix advertisement has passed: e.g, AS 67, AS 17</li>
<li>NEXT-HOP: indicates specific internal-AS router to next-hop AS. (may be multiple links from current AS to next-hop-AS)<br>
指定到下一跳自治系统的特定AS内部路由器。(可能是从当前自治系统到下一跳自治系统的多条链路)
<ul>
<li>标识了应该用于到达目的网络的下一个最近的路由器（通常在同一个AS内部）。</li>
</ul>
</li>
</ul>
<h3 id="BGP路径选择依据"><a class="header-anchor" href="#BGP路径选择依据"></a>BGP路径选择依据</h3>
<p>selects route based on:<br>
local preference value attribute: policy decision<br>
shortest AS-PATH<br>
closest NEXT-HOP router: hot potato routing<br>
additional criteria</p>
<ul>
<li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary)</li>
</ul>
<p>Why there are different routing algorithms?</p>
<p>Link state</p>
<ul>
<li>principle of algorithm</li>
<li>how to use Dijkstra’s algorithms to calculate the shortest path—<br>
examples table of ppt<br>
r Distance Vector algorithm</li>
<li>Principle of algorithm &amp; how to calculating route by DV</li>
</ul>
<p>4.6 Routing in the Internet<br>
r Two levels of routing in Internet and why<br>
r Inter-AS routing - policy<br>
r Intra-AS routing- performance (costs)<br>
r Interior Gateway Protocols/intra-domain: RIP, OSPF<br>
r Principles of them<br>
r Border Gateway Protocol/inter-domain: BGP<br>
r “hot potato routing”<br>
r based on Path vector</p>
<h1 id="链路层"><a class="header-anchor" href="#链路层"></a>链路层</h1>
<h2 id="5-1-data-transmission-services"><a class="header-anchor" href="#5-1-data-transmission-services"></a>5.1 data transmission services</h2>
<h3 id="链路层的实现"><a class="header-anchor" href="#链路层的实现"></a>链路层的实现</h3>
<p>在每一个 router 和 host 的适配器 adaptor(Network Interface Card 网络接口卡，网卡) 当中去实现：以太网适配器实现了链路层和物理层</p>
<h3 id="Link-Layer-Services"><a class="header-anchor" href="#Link-Layer-Services"></a>Link Layer Services</h3>
<p>负责将datagram从一个node移动到另一个node</p>
<ol>
<li>flow control.
<ul>
<li>相邻发送和接收节点之间的速度<br>
pacing between adjacent sending and receiving nodes</li>
</ul>
</li>
<li>framing：对来自网络层的datagram进行封装，要加header和trailer
<ul>
<li>在封装过程中，发送方在frame中加入checking bits，rdt，flow control</li>
<li>接收方查看frame中添加的带有那些功能的位</li>
</ul>
</li>
<li>error detection and correction bits EDC：
<ul>
<li>Error detection not 100% reliable!</li>
<li>接收器检测到错误的存在:<br>
receiver detects presence of errors</li>
<li>接收器识别并纠正比特错误，而不需要重传<br>
receiver identifies and corrects bit error(s) without resorting to retransmission</li>
<li>使用的 EDC 方法为：Checksumming：Cyclic redundancy Check 循环校冗余检测</li>
</ul>
</li>
<li>half-duplex and full-duplex 半双工和全双工
<ul>
<li>对于半双工，链路两端的节点可以传输，但不能同时传输<br>
with half duplex, nodes at both ends of link can transmit, but not at same time</li>
</ul>
</li>
<li>reliable delivery<br>
6. link access：</li>
</ol>
<h2 id="CRC计算"><a class="header-anchor" href="#CRC计算"></a>CRC计算</h2>
<h3 id="CRC的基本原理"><a class="header-anchor" href="#CRC的基本原理"></a>CRC的基本原理</h3>
<ol>
<li><strong>多项式表示</strong>：
<ul>
<li>数据被视为一个二进制序列，并用一个多项式表示。例如，数据1101可以表示为多项式x³ + x² + 1。</li>
<li>生成多项式（Generator Polynomial）也是一个固定的二进制序列，如常用的CRC-32的生成多项式为x³² + x²⁶ + x²³ + … + 1。</li>
</ul>
</li>
<li><strong>附加零位</strong>：
<ul>
<li>在数据后面附加与生成多项式长度相同的零位。</li>
<li>例如，假设生成多项式为G(x)二进制数字长度为 n 位，</li>
<li>对于数据D(x)，在其后面附加 n-1 个零位，形成D’(x)。</li>
</ul>
</li>
<li><strong>二进制除法</strong>：一个异或操作
<ul>
<li>对D’(x)进行二进制除法，除数为生成多项式G(x)，得到余数R(x)。</li>
</ul>
</li>
<li><strong>生成校验码</strong>：
<ul>
<li>余数R(x)就是校验码，将其附加在原始数据后面形成传输数据。</li>
</ul>
</li>
</ol>
<h3 id="CRC校验过程"><a class="header-anchor" href="#CRC校验过程"></a>CRC校验过程</h3>
<ol>
<li><strong>接收数据</strong>：
<ul>
<li>接收方接收到数据D(x)和附加的校验码R(x)。</li>
</ul>
</li>
<li><strong>二进制除法校验</strong>：
<ul>
<li>接收方对包含校验码的接收数据进行与生成步骤相同的二进制除法，检查是否余数为零。</li>
<li>如果余数为零，说明数据没有错误；否则，数据存在错误。</li>
</ul>
</li>
</ol>
<h3 id="CRC示例（CRC-4）"><a class="header-anchor" href="#CRC示例（CRC-4）"></a>CRC示例（CRC-4）</h3>
<p>假设我们要发送的数据是1101，生成多项式为x⁴ + x + 1（对应的二进制为10011），步骤如下：</p>
<ol>
<li><strong>附加零位</strong>：
<ul>
<li>数据：1101</li>
<li>生成多项式长度为5位，所以附加4个零位：1101 0000</li>
</ul>
</li>
<li><strong>二进制除法</strong>：
<ul>
<li>1101 0000 ÷ 1001 1</li>
<li>二进制除法的过程类似于十进制的长除法，得到的余数R(x)为0100</li>
</ul>
</li>
<li><strong>生成校验码</strong>：
<ul>
<li>校验码为1000</li>
<li>发送的数据为1101 0100</li>
</ul>
</li>
</ol>
<h3 id="接收方校验"><a class="header-anchor" href="#接收方校验"></a>接收方校验</h3>
<ol>
<li><strong>接收数据</strong>：
<ul>
<li>接收数据为1101 0100</li>
</ul>
</li>
<li><strong>二进制除法</strong>：
<ul>
<li>1101 0100 ÷ 10011</li>
<li>如果余数为0，说明数据无误；如果余数非0，说明数据出错。</li>
</ul>
</li>
</ol>
<h2 id="5-3-Multiple-access-protocols"><a class="header-anchor" href="#5-3-Multiple-access-protocols"></a>5.3 Multiple access protocols</h2>
<h3 id="两种多连接链路"><a class="header-anchor" href="#两种多连接链路"></a>两种多连接链路</h3>
<ol>
<li>点对点式：point to point</li>
<li>广播式：  broadcast</li>
</ol>
<h3 id="多道访问协议-Multiple-Access-protocols"><a class="header-anchor" href="#多道访问协议-Multiple-Access-protocols"></a>多道访问协议 Multiple Access protocols</h3>
<h3 id="碰撞-Collision"><a class="header-anchor" href="#碰撞-Collision"></a>碰撞 Collision</h3>
<p>Collision(碰撞) of broadcast channel when two or more nodes send data at the same time<br>
当两个及以上个节点<strong>同时</strong>在信道内发送数据，则会导致 “碰撞” 的发生</p>
<h3 id="three-broad-classes（MAC-协议）"><a class="header-anchor" href="#three-broad-classes（MAC-协议）"></a>three broad classes（MAC 协议）</h3>
<h4 id="Channel-Partitioning-Multiplexing"><a class="header-anchor" href="#Channel-Partitioning-Multiplexing"></a>Channel Partitioning/Multiplexing:</h4>
<p>将信道分层小的“pieces”（时间隙）</p>
<ol>
<li>TDMA time division multiple access
<ul>
<li>时分 time slots 将一段固定的周期分成小的时间间隙，每个节点使用一个固定序号的间隙</li>
</ul>
</li>
<li>FDMA frequency division multiple access
<ul>
<li>频分 frequency</li>
</ul>
</li>
<li>CDMA 码分 code</li>
</ol>
<h4 id="Random-Access"><a class="header-anchor" href="#Random-Access"></a>Random Access:</h4>
<ol>
<li>ALOHA<br>
1.</li>
<li>slotted ALOHA</li>
<li>CSMA carrier sense multiple access
<ol>
<li>传输之前先监听信道：如果信道空闲，发送frame；如果信道忙碌，延迟发送</li>
<li></li>
</ol>
</li>
<li>CSMA\CD (Collision Detection) 载波监听多道访问（碰撞检测版）
<ol>
<li>先听再讲–载波监听</li>
<li>边讲边听—进行检测检测</li>
<li>冲突处理–发送站检测到冲突后立即停止帧的发送,并且发一个简短的堵塞信号(称强化冲突信号，Jamming signal),通知网上各站已经发生冲突,本站及网上所有站都等待一段随机分布的时间,然后再按CSMA/CD方式重发该帧。</li>
</ol>
</li>
<li>CSMA/CD 遇到冲突时进行重传的算法：Binary backoff
<ol>
<li>随机选择的时隙数 $ n \in (0,2^{重传次数}−1)$ 内选择。</li>
<li>这意味着 n 可以是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mtext>重传次数</mtext></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{重传次数}−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">重传次数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 中的任意值。</li>
<li>After 16 collisions, abandon the transmission.</li>
</ol>
</li>
</ol>
<h4 id="CSMA-CD算法也用在以太网中"><a class="header-anchor" href="#CSMA-CD算法也用在以太网中"></a>CSMA/CD算法也用在以太网中</h4>
<p>NIC network interface card</p>
<h4 id="“Taking-turns”-Tokening-Ring"><a class="header-anchor" href="#“Taking-turns”-Tokening-Ring"></a>“Taking turns”:Tokening Ring</h4>
<ol>
<li><strong>令牌传递机制</strong>：
<ul>
<li>使用一个特殊的数据包，称为“令牌”（token），在网络节点之间传递。</li>
<li>持有令牌的节点获得发送数据的权限。</li>
<li>令牌在节点之间按照特定顺序传递（通常是环形网络）。</li>
<li>当节点完成数据传输后，将令牌传递给下一个节点</li>
<li>如果节点没有数据要传输，它会简单地将令牌传递给环路中的下一个节点，而不作修改。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>网络带宽高效利用：只有需要传输数据的节点才使用网络，减少碰撞，提高效率。</li>
<li>**公平性：**每个节点根据令牌传递顺序有平等的机会传输数据。</li>
<li>**可靠性：**由于一次只能有一个节点传输，碰撞减少，提高了网络的可靠性。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>网络管理复杂：令牌管理需要额外的开销，并且实现和故障排除可能较为复杂。</li>
<li>**单点故障：**如果令牌帧丢失或损坏，或者拿到令牌的主机，可能会导致网络通信中断，直到问题解决为止。</li>
<li><strong>有效利用率不高</strong>：当网络中仅有一台主机活跃需要令牌时，它必须等待令牌的到来才可以进行数据的传输</li>
</ul>
</li>
</ol>
<h2 id="5-4-LAN-Local-Area-Network"><a class="header-anchor" href="#5-4-LAN-Local-Area-Network"></a>5.4 LAN Local Area Network</h2>
<h3 id="MAC-address"><a class="header-anchor" href="#MAC-address"></a>MAC address</h3>
<p>MAC(Media Access Control)媒体访问控制(or LAN or physical or Ethernet) address ：</p>
<p>在NIC出厂前就烧制在NIC当中，</p>
<p>48bits 的 MAC地址(对于大部分LANs)通常存储在网卡的ROM当中,也可以通过软件设置<br>
e.g.: 1A-2F-BB-76-09-AD</p>
<p>MAC address 由IEEE统一管理和分配；</p>
<p>MAC地址就像身份证号码一样；IP地址就像邮政编码一样：</p>
<p>人可以改变地址，进而修改邮政编码，但是除非重生，负责身份证号码不可以改变</p>
<h3 id="ARP（Address-Resolution-Protocol）"><a class="header-anchor" href="#ARP（Address-Resolution-Protocol）"></a>ARP（Address Resolution Protocol）</h3>
<p>将一个IP地址转换成一个MAC地址</p>
<p>有一个广播地址：FF-FF-FF-FF-FF-FF</p>
<p>每一个适配器在 Local Area Network 中有独一无二的LAN地址，那就是 MAC地址</p>
<h4 id="ARP-Table"><a class="header-anchor" href="#ARP-Table"></a>ARP Table</h4>
<p>有一个字段 TTL time to leave：用于记录 IP和MAC 的映射关系存在于ARP表中的时间，到时间则进行清除。</p>
<h4 id="ARP的工作过程"><a class="header-anchor" href="#ARP的工作过程"></a>ARP的工作过程</h4>
<ol>
<li><strong>ARP请求</strong>：
<ul>
<li>当一台主机（例如，主机A）想要和另一台主机（例如，主机B）通信时，它需要知道主机B的MAC地址。</li>
<li>如果主机A只有主机B的IP地址，它会发送一个ARP请求广播到网络中。ARP请求中包含了主机A的IP地址和MAC地址，以及主机B的IP地址（请求的目标）。</li>
</ul>
</li>
<li><strong>ARP响应</strong>：
<ul>
<li>网络中所有接收到ARP请求的设备都会检查请求中的目标IP地址是否与自身的IP地址匹配。</li>
<li>如果某台设备（即主机B）的IP地址与请求中的目标IP地址匹配，它会发送一个ARP响应，其中包含自己的MAC地址。</li>
<li>这个ARP响应是单播的，直接发送给请求者（主机A）。</li>
</ul>
</li>
<li><strong>更新ARP缓存</strong>：
<ul>
<li>主机A收到ARP响应后，会将主机B的IP地址和对应的MAC地址记录在自己的ARP缓存中，以后再次与主机B通信时，可以直接从ARP缓存中获取MAC地址，而不需要再次发送ARP请求。</li>
</ul>
</li>
<li><strong>通信</strong>：
<ul>
<li>有了主机B的MAC地址后，主机A可以通过以太网帧的目的MAC地址字段将数据包发送给主机B。</li>
</ul>
</li>
</ol>
<h4 id="ARP缓存"><a class="header-anchor" href="#ARP缓存"></a>ARP缓存</h4>
<p>为了提高效率，主机通常会维护一个ARP缓存（ARP table），其中记录了最近解析过的IP地址和MAC地址的对应关系。缓存条目有一定的生存时间（TTL），过期后会被删除。</p>
<h4 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h4>
<ul>
<li>动态解析：ARP能动态解析IP地址为MAC地址，适用于动态变化的网络环境。</li>
<li>广播请求：通过广播请求，可以确保网络中任何节点的MAC地址都能被发现。</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>安全问题：ARP协议容易受到ARP欺骗（ARP spoofing）攻击，攻击者可以发送伪造的ARP响应，导致网络中的流量被重定向或中断。</li>
<li>广播开销：ARP请求是广播的，在大型网络中频繁的ARP请求会产生一定的广播开销。</li>
</ul>
<h3 id="以太网"><a class="header-anchor" href="#以太网"></a>以太网</h3>
<p>以太网:其实就是物理拓扑图</p>
<ol>
<li>总线型：所有节点node都在一个冲突域内，如果多个node同时发生数据，这会发生冲突</li>
<li>星型：</li>
</ol>
<h4 id="Ethernet-Frame"><a class="header-anchor" href="#Ethernet-Frame"></a>Ethernet Frame</h4>
<p>将IP数据报封装到Ethernet Frame中</p>
<h4 id="不可靠、无连接"><a class="header-anchor" href="#不可靠、无连接"></a>不可靠、无连接</h4>
<ol>
<li>
<p>不可靠的：发送和接收 NIC网卡 间不发送ack；</p>
</li>
<li>
<p>无连接的：在发送和接收网卡间没有握手</p>
</li>
</ol>
<p>采取 带有二进制退避算法的无时隙的CSMA/CD 的 MAC 协议 carrier sense multiple access/collision detection</p>
<h2 id="Switch"><a class="header-anchor" href="#Switch"></a>Switch</h2>
<h3 id="Hubs-集线器"><a class="header-anchor" href="#Hubs-集线器"></a>Hubs 集线器</h3>
<h1 id="RTP"><a class="header-anchor" href="#RTP"></a>RTP</h1>
<p><em>Real-time Transport Protocol</em>（实时传输协议）</p>
<p>为<em>IP</em>网上的语音、图像、传真等多种需要实时传输的多媒体数据提供端到端的实时传输服务</p>
<p><em>RTP</em>为<em>Internet</em>上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由<em>RTCP</em>来提供。</p>
<p>单播或多播网络中传送实时数据。</p>
<h1 id="VLAN"><a class="header-anchor" href="#VLAN"></a>VLAN</h1>
<h1 id="IPv6"><a class="header-anchor" href="#IPv6"></a>IPv6</h1>
<h1 id="零散知识"><a class="header-anchor" href="#零散知识"></a>零散知识</h1>
<p>接入网/enterprise：以太网和wifi的特点：</p>
<h2 id="一些指定的端口port"><a class="header-anchor" href="#一些指定的端口port"></a>一些指定的端口port</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919169.png" alt="image-20240612205125464"></p>
<h2 id="带宽是什么"><a class="header-anchor" href="#带宽是什么"></a>带宽是什么</h2>
<p>带宽是所有链路中传输速度最小的那个值</p>
<h2 id="各种应用对于数据丢失、宽带和时间敏感的要求"><a class="header-anchor" href="#各种应用对于数据丢失、宽带和时间敏感的要求"></a>各种应用对于数据丢失、宽带和时间敏感的要求</h2>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011919421.png" alt="image-20240611195201263"></p>
<h2 id="MAC地址相关"><a class="header-anchor" href="#MAC地址相关"></a>MAC地址相关</h2>
<p>Ethernet interface addresses以太网接口地址</p>
<ul>
<li>
<p>也称为MAC地址</p>
</li>
<li>
<p>也称为硬件地址（Hardware Address）</p>
</li>
</ul>
<p><strong>IEEE注册管理机构</strong>：</p>
<ul>
<li>IEEE（电气电子工程师学会）管理MAC地址的分配。</li>
<li>网络设备制造商必须向IEEE注册，并被分配一个唯一的组织唯一标识符（OUI）。</li>
<li>确保了每个以太网接口都有一个唯一的MAC地址。</li>
</ul>
<p><strong>组织唯一标识符（OUI）</strong>：</p>
<ul>
<li>OUI是一个24位（3字节）的数字，用于唯一标识制造商或组织。</li>
<li>OUI构成MAC地址的前三个字节（24位）。</li>
</ul>
<p><strong>设备特定标识符</strong>：</p>
<ul>
<li>MAC地址的剩余24位由制造商分配。这些位用于唯一标识制造商生产的每个网络接口卡。</li>
<li>这意味着每个制造商可以为每个OUI生成多达 2242^{24}224 个唯一的MAC地址。</li>
</ul>
<h2 id="数据链路层某些协议的分类："><a class="header-anchor" href="#数据链路层某些协议的分类："></a>数据链路层某些协议的分类：</h2>
<p><strong>基于竞争的协议</strong>：</p>
<ul>
<li>CSMA/CD</li>
<li>CSMA</li>
<li>ALOHA</li>
</ul>
<p><strong>基于时分多址的协议</strong>：</p>
<ul>
<li>TDMA</li>
</ul>
<h2 id="各层协议的头部："><a class="header-anchor" href="#各层协议的头部："></a>各层协议的头部：</h2>
<p><strong>应用层（Application Layer）</strong>：</p>
<ul>
<li>应用层数据报不会添加额外的头部。例如，HTTP请求和响应的头部信息已经包含在应用层数据中。</li>
</ul>
<p><strong>传输层（Transport Layer）</strong>：</p>
<ul>
<li>TCP头部大小通常是20字节，但在某些情况下可能会有额外的选项字段，最大可达60字节。</li>
<li>UDP头部大小固定为8字节。</li>
</ul>
<p><strong>网络层（Network Layer）</strong>：</p>
<ul>
<li>IPv4头部大小通常是20字节，但也可能因选项字段而有所增加，最大可达60字节。</li>
<li>IPv6头部大小固定为40字节。</li>
</ul>
<p><strong>数据链路层（Data Link Layer）</strong>：</p>
<ul>
<li>数据链路层的头部大小取决于使用的协议，例如以太网帧的头部大小通常为14字节。不过，需要注意的是，这个头部大小不是在所有情况下都一样，它可能会因为使用的协议和网络设备而有所变化。</li>
</ul>
<h2 id="复用和解复用"><a class="header-anchor" href="#复用和解复用"></a>复用和解复用</h2>
<p><strong>复用 multiplexing</strong>：发送端将将应用层的每一个socket的数据合并交付给传输层</p>
<p><strong>解复用 demultiplexing</strong>：传输层将收到的数据交付给正确的socket</p>
<h2 id="电路交换和分组交换、数据报交换和虚电路交换的特点"><a class="header-anchor" href="#电路交换和分组交换、数据报交换和虚电路交换的特点"></a>电路交换和分组交换、数据报交换和虚电路交换的特点</h2>
<ol>
<li>电路交换：最经典的电路交换网是电话网络。
<ol>
<li>数据传输方式：
<ol>
<li>在通信之前需要先建立电路，连接两个通信端点</li>
<li>通信中的数据都跳过这条电路进行传输</li>
</ol>
</li>
<li>资源使用：
<ol>
<li>主要特点是可以独占资源</li>
</ol>
</li>
<li>连接建立：
<ol>
<li>三个阶段：1. 建立连接  2. 通信  3. 释放连接</li>
</ol>
</li>
</ol>
</li>
<li>分组交换：
<ol>
<li>数据传输方式：
<ol>
<li>大的报文被分割成小的packet，每个packet独立传输</li>
<li>pkt选择最佳路径进行传输，可能经过不同的网络节点和链路</li>
</ol>
</li>
<li>资源使用：
<ol>
<li>传输时，网络资源动态分配和共享</li>
</ol>
</li>
<li>通信连接：在进行通信之前不建立连接</li>
</ol>
</li>
</ol>
<h3 id="分组交换和电路交换的区别"><a class="header-anchor" href="#分组交换和电路交换的区别"></a>分组交换和电路交换的区别</h3>
<p><strong>资源使用</strong>：</p>
<ul>
<li>分组交换：动态分配和共享网络资源。</li>
<li>电路交换：建立专用的连接，独占网络资源。</li>
</ul>
<p><strong>连接建立</strong>：</p>
<ul>
<li>分组交换：不需要事先建立连接，每个数据包独立传输。</li>
<li>电路交换：需要事先建立连接，通信双方独占建立的电路。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>分组交换：Internet中的IP网络。</li>
<li>电路交换：传统的电话网络。</li>
</ul>
<h2 id="互联网分层的两个重要原因"><a class="header-anchor" href="#互联网分层的两个重要原因"></a>互联网分层的两个重要原因</h2>
<p><strong>Scale and administrative autonomy</strong></p>
<h2 id="分组交换网络性能评估指标：延迟、丢包和吞吐量"><a class="header-anchor" href="#分组交换网络性能评估指标：延迟、丢包和吞吐量"></a>分组交换网络性能评估指标：延迟、丢包和吞吐量</h2>
<p><strong>丢包</strong>：</p>
<ul>
<li><strong>数据包丢失</strong>：在到达目的地之前丢弃或丢失的数据包。可能由于拥塞、错误或缓冲区溢出等原因造成。</li>
<li><strong>比特错误率（BER）</strong>：接收到的错误比特数与发送的总比特数的比率。反映了传输媒介的可靠性。</li>
</ul>
<p><strong>吞吐量</strong>：</p>
<ul>
<li><strong>有效吞吐量</strong>：单位时间内传输的实际有用数据量，不包括协议开销和重传。反映了数据传输的有效速率。</li>
<li><strong>链路利用率</strong>：链路被使用来传输数据的时间百分比。反映了链路容量的有效利用程度。</li>
</ul>
<h3 id="对网络性能的影响-v2"><a class="header-anchor" href="#对网络性能的影响-v2"></a>对网络性能的影响</h3>
<ul>
<li><strong>延迟</strong>：高延迟会导致响应时间增加和实时通信性能下降。</li>
<li><strong>丢包</strong>：数据包丢失会降低数据传输的质量，影响网络的可靠性。</li>
<li><strong>吞吐量</strong>：较高的吞吐量表示网络容量和性能更好，允许在给定时间内传输更多的数据。</li>
</ul>
<h2 id="DHCP"><a class="header-anchor" href="#DHCP"></a>DHCP</h2>
<p>用于在计算机网络中自动分配IP地址和其他网络配置参数的协议。</p>
<p>主要目的是简化网络管理，提高网络的可扩展性和灵活性。</p>
<h2 id="填空题"><a class="header-anchor" href="#填空题"></a>填空题</h2>
<p>Data link layer in IEEE802.3 is divided to two function sub-layers. They are (MAC) and (LLC).</p>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="软件项目管理期末复习"><a class="header-anchor" href="#软件项目管理期末复习"></a>软件项目管理期末复习</h1>
<blockquote>
<p>IT 项目管理，项目题量是以前的 1.5 倍，但是平均难度下降的<br>
以前 IT 项目管理没有选择判断题，今年第一次出现<br>
小题（30 分）<br>
选择题：单选题，多选题<br>
判断题：判断正确或者错误<br>
这两块一共占了 30 分，往年是没有小题的</p>
<p>第三部分是概念题<br>
概念题就是要解释我们项目管理的一些核心概念（20 分）<br>
有一些章节和图片的核心概念，特别重点的内容大家要关注</p>
<p>简答题（20 分）<br>
分析一下这里面某一个计划是干什么用的，某一个管理方法可以用来解决什么问题，或者说在处理人力和成本问题中的挑战是什么啊，用什么技术来处理啊</p>
<p>计算题（30 分）<br>
计算题考点相对固定<br>
时间管理</p>
<p>成本管理<br>
课堂上反复跟大家强调的净值处理</p>
<p>重点要放在前面的七章<br>
尤其是范围管理、时间管理、成本管理<br>
这三大要素里面的主干知识点，占比很高<br>
前面的一些综合管理考小题可能性大<br>
概念题和其他的分析题只要言之有理，基本都会酌情给分<br>
让我们继续复习一下主干内容(◕_◕)/✏️，考完机器学习就可以复习软件项目管理了</p>
</blockquote>
<h2 id="CH1-项目管理概述"><a class="header-anchor" href="#CH1-项目管理概述"></a>CH1 项目管理概述</h2>
<h3 id="概要"><a class="header-anchor" href="#概要"></a>概要</h3>
<ul>
<li>体会到对更好的项目管理(尤其是 IT 项目管理)不断增长的需求。</li>
<li>解释什么是项目,列举 IT 项目的例子,列出项目的各种特征,并千描述项目管理的约束。</li>
<li>定义项目管理,并论述项目管理框架中的关键因素,包括牙项目干系人、项目管理的知识领域、常用工具和技术,以及项目成功的要素。</li>
<li>讨论项目管理、项目集管理和项目组合管理之间的关系,以及它们中的每一个对企业成功的重要性。</li>
<li>通过描述项目经理做些什么、需要什么技能、理想的技能给组合(能力三角形)和 IT 项目经理的就业机会来了解项目经理的角色。</li>
</ul>
<h3 id="项目管理的四个层次"><a class="header-anchor" href="#项目管理的四个层次"></a>项目管理的四个层次</h3>
<ul>
<li>将复杂的简单化：分解，通过分治的思想，将大问题拆分为小问题进而解决</li>
<li>将简单的量化：临界值，设定好解决问题的值域，谋求在有限空间中寻求解</li>
<li>将量化的专业化：规律，通过量化的指标寻找出解决问题的共通的规律，在其他场景应用</li>
<li>将专业的模板化：框架与模板，将共通的规律抽象成一套解决问题的方法，使上一个解决方案在新的场景里可以简易修改好进行复现与应用</li>
</ul>
<h3 id="为什么要进行项目管理"><a class="header-anchor" href="#为什么要进行项目管理"></a>为什么要进行项目管理</h3>
<ul>
<li>对财务、物质和人力资源的严格控制</li>
<li>改善客户关系</li>
<li>更短的开发时间</li>
<li>降低成本</li>
<li>更高的质量和可靠性</li>
<li>提高利润率</li>
<li>提高生产力</li>
<li>更好的内部协调</li>
</ul>
<h3 id="什么是项目"><a class="header-anchor" href="#什么是项目"></a>什么是项目</h3>
<ul>
<li><strong>项目 project</strong>是为创造独特产品、服务或结果的临时努力</li>
</ul>
<h4 id="项目属性"><a class="header-anchor" href="#项目属性"></a>项目属性</h4>
<ul>
<li>项目有一个独特的目的</li>
<li>项目是临时性的</li>
<li>项目推动变革并创造价值</li>
<li>项目是通过不断完善细节而逐步开展的</li>
<li>项目需要来自不同领域的资源</li>
<li>项目具有不确定性</li>
</ul>
<h4 id="项目约束"><a class="header-anchor" href="#项目约束"></a>项目约束</h4>
<p>范围目标、时间目标和成本目标被称为项目管理的`三项约束(triple constraint)``</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113150457588.png" alt="image-20241113150457588"></p>
<h4 id="项目管理和程序管理"><a class="header-anchor" href="#项目管理和程序管理"></a>项目管理和程序管理</h4>
<p><strong>项目经理</strong>：项目经理与项目发起人、项目团队和其他参与项目工作的人员一起工作，以实现项目目标</p>
<p><strong>项目</strong>：以协调的方式管理的一组相关项目，以获得单独管理它们无法获得的利益和控制</p>
<h3 id="什么是项目管理"><a class="header-anchor" href="#什么是项目管理"></a>什么是项目管理</h3>
<p><code>项目管理(project management)</code>是&quot;将知识、技能、工具和技术应用于项目活动,以满<br>
足项目要求。&quot;项目经理不应该局限于试图满足项目具体的范围目标、时间目标、成本目<br>
标和质量目标,同时也必须协调整个过程,以满足项目活动相关者或干系人的需求或期望。</p>
<ul>
<li>一个项目开发的过程总是不断努力去满足三重约束（项目范围、时间和成本目标），并促进整个过程，以满足项目利益相关者的需求和期望</li>
</ul>
<h4 id="项目利益相关者"><a class="header-anchor" href="#项目利益相关者"></a>项目利益相关者</h4>
<p>项目利益相关者<code>(stakeholder)</code>是指参与项目活动或受项目活动影响的个人、群体或组织,包括项目发起人、项目团队、支持人员、客户、用户、供应商,甚至项目的反对者。这些干系人通常有完全不同的需求和期望。房屋建设项目是常见的功项目例子,其中可能包含以下干系人</p>
<ul>
<li>项目发起人为潜在的新业主</li>
<li>银行、融资机构</li>
<li>项目经理是承包商</li>
<li>项目团队包括建筑工人、电工、木匠等</li>
<li>支持人员包括买方的雇主</li>
<li>消费者</li>
<li>使用者</li>
<li>材料供应商</li>
<li>反对者：附近的邻居，因为噪音干扰</li>
</ul>
<h4 id="项目管理知识领域"><a class="header-anchor" href="#项目管理知识领域"></a>项目管理知识领域</h4>
<p><code>项目管理知识领域(projectmanagementknowledgeareas)</code>描述了项领目经理必须具备的关键<br>
能力。图 1-2 的中间部分展示了项目管理的 10 大知识领域。这 10 大知识领域的简要描述如下:</p>
<ol>
<li>
<p><strong>项目整合管理</strong>：包括定义和管理成功完成项目所需的全部工作。</p>
<ol>
<li>制定项目章程</li>
<li>制定项目管理计划</li>
<li>指导和管理项目工作</li>
<li>实施整体变更控制</li>
<li>结束项目或阶段</li>
<li>监控项目工作</li>
</ol>
</li>
<li>
<p><strong>项目范围管理</strong>：包括定义和管理成功完成项目所需的全部工作。</p>
<ol>
<li>规划范围管理</li>
<li>收集需求</li>
<li>定义范围</li>
<li>创建工作分解结构</li>
<li>确认范围</li>
<li>控制范围</li>
</ol>
</li>
<li>
<p><strong>项目进度管理(也称项目时间管理)</strong>：包括估计完成工作所需的时间,制定可接受的项目进度,并确保项目按时完成。</p>
<ol>
<li>规划进度管理</li>
<li>定义活动</li>
<li>排列活动顺序</li>
<li>估算活动资源</li>
<li>估算活动持续时间</li>
<li>制定进度计划</li>
<li>控制进度</li>
</ol>
</li>
<li>
<p><strong>项目成本管理</strong>：包括项目预算的制定和管理。</p>
<ol>
<li>规划成本管理</li>
<li>估算成本</li>
<li>制定预算</li>
</ol>
</li>
<li>
<p><strong>项目质量管</strong>：确保项目满足各方明确表述的或隐含的需求。</p>
<ol>
<li>规划质量管理</li>
<li>质量保证</li>
<li>控制质量</li>
</ol>
</li>
<li>
<p><strong>项目人力资源管理</strong>：有效利用与项目有关的人员和物质资源。</p>
<ol>
<li>规划人力资源管理</li>
<li>组建项目团队</li>
<li>建设项目团队</li>
<li>管理项目团队</li>
</ol>
</li>
<li>
<p><strong>项目沟通管理</strong>：包括生成、收集、传播和存储项目信息。</p>
<ol>
<li>规划沟通管理</li>
<li>管理沟通</li>
<li>控制沟通</li>
</ol>
</li>
<li>
<p><strong>项目风险管理</strong>：包括识别、分析和应对与项目相关的风险。</p>
<ol>
<li>规划风险管理</li>
<li>识别风险</li>
<li>定性风险分析</li>
<li>定量风险分析</li>
<li>规划风险应对</li>
<li>控制风险</li>
</ol>
</li>
<li>
<p><strong>项目采购管理</strong>：包括从实施项目的组织外部获取或采购产品和服务。</p>
<ol>
<li>规划采购</li>
<li>实施采购</li>
<li>结束采购</li>
<li>控制采购</li>
</ol>
</li>
<li>
<p><strong>项目利益相关者管理</strong>：包括识别和分析干系人的需求,同时在项目的整个生命周期中管理和<br>
控制干系人参与项目决策和执行。</p>
<ol>
<li>识别利益相关者</li>
<li>规划利益相关者管理</li>
<li>管理利益相关者参与</li>
<li>控制利益相关者参与</li>
</ol>
</li>
</ol>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113163112719.png" alt="image-20241113163112719"></p>
<p>项目整合管理是一个影响所有其他知识领域并受其影响的总体功能</p>
<h4 id="项目管理工具和技术"><a class="header-anchor" href="#项目管理工具和技术"></a>项目管理工具和技术</h4>
<p><code>项目管理工具和技术(Project management tools and techniques)</code>帮助项目经理及其团队在所有 10 个知识领域开展工作。例如,一些流行的时间管理工具和技术包括:甘特图(Gantt charts)、项目网络图(project network diagrams)和关键路径分析(critical path analysis)。下表列出了一些知识领域常用的工具和技术。</p>
<p>一些具体的内容包括</p>
<ul>
<li>
<p>cs项目章程、范围语句和WBS（范围）。</p>
<ul>
<li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113162710748.png" alt="image-20241113162710748"></li>
</ul>
</li>
<li>
<p>甘特图、网络图、关键路径分析、关键链调度（时间）。</p>
<ul>
<li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113162727435.png" alt="image-20241113162727435"></li>
<li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113162754583.png" alt="image-20241113162754583"></li>
<li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113162807742.png" alt="image-20241113162807742"></li>
</ul>
</li>
<li>
<p>成本估算和收益价值管理（成本）。</p>
</li>
</ul>
<h4 id="项目成功"><a class="header-anchor" href="#项目成功"></a>项目成功</h4>
<ul>
<li>项目达到了范围目标、时间目标和成本目标。</li>
<li>项目使客户/发起人满意。</li>
<li>项目的结果达到了主要目标,比如赚取或节省了一定数目目的钱,带来了较好的投资回报率,或者仅仅是让项目发起人感到满意。</li>
</ul>
<h3 id="项目集和项目组合管理"><a class="header-anchor" href="#项目集和项目组合管理"></a>项目集和项目组合管理</h3>
<h4 id="项目集"><a class="header-anchor" href="#项目集"></a>项目集</h4>
<ul>
<li><code>项目集(program)</code>是指&quot;以协调的方式管理一组相互关联的项目、子项目集和项目集<br>
活动,以便获得分别管理所无法获得的利益。&quot;，例如基础设施项目集包括体的项目,例如提供更多的无线网络连接、升级硬件和软件、增强计算机安全、开发或维护公司的 IT 标准等</li>
<li>项目集≠超大项目，</li>
<li><code>项目集经理(program manager)</code>对领导项目集内项目的项目经理进行领导并指明方向。</li>
<li>作为<strong>项目组合管理</strong>的一部分，组织将项目和项目作为一个投资组合，进行分组和管理</li>
</ul>
<h4 id="项目组合管理"><a class="header-anchor" href="#项目组合管理"></a>项目组合管理</h4>
<p>在许多组织中,项目经理还会实行一种新兴的业务战略,即本书所称的<code>项目组合管理(project portfolio management)</code>或<code>组合管理(portfolio management)</code>。在这种战略中,组织将项目以及项目集组合并进行管理,使其作为一个投资组合,从而促足成整个企业的成功。</p>
<p><strong>项目管理与项目投资组合管理的比较</strong></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241113163643684.png" alt="image-20241113163643684"></p>
<h3 id="组织项目管理"><a class="header-anchor" href="#组织项目管理"></a>组织项目管理</h3>
<p>通过将项目分组到项目组合中,组织可以更好地将它们的项目与战略目标联系起来。项目组合管理还可以通过聘用、培训和留住员工来支持投资组合中的项目,进而帮助组织更好地管理其人力资源。简单来说有三种基本的 IT 项目组合种类：</p>
<ul>
<li>冒险类项目:该类项目有助于改变目前的业务经营。例如,在&quot;开篇案例&quot;描述的大型零售连锁示例中,或许存在着一个 IT 项目–在商店里提供 kiosks,同样也在网上提供,这样顾客和供应商就能够迅速提供有关产品和服务的反馈。这个项目能通过与顾客和供应商发展更亲密的关系来转变业务经营。</li>
<li>成长类项目:这类项目能帮助公司提高收入。例如,一家公司或许有一个新的 IT 项目–在其公司网站上用一种新的语言(中文或者日文)提供信息。这种项目能够促进他们在使用该语言的国家增加收入。</li>
<li>核心类项目:它是指为了商业活动的正常运营而必须要完成的那些项目。例如,为新员工提供计算机的 IT 项目就属于此类。</li>
</ul>
<h3 id="关键术语"><a class="header-anchor" href="#关键术语"></a>关键术语</h3>
<p>最佳实践(best practice)<br>
魅力型(charismatic)<br>
DevOps (DevOps)<br>
企业项目管理软件(enterprise project management software)<br>
道德(ethics)<br>
甘特图(Gantt chart)<br>
交互型(interactional)<br>
放任型(laissez-faire)<br>
领导者(leader)<br>
经理(manager)<br>
超大型项目(megaproject)<br>
组织项目管理(organizational project management)<br>
项目组合(portfolio)<br>
项目集(program)<br>
项目集经理(programmanager)<br>
项目(project)<br>
项目和项目组合管理软件(projectand portfolio management software)<br>
项目管理(projectmanagement)<br>
项目管理协会(ProjectManagement Institute(PMI))<br>
项目管理知识领域(projectmanagementknowledge areas)<br>
项目管理办公室(ProjectManagementOffice,PMO)<br>
项目管理专业人士(ProjectManagement Professional, PMP)<br>
项目管理工具和技术(projectmanagement tools and techniques)<br>
项目经理(projectmanager)<br>
项目组合管理或组合管理(project portfolio management or portfolio management)<br>
项目发起人(projectsponsor)<br>
干系人(servant leader stakeholders)<br>
交易型(transactional)<br>
变革型(transformational)<br>
三项约束(tripleconstraint)</p>
<h2 id="CH2-项目管理和IT-Information-Technology-环境"><a class="header-anchor" href="#CH2-项目管理和IT-Information-Technology-环境"></a>CH2 项目管理和IT(Information Technology)环境</h2>
<h3 id="概要-v2"><a class="header-anchor" href="#概要-v2"></a>概要</h3>
<ul>
<li>定义项目管理的系统观以及如何将项目管理应用于 IT 项目中。</li>
<li>总结组织的相关要点,包括组织的 4 个框架、组织结构和组织文化。</li>
<li>解释为什么项目干系人管理和企业高层的承诺对项目成功至关重要。</li>
<li>区分项目生命周期和产品生命周期之间的异同。</li>
<li>讨论 IT 项目的独特性和多样性。</li>
<li>总结影响 IT 项目管理的最新趋势,包括全球化、外包、虚拟团队和敏捷项目管理。</li>
</ul>
<h3 id="项目管理的系统馆"><a class="header-anchor" href="#项目管理的系统馆"></a>项目管理的系统馆</h3>
<p>为了高效处理复杂的情况，项目经理必须以整体的观点认识项目，并且处理该项目是如何与更大组织进行联系的，<code>系统思考 system thinking</code>描述了这种整体的观点。</p>
<h4 id="系统方法"><a class="header-anchor" href="#系统方法"></a>系统方法</h4>
<ul>
<li><code>系统方法systems approach</code>：用于描述一种在解决复杂问题时所需的整体性的和分析性的方法。</li>
<li><code>系统哲学systems philosophy</code>：是将事情作为系统考虑的整体模型</li>
<li><code>系统分析systems analysis</code>：是一种解决问题的方法，该方法需要定义系统的范围，将其分解为各个组成部分，然后识别和估计其问题、机会、约束和需求。</li>
<li><code>系统管理systems management</code>：解决与系统开发、维护和变更相关的业务、技术和组织问题。</li>
</ul>
<h4 id="系统管理的三球模型"><a class="header-anchor" href="#系统管理的三球模型"></a>系统管理的三球模型</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011921554.png" alt="Alt text"></p>
<h3 id="了解组织"><a class="header-anchor" href="#了解组织"></a>了解组织</h3>
<h4 id="组织的四个框架"><a class="header-anchor" href="#组织的四个框架"></a>组织的四个框架</h4>
<ul>
<li><code>结构框架 structural frame</code>：用来解决组织结构的问题（通常由组织结构图表示），它关注不同部门的角色和职责，以满足高层管理者设定的目标和政策。</li>
<li><code>人力资源框架 human resources frame</code>：达到组织需求和个人需求之间的平衡</li>
<li><code>政治框架 political frame</code>：处理组织和个人的政治问题。组织中的<strong>组织politics</strong>表现为团队或个人对权力、资源和领导地位的竞争。</li>
<li><code>符号框架 symbolic frame</code>：关注符号和含义。在符号框架中，可以对应在一个组织中所发生的任何事件，重要的不是表面发生了什么，而是意味着什么。</li>
</ul>
<h4 id="组织结构"><a class="header-anchor" href="#组织结构"></a>组织结构</h4>
<ul>
<li>职能型组织结构：职能部门经理向首席执行官汇报工作</li>
<li>项目型组织结构：项目经理向首席执行官汇报工作</li>
<li>矩阵型组织结构：功能结构和项目结构之间的中间地带；人员经常向两个或两个以上的老板报告；结构可以是弱、平衡或强矩阵</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011923388.png" alt="Alt text"></p>
<h4 id="组织文化"><a class="header-anchor" href="#组织文化"></a>组织文化</h4>
<ul>
<li><code>组织文化(organizational culture)</code>是一系列共享的假设、价值观和行为,它们刻画了组织的职能。</li>
</ul>
<h3 id="项目生命周期和产品生命周期"><a class="header-anchor" href="#项目生命周期和产品生命周期"></a>项目生命周期和产品生命周期</h3>
<h4 id="项目生命周期"><a class="header-anchor" href="#项目生命周期"></a>项目生命周期</h4>
<p><code>项目生命周期(project life cycle)</code>是一系列项目阶段的集合,项目从人开始到完成需要经历所有这些阶段。</p>
<p>可交付物是作为项目的一部分而生产或提供的产品或服务</p>
<p>通用的项目生命周期,包括以下 4 个阶段:</p>
<ol>
<li>开始项目</li>
<li>组织与准备</li>
<li>执行项目工作</li>
<li>结束项目</li>
</ol>
<blockquote>
<p>这些阶段不应与第 3 章描述的项目管理过程组的<strong>启动、规划、执行、监控和收尾</strong>相混淆。</p>
</blockquote>
<p>一般情况下,项目生命周期定义了每个阶段需要开展的工作、可交付成果、各个阶段在什么时间需要什么样的人员,以及管理层将如何控制和核准每个阶段中的工作。<code>可交付成果(deliverable)</code>是作为项目的一部分生产或提供的产品或服务,例如技术报告、培训课程、硬件或软件代码段。(有关可交付成果的详细内容,请参见第 5 章。)</p>
<h4 id="产品生命周期"><a class="header-anchor" href="#产品生命周期"></a>产品生命周期</h4>
<p><code>产品生命周期(product life cycle)</code>是<strong>定义、开发和交付产品</strong>的过程。通常,开发一个产品(例如一个新的信息系统、一辆汽车、一栋建筑物等)涉及许多项目。</p>
<blockquote>
<p>相关信息</p>
<p>软件开发项目是 IT 项目的一个子项目。许多 IT 项目涉及研究与分析,然后后采购和安装新的硬件和软件,附带少量必要的软件开发,或者完全不需要软件开发。但是,一些项目包括少量的软件更改,以增强现有软件的性能或将一个应用程序与另一个应用程序进行整合。其他的一些项目则涉及大量的软件开发工作。因此 IT 项目 ≠ 软件开发项目</p>
</blockquote>
<p><code>系统开发生命周期(Systems Development Life Cycle, SDLC)</code>是一个用来描述开发信息系统不同阶段的框架。《项目管理知识体系指南(第 6 版)》简要介绍了 5 种产品或开发生命周期。在确定使用哪种生命周期时,有两个因素很重要–需求的变化程度我和有用成果的交付频率。例如,对于需求变化程度低且交付频率低的产品,预测型生命周期更适适用。</p>
<h4 id="五种产品-开发生命周期"><a class="header-anchor" href="#五种产品-开发生命周期"></a>五种产品/开发生命周期</h4>
<ul>
<li><code>预测型生命周期 predictive-life cycle</code>:在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。PMI 将预测型生命周期也称为瀑布型生命周期</li>
<li><code>选代型生命周期 Iterative life cycle</code>:通常在项目生命周期的早期确定项目范围,但时间及成本估算将随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品,以增加产品的功能。当需求变化程度高而交付频率低 I 时,迭代型生命周期最适用。</li>
<li><code>增量型生命周期 incremental build model-life cycle</code>:通过在预定的时间区间内渐进增加产品功能的一系列迭代来产出可交付成果。最后一次迭代完成后,可交付成果才是完整的。当需求变化程度低而交付频率高时,增量型生命周期最适用。</li>
<li><code>适应型生命周期 adaptive software development(ASD)-life cycle</code>:干系人在迭代开始之前定义并批准详细范围,并在每次迭代结束时产生可用的产品。PMI 将适应型生命周期也称为敏捷型或不变更驱动型生命周期。当需求变化程度高且交付频率高时,适应型生命周期最适用。</li>
<li><code>混合型生命周期</code>:根据工作的特性混合使用多种生命周期。例如,像每周进度报告这样的可交付成果具有低需求变化和低交付频率,而像软件马功能这样的可交付成果,就具有高需求变化和高交付频率。</li>
</ul>
<p>目前,许多组织在产品开发中使用混合型生命周期。其中,将预测型生命周期的步骤用作总体方法,以协调适应型生命周期的详细步骤。预测型生命周期和适应型生命周期不是互斥的选择。</p>
<p>预测型生命周期也不仅仅是 SDLC 的瀑布模型一种，还有螺旋模型、原型模型和快速应用开发(RapidApplication Development,RAD)模型。</p>
<h4 id="项目阶段和管理评审"><a class="header-anchor" href="#项目阶段和管理评审"></a>项目阶段和管理评审</h4>
<p>管理评审又称为<code>阶段出口(phaseexit)</code>、<code>阶段关口评审(phasegatereview)</code>或<code>终止点(kill point)</code>。这一活动对于保持项目在正确的轨道上和确定项目是否应该继续、重新定位或终止非常重要。</p>
<h3 id="关键术语-v2"><a class="header-anchor" href="#关键术语-v2"></a>关键术语</h3>
<p>敏捷(agile)<br>
倡导者(champion)<br>
可交付成果(deliverable)<br>
执行指导委员会(executivesteering committee)<br>
职能型组织结构(functionalorganizational structure)<br>
人力资源(HR)框架(humanresources,HRframe)<br>
IT 治理(IT governance)<br>
看板(Kanban)<br>
终止点(kill point)<br>
矩阵型组织结构(matrix organizational structure)<br>
项目组织结构(Projectorganizational structure)<br>
Scrum (Scrum)<br>
结构框架(structural frame)<br>
符号框架(symbolic frame)<br>
系统分析(systemsanalysis)<br>
系统方法(systems approach)<br>
离岸外包(offshoring)<br>
组织文化(organizational culture)<br>
外包(outsourcing)<br>
阶段关口评审/阶段出口(phasegatereview phase exit)<br>
政治框架(political frame)<br>
政治(politics)<br>
预测型生命周期(predictivelifecycle)<br>
产品生命周期(product lifecycle)<br>
项目生命周期(projectlifecycle)<br>
系统开发生命周期(SDLC)(systemsdevelopment life cycle, SDLC)<br>
系统管理(systemsmanagement)<br>
系统哲学(systemsphilosophy)<br>
系统思考(systems thinking)<br>
虚拟团队(virtual team)</p>
<h2 id="CH3-项目管理过程组"><a class="header-anchor" href="#CH3-项目管理过程组"></a>CH3 项目管理过程组</h2>
<h3 id="概要-v3"><a class="header-anchor" href="#概要-v3"></a>概要</h3>
<ul>
<li>描述 5 大项目管理过程组及其各自典型的活动水平,以及它们之间的相互关系。</li>
<li>了解项目管理过程组与项目管理知识领域之间的相互关系。</li>
<li>讨论组织如何开发 IT 项目管理方法论来满足自身的需要。</li>
<li>回顾一个组织应用项目管理过程组管理 IT 项目的案例研究,描述每个过程组的输出,了解有效的项目启动、项目计划、项目执行、项目监控和项目收尾是如何促进项目成功的。</li>
<li>回顾应用敏捷方法管理的同一个 IT 项目的案例研究,并比比较敏捷方法和预测方法之间的关键区别。</li>
<li>描述为每个过程组创建文档的几个模板</li>
</ul>
<h3 id="项目管理过程组"><a class="header-anchor" href="#项目管理过程组"></a>项目管理过程组</h3>
<p><code>过程(process)</code>是指朝向特定结果的一系列行动。<code>项目管理过程组(project management process groups)</code>包括启动活动、执行活动、执行活动、监控活动和以收尾活动。</p>
<ul>
<li>启动过程(initiating processes)</li>
<li>计划过程(planning processes)</li>
<li>执行过程(executing processes)</li>
<li>监控过程(monitoring and controlling processes)</li>
<li>收尾过程(closing processes)</li>
</ul>
<blockquote>
<p>过程组不是独立的</p>
<p>这些过程组并非是相互独立的。例如,项目经理必须确保!监控过程贯穿整个项目。也就是说,在项目中监控过程可能与启动、计划、执行和收尾过程同时发生,启动和计划过程可以与执行过程等其他任何过程组同时发生。</p>
</blockquote>
<h4 id="将流程组映射到知识领域"><a class="header-anchor" href="#将流程组映射到知识领域"></a>将流程组映射到知识领域</h4>
<p>您可以使用PMBOKR指南，第五版，将每个PM流程组的主要活动映射到10个知识领域。请注意，在规划流程组下都有来自每个知识领域的活动</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011921589.png" alt="image-20241118153749769"></p>
<h3 id="开发IT项目管理方法论"><a class="header-anchor" href="#开发IT项目管理方法论"></a>开发IT项目管理方法论</h3>
<ul>
<li>
<p>《项目管理知识体系指南》作为项目管理方法论的基础</p>
</li>
<li>
<p>受控环境下的项目管理(PRINCE2):最初是为 IT 项目开发的。1996 年,英国政府商务办公室(OCG)为 IT 项目开发出这一项目管理的通用方法论。它是英国约定俗成的标准,被 50 多个国家采用(</p>
<p>详情请登录www.prince2.comopen in new window</p>
<p>)。PRINCE2定义了45个独立的子过程,并将它们分成8个过程组,如下所示:</p>
<ol>
<li>项目发起</li>
<li>项目规划</li>
<li>项目启动</li>
<li>项目指导</li>
<li>项目阶段控制</li>
<li>产品交付管理</li>
<li>阶段界限管理</li>
<li>项目收尾</li>
</ol>
</li>
<li>
<p>敏捷方法:如第 2 章所述,敏捷是一种自适应的产品生命周其期,适用于可交付成果具有高变更度、高交付频率的项目。“敏捷&quot;这个术语经常被用来描述各种各样的方法。比如,《敏捷实践指南》(Agile Practice Guide)描述了了敏捷和作为精益管理<br>
子集的看板管理。(有关&quot;精益”(lean)的内容将在第 8 章中详细介绍)。一些流行的敏捷方法包括 Scrum,Scrumban(Scrum 和 Kanban 的结合),极限开发(ExtremeProgramming,XP),特征驱动开发(Feature Driven Development, FDD)等等</p>
</li>
<li>
<p>统一软件开发过程(RUP)框架(Rational Unified Process framework):RUP 是由 IBM 创建的迭代软件开发过程,它关注团队生产力,并使所有团队成员能够向组织交付最佳的软件。RUP 专家 Bill Cottrell 说:“RUP 包含了行业标准的管理和技术方法,目的是提供一个软件开发过程,这个过程尤其适用于创建并维护基于组件的软件系统解决方案。”</p>
</li>
<li>
<p>六西格玛方法论。很多组织采用六西格玛方法论做项目。项目质量专家的工作促进了今天六西格玛原则的发展。六西格玛项目经常采用的两两种方法论分别为:DMAIC,即定义(Define)、度量(Measure)、分析(Analysis)、改进(Improve)、控制(Control),用于改进已有业务流程;DMADV,即定义(Define)、度量(Measure)、分析(Analysis)、设计(Design)、证实(Verify),用于创造新产品品或过程设计,以取得可预测且无缺陷的业绩。(了解更多关于六西格玛的信息,请参见第 8 章。)</p>
</li>
</ul>
<h3 id="项目流程"><a class="header-anchor" href="#项目流程"></a>项目流程</h3>
<h4 id="项目的预启动及启动"><a class="header-anchor" href="#项目的预启动及启动"></a>项目的预启动及启动</h4>
<ul>
<li>在项目管理中,启动包括识别和开始一个新的项目。组织在选择项目时要深思熟虑,要确保是为了一个恰当的原因而启动了一个恰当的项目。一个重要的项目取得中等的或较小的成功,要优于在一个不重要的项目上取得的巨大成功。</li>
<li>在决定开展哪些项目时,战略规划应当作为功项目决策的基础。组织的战略规划表明了该组织的愿景、使命、目的、目标和组织的战略。一个组织启动 IT 项目可能有多个原因,但最重要的原因是是支持业务目标。</li>
</ul>
<h4 id="项目预启动任务"><a class="header-anchor" href="#项目预启动任务"></a>项目预启动任务</h4>
<p>在正式启动项目之前,为项目奠定良好的基础非常重要。为此,高级经理经常先完成一些任务,称为预启动任务,主要包括以下任务:</p>
<ul>
<li>决定项目的范围、时间和成本的约束因素。</li>
<li>确定项目发起人。</li>
<li>选择项目经理。</li>
<li>为项目开发一个商业论证。</li>
<li>与项目经理开会讨论项目管理过程及预期成果。</li>
<li>确定项目是否应该分成两个或两个以上的小项目。</li>
<li>决定项目是否需要被分为两个或更多子项目。</li>
</ul>
<h4 id="项目启动"><a class="header-anchor" href="#项目启动"></a>项目启动</h4>
<p>项目启动的主要任务是识别所有项目干系人,并制定项目章程。这一任务的主要输出包括:项目章程和干系人登记册。</p>
<h4 id="项目计划"><a class="header-anchor" href="#项目计划"></a>项目计划</h4>
<blockquote>
<p>计划过程组有许多潜在的输出,每个知识领域都包括在内。</p>
</blockquote>
<p>项目计划的主要目的是指导项目的执行。第 5~12 章从每个知识领域的角度再次描述了项目计划过程。</p>
<h4 id="项目监控"><a class="header-anchor" href="#项目监控"></a>项目监控</h4>
<p>项目监控是一个针对项目目标来衡量进展情况、监测计划的偏离情况,并采取纠正措施使项目进展与计划相匹配的过程。监控贯穿整个项目周期,滋步及所有 10 大项目管理知识领域。与监控过程组相关的模板在本章中的后面列出。</p>
<h4 id="项目收尾"><a class="header-anchor" href="#项目收尾"></a>项目收尾</h4>
<p>收尾过程包括获得干系人和客户对最终产品和服务的验收,并使得项目或项目阶段有序地结束。它包括核实所有的成果是否已经完成,而且通常包括一个最终的项目报告和展示。</p>
<h3 id="关键术语-v3"><a class="header-anchor" href="#关键术语-v3"></a>关键术语</h3>
<p>敏捷方法(agilemethods)<br>
工件(artifact)<br>
每日例会(dailyScrum)<br>
执行过程(executing processes)<br>
启动过程(initiating processes)<br>
启动会议(kick-off meeting)<br>
方法论(methodology)<br>
监控过程(monitoring and controlling processes)<br>
计划过程(planning processes)<br>
过程(process)<br>
产品待办事项(productbacklog)<br>
产品负责人(productowner)<br>
项目管理过程组(projectmanagementprocess groups)<br>
受控环境下的项目管理(PRINCE2)(PRojects IN Controlled Environments, PRINCE2)<br>
统一软件开发(RUP)框架(Rational Unified Process (RUP) framework)<br>
燃尽图(burndownchart)<br>
收尾过程(closing processes)<br>
敏捷教练(ScrumMaster)<br>
Scrum 团队或开发团队(Scrum team or development team)<br>
六西格玛(方法论)(SixSigmamethodologies)<br>
冲刺(sprint)<br>
冲刺待办事项(sprintbacklog)<br>
冲刺计划会(sprintplanning session)<br>
冲刺回顾会(sprintretrospectives)<br>
冲刺评审会(sprintreviews)<br>
干系人登记册(stakeholderregister)<br>
标准(standard)<br>
用户故事(userstories)</p>
<h2 id="CH4-项目一体化-整合-管理"><a class="header-anchor" href="#CH4-项目一体化-整合-管理"></a>CH4 项目一体化(整合)管理</h2>
<blockquote>
<p>关键：</p>
<ol>
<li>项目集成管理的过程</li>
<li>选择 IT 项目的计划过程</li>
<li>选择项目的 5 个常用技术</li>
<li>NPV 的计算步骤</li>
<li>综合变更控制的 3 个主要目标</li>
<li>在组织中，设立变更请求书的意义？如何建立一个好的变更请求管理过程</li>
</ol>
</blockquote>
<h3 id="项目整合管理是什么"><a class="header-anchor" href="#项目整合管理是什么"></a>项目整合管理是什么</h3>
<ul>
<li><code>项目整合管理(project integration management)</code>包括在整个项目生命周期中协调所有其他的项目管理知识领域。这种整合确保了项目的所有因素能在正确的时间集合在一起,从而成功地完成项目。根据《项目管理知识体系指南(第 6 版)》所述,项目整合管理包括 <strong>7 个主要过程</strong>：
<ol>
<li><strong>制定项目章程</strong>。即与项目干系人一起合作,制定正式批准项目的文件——章程。</li>
<li><strong>制定项目管理计划</strong>。即协调项目计划的所有组成部分,并把它它们整合为一份一致的连贯的文件——项目管理计划。</li>
<li><strong>指导与管理项目工作</strong>。即通过实施项目管理计划中的活动,来执行项目管理计划。</li>
<li><strong>管理项目知识</strong>。即使用现有知识并生成新知识,以实现项目目标,并帮助组织学习。</li>
<li><strong>监控项目工作</strong>。即监督项目工作是否符合项目的绩效目标。</li>
<li><strong>实施整体变更控制</strong>。即在整个项目生命周期中识别、评估和管理变更。</li>
<li><strong>项目或阶段收尾</strong>。即终结项目或阶段的所有活动,从而而正式结束项目或阶段。</li>
</ol>
</li>
<li>项目经理要协调项目资源、统领全局，解决项目冲突，而完成这些任务的首要方法就是项目整合管理</li>
<li>良好的项目整合管理对满足干系人的需求至关重要。项目整合管理包括界面管理。<code>界面管理(interface management)</code>涉及明确和管理众多项目元素相互作用的交界点。界面管理的主要工具是沟通和关系。随着项目参与人员的增加,交界点的数量可能会呈现指数级增长。</li>
<li>项目整合管理是在整个组织的环境中进行的,而不仅仅发生在一个特定项目的内部。项目经理必须将项目的工作和组织的运营整合起来</li>
</ul>
<h3 id="战略计划和项目选择"><a class="header-anchor" href="#战略计划和项目选择"></a>战略计划和项目选择</h3>
<h4 id="战略计划"><a class="header-anchor" href="#战略计划"></a>战略计划</h4>
<ul>
<li><code>战略计划(strategic planning)</code>包括:通过分析组织的优势和劣势来确定长期目标;研究商业环境中的机遇和威胁;预测未来趋势;预测对新产品和服务的需求。战略计划借助重要的信息来帮助组织识别并选择潜在的项目。</li>
</ul>
<blockquote>
<p>SWOT 分析法</p>
<p>SWOT 分析法(SWOT analysis),即分析</p>
<ul>
<li><strong>优势(strength)</strong></li>
<li><strong>劣势(weakness)</strong></li>
<li><strong>机会(opportunity)</strong></li>
<li><strong>威胁(thrent)</strong></li>
</ul>
<p>这是战略计划中使用的一种工具。有时会使用如图 4-1 所示的思维导图(mid mapping)来进行 SWOT 分析</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011923513.png" alt="图4-1 思维导图——识别潜在项目的SWOT分析"></p>
<h4 id="识别潜在项目"><a class="header-anchor" href="#识别潜在项目"></a>识别潜在项目</h4>
<p>除了使用 SWOT 分析法之外,组织还应该遵循具体的项目选选择过程。图 4-2 是选择 IT 项目计划过程的 4 个阶段,注意这个模型的层次结构以及每个阶段性的结果。顺序是从上到下</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011924314.png" alt="图4-2 选择IT项目的计划过程"></p>
<h4 id="选择项目的方式"><a class="header-anchor" href="#选择项目的方式"></a>选择项目的方式</h4>
<p>组织将识别众多有潜力的项目作为战略计划过程的一部分,组织需要缩小有潜力的项目列表,直到只剩下那些可使利益最大化的项目。通常,他们依赖经验丰富的项目经理来协助做出项目决策。有五种常见的方法：</p>
<p>-聚焦于重要的组织需求 -将 IT 项目分类 -进行净现值或其他财务分析 -使用加权评分模型 -实施平衡计分卡</p>
<h4 id="聚焦于重要的组织需求"><a class="header-anchor" href="#聚焦于重要的组织需求"></a>聚焦于重要的组织需求</h4>
<p>一种根据重要的组织需求来选择项目的方法是,首先确定它们是否符合 3 个重要的标准:需求、资金和意愿。</p>
<p>在组织中,人们需要实施这个项目吗?组织有决心和能力提供充足的资金来执行项目吗?有没有很强的决心来保证项目的成功</p>
<h4 id="在IT项目进行分类"><a class="header-anchor" href="#在IT项目进行分类"></a>在IT项目进行分类</h4>
<p>另一个选择项目的方法是依据多种分类进行决策,例如功项目的动机、时间窗口以及一般优先权:</p>
<ul>
<li>项目的动机一般是对一个问题、一项机遇或一个个指令的反应。</li>
<li>IT 项目的另一种分类依据是基于时间的,即完成一个项目所需要的时间以及项目必须完成的截止时间。例如,某些潜在项目必须在一个特定的时间段内完成。如果到规定的日期还未完成,那它们便不再是有效的项目。</li>
<li>组织还可以根据当前的业务环境将不同的 IT 项目分为高、中、低不同的优先级别。例如,如果快速减少运营成本非常关键,则最有助于减少运营成成本的项目将被赋予最高优先级</li>
</ul>
<h3 id="进行财务分析"><a class="header-anchor" href="#进行财务分析"></a>进行财务分析</h3>
<h4 id="净现值分析"><a class="header-anchor" href="#净现值分析"></a>净现值分析</h4>
<ul>
<li>
<p><code>净现值NPV</code>分析是一种计算项目预期净货币收益/损失的方法，该方法将当前时间点之间的所有未来预期现金流入和流出都折现计算。</p>
</li>
<li>
<p>计算净现值时，必须假设一个特定的折现率。<strong>折现率</strong>是用于折现现金流的比率，不仅考虑金钱的时间价值，还考虑未来现金流的风险或不确定性。未来现金流的不确定性越大，折现率越高。折现率也称为<code>资本化率</code>或<code>资本机会成本</code>。</p>
<p><img src="https://chiichen.github.io/assets/image-2-CbDiMR36.png" alt="图4-3 净现值算例"></p>
</li>
<li>
<p>净现值可以通过以下步骤计算：</p>
<ol>
<li>
<p>为项目生命周期及项目产品确定预期成本和收益。</p>
</li>
<li>
<p>确定折现率</p>
</li>
<li>
<p>计算净现值</p>
</li>
<li>
<p>计算净现值公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>P</mi><mi>V</mi><mo>=</mo><msub><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>0...</mn><mi>n</mi></mrow></msub><mfrac><msub><mi>A</mi><mi>t</mi></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">NPV = \sum_{t=0...n} \frac{A_t}{(1+r)^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">NP</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4084em;vertical-align:-0.52em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0...</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><em>t</em>表示现金流的年份</p>
<p><em>n</em>表示现金流的最后一年</p>
<p><em>A</em>表示每年的现金流</p>
<p><em>r</em>表示折现率</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{(1+r)^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>表示折现因子 discount-factor</p>
</li>
</ol>
</li>
</ul>
<h4 id="折现回报率"><a class="header-anchor" href="#折现回报率"></a>折现回报率</h4>
<ul>
<li>
<p><code>投资回报率 return-oninvestment,ROI</code>是项目的收益减去成本后，再除以成本的结果。<em>ROI</em>通常以百分比的形式出现，可正可负。</p>
<p>ROI计算公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mtext>折现收益总额</mtext><mo>−</mo><mtext>折现成本总额</mtext><mo stretchy="false">)</mo></mrow><mtext>折现成本</mtext></mfrac></mrow><annotation encoding="application/x-tex">ROI = \frac{(折现收益总额 - 折现成本总额)}{折现成本}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RO</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">折现成本</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">折现收益总额</span><span class="mbin mtight">−</span><span class="mord cjk_fallback mtight">折现成本总额</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>ROI越高越好，意味着成本越低而收益越高</p>
</li>
<li>
<p><code>要求回报率</code>：可接受的最低投资回报率，因为一个正常的组织对于项目都会有投资回报率的要求，项目需要有收益。</p>
</li>
<li>
<p><code>内部收益率</code>：通过找出导致项目净现值为零的折现率来确定</p>
</li>
</ul>
<h4 id="投资回报期分析"><a class="header-anchor" href="#投资回报期分析"></a>投资回报期分析</h4>
<ul>
<li>
<p><code>投资回报期 payback-period</code>是以净现金流的方式，将项目中的总投资全部收回的时间。即成本回收</p>
<p><img src="https://chiichen.github.io/assets/image-4-8yfIZ-bp.png" alt="图4-5 绘制JWD咨询项目的回收期图"></p>
</li>
</ul>
<h3 id="使用加权评分模型"><a class="header-anchor" href="#使用加权评分模型"></a>使用加权评分模型</h3>
<p><code>加权评分模型 weighted-scoring-model</code>是一种基于多种标准进行<em>J</em>项目选择的系统方法这些标准可能包括多种要素，例如，满足重要的组织需求；解决问题、把握机会以及应对指令的能力；完成项目所需的时间；项目的总体优先级；项目的预期财务表现等。创建加权评分模型的基本步骤如下：</p>
<ol>
<li>确认对项目选择过程非常重要的标准。开发这些标准并达成一致可能很耗费时间，对于IT项目而言，一些可能的标准包括：
<ol>
<li>支持核心业务目标或战略</li>
<li>有强势的内部发起人</li>
<li>有强大的客户支持</li>
<li>使用符合实际的技术</li>
<li>在一年内或更短的时间内实施</li>
<li>提供正的的净现值</li>
<li>在低风险水平下实现范围，时间和成本目标</li>
</ol>
</li>
<li>根据重要性为每项标准赋予一定的权重。确定权重同样需要协商并达成一致。你也可以基于百分比来分配权重，所有标准的权重总和必须 1 为 100%。然后，你可以针对每项标准对每个项目进行评分（如 0~100），这些分数代表了功项目符合每项标准的程度。</li>
</ol>
<h4 id="实施平衡计分卡"><a class="header-anchor" href="#实施平衡计分卡"></a>实施平衡计分卡</h4>
<p><code>平衡计分卡 balanced-score-card</code>是一种战略计划和管理系统，可以使组织的业务活动与战略保持一致，改善沟通并根据战略目标监控绩效。</p>
<h3 id="制定项目章程"><a class="header-anchor" href="#制定项目章程"></a>制定项目章程</h3>
<p><code>项目章程 project-charter</code>是一份正式确认项目存在的文件，并对项目的目标与管理提供指导利用组织的资源来完成项目。</p>
<p>理想情况下，制定项目章程的过程中主要需要的输入为：</p>
<ul>
<li>
<p><strong>项目工作说明书</strong>：工作说明书是说明将要由项目组完成的产品或服务。</p>
<ul>
<li>项目的业务需求说明</li>
<li>产品/服务的要求和特点的综述</li>
<li>组织信息</li>
</ul>
</li>
<li>
<p><strong>商业论证</strong>：上一章所述，许多项目都会用商业论证来证明项目的投资合理性。项目章程中包括的商业论证信息有：</p>
<ul>
<li>项目目标</li>
<li>高层要求、时间和成本目标</li>
</ul>
</li>
<li>
<p><strong>收益管理计划</strong>：收益管理计划描述了项目收益的交付时间和交付方式，以及如何对项目收益进行管理。收益管理计划涵盖的主题包括目标收益，战略一致，实现收益的时间计划，收益的持有人，度量标准，假设和风险。</p>
</li>
<li>
<p><strong>合同</strong>：如果根据外部客户的合同来实施项目，那么这份协议应该包含创建一个完整的项目章程所需要的大部分信息。有些人可能用合同/协议来代替章程，然而，大部分合同的语言晦涩且多变。</p>
</li>
<li>
<p><strong>企业环境因素</strong>：包括政府/行业的相关标准、组织的基础设施以及市场条件。</p>
</li>
<li>
<p><strong>组织过程资产 organization-process-assets</strong>：包括正式与非正式的计划、政策、程序、指南、信息系统…</p>
</li>
</ul>
<h3 id="制定项目管理计划"><a class="header-anchor" href="#制定项目管理计划"></a>制定项目管理计划</h3>
<ul>
<li><code>项目管理计划 project-management-plan</code>是用于协调所有项目计划文件，并帮助指导项目的执行与控制的文件。</li>
<li>制定项目管理计划阶段的主要输入：
<ul>
<li>项目章程</li>
<li>其他过程的输出</li>
<li>企业环境因素</li>
<li>组织过程资产</li>
</ul>
</li>
</ul>
<h4 id="项目管理计划"><a class="header-anchor" href="#项目管理计划"></a>项目管理计划</h4>
<p>大部分项目管理计划存在：</p>
<ul>
<li>项目介绍/概述</li>
<li>项目组织</li>
<li>项目管理和技术流程</li>
<li>项目待执行的工作（范围）</li>
<li>项目进度和预算信息</li>
<li>其他项目计划文件</li>
</ul>
<h3 id="监控项目工作"><a class="header-anchor" href="#监控项目工作"></a>监控项目工作</h3>
<ul>
<li>监控项目的工作包括
<ul>
<li>收集、衡量、发布绩效信息</li>
<li>评估度量、分析趋势以确定可以进行哪些过程优化</li>
</ul>
</li>
<li>项目管理计划为识别和控制项目变更提供了<code>基准 baseline</code>——是被记录下来的一个起点、一组度量或一组观察值，能够用于将来的比较。</li>
<li>监控项目工作的重要输出包括：
<ul>
<li>变更请求：
<ul>
<li>纠正措施：改善项目绩效</li>
<li>预防措施：减少与项目风险相关的负面影响</li>
<li>缺陷补救措施：使有缺陷的可交付成果符合要求</li>
</ul>
</li>
<li>工作绩效报告</li>
</ul>
</li>
</ul>
<h3 id="实施整体变更控制"><a class="header-anchor" href="#实施整体变更控制"></a>实施整体变更控制</h3>
<p><code>整体变更控制 intergrated-change-control</code>涉及在整个项目生命周期中识别、评估和管理变更。整体变更控制的3个主要目标是：</p>
<ul>
<li>控制可能造成变更的因素以确保变更都是有益的</li>
<li>确认变更已发送</li>
<li>管理发生的变更</li>
</ul>
<h4 id="变更控制系统"><a class="header-anchor" href="#变更控制系统"></a>变更控制系统</h4>
<ul>
<li><strong>变更控制系统</strong>是一个正式的、文档化的过程，描述了正式的项目文件可能何时以及如何变更、授权进行变更的人员、变更所需的文书工作，以及项目将使用的任何自动/手动的跟踪系统
<ul>
<li>变更委员会</li>
<li>配置管理</li>
<li>沟通变更的过程</li>
</ul>
</li>
<li><strong>变更控制委员会 ChangeControl-Board CCB</strong>是负责批准或拒绝项目变更的正式团队</li>
<li><strong>配置管理</strong>确保项目产品的描述是正确的、完整的。</li>
</ul>
<h3 id="项目或阶段收尾"><a class="header-anchor" href="#项目或阶段收尾"></a>项目或阶段收尾</h3>
<p>项目整合管理最后一步</p>
<p>为了终止一个项目，必须将所有活动收尾，并将已完成/取消的工作移交给相应的人员。</p>
<p><strong>输入为</strong>：</p>
<ul>
<li>项目章程</li>
<li>项目管理计划</li>
<li>项目文件</li>
<li>验收的可交付成果</li>
<li>商业文件</li>
<li>协议</li>
<li>采购文件</li>
<li>组织过程资产</li>
</ul>
<h3 id="关键术语-v4"><a class="header-anchor" href="#关键术语-v4"></a>关键术语</h3>
<p>平衡计分卡(balancedscorecard)<br>
基准(baseline)<br>
资本化率(capitalization rate)<br>
现金流(cashflow)<br>
变更控制委员会(CCB)(changecontrolboard,CCB)<br>
变更控制系统(changecontrolsystem)<br>
配置管理(configuration management)<br>
资本成本(cost of capital)<br>
指令(directives)<br>
折现因子(discountfactor)<br>
折现率(discountrate)<br>
显性知识(explicitknowledge)<br>
整体变更控制(integrated change control)<br>
界面管理(interface management)<br>
内部收益率(IRR)(internal rate of return,IRR)<br>
思维导图(mindmapping)<br>
净现值(NPV)分析(net present value(NPV)analysis)<br>
机会(opportunities)<br>
资本机会成本(opportunity costof capital)<br>
组织过程资产(organizational process assets)<br>
投资回收期(payback period)<br>
问题(problems)<br>
项目章程(projectcharter)<br>
项目整合管理(project integration management)<br>
项目管理计划(project managementplan)<br>
要求回报率(required rate of return)<br>
投资回报率(ROI)(return on investment,ROI)<br>
战略计划(strategic planning)<br>
SWOT 分析法(SWOT analysis)<br>
隐性知识(tacit knowledge)<br>
加权评分模型(weighted scoring model)</p>
<h2 id="CH5-项目范围管理"><a class="header-anchor" href="#CH5-项目范围管理"></a>CH5 项目范围管理</h2>
<h3 id="什么是项目范围管理"><a class="header-anchor" href="#什么是项目范围管理"></a>什么是项目范围管理</h3>
<ul>
<li>项目管理最重要也最难做的一项工作就是定义项目范围。
<ul>
<li>范围是指：开发项目产品所涉及的所有工作和用于开发产品的所有过程。</li>
</ul>
</li>
<li>项目范围管理 project-scope-management是指定界定和控制项目中应包括什么和不包括什么所涉及的过程。</li>
</ul>
<h4 id="项目范围管理包含的6个主要过程："><a class="header-anchor" href="#项目范围管理包含的6个主要过程："></a>项目范围管理包含的6个主要过程：</h4>
<ol>
<li><strong>计划范围管理</strong>：确定如何管理项目的范围和需求</li>
<li><strong>收集需求</strong>：定义并记录产品的特点和功能以及开发这些产品的过程</li>
<li><strong>定义范围</strong>：审查范围管理计划、项目章程、需求文档和组织过程资产来制定一份范围说明书，并且在需求的扩展和变更请求得到批准时增加更多的信息</li>
<li><strong>创建工作分解结构</strong>：将主要的项目可交付成果分解成更细小和更易管理的组成部分</li>
<li><strong>确认范围</strong>：项目可交付成果的正式验收。</li>
<li><strong>控制范围</strong>：对项目范围的变化进行控制。范围变更经常影响团队实现项目的时间目标和成本目标的能力</li>
</ol>
<h3 id="计划范围管理"><a class="header-anchor" href="#计划范围管理"></a>计划范围管理</h3>
<h2 id="CH6-项目时间管理"><a class="header-anchor" href="#CH6-项目时间管理"></a>CH6 项目时间管理</h2>
<h2 id="CH7-项目成本管理"><a class="header-anchor" href="#CH7-项目成本管理"></a>CH7 项目成本管理</h2>
<blockquote>
<p><strong>成本</strong>：为实现一个特定目标而牺牲或放弃的资源。在本章的例子中使用美元货币数量)来衡量。</p>
<p><strong>成本超支 overrun</strong>：实际成本超过估计的额外百分比或金额</p>
</blockquote>
<h3 id="为什么需要进行项目成本的管理"><a class="header-anchor" href="#为什么需要进行项目成本的管理"></a>为什么需要进行项目成本的管理</h3>
<h4 id="项目0-成本管理是什么："><a class="header-anchor" href="#项目0-成本管理是什么："></a>项目0.成本管理是什么：</h4>
<ul>
<li><code>项目成本管理(project cost management)</code>包含用来确保项目团队在批准的预算内完成一个项目的必要过程。请注意这个定义中的两个关键短语:“一个项目&quot;和&quot;批准的预算”。项目经理必须确保他们的项目有恰当的定义、准确的进度计划和成本估算,并有他们参与批准通过的、切合实际的预算。</li>
</ul>
<h4 id="项目成本管理的四个过程："><a class="header-anchor" href="#项目成本管理的四个过程："></a>项目成本管理的四个过程：</h4>
<ol>
<li><strong>计划成本管理</strong>：包括确定用于计划、执行、控制项目成本的政策、程序和文档。这个过程主要输出成本管理计划。</li>
<li><strong>估算成本</strong>：包括完成项目所需资源的近似或估算成本。成本估算过程的主要输出是<strong>活动的成本估算、估算的基础和更新的项目文档。</strong></li>
<li><strong>制定预算</strong>：括将整体成本估算配置到各单项工作，以建立一个衡量绩效的基线。成本预算过程的主要输出是成本基线、项目资金需求和更新的项目文档。</li>
<li><strong>控制成本</strong>：包括控制项目预算的变更。在成本控制过程的主要输出是工作绩效信息、成本预测、请求变更、更新的项目管理计划、更新的项目文档和更新的组织过程资产。</li>
</ol>
<h3 id="成本管理的基本原理"><a class="header-anchor" href="#成本管理的基本原理"></a>成本管理的基本原理</h3>
<ul>
<li><code>利润(profits)</code>：是收入减去支出。</li>
<li><code>利润率(profitmargin)</code>：是利润与收入的比率。</li>
<li><code>生命周期成本(life cycle costing)</code>：是对整个项目生命周期成本的全局认识。例如项目开发一年，运行十年，那么就要对整个生命周期(十年)的成本和收益进行估算</li>
<li><code>现金流分析(cash flow analysis)</code>：是确定项目的年度成本估算和收益以及由此产生的年度现金流的一种方法。项目经理必须进行现金流分析,以确定净现值。</li>
<li><code>有形成本或收益(tangible costs or benefits)</code>和<code>无形成本或收益(intangible costs or benefits)</code>分别表示<strong>容易和不容易</strong>用现金来衡量的成本与收益。</li>
<li><code>直接成本(direct costs)</code>是指那些与创造项目产品和服务直接相关的成本。比如员工的工资</li>
<li><code>间接成本(indirect costs)</code>与项目的产品或服务不直接相关,但它们与项目的工作绩效间接相关。例如,水电费、纸巾等必需品</li>
<li><code>沉没成本(sunk cost)</code>是过去已经花费的钱,它就像沉船一样消失了,永远也打捞不起来。在决定投资或继续哪些项目时,<strong>不应该考虑沉没成本</strong>。例如,赌徒因为输了钱而一直赌博就是因为没有忘记沉没成本</li>
<li><code>学习曲线理论(learning curve theory)</code>指出,当许多产品被重复生产时,这些产品的单位成本会随着产品数量的增加而有规律地降低。例如,假定 Surveyvor Pro 项目可能会生产</li>
<li><code>储备金(reserves)</code>包含于成本估算中,是为了消减由于未来难以预测而带来的成本风险而预先留出的资金。
<ul>
<li><code>应急储备金(contingency reserves)</code>为一些可以部分预计的未来情况(有时称为<code>已知的未知(known unknowns)</code>)做准备,它包含在项目成本基准中。例如,如果一个组织知道 IT 人员的流动率为 20%,它就应该准备应急储备金来支付 IT 人员的招聘和培训成本。</li>
<li><code>管理储备金(management reserves)</code>考虑到未来不可预测的情况(有时称为<code>未知的未知(unknownunknowns)</code>)。例如,如果一个项目经理生病了两周,或者一个重要的供应商</li>
</ul>
</li>
</ul>
<h3 id="计划成本管理"><a class="header-anchor" href="#计划成本管理"></a>计划成本管理</h3>
<blockquote>
<p>项目成本管理的第一步是规划整个项目生命周期中的费用如何管理</p>
</blockquote>
<h4 id="成本管理计划的基本信息"><a class="header-anchor" href="#成本管理计划的基本信息"></a>成本管理计划的基本信息</h4>
<ul>
<li><code>精确度</code>：活动成本估算通常有舍入准则，例如舍入到最近的100美元。</li>
<li><code>测量单位</code>：应定义各单位采用的成本测量</li>
<li><code>组织程序链接</code>：许多组织用于项目成本账户的**工作分解结构(WBS)**的组成结构，被称为控制账户(CA)。每个控制账户通常被分配一个唯一的代码，并用此链接到组织的会计系统。项目团队必须正确理解和使用这些代码。</li>
<li><code>控制临界值</code>：类似于进度偏差，成本通常有一定量的可允许的偏差区间。在区间内，无需采取行动，例如基准成本的±10%</li>
<li><code>绩效测量规则</code>：如果项目采用在本章的后面描述的挣值管理系统(EVM),成本管理计划将定义测量的规则，比如实际成本将被追踪到什么水平的细节。</li>
<li><code>报告模板</code>：描述项目成本报告的格式和频度。</li>
<li><code>过程描述</code>：描述如何执行所有的成本管理流程。</li>
</ul>
<h3 id="成本估算"><a class="header-anchor" href="#成本估算"></a>成本估算</h3>
<h4 id="成本估算类型："><a class="header-anchor" href="#成本估算类型："></a>成本估算类型：</h4>
<ul>
<li>
<p><code>粗粒度估算(ROM)(Rough Order of Magnitude ROM estimate)</code>：提供了一个项目的粗略估算。ROM 估算也可以称作近似估算、猜算、虚估或泛算。准确度通常为-50%~+100%；</p>
</li>
<li>
<p><code>预算估算(budgetary estimate)</code>是用来分配资金到组织中的预算。许多组织制定至少未来两年的预算。预算在项目完成前 1~2 年做出。预算的准确度一般是-10%~+25%；</p>
</li>
<li>
<p><code>确定性估算(definitive estimate)</code>提供了对项目成本的准确估算。确定性估算用于做出许多需要准确估算的采购决策和估算最终的项目成本。</p>
</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241109112541888.png" alt="image-20241109112541888"></p>
<h4 id="成本估算的工具和技术"><a class="header-anchor" href="#成本估算的工具和技术"></a>成本估算的工具和技术</h4>
<ul>
<li><code>专家判断</code>：</li>
<li><code>类比估算(analogous estimates)</code>，也称为<code>自上而下估算(top-down estimates)</code>，使用以前类似项目的实际成本作为估算当前项目成本的依据。不准确</li>
<li><code>自下而上估算(bottom-up estimates)</code>，估算单个工作项或者活动的成本，相加得到整体估算。准确但是花费时间长，成本高</li>
<li><code>三点估算(three-point estimates)</code>包括估算项目最可能的、最乐观的和最悲观的成本。你可以使用第 6 章中描述的 PERT 加权平均公式,或者使用第 11 章中描述的蒙特卡罗模拟来进行成本估算。</li>
<li><code>参数估算(parametric estimating)</code>使用数学模型中的项目特征(参数)来估算项目成本。例如,参数化模型可能根据项目使用的编程语言、程序员的专业水平、所涉及数据的大小和复杂性等为软件开发项目提供每行代码 50 美元的估算。</li>
<li><code>质量成本</code></li>
<li><code>项目管理估算软件</code></li>
<li><code>供应商报价分析和储备分析</code></li>
<li>实践中，混合使用以上方法可以提供最佳的成本估算。</li>
</ul>
<h2 id="CH8-项目质量管理"><a class="header-anchor" href="#CH8-项目质量管理"></a>CH8 项目质量管理</h2>
<h2 id="CH9-项目资源管理"><a class="header-anchor" href="#CH9-项目资源管理"></a>CH9 项目资源管理</h2>
<h2 id="CH10-项目沟通管理"><a class="header-anchor" href="#CH10-项目沟通管理"></a>CH10 项目沟通管理</h2>
<h2 id="CH11-项目风险管理"><a class="header-anchor" href="#CH11-项目风险管理"></a>CH11 项目风险管理</h2>
<h2 id="CH12-项目采购管理"><a class="header-anchor" href="#CH12-项目采购管理"></a>CH12 项目采购管理</h2>
<h2 id="CH13-项目干系人管理"><a class="header-anchor" href="#CH13-项目干系人管理"></a>CH13 项目干系人管理</h2>
]]></content>
      <tags>
        <tag>软件项目管理</tag>
        <tag>q&#39;m</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h1>
<h2 id="CH1—基本概念概述"><a class="header-anchor" href="#CH1—基本概念概述"></a>CH1—基本概念概述</h2>
<p>操作系统：</p>
<ol>
<li>是一台将复杂的执行细节隐藏， 向用户提供虚拟的易于使用的功能的一种机器。</li>
<li>一种资源管理机器</li>
</ol>
<h3 id="进程："><a class="header-anchor" href="#进程："></a>进程：</h3>
<blockquote>
<p>正在执行的一个程序就是一个进程</p>
<p>为了描述和控制进程的运行</p>
</blockquote>
<ol>
<li>
<p>一个称为command interpret或shell的进程从终端读取命令。</p>
</li>
<li>
<p>一个进程可以创建一个或多个子进程，从而构成进程树。</p>
</li>
<li>
<p>UNIX有一个共同的父进程：<strong>root</strong></p>
</li>
</ol>
<h3 id="进程块-PCB"><a class="header-anchor" href="#进程块-PCB"></a>进程块 PCB</h3>
<p>为了便于描述和控制进程的运行，OS为进程定义了一种数据结构“进程块 PCB（Process Control Block）”，每创建一个进程，即是为某个程序设置了一个PCB，用于对该进程进行控制和管理。进程任务完成则收回PCB，代表进程消亡。</p>
<p>至此，PCB是进程存在的唯一标志。</p>
<h3 id="进程的状态"><a class="header-anchor" href="#进程的状态"></a>进程的状态</h3>
<ul>
<li>
<p><strong>running</strong></p>
</li>
<li>
<p><strong>blocked</strong>(阻塞，不可抢占CPU资源)</p>
</li>
<li>
<p><strong>ready</strong>(可抢占CPU资源状态)</p>
</li>
</ul>
<h3 id="不同种类的ID"><a class="header-anchor" href="#不同种类的ID"></a>不同种类的ID</h3>
<ul>
<li>
<p><strong>UID</strong>：Each person authorized to use a system is assigned a User IDentification</p>
</li>
<li>
<p><strong>PID</strong>：A process is assigned a Process IDentification</p>
</li>
<li>
<p><strong>GID</strong>：在一个Group内的用户具有在该组内的Group identification</p>
</li>
</ul>
<p>**进程间通信：**协作和同步进程的通信称为进程间通信</p>
<p>**信道：**一种伪文件，用于连接两个进程</p>
<h3 id="系统调用"><a class="header-anchor" href="#系统调用"></a>系统调用</h3>
<p>系统调用提供了运行程序和操作系统之间的接口</p>
<p>系统调用的目的：</p>
<ul>
<li>
<p>应用程序用来向操作系统请求服务的机制。</p>
</li>
<li>
<p>主要由程序通过高级应用程序编程接口(API)访问，而不是直接使用系统调用</p>
<p>应用通过申请 预先设定好的用来调用系统的程序 来完成调用系统某项操作的目的</p>
</li>
</ul>
<p>有以下两种考虑：</p>
<ol>
<li>
<p>使用接口，可以不用事先考虑以后添加新的应用和程序时需要对操作系统进行修改，而只需要提供一套统一的接口调用标准，厂商开发时按照这一套标准进行，而后将开发好的应用安装到操作系统即可</p>
</li>
<li>
<p><strong>独立</strong>了系统和用户应用程序之间，降低了耦合度。</p>
</li>
</ol>
<h4 id="系统调用和库函数的区别"><a class="header-anchor" href="#系统调用和库函数的区别"></a>系统调用和库函数的区别</h4>
<ol>
<li>操作系统是比库函数更加底层的一种接口。因为应用程序在调用部分库函数以后，部分库函数也需要去调用系统调用。</li>
<li>部分库函数各种功能的实现是通过调用了系统调用，进而请求操作系统的内核服务从而完成一系列功能。</li>
<li>部分库函数对系统调用进行了封装。</li>
</ol>
<p><strong>按功能分类，常见的系统调用</strong>·</p>
<blockquote>
<p>凡是与共享资源有关的操作（存储分配、I/O操作、文件管理等）都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核来完成。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">功能名称</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">设备管理</td>
<td style="text-align:left">完成设备的 请求、释放、启动 等功能</td>
</tr>
<tr>
<td style="text-align:center">文件管理</td>
<td style="text-align:left">完成文件的 读、写、创建、删除 等功能</td>
</tr>
<tr>
<td style="text-align:center">进程控制</td>
<td style="text-align:left">完成进程的 创建、撤销、阻塞、唤醒 等功能</td>
</tr>
<tr>
<td style="text-align:center">进程通信</td>
<td style="text-align:left">完成进程之间的 信息传递、信号传递 等功能</td>
</tr>
<tr>
<td style="text-align:center">内存管理</td>
<td style="text-align:left">完成内存的 分配、回收 等功能</td>
</tr>
</tbody>
</table>
<h4 id="POSIX："><a class="header-anchor" href="#POSIX："></a>POSIX：</h4>
<p>调用操作系统接口：用于调用系统调用的一种<strong>procedure</strong>，通常是一个<strong>procedure</strong>对应一个系统调用<strong>system call</strong>，但并不是绝对的。</p>
<p>完成一个系统调用的步骤</p>
<blockquote>
<p>以read系统调用为例，进行简单的学习</p>
<p>read调用有三个参数： <code>read(fd,buffer,nbytes)</code></p>
</blockquote>
<ul>
<li>
<p>1、2、3：调用程序首先将三个参数压入堆栈;</p>
</li>
<li>
<p>4：接着对库过程的实际调用，该指令是用来调用所有过程的正常过程调用指令;</p>
</li>
<li>
<p>5：将<code>read</code>函数代码放入寄存器当中;</p>
</li>
<li>
<p>6：陷入内核：而后执行一个<code>TRAP</code>指令，将用户态切换到内核态，并在内核一个固定地址开始执行；(<code>TRAP</code>不能跳转到任意地址上);</p>
</li>
<li>
<p>7：分派：内核代码检查系统调用编号，分派给正确的系统调用处理器。通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表完成;</p>
</li>
<li>
<p>8：系统调用处理器运行;</p>
</li>
<li>
<p>9：系统调用处理器完成工作，控制可能会在跟随<code>TRAP</code>指令后面的指令中返回给用户空间库过程;</p>
</li>
<li>
<p>10：这个过程接着以通常的过程调用返回的方式，返回到用户程序;</p>
</li>
<li>
<p>11：完成整个工作后，用户程序清除堆栈，还原回进行任何过程调用之前一样，SP自增。</p>
</li>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241434.png" alt="image-20240610133629462" style="zoom:80%;" /> 
</li>
</ul>
<h3 id="操作系统体系结构"><a class="header-anchor" href="#操作系统体系结构"></a>操作系统体系结构</h3>
<blockquote>
<p>大内核、微内核、分层结构、模块化、外核</p>
</blockquote>
<h4 id="单体架构（Monolithic-Architecture）"><a class="header-anchor" href="#单体架构（Monolithic-Architecture）"></a>单体架构（Monolithic Architecture）</h4>
<ul>
<li><strong>宏内核</strong>：将操作系统的主要功能模块都作为系统内核，运行在和心态
<ul>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
<li>例如：早期的Linux，UNIX</li>
</ul>
</li>
</ul>
<h4 id="微内核（Microkernel-Architecture）"><a class="header-anchor" href="#微内核（Microkernel-Architecture）"></a>微内核（Microkernel Architecture）</h4>
<ul>
<li><strong>微内核</strong>：只把核心功能（如进程间通信、基本的内存管理、CPU调度等）保留在内核中，而其他服务（如文件系统、设备驱动等）移到用户空间运行。
<ul>
<li>优点：缩小内核，只保留核心功能，结构清晰，方便维护</li>
<li>缺点：需要频繁在核心态和用户态之间切换、性能低</li>
<li>例如：Windows NT</li>
</ul>
</li>
</ul>
<h4 id="层次结构（Layered-Architecture）"><a class="header-anchor" href="#层次结构（Layered-Architecture）"></a>层次结构（Layered Architecture）</h4>
<ul>
<li><strong>分层次结构</strong>：内核分多层，每一层都只使用其下层提供的功能，并为其上层提供服务。
<ul>
<li>
<p>优点：模块化设计，易于理解和调试</p>
</li>
<li>
<p>缺点：严格的层次划分可能导致效率低下，跨层通信复杂。</p>
</li>
</ul>
</li>
</ul>
<h4 id="模块化结构（Modular-Architecture）"><a class="header-anchor" href="#模块化结构（Modular-Architecture）"></a>模块化结构（Modular Architecture）</h4>
<ul>
<li>
<p><strong>模块化</strong>：将操作系统按功能划分为若干具有一定独立性的模块，可以独立编译和加载。</p>
<ul>
<li>灵活性高，易于扩展和维护</li>
<li>模块间接口设计复杂，安全性和稳定性需要严格管理。</li>
</ul>
</li>
<li>
<p><strong>外核(exokernel)</strong>：内核负责进程调度、进程通信等功能；外核负责用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>
</li>
<li>
<p><strong>虚拟机(Hypervisor)</strong>：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机都可以独立运行一个操作系统。</p>
</li>
</ul>
<h2 id="CH2—进程-Process-————"><a class="header-anchor" href="#CH2—进程-Process-————"></a>CH2—进程&amp;Process ————</h2>
<blockquote>
<p>25~30分</p>
<p>两个大题；</p>
<p>两个选择题；</p>
<p>可能一个简答题</p>
</blockquote>
<blockquote>
<ol>
<li>Process  进程</li>
<li>Threads 线程</li>
</ol>
<hr>
<ol start="3">
<li>
<p><strong>Interprocess communication</strong>进程间通信</p>
</li>
<li>
<p><strong>Classical IPC problems</strong>进程间通信的经典问题</p>
</li>
</ol>
<hr>
<ol start="5">
<li>Scheduling  进程调度问题</li>
</ol>
<p>在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每一个进程个运行几十或几百毫秒。严格来说，在CPU运行的某一个瞬间，CPU只能运行一个进程，但在1秒内可能运行多个进程，则对人来说就会产生类似于看电影一样的效果，感觉同一时间运行了多个进程，也就是<strong>伪并行</strong>。</p>
</blockquote>
<h3 id="进程"><a class="header-anchor" href="#进程"></a>进程</h3>
<h4 id="PCB存储的信息"><a class="header-anchor" href="#PCB存储的信息"></a>PCB存储的信息</h4>
<table>
<thead>
<tr>
<th style="text-align:left">信息种类</th>
<th style="text-align:left">具体描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">进程描述信息</td>
<td style="text-align:left">进程标识符<strong>PID</strong>&amp;用户标识符<strong>UID</strong></td>
</tr>
<tr>
<td style="text-align:left">进程控制和管理信息</td>
<td style="text-align:left"><strong>CPU</strong>、磁盘、网络流量使用情况统计…&amp;进程当前状态：就绪态、阻塞态、运行态</td>
</tr>
<tr>
<td style="text-align:left">资源分配清单</td>
<td style="text-align:left">正在使用哪些文件&amp;正在使用哪些内存区域&amp;正在使用哪些<strong>I/O</strong>设备</td>
</tr>
<tr>
<td style="text-align:left">处理机相关信息</td>
<td style="text-align:left">如<strong>PSW</strong>、<strong>PC</strong>等各种寄存器的值（用于实现进程切换）</td>
</tr>
</tbody>
</table>
<p>当一个程序开始运行前，创建了相对应的<strong>PCB</strong>，同时将程序中一系列的指令存放到内存当中——构成程序段，包括程序指令——而一个程序执行的过程即是<strong>CPU</strong>从内存中读取一条条指令并依次执行的过程</p>
<p>一个进程实例（进程映像）是由PCB、程序段、数据段组成。</p>
<p>进程是<strong>动态</strong>的，进程实例是<strong>静态</strong>的。</p>
<p>操作系统<strong>以进程为单位进行资源的分配和调度</strong>。</p>
<h4 id="进程模型"><a class="header-anchor" href="#进程模型"></a>进程模型</h4>
<p>软件可以视为一组进程的集合</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241488.png" alt="image-20240610140621701" style="zoom:50%;" /> 
<p>Multiprogramming of four programs 四个程序的多路编程<br>
Conceptual model of 4 independent, sequential processes 4个独立的顺序过程的概念模型<br>
Only one program active at any instant 任何时刻只有一个程序处于活动状态</p>
<h4 id="Definition"><a class="header-anchor" href="#Definition"></a>Definition</h4>
<p><strong>进程的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次活动</strong></p>
<p>当进程被创建时，会给予进程一个不重复的独一无二的PID。</p>
<p>与进程相关的信息使用一种数据结构<strong>PCB(Process Control Block)<strong>当中，即进程控制块。当一个进程被创建时，操作系统会为其创建相应的</strong>PCB</strong>，当进程结束时再回收其<strong>PCB</strong>。</p>
<h4 id="Process-Vs-Program"><a class="header-anchor" href="#Process-Vs-Program"></a>Process Vs Program</h4>
<p>程序：</p>
<ul>
<li>集合指令，静态概念；</li>
<li>永久</li>
<li>一个程序可以是多个进程的执行程序;</li>
</ul>
<p>进程：</p>
<ul>
<li>描述并发、动态的概念；</li>
<li>进程包括程序、数据和PCB</li>
<li>暂时的</li>
<li>进程可以在其中创建其他进程。</li>
<li>另外，一个进程可以调用多个程序。</li>
</ul>
<h4 id="进程的创建"><a class="header-anchor" href="#进程的创建"></a>进程的创建</h4>
<ol>
<li>系统初始化时</li>
<li>执行进程创建系统调用时（fork()函数）：请求创建进程的是父进程
<ol>
<li>从当前进程创建新的进程，新进程是当前进程的子进程，也是父进程的副本</li>
</ol>
</li>
<li>创建新进程的用户请求：请求创建进程的是用户
<ol>
<li>请求是用户或应用程序向操作系统提出的请求，目的是启动一个新的进程。</li>
</ol>
</li>
<li>启动批处理作业</li>
</ol>
<h4 id="进程终止"><a class="header-anchor" href="#进程终止"></a>进程终止</h4>
<ol>
<li>Normal exit 正常退出（自愿）
<ol>
<li>程序正常执行完毕</li>
</ol>
</li>
<li>Error exit 错误退出（自愿）
<ol>
<li>编译出错</li>
</ol>
</li>
<li>Fatal error 致命错误（非自愿）
<ol>
<li>除以0，执行非法指令，引用不存在的内存</li>
</ol>
</li>
<li>Killed by another process 被其他进程杀死（非自愿）</li>
</ol>
<h4 id="进程状态"><a class="header-anchor" href="#进程状态"></a>进程状态</h4>
<ul>
<li>基本状态：
<ul>
<li>运行 running state</li>
<li>就绪 ready state</li>
<li>阻塞 blocked state</li>
</ul>
</li>
<li>其他状态
<ul>
<li>New state</li>
<li>Exit state</li>
</ul>
</li>
<li>挂起
<ul>
<li>阻塞挂起状态</li>
<li>就绪挂起状态</li>
</ul>
</li>
</ul>
 <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241084.png" alt="image-20240610172240806" style="zoom:50%;" /> 
<h3 id="线程-Thread"><a class="header-anchor" href="#线程-Thread"></a>线程 Thread</h3>
<h4 id="线程的概念"><a class="header-anchor" href="#线程的概念"></a>线程的概念</h4>
<p>在进程当中划分出线程，是对一个进程中已得到CPU资源的一种利用的方式</p>
<ul>
<li>
<p>**什么是进程：**进程内的顺序执行流。</p>
<ul>
<li>线程将执行的概念与流程抽象分离开来。</li>
<li>每个线程<strong>共享进程的资源</strong>（如地址空间、全局变量、文件描述符等），<strong>但有自己的栈、程序计数器和寄存器</strong>。线程是CPU调度和执行的基本单位。</li>
</ul>
</li>
<li>
<p><strong>线程控制块ThreadControlBlock TCB：</strong></p>
</li>
</ul>
<h4 id="线程优点："><a class="header-anchor" href="#线程优点："></a>线程优点：</h4>
<ol>
<li>创建、销毁、切换用时短</li>
</ol>
<h4 id="进程的作用："><a class="header-anchor" href="#进程的作用："></a>进程的作用：</h4>
<ul>
<li>响应性:多个活动可以同时完成。他们可以加快申请速度。</li>
<li>资源共享:线程共享它们所属进程的内存和资源。</li>
<li>经济:它们很容易被创造和摧毁。</li>
<li>MP(多处理器)体系结构的利用:它们在多CPU系统上很有用。</li>
</ul>
<h4 id="线程的实现"><a class="header-anchor" href="#线程的实现"></a>线程的实现</h4>
<ul>
<li><strong>三种实现方式：</strong>
<ul>
<li>用户级：
<ul>
<li>线程完全处于用户空间中，内核不知道有该线程存在</li>
<li>线程管理由用户级线程库完成</li>
<li>线程切换不需要内核权限，用户级线程创建和管理速度快。</li>
<li>问题:如果内核是单线程的，那么任何执行阻塞系统调用的用户级线程都将导致整个进程阻塞。</li>
</ul>
</li>
<li>内核级
<ul>
<li>内核支持:内核在内核空间中执行线程创建、调度和管理。</li>
<li>没有线程库，内核提供API</li>
<li>内核维护进程和线程的上下文</li>
<li>线程切换需要内核</li>
<li>线程是Scheduler的基本单位。</li>
<li>缺点是：资源花销太大</li>
</ul>
</li>
<li>混合实现</li>
</ul>
</li>
</ul>
<h4 id="线程和进程的对比："><a class="header-anchor" href="#线程和进程的对比："></a>线程和进程的对比：</h4>
<ol>
<li>
<p><strong>资源分配</strong>：进程是资源分配的基本单位，拥有独立的资源记录，而线程与资源分配无关，属于进程的一部分。</p>
</li>
<li>
<p><strong>地址空间</strong>：不同进程拥有独立的虚拟地址空间，同一进程中的多个线程共享同一地址空间。</p>
</li>
<li>
<p><strong>切换开销</strong>：进程切换涉及资源指针保存和地址空间转换，开销较大，而线程切换不涉及这些问题，开销较小。</p>
</li>
<li>
<p><strong>调度机制</strong>：进程调度由操作系统内核完成，线程调度可以由操作系统内核或用户程序完成。</p>
</li>
<li>
<p><strong>创建能力</strong>：进程可以动态创建进程，线程也可以由进程创建其他线程。</p>
</li>
<li>
<p><strong>生命周期</strong>：进程和线程都有创建、执行和消亡的生命周期。</p>
</li>
</ol>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信"></a>进程间通信</h3>
<blockquote>
<p>三个问题作为引言：</p>
<ol>
<li>一个进程如何传递消息给另一个进程</li>
<li>资源共享
<ol>
<li>如何确保两个或多个进程在进行关键活动时不会相互妨碍。(互斥)</li>
</ol>
</li>
<li>进程间协作
<ol>
<li>当存在依赖关系时，进行适当的排序(同步)。</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="进程间同步"><a class="header-anchor" href="#进程间同步"></a>进程间同步</h4>
<p>对多个相关进程在执行次序上的协调,用于保证这种关系的相应机制称为进程同步。</p>
<p>相互合作的一组并发进程在一些关键点上可能需要互相等待与互通消息,相互制约的等待与互通消息称为进程同步。</p>
<ul>
<li>
<p>进程间竞争 race：</p>
<ul>
<li>防止竞争的出现关键在于禁止多个进程同时读写共享数据。</li>
</ul>
</li>
<li>
<p>互斥 Mutual exclusion</p>
</li>
</ul>
<p>确保一个进程使用某共享资源时，其他进程无法访问这个变量</p>
<ul>
<li>临界区
<ul>
<li>临界资源：一次仅允许一个进程访问的资源称之为临界资源</li>
<li>程序中访问临界资源的部分称为临界区域或临界段</li>
</ul>
</li>
</ul>
<h4 id="临界区四个性质要求："><a class="header-anchor" href="#临界区四个性质要求："></a>临界区四个性质要求：</h4>
<ul>
<li>没有两个进程同时处于临界区域</li>
<li>没有对cpu的速度或数量做任何假设</li>
<li>任何在临界区域外运行的进程都不能阻塞另一个进程</li>
<li>没有进程必须永远等待才能进入其临界区域</li>
</ul>
<h4 id="实现互斥"><a class="header-anchor" href="#实现互斥"></a>实现互斥</h4>
<ol>
<li>
<p><strong>禁用中断</strong></p>
<ul>
<li>在进入临界区后禁用所有中断，并在离开临界区之前重新启用它们。</li>
<li>禁用中断后，不会发生时钟中断，因为CPU只有在时钟中断时才可以进行进程的切换，禁用后就不会发生切换了。</li>
</ul>
</li>
<li>
<p><strong>锁变量</strong>：使用一个简单的锁变量来表示临界区是否被占用。</p>
<ul>
<li>进程在进入临界区之前检查该变量：</li>
<li>如果它没有被锁定，则设置它为锁定状态并进入临界区；</li>
<li>如果被锁定，则等待。该方法存在忙等待问题，并且容易出现竞争条件。</li>
</ul>
</li>
<li>
<p><strong>严格的轮换法</strong>：用于两个进程之间的互斥。进程交替进入临界区。一个进程完成后设置一个标志，允许另一个进程进入临界区。</p>
<ul>
<li>缺点是会导致不必要的等待，即使一个进程不需要进入临界区，另一个进程也必须等待。</li>
<li>这个方法可能违反性质3——任何在<strong>临界区域外的进程不能</strong>阻塞另一个进程
<ul>
<li>由于进程必须严格交替进入它们的临界区，因此想要连续两次进入其临界区的进程将被阻塞，直到另一个进程决定进入(和离开)其临界区。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Peterson算法</strong>：使用两个标志和一个“turn”变量来确保互斥。</p>
<ul>
<li>
<pre><code class="language-c">// 伪代码
boolean flag[2] = &#123;false, false&#125;;
int turn = 0;

process 0:
while (true) &#123;
    flag[0] = true;
    turn = 1;
    while (flag[1] &amp;&amp; turn == 1);
    critical_section();
    flag[0] = false;
&#125;

process 1:
while (true) &#123;
    flag[1] = true;
    turn = 0;
    while (flag[0] &amp;&amp; turn == 0);
    critical_section();
    flag[1] = false;
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. **Test-and-Set Lock (TSL)**：</span><br><span class="line"></span><br><span class="line">   - 硬件必须支持一个特殊的指令，tsl，它在一个原子动作中做两件事:</span><br><span class="line">     TSL register，flag</span><br><span class="line">     - copy a value in memory (flag) to a CPU register</span><br><span class="line">     - set flag to 1.</span><br><span class="line"></span><br><span class="line">   - ```c</span><br><span class="line">     // 伪代码</span><br><span class="line">     boolean lock = false;</span><br><span class="line">     </span><br><span class="line">     boolean TestAndSet(boolean *target) &#123;</span><br><span class="line">         boolean rv = *target;</span><br><span class="line">         *target = true;</span><br><span class="line">         return rv;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     while (true) &#123;</span><br><span class="line">         while (TestAndSet(&amp;lock));</span><br><span class="line">         critical_section();</span><br><span class="line">         lock = false;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Sleep and Wakeup</strong>：当一个进程不能进入临界区时，它会进入sleep状态（其实就是blocked），直到另一个进程唤醒wake up它。该方法避免了忙等待问题。</p>
</li>
<li>
<p><strong>互斥导致的忙等待</strong></p>
<ol>
<li>Peterson算法 和 TSL方法 会造成忙等待，即执行入口代码的进程会一直处于一个紧循环的状态，消耗CPU周期，一般般测试某些条件是否成立，直到为真</li>
<li>如果使用简单的优先级调度来调度进程，着忙等待会导致优先级反转的问题</li>
</ol>
</li>
</ol>
<h2 id="CH3—"><a class="header-anchor" href="#CH3—"></a>CH3—</h2>
<h3 id=""><a class="header-anchor" href="#"></a></h3>
<p>操作系统的文件资源管理MainMemmroy</p>
<p>主存空间的分配问题</p>
<p>操作系统管理虚存：Address Space：地址空间</p>
<h2 id="CH4—"><a class="header-anchor" href="#CH4—"></a>CH4—</h2>
<p>文件系统 File System</p>
<p>directory 目录</p>
<p>目录树</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241444.png" alt="image-20240313110501430" style="zoom:50%;" /> 
<p>UNIX中目录树唯一</p>
<p>两种查找方式：</p>
<p>绝对路径：从根目录开始</p>
<p>相对路径：从当前目录开始</p>
<h2 id="CH5—Input-Output"><a class="header-anchor" href="#CH5—Input-Output"></a>CH5—Input/Output</h2>
<p>I/O sub-system 子系统去管理I/O设备</p>
<p>设备驱动程序 device driver</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="编译原理"><a class="header-anchor" href="#编译原理"></a>编译原理</h1>
<h2 id="CH1-编译器介绍"><a class="header-anchor" href="#CH1-编译器介绍"></a>CH1: 编译器介绍</h2>
<h3 id="编译器概述"><a class="header-anchor" href="#编译器概述"></a>编译器概述</h3>
<blockquote>
<p>为什么需要编译器？</p>
<p>因为计算机只能执行机器语言，而为了便于项目开发，人们需要使用高级程序语言提高效率。此时需要编译器将人能看懂但机器看不懂的高级程序语言转换为机器可以看得懂的机器码(machine code)</p>
<p>什么是编译器？</p>
<ol>
<li>
<p>编译器也是一种程序或软件</p>
</li>
<li>
<p>其核心功能是将<strong>输入</strong>的<strong>源代码</strong>翻译为<strong>目标代码</strong>进行<strong>输出</strong>。</p>
<p>即将代码由一种语言转换为另一种语言的翻译软件</p>
</li>
</ol>
</blockquote>
<h3 id="解释器"><a class="header-anchor" href="#解释器"></a>解释器</h3>
<ol>
<li>一种常见的语言处理器。</li>
<li>它并不通过翻译的方式生成目标程序；解释器直接利用用户提供的输入执行源程序中指定对的操作。</li>
</ol>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240735.png" alt="image-20240311182629128"></p>
<h3 id="编译器和解释器对比"><a class="header-anchor" href="#编译器和解释器对比"></a>编译器和解释器对比</h3>
<h4 id="相同点：都是一种语言实现系统"><a class="header-anchor" href="#相同点：都是一种语言实现系统"></a>相同点：都是一种语言实现系统</h4>
<h4 id="不同点："><a class="header-anchor" href="#不同点："></a>不同点：</h4>
<ol>
<li>
<p>解释器边解释边执行。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240650.png" alt="image-20240311194928864"></p>
</li>
<li>
<p>编译器对源代码总的进行编译并产生可直接使用的对象代码。</p>
</li>
<li>
<p>解释器运行程序基本没有预处理。</p>
</li>
<li>
<p>编译器做了许多拓展性的预处理，大部分都是靠编译器实现。</p>
</li>
<li>
<p>编译器和解释器配合使用，法力无边（参考JAVA）</p>
</li>
</ol>
<h3 id="编译器结构"><a class="header-anchor" href="#编译器结构"></a>编译器结构</h3>
<ol>
<li>
<p><strong>Lexical analysis(Scanning)词法分析</strong>：识别description逻辑块。</p>
</li>
<li>
<p><strong>Syntax analysis(Parsing) 语法分析</strong>：识别逻辑块间的相互关系。</p>
</li>
<li>
<p><strong>Semantic analysis 语义分析</strong>：识别整个结构的意义。</p>
</li>
<li>
<p><strong>IR Generation 中间代码生成</strong>：设计一个可能符合的结构</p>
</li>
<li>
<p><strong>IR Optimization 中间代码优化</strong>：简化生成的目的结构</p>
</li>
<li>
<p><strong>Generation (最终)代码生成</strong>：产生目的结构</p>
</li>
<li>
<p><strong>Optimization 机器相关代码优化</strong>：优化最终结构</p>
</li>
</ol>
<h4 id="编译器的高层结构"><a class="header-anchor" href="#编译器的高层结构"></a>编译器的高层结构</h4>
<ol>
<li>编译器具有非常<strong>模块化</strong>的高层结构
<ol>
<li>前端 <strong>Front End</strong></li>
<li>后端 <strong>Back End</strong></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">	str1[&quot;源代码&quot;]</span><br><span class="line">	str2[&quot;词法分析&quot;]</span><br><span class="line">	str3[&quot;语法分析&quot;]</span><br><span class="line">	str4[&quot;语义分析&quot;]</span><br><span class="line">	str5[&quot;代码生成&quot;]</span><br><span class="line"></span><br><span class="line">	str1 --字符序列--&gt; str2 --token序列--&gt; str3 --抽象语法树--&gt; str4 --中间代码--&gt; str5</span><br></pre></td></tr></table></figure>
<h2 id="CH2-词法分析"><a class="header-anchor" href="#CH2-词法分析"></a>CH2: 词法分析</h2>
<blockquote>
<p>编译器的第一个步骤称为<strong>词法分析(lexical analysis)</strong>&amp;<strong>扫描(Scanning)</strong>。</p>
</blockquote>
<h3 id="词法分析的工作："><a class="header-anchor" href="#词法分析的工作："></a>词法分析的工作：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">字符流--&gt;|词法分析器|记号流</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>词法分析器读入组成源程序的<strong>字符流</strong>，并且将它们组成有意义的词素(lexeme)的序列，生成并输出一个词法单元序列，每个词法单元对应一个词素lexeme。</p>
</li>
<li>
<p>对于每个词素，词法分析器产生词法单元，该单元会传入下一步骤——<strong>语法分析</strong>当中。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240118.png" alt="image-20240312170757833" style="zoom:50%;" /> 
</li>
<li>
<p>词法分析器通常需要和符号表进行交互，当发现一个<strong>标识符</strong>的词素时，将该词素添加到符号表当中。<br>
符号表条目的信息会在<strong>语义分析</strong>和<strong>代码生成</strong>步骤使用</p>
</li>
<li>
<p>词法分析器在编译器中的其他任务：</p>
<ol>
<li>过滤源程序中的注释和空白(空格、换行符、制表符以及在输入中用于分隔词法单元的其他字符)。</li>
<li>将编译器生成的错误信息和源程序的位置联系起来。</li>
<li>如果源程序使用了宏预处理器，则宏的拓展也可以由词法分析器完成。</li>
</ol>
</li>
<li>
<p>词法分析可分为两个阶段：</p>
<ol>
<li>
<p><strong>扫描阶段</strong>：完成一些不需要生成词法单元<strong>token</strong>的简单处理，如删除注释和将多个连续空白符压缩为一个。</p>
</li>
<li>
<p><strong>词法分析阶段</strong>：处理扫描阶段的输出并生成<strong>token</strong>。</p>
</li>
</ol>
</li>
<li>
<p>词法分析步骤将源代码的字符流转换为记号流，以待后续使用。</p>
</li>
</ol>
<h3 id="词法单元、模式和词素"><a class="header-anchor" href="#词法单元、模式和词素"></a>词法单元、模式和词素</h3>
<h4 id="词法单元-Token"><a class="header-anchor" href="#词法单元-Token"></a>词法单元 Token</h4>
<p><strong>token的组成</strong>：一个词法单元名和一个可选的属性值（不一定有）组成。</p>
<p>（<strong>token-name</strong>，<strong>attribute-value</strong>）</p>
<pre><code>  1. *token-name*：是一个表示某种词法单位的抽象符号，如：特定的关键字，或代表标识符的输入字符序列。
  2. *attribute-value*：多个词素和一个模式匹配，则词法分析器需要向编译器的后续阶段提供被匹配词素的附加信息。因而词法分析器和语法分析器的交互中，词法分析器需要向语法分析器不仅返回**token-name**，还要返回一个描述该词法单元的词素的**attribut-value**。（词法单元名字影响语法分析过程中的决定；属性值影响语法分析之后对这个词法单元的翻译，语义）
  3. 以标识符举例：**id**，和一个标识符相关的信息——词素、类型、首次出现位置（报错时使用）存放在符号表中。一个标识符的属性值是一个指向符号表中该标识符对应条目的指针。
</code></pre>
<h4 id="模式"><a class="header-anchor" href="#模式"></a>模式</h4>
<p><strong>模式的定义</strong>：描述了一个词法单元的词素可能具有的形式。</p>
<h4 id="词素"><a class="header-anchor" href="#词素"></a>词素</h4>
<p><strong>词素的定义</strong>：源程序中的一个的字符序列，与某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。</p>
<h4 id="常见的词法单元类别："><a class="header-anchor" href="#常见的词法单元类别："></a>常见的词法单元类别：</h4>
<ol>
<li>每个关键字有一个词法单元。一个关键字的模式就是其本身；</li>
<li>表示运算符的词法单元。可以表示单个运算符；也快有表示一类运算符；</li>
<li>一个表示所有标识符的词法单元；</li>
<li>一个或多个表示常量的词法单元，如数字和字面值字符串；</li>
<li>每一个标点符号有一个词法单元，比如左右括号、逗号和分号。</li>
</ol>
<h4 id="词法错误"><a class="header-anchor" href="#词法错误"></a>词法错误</h4>
<p>解决词法错误的策略：<strong>“恐慌模式”恢复</strong>。</p>
<p>其他可能的错误恢复动作：</p>
<ol>
<li>从剩余的输入中删除一个字符。</li>
<li>向剩余的输入中插入一个遗漏的字符。</li>
<li>用一个字符来替换另一个字符。</li>
<li>交换两个相邻字符。</li>
</ol>
<h3 id="输入缓冲"><a class="header-anchor" href="#输入缓冲"></a>输入缓冲</h3>
<h4 id="缓冲区对"><a class="header-anchor" href="#缓冲区对"></a>缓冲区对</h4>
<p>两个交替读入的缓冲区，每个缓冲区的容量为N（通常为磁盘大小）。当输入文件中的剩余字符不足<strong>N</strong>时，使用<strong>eof</strong>标记末尾。</p>
<p><strong>两个指针</strong>：</p>
<ol>
<li><strong>lexemeBegin</strong> Pointer：该指针指向当前词素的开始处。</li>
<li><strong>forward</strong> Pointer：向前扫描，直到发现匹配某个模式为止。</li>
</ol>
<h4 id="哨兵标记"><a class="header-anchor" href="#哨兵标记"></a>哨兵标记</h4>
<p>在缓冲区对的基础上，</p>
<h3 id="扫描和token"><a class="header-anchor" href="#扫描和token"></a>扫描和token</h3>
<ol>
<li>扫描得到一个<strong>lexeme</strong>，将词素加上记号构成一个<strong>token</strong>。有些<strong>token</strong>只有<strong>token-name</strong>而没有<strong>token-attribute</strong>，例如保留关键字<strong>while</strong>：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240860.png" alt="image-20240312170715066" style="zoom: 50%;" /></li>
<li>扫描过程中，空格虽然算作一个词素，但并不将之存储，因为没有意义</li>
<li>某些<strong>token</strong>含有属性<strong>attribute</strong>，用于存储关于这个<strong>token</strong>额外的信息，例如一个数123，则会存储为：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240675.png" alt="image-20240312170546745" style="zoom:33%;" /></li>
</ol>
<h3 id="正则表达式"><a class="header-anchor" href="#正则表达式"></a>正则表达式</h3>
<blockquote>
<p>正则表达式可以由较小的正则表达式按照规则递归构建：</p>
<ul>
<li>每个正则表达式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>标识一个语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> ，这个语言也是根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>的子表达式所表示的语言递归定义的。</li>
</ul>
</blockquote>
<h4 id="归纳基础"><a class="header-anchor" href="#归纳基础"></a>归纳基础</h4>
<p>给定字符集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>c</mi><mi>n</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\Sigma = {c_1,c_2,...c_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>；</p>
<ol>
<li>空串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>是正则表达式；若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>ϵ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">L(\epsilon) = {\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">ϵ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span></span></span>，则该语言只包含空串；</li>
<li>对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">c \in \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>​是正则表达式</li>
</ol>
<h4 id="归纳步骤"><a class="header-anchor" href="#归纳步骤"></a>归纳步骤</h4>
<p>由小的正则表达式构造大的正则表达式有四种方式，假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>都是正则表达式，分别表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>，则有：</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r)|(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>是一个正则表达式，表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r) \cup L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>；</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r)(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>是一个正则表达式，表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r)L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>；</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(r)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>是一个正则表达式，表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(L(r))^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>；</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>是一个正则表达式，表示语言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>。</p>
</li>
</ol>
<p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是正则表达式，则具有以下归纳关系：</p>
<ol>
<li>选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">∣</mi><mi>N</mi><mo>=</mo><mrow><mi>M</mi><mo>∪</mo><mi>N</mi></mrow></mrow><annotation encoding="application/x-tex">M|N = {M \cup N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></li>
<li>连接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mo>=</mo><mrow><mi>m</mi><mi>n</mi><mi mathvariant="normal">∣</mi><mi>m</mi><mo>∈</mo><mi>M</mi><mo separator="true">,</mo><mi>n</mi><mo>∈</mo><mi>N</mi></mrow></mrow><annotation encoding="application/x-tex">MN = {mn|m \in M,n \in N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">MN</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">mn</span><span class="mord">∣</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></li>
<li>闭包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>=</mo><mrow><mi>ε</mi><mo separator="true">,</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mi>M</mi><mi>M</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mrow><annotation encoding="application/x-tex">M^{*} = {\varepsilon,M,MM,MMM,...}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">ε</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">MM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">MMM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span></span></span></span></span></li>
</ol>
<h4 id="规定正则表达式优先级"><a class="header-anchor" href="#规定正则表达式优先级"></a>规定正则表达式优先级</h4>
<ol>
<li>一元运算符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>具有最高的优先级，并且是左结合；</li>
<li>连接具有次高的优先级，是左结合；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span></span></span></span>​ 的优先级最低，是左结合;</li>
<li>例如,我们可以根据这个约定将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>b</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a)|(~(b*(c)~)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace nobreak"> </span><span class="mclose">)</span></span></span></span>改写为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">∣</mi><msup><mi>b</mi><mo>∗</mo></msup><mi>c</mi></mrow><annotation encoding="application/x-tex">a|b^*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">c</span></span></span></span>。</li>
</ol>
<h4 id="正则表达式代数定律"><a class="header-anchor" href="#正则表达式代数定律"></a>正则表达式代数定律</h4>
<table>
<thead>
<tr>
<th style="text-align:left">定律</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$r</td>
<td style="text-align:left">s=s</td>
</tr>
<tr>
<td style="text-align:left">$r</td>
<td style="text-align:left">(s</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">r(st)=(rs)t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mord mathnormal">t</span></span></span></span></td>
<td style="text-align:left">连接是可结合的</td>
</tr>
<tr>
<td style="text-align:left">$r(s</td>
<td style="text-align:left">t)=rs</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mi>r</mi><mo>=</mo><mi>r</mi><mi>ϵ</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">\epsilon r=r\epsilon=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">ϵr</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">rϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>是连接的单位元</td>
</tr>
<tr>
<td style="text-align:left">$r^*=(r</td>
<td style="text-align:left">\epsilon)^*$</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∗</mo><mo>∗</mo><mo>=</mo><mi>r</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">r**=r*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">∗</span></span></span></span></td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>具有幂等性</td>
</tr>
</tbody>
</table>
<h4 id="正则表达式拓展"><a class="header-anchor" href="#正则表达式拓展"></a>正则表达式拓展</h4>
<ol>
<li>
<p>至少一个实例：单目运算符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span>表示以一个正则表达式的正闭包。</p>
</li>
<li>
<p>0个或1个实例：单目运算符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose">?</span></span></span></span>表示“0个或一个实例</p>
</li>
<li>
<p>字符类：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_1 a_2 ... a_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_1 a_2 ... a_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>形成一个逻辑上连续的序列，如连续的大写字母、小写字母或数位时：表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1 -a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，只写出序列的首尾符号，中间连词符隔开。如：[a-z]表示26个小写字母。</p>
</li>
<li>
<p>Lex的正则表达式</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240451.png" alt="image-20240317200417333"></p>
</li>
</ol>
<h3 id="词法单元的识别"><a class="header-anchor" href="#词法单元的识别"></a>词法单元的识别</h3>
<blockquote>
<p>用正则表达式来表示一个模式，用模式来匹配词素</p>
</blockquote>
<ul>
<li>让词法分析器消除空白符
<ul>
<li>方法：让词法分析器去识别：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>s</mi><mo>→</mo><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>k</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">ws \rightarrow (blank|tab|newline)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">ank</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord">∣</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">wl</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li>
<li>blank、tab及newline是用于表示具有同样名字的ASCII字符的抽象符号。</li>
<li>当我们识别到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ws</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span></span></span></span>时,我们并不将它返回给语法分析器,而是从这个空白之后的字符开始继续进行词法分析。返回给语法分析器的是下一个词法单元。</li>
</ul>
</li>
</ul>
<h4 id="状态转移图"><a class="header-anchor" href="#状态转移图"></a>状态转移图</h4>
<blockquote>
<p>将模式转换成具有特定风格的流图</p>
</blockquote>
<p><strong>重要约定</strong>：</p>
<ul>
<li>某些状态定义为接受状态或最终状态。双圈表示接受状态
<ul>
<li>接受状态可执行的动作：向语法分析器返回一个词法单元和相关属性值</li>
</ul>
</li>
<li>如果需要forward回退一个位置（即相应词素并不包括那个在最后一部使我们到达接受状态的符号）则将在该接受状态的附近加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>​。</li>
<li>有一个状态指定为开始状态&amp;初始状态，该状态由一条没有出发结点的、标号为“start”的边指明。在读入任何输入符号之前，状态转换图总是位于它的开始状态。</li>
</ul>
<h4 id="保留字和标识符的识别"><a class="header-anchor" href="#保留字和标识符的识别"></a>保留字和标识符的识别</h4>
<h5 id="两种处理看起来很像标识符的保留字："><a class="header-anchor" href="#两种处理看起来很像标识符的保留字："></a>两种处理看起来很像标识符的保留字：</h5>
<ul>
<li>
<p>初始化时就将各个保留字填入符号表中。</p>
<ul>
<li>任何词法分析时不在符号表中的标识符都不可能是一个保留字</li>
<li></li>
</ul>
</li>
<li>
<p>为每个关键字建立单独的状态转换图。</p>
<ul>
<li>
<p>以then为例：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011240322.png" alt="image-20240317215751827" style="zoom:67%;" />
</li>
<li>
<p>这样的状态转换图包含的状态表示看到该关键字的各个后续字母后的情况,最后是一个“非字母或数字”的测试,也就是检查后面是否为某个不可能成为标识符一部分的字符。</p>
</li>
<li>
<p>如果采用这个方法,我们必须设定词法单元之间的优先级,使得当一个词素同时匹配id的模式和关键字的模式时,优先识别保留字词法单元,而不是id词法单元。</p>
</li>
</ul>
</li>
</ul>
<p>词法规则是一个Patamer集合，会有许许多多种正则表达式，许许多多种模式去匹配。</p>
<h4 id="冲突解决两种经典方案"><a class="header-anchor" href="#冲突解决两种经典方案"></a>冲突解决两种经典方案</h4>
<ul>
<li>
<p>最长子串原则：</p>
<ul>
<li>自动机：用新的匹配得到的token去替换已经匹配到的token，进入<code>last-match</code>，当所有模式都卡住时返回<code>last-match</code>。</li>
</ul>
</li>
<li>
<p>优先级规则：如果最长的可能前缀与多个模式匹配，选择优先级高的进行匹配。</p>
</li>
</ul>
<h3 id="有限状态自动机"><a class="header-anchor" href="#有限状态自动机"></a>有限状态自动机</h3>
<blockquote>
<p>字符流转换为token的核心是有穷自动机。</p>
</blockquote>
<ul>
<li>有穷自动机是识别器 recognizer，只能对每个可能输入串简单地回答“是&amp;否”。</li>
<li>分类：
<ul>
<li>不确定的有穷自动机 NFA</li>
<li>确定的有穷自动机 DFA</li>
</ul>
</li>
<li>两种自动机能识别的语言集合是一样的，这些语言的集合正好是正则表达式描述的语言的集合————正则语言(RE，regular language)</li>
</ul>
<h4 id="NFA-不确定的自动机"><a class="header-anchor" href="#NFA-不确定的自动机"></a>NFA 不确定的自动机</h4>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Σ,S,T,S_0,{S_n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>符号集，有穷的状态集合，变迁函数，开始状态，接受状态集</p>
</blockquote>
<p>一个不确定的有穷自动机(NFA)由以下几个部分组成:</p>
<ul>
<li>一个有穷的状态集合S。</li>
<li>一个输入符号集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>,即输入字母表(input alphabet)。我们假设代表空串的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>中的元素。</li>
<li>一个转换函数(transition function),它为每个状态和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>∪</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">Σ∪{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span></span></span>​中的每个符号都给出了相应的后继状态(next state)的集合。</li>
<li>S中的一个状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>被指定为开始状态,或者说初始状态。</li>
<li>S的一个子集F被指定为接受状态(或者说终止状态的)集合。</li>
</ul>
<p>将自动机表示为一张转换图：</p>
<blockquote>
<p>图中的结点是状态，带有标号的边表示自动机的转换函数</p>
</blockquote>
<ol>
<li>同一个符号可以标记从同一状态出发到达多个目标状态的多条边</li>
<li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>。</li>
</ol>
<h4 id="自动机中输入字符串的接受"><a class="header-anchor" href="#自动机中输入字符串的接受"></a>自动机中输入字符串的接受</h4>
<ul>
<li>一个NFA accpet输入字符串xx，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径，使该路径中各条边上的标号组成符号串x。</li>
<li>路径中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>标号将被忽略，因为<strong>空串不影响根据路径得到的字符串</strong></li>
</ul>
<p>由一个NFA定义(或接受)的语言是从开始状态到某个接受状态的所有路径上的标号串的集合。</p>
<h3 id="DFA-确定的有穷自动机"><a class="header-anchor" href="#DFA-确定的有穷自动机"></a>DFA 确定的有穷自动机</h3>
<ol>
<li>没有输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>变迁</li>
<li>一个不会变迁到多个状态：每个状态s和每个输入符号a，有且只有一条标号为a的边离开s。</li>
</ol>
<h3 id="RE转换成NFA：Thompson算法"><a class="header-anchor" href="#RE转换成NFA：Thompson算法"></a>RE转换成NFA：Thompson算法</h3>
<blockquote>
<p>只有一个开始状态&amp;接受状态；</p>
</blockquote>
<p><strong>算法转换步骤</strong>：</p>
<ol>
<li>增加开始状态</li>
<li>增加接受状态</li>
<li>将原来的开始和接受状态转换为中间状态</li>
<li>用空变迁来连接开始状态和接受状态到中间状态的变迁</li>
</ol>
<h3 id="NFA转换成DFA：子集构造算法"><a class="header-anchor" href="#NFA转换成DFA：子集构造算法"></a>NFA转换成DFA：子集构造算法</h3>
<h4 id="NFA和DFA的区别"><a class="header-anchor" href="#NFA和DFA的区别"></a>NFA和DFA的区别</h4>
<ol>
<li>空变迁</li>
<li>多重变迁</li>
</ol>
<h4 id="子集构造算法"><a class="header-anchor" href="#子集构造算法"></a>子集构造算法</h4>
<blockquote>
<p>思想核心是——讲构造得到的DFA的每个状态去对应原来NFA的一个状态集合。</p>
<p>NFA和DFA的状态数量大致相同</p>
</blockquote>
<h4 id="在NFA状态集上的操作"><a class="header-anchor" href="#在NFA状态集上的操作"></a>在NFA状态集上的操作</h4>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varepsilon-closure(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">os</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:left">能够从NFA的状态s开始只通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>转换到达的NFA状态集合</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varepsilon-closure(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">os</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:left">能够从T中某个NFA状态s开始，只通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>转换到达的NFA状态集合，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∪</mo><mrow><mi>s</mi><mo>∈</mo><mi>T</mi></mrow></msub><mi>ε</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cup _{s\in T}\varepsilon-closure(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7607em;vertical-align:-0.1774em;"></span><span class="mord"><span class="mbin">∪</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">os</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">move(T,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:left">能够从T中某个状态s出发通过标号为a的转换到达的NFA状态集合</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>是为了消除以上NFA和DFA的区别</p>
</li>
<li>
<p>子集构造法将多重变迁的多种状态构成一个集合，然后让同一个输入由原来的<strong>变迁到多种状态</strong>变成现在的<strong>变迁到同一个状态集合</strong>。</p>
<p>在得到等价状态集合的时候需要消除空变迁，即所有由空变迁可达的状态都是等价状态集合的元素。</p>
<p>将开始状态可达的状态包含入一个状态集合中，然后用其中一个集合符号进行代表。</p>
</li>
<li>
<p>构造结束：当DFA的状态表不在产生新的元素的改变，即集合不在因为输入而改变，</p>
<ol>
<li>需要求一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span>闭包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\varepsilon-closure(I) = I \cup \Sigma S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">os</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li>
<li>则会停止NFA到DFA的转换，得到了最简子集。</li>
</ol>
</li>
</ol>
<h3 id="DFA的最小化：Hopcroft算法"><a class="header-anchor" href="#DFA的最小化：Hopcroft算法"></a>DFA的最小化：Hopcroft算法</h3>
<p>简化DFA，将构建出的DFA最小化</p>
<ol>
<li>将同类型的n个会转化到等价状态的状态进行等价合并（若A是中间状态，但B是接受状态，则A和B不可以合并）</li>
</ol>
<h4 id="等价状态"><a class="header-anchor" href="#等价状态"></a>等价状态</h4>
<p>等价标准：</p>
<ul>
<li>s和t都是接受状态或都是非接受状态</li>
</ul>
<p>树的数据结构可以用来表达嵌套结构。</p>
<h3 id="从DFA生成分析算法"><a class="header-anchor" href="#从DFA生成分析算法"></a>从DFA生成分析算法</h3>
<h2 id="CH3-语法分析-Part-I"><a class="header-anchor" href="#CH3-语法分析-Part-I"></a>CH3: 语法分析(Part I)</h2>
<p><a href="https://zhuanlan.zhihu.com/p/501849448">学生角度————编译原理-语法分析详解</a></p>
<blockquote>
<p>语法分析器从词法分析器得到一个由token组成的token序列，并验证这个token串可以由源语言的文法生成。</p>
<p><img src="D:%5CDeskTable%5C%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE%E4%BC%A0%E8%BE%93%5Cimage-20240319141414360.png" alt="image-20240319141414360"></p>
<p>词法分析阶段处理了多个字符组成的构造，如标识符；</p>
<p>语法分析阶段因为词法分析已经完成了字符的token化，所以可以把原本由多个字符组成的标识符当作<strong>单元</strong>进行处理。</p>
</blockquote>
<h3 id="语法分析的任务"><a class="header-anchor" href="#语法分析的任务"></a>语法分析的任务</h3>
<ol>
<li>
<p>还原token序列所描述的语法结构；</p>
<p>Recover the structure described by that series of tokens.</p>
</li>
<li>
<p>对token序列构成的不符合文法要求的结构进行报错</p>
<p>Report errors if those tokens do not properly encode a structure.</p>
</li>
</ol>
<h4 id="语法分析器分为三类："><a class="header-anchor" href="#语法分析器分为三类："></a>语法分析器分为三类：</h4>
<ol>
<li>通用的</li>
<li>自顶向下的</li>
<li>自底向上的</li>
</ol>
<h3 id="上下文无关文法和推导"><a class="header-anchor" href="#上下文无关文法和推导"></a>上下文无关文法和推导</h3>
<blockquote>
<p>上下文无关文法——简称“文法”。</p>
</blockquote>
<p>Derivation————得到上下文无关法</p>
<h4 id="组成"><a class="header-anchor" href="#组成"></a>组成</h4>
<ul>
<li>
<p>一个终结符号集合(也称“词法单元”)：终结符号是该文法所定义的语言的基本符号的集合。</p>
</li>
<li>
<p>一个非终结符号集合(也称“语法变量”)：每个非终结符号表示一个终结符号串的集合。</p>
</li>
<li>
<p>一个产生式集合：主要用来表示某个构造的某种书写形式，其中每个产生式包括：</p>
<ul>
<li>一个称为产生式头或左部的非终结符号；</li>
<li>一个箭头；</li>
<li>一个称为产生式体或右部的由终结符号及非终结符号组成的序列。</li>
</ul>
<p>如果产生式头非终结符号代表一个构造，那么该产生式体就代表该构造的一种书写方式。</p>
</li>
<li>
<p>指定一个非终结符号为开始符号。</p>
</li>
</ul>
<h3 id="分析树和二义性文法"><a class="header-anchor" href="#分析树和二义性文法"></a>分析树和二义性文法</h3>
<h3 id="自顶向下分析"><a class="header-anchor" href="#自顶向下分析"></a>自顶向下分析</h3>
<p>LR(0)</p>
<p>LR(1)</p>
<p>SLR(1)</p>
<p>LALR(1)</p>
<h3 id="递归下降分析算法"><a class="header-anchor" href="#递归下降分析算法"></a>递归下降分析算法</h3>
<h2 id="CH5-语法分析-Part-II"><a class="header-anchor" href="#CH5-语法分析-Part-II"></a>CH5: 语法分析(Part II)</h2>
<h3 id="LL-1-分析算法"><a class="header-anchor" href="#LL-1-分析算法"></a>LL(1)分析算法</h3>
<h3 id="LL-1-分析的冲突处理"><a class="header-anchor" href="#LL-1-分析的冲突处理"></a>LL(1)分析的冲突处理</h3>
<h3 id="LR-0-分析算法"><a class="header-anchor" href="#LR-0-分析算法"></a>LR(0)分析算法</h3>
<h3 id="SLR分析算法"><a class="header-anchor" href="#SLR分析算法"></a>SLR分析算法</h3>
<h3 id="LR-1-分析算法"><a class="header-anchor" href="#LR-1-分析算法"></a>LR(1)分析算法</h3>
<h3 id="LR-1-分析工具"><a class="header-anchor" href="#LR-1-分析工具"></a>LR(1)分析工具</h3>
<p>采取管道过滤器的架构</p>
<p>源代码input – 词法分析器lexical Analysis – output token序列（存储于符号表）input – 语法分析器 syntax Analysis – output 语法树 input – 语义分析器（理解语句的意思）— 带注解的语法树</p>
<p>语义分析：</p>
<ol>
<li>从类型检测开始。</li>
<li></li>
</ol>
<p>语法指导的翻译SDD<br>
符号表是一个使用hash table的表 便于查询和搜索 核心是search<br>
语法和词法分析是 类型检查</p>
<p>TAC three address code 三地址码拓展<br>
中间代码：为了方便优化代码，方便计算上的优化。采取优化方法。<br>
中间代码的翻译称为与机器无关的翻译<br>
生成代码称为与机器有关的翻译</p>
<p>语法分析的目的：<br>
分词，token抽取<br>
基于词法规则来进行分词<br>
词法规则的描述：正则表达式 Regular expression</p>
<ol>
<li>检查词法错误，使用的token是否正确；</li>
<li></li>
</ol>
<p>原子正则表达式<br>
a和空串<br>
递归的方式</p>
<p>复合复杂的正则表达式<br>
4种操作</p>
<ol>
<li>R1 R2 的串</li>
<li>R1 union R2 并集</li>
<li>R*</li>
<li>括号()区分union集使用</li>
</ol>
<p>patern————使用正则表达式 RE表示&amp;自动机 FA</p>
<p>自动机，FA：过于复杂，难以理解，机器易于阅读，刻画算法过程。对算法动态转移的直观展示，转移的过程也是翻译的问题。<br>
正则表达式 RE：易于理解，人易于阅读，对规则的静态描述。</p>
<p>正则表达式+自动tb机，融合优点。<br>
正则表达式容易地转换为自动机</p>
<p>如何将RE转换问DFA</p>
<p>Scanner program generator<br>
输入正则表达式集合<br>
输出Scanner code<br>
flex 词法生成器<br>
bis语法生成器</p>
<p>tb</p>
]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h1>
<h2 id="一、引言"><a class="header-anchor" href="#一、引言"></a>一、引言</h2>
<h3 id="数据结构三要素"><a class="header-anchor" href="#数据结构三要素"></a>数据结构三要素:</h3>
<ol>
<li>
<p>逻辑结构</p>
</li>
<li>
<p>存储结构（物理结构）</p>
</li>
<li>
<p>具体的运算，即包含基础操作：数据的访问、添加、删除、更新</p>
</li>
</ol>
<h3 id="为什么要有数据结构"><a class="header-anchor" href="#为什么要有数据结构"></a>为什么要有数据结构:</h3>
<p>数据结构的提出是为了满足实际生产需求当作遇到的数据存储空间的分配问题,良好的空间分配方式可以提高程序的效率,降低成本,提高产能,因而数据结构并不高深,取之于生活再用之于生活。</p>
<h2 id="二、线性数据结构"><a class="header-anchor" href="#二、线性数据结构"></a>二、线性数据结构</h2>
<h3 id="数组-Array"><a class="header-anchor" href="#数组-Array"></a>数组(Array)</h3>
<h4 id="特点"><a class="header-anchor" href="#特点"></a>特点</h4>
<ul>
<li>数组内元素具有相同的类型</li>
<li>每个元素对应一个唯一的索引，可以通过索引对数组内元素进行操作</li>
<li>数组大小在创建时固定，因而数组长度和元素个数可知</li>
<li>在内存中连续存储，可以进行高效的随机访问——通过索引直接访问</li>
<li></li>
</ul>
<h3 id="链表-Linked-List"><a class="header-anchor" href="#链表-Linked-List"></a>链表(Linked List)</h3>
<h3 id="栈-Stack"><a class="header-anchor" href="#栈-Stack"></a>栈(Stack)</h3>
<p>用顺序表进行模拟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] elem;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">usedSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.elem = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">this</span>.usedSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usedSize == <span class="built_in">this</span>.elem.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//栈满则扩容</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="built_in">this</span>.elem = Arrays.copyOf(elem,<span class="number">2</span>*<span class="built_in">this</span>.elem.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.elem[<span class="built_in">this</span>.usedSize] = val;</span><br><span class="line">        usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.usedSize==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="built_in">this</span>.elem[usedSize-<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.usedSize--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>((<span class="string">&quot;栈为空！&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elem[usedSize-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列-Queue"><a class="header-anchor" href="#队列-Queue"></a>队列(Queue)</h3>
<h3 id="线性-哈希表-Hash"><a class="header-anchor" href="#线性-哈希表-Hash"></a>(线性)哈希表(Hash)</h3>
<h4 id="Hash概念引入"><a class="header-anchor" href="#Hash概念引入"></a>Hash概念引入</h4>
<p>本质很简单，即通过一个函数，实现 键<strong>key</strong>和值<strong>value</strong>的映射,实现高效的元素查询.即向哈希表输入<strong>key</strong>,即可在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内获取对应的<strong>value</strong>.</p>
<p>可联想: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>学号</mtext><munderover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>Hash Function</mtext></mpadded><mpadded width="+0.6em" lspace="0.3em"><mtext>哈希函数</mtext></mpadded></munderover><mtext>姓名</mtext></mrow><annotation encoding="application/x-tex">学号 \xrightarrow[\text{Hash Function}]{\text{哈希函数}} 姓名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7084em;vertical-align:-0.6081em;"></span><span class="mord cjk_fallback">学号</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">哈希函数</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span><span style="top:-2.0919em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Hash Function</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6081em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">姓名</span></span></span></span></p>
<p>哈希表的增删查改四大基础操作时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h4 id="Hash的简单实现"><a class="header-anchor" href="#Hash的简单实现"></a>Hash的简单实现</h4>
<p>先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为「桶Bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。</p>
<p>是通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>「哈希函数</mtext><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>F</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext>」</mtext></mrow><annotation encoding="application/x-tex">「哈希函数 Hash Function」</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback">「哈希函数</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">」</span></span></span></span> 实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <strong>key</strong> ，输出空间是所有桶（<em>index</em>）。换句话说，输入一个<strong>key</strong>，我们可以通过哈希函数得到该 <strong>key</strong> 对应的键值对在数组中的存储位置。</p>
<p>输入一个<strong>key</strong> ，哈希函数计算过程:</p>
<ol>
<li>通过某种哈希算法 hash() 计算得到哈希值。</li>
<li>将哈希值对桶数量（数组长度）<strong>capacity</strong> 取模，从而获取该 <strong>key</strong> 对应的数组索引 <strong>index</strong>。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">index = hash(key) % capacity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span></span></span></span></li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246595.png" alt="image-20231013000021119" style="zoom: 80%;" />
<h4 id="哈希冲突"><a class="header-anchor" href="#哈希冲突"></a>哈希冲突</h4>
<p>本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在<strong>多个输入对应相同输出</strong>的情况。而这种<strong>多对一</strong>的情况即被称为哈希冲突。</p>
<h4 id="链式地址法"><a class="header-anchor" href="#链式地址法"></a>链式地址法</h4>
<p>为解决哈希冲突的第一种方法——「链式地址 Separate Chaining」，原理即是：单元格转换为链表，将生成的键值对当作链表节点，将所有发生冲突的键值对都存储在同一链表中。</p>
<ul>
<li>局限性:</li>
<li>空间开销较大</li>
<li>查询效果随着数据量的增大以及哈希冲突现象的出现频率的增多而逐渐降低,设想当有N个值对应同一个键时,此时在该节点上哈希表退化为了链表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key 则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key 则返回 nullptr</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id=""><a class="header-anchor" href="#"></a></h4>
<h2 id="三、非线性结构"><a class="header-anchor" href="#三、非线性结构"></a>三、非线性结构</h2>
<h1 align = center > 树 </h1>
<h3 id="树"><a class="header-anchor" href="#树"></a>树</h3>
<p>（Tree）</p>
<p>树（Tree）是一种常见的数据结构，它具有分层结构，类似于自然界中的树，由节点（Node）和边（Edge）组成。<code>每个树结构都包括一个根节点</code>，该节点没有父节点，而其他节点通过边与根节点和其他节点相连。</p>
<p>树可以被称为递归数据结构</p>
<p>树结构有许多不同的应用，包括计算机科学中的数据存储、搜索、排序以及层次性组织等。</p>
<h4 id="树结构中的常见的术语和特性"><a class="header-anchor" href="#树结构中的常见的术语和特性"></a>树结构中的常见的术语和特性</h4>
<ol>
<li><strong>根节点（Root）</strong>：树结构的顶部节点，<strong>没有父节点</strong>，它是树的起始点。</li>
<li><strong>子节点（Child）</strong>：树中的每个节点可以有<strong>零个或多个</strong>子节点，子节点是其父节点的直接下级节点。</li>
<li><strong>父节点（Parent）</strong>：每个节点<strong>除了根节点</strong>外，都有一个父节点，它是其子节点的直接上级节点。</li>
<li><strong>叶子节点（Leaf）</strong>：<strong>没有子节点</strong>的节点称为叶子节点，它们位于树结构的末端 。</li>
<li><strong>兄弟节点（Sibling）</strong>：<strong>具有相同父节点</strong>的节点称为兄弟节点。</li>
<li><strong>节点的度</strong>：一个节点包含的子树的个数即为该节点的度</li>
<li><strong>树的度</strong>：所有节点的度当中的最大值</li>
<li><strong>节点的层次</strong>：根节点层次为1，以此递增</li>
<li><strong>深度（Depth）</strong>：从根节点到某个节点的路径上的边数称为该节点的深度。根节点的深度为0。</li>
<li><strong>高度（Height）</strong>：树结构中任意节点的最长路径（边数）称为树的高度。树的高度通常以根节点为参考。</li>
<li><strong>子树（Subtree）</strong>：树中的任何节点和其所有后代节点（包括该节点本身）构成的子树。</li>
<li><strong>有向边（Directed Edge）</strong>：连接两个节点的边<strong>具有方向</strong>，从一个节点指向另一个节点。</li>
</ol>
<h4 id="常见的树类型"><a class="header-anchor" href="#常见的树类型"></a>常见的树类型</h4>
<ol>
<li>
<p><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，左子节点和右子节点。</p>
</li>
<li>
<p><strong>二叉搜索树（Binary Search Tree）</strong>：二叉树的一种，具有特定的排序规则，左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</p>
</li>
<li>
<p><strong>平衡二叉树（Balanced Binary Tree）</strong>：一种二叉搜索树，具有平衡性质，确保树的高度较低，提高了搜索等操作的效率。</p>
</li>
<li>
<p><strong>B树和B+树</strong>：用于在磁盘上高效存储和检索数据的树状数据结构，常见于数据库管理系统中。</p>
</li>
<li>
<p><strong>树堆（Heap）</strong>：一种特殊的树结构，用于高效查找和删除最大或最小值的元素，通常用于堆排序和优先队列。</p>
</li>
<li>
<p><strong>树结构的图形表示</strong>：树结构通常可以以树状图的方式进行可视化表示，根节点在顶部，子节点向下延伸。</p>
</li>
</ol>
<p>树结构是计算机科学中的重要数据结构之一，它们用于解决各种问题，包括数据存储、搜索、排序、编译器中的语法分析、操作系统中的文件系统等等。了解树结构的基本概念和特性对于编写高效的算法和解决问题非常重要。</p>
<h4 id="树的遍历操作："><a class="header-anchor" href="#树的遍历操作："></a>树的遍历操作：</h4>
<h5 id="先根遍历"><a class="header-anchor" href="#先根遍历"></a>先根遍历</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">visit</span>(R);</span><br><span class="line">		<span class="keyword">while</span>(!R-&gt;next)&#123;</span><br><span class="line">			<span class="built_in">preOrder</span>(R-&gt;next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后根遍历"><a class="header-anchor" href="#后根遍历"></a>后根遍历</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!R)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!R-&gt;next)&#123;</span><br><span class="line">			<span class="built_in">postOrder</span>(R-&gt;next);</span><br><span class="line">			<span class="built_in">visit</span>(R);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历"><a class="header-anchor" href="#层序遍历"></a>层序遍历</h5>
<p>当前根节点R入队，R出队时将R所有的子节点入队，而后每出队一个一个节点，就入队该节点的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void </span><br></pre></td></tr></table></figure>
<h4 id="二叉树"><a class="header-anchor" href="#二叉树"></a>二叉树</h4>
<p>树中的许多操作的时间开销取决于树的高度，因此总希望二叉树的高度尽可能的小</p>
<h5 id="二叉树的三种遍历："><a class="header-anchor" href="#二叉树的三种遍历："></a>二叉树的三种遍历：</h5>
<ul>
<li>前序遍历——先后访问根节点、左子树、右子树</li>
<li>中序遍历——先后访问左子树、根节点、右子树</li>
<li>后序遍历——先后访问左子树、右子树、根节点</li>
</ul>
<p>三序的遍历有更加直观易记的方法 <a href="https://www.bilibili.com/video/BV1Ub4y147Zv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">无脑画点连线法，一学就会</a> 作者：<a href="https://space.bilibili.com/446171901">阿琛w</a></p>
<p>具体思路：</p>
<p>对于任意一颗树而言，前序遍历的形式总是<br>
[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>
即根节点总是前序遍历中的第一个节点。</p>
<p>而中序遍历的形式总是<br>
[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
<p>已知其中xx和xx序，推测第三种yy序：</p>
<p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。</p>
<p>由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>细节</p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p>
<hr>
<p>版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a href="https://blog.csdn.net/qq_43762191/article/details/107280503">种树：二叉树、二叉搜索树、AVL树、红黑树、哈夫曼树、B树、树与森林</a></p>
<hr>
<p>作者：LeetCode-Solution<br>
原文链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树</a></p>
<h4 id="完整二叉树"><a class="header-anchor" href="#完整二叉树"></a>完整二叉树</h4>
<p>（Complete Binary Tree）</p>
<p>完整二叉树（Complete Binary Tree）是一种二叉树，其中每一层都被完全填充，<strong>除了最后一层</strong>可能不是满的，但是最后一层的所有节点都<strong>集中在该层的左侧</strong>。</p>
<h5 id="特点："><a class="header-anchor" href="#特点："></a>特点：</h5>
<ol>
<li>所有叶子节点都出现在最后一层或倒数第二层。</li>
<li>如果有子节点，每个节点都有两个子节点。</li>
<li>最后一层的节点都尽可能地靠左排列。</li>
</ol>
<h5 id="图示"><a class="header-anchor" href="#图示"></a>图示</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line">/   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>
<h4 id="完美二叉树"><a class="header-anchor" href="#完美二叉树"></a>完美二叉树</h4>
<p>（Perfect Binary Tree）</p>
<p>完美二叉树（Perfect Binary Tree），也被称为满二叉树（Full Binary Tree），是一种特殊类型的二叉树</p>
<h5 id="特点：-v2"><a class="header-anchor" href="#特点：-v2"></a>特点：</h5>
<ol>
<li>每个非叶子节点都有两个子节点。</li>
<li>所有叶子节点都在同一层级上，也就是说，树的<strong>所有层级都被完全填充</strong>。</li>
</ol>
<p>这意味着在完美二叉树中，每一层都包含最大数量的节点，即每一层的节点数都是2的幂次方。完美二叉树的高度（深度）通常由叶子节点的层级决定，如果有h层，则叶子节点位于第h层，树的高度为h。</p>
<h5 id="图示-v2"><a class="header-anchor" href="#图示-v2"></a>图示</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树"><a class="header-anchor" href="#二叉搜索树"></a>二叉搜索树</h4>
<p>（Binary Search Tree，BST）</p>
<p>二叉搜索树（Binary Search Tree，BST）是一种二叉树的特殊形式。</p>
<h5 id="特点-v2"><a class="header-anchor" href="#特点-v2"></a>特点</h5>
<ol>
<li>每个节点都包含一个值（通常是一个可比较的值），并且这些值按照特定的顺序排列。</li>
<li>对于每个节点：
<ul>
<li>所有左子树中的节点的值都小于该节点的值。</li>
<li>所有右子树中的节点的值都大于该节点的值。</li>
<li>左右子树都是二叉搜索树。</li>
<li>每个节点的左右子树也是BST</li>
</ul>
</li>
<li>左子树的每一个节点的键值一定小于右子树每一个节点的键值（即右子树最小的键值）</li>
</ol>
<p>这个特性使得二叉搜索树非常适合进行快速的搜索、插入和删除操作，因为它充分利用了值的相对大小来构建树结构。如果树的结构是平衡的，搜索、插入和删除操作的时间复杂度通常为O(log n)，其中n是树中节点的数量。</p>
<h5 id="图示-v3"><a class="header-anchor" href="#图示-v3"></a>图示</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \ / \</span><br><span class="line">1  4 7  9</span><br></pre></td></tr></table></figure>
<h5 id="Tips"><a class="header-anchor" href="#Tips"></a>Tips</h5>
<p>需要注意的是，如果二叉搜索树的<strong>结构不平衡</strong>，即左子树和右子树的高度差异很大，搜索操作的性能可能会退化到O(n)，其中n是树中节点的数量。在极限情况下可能退化成链表（重新变成线性结构）</p>
<h5 id="BST常见操作："><a class="header-anchor" href="#BST常见操作："></a>BST常见操作：</h5>
<h6 id="1、查找（搜索）："><a class="header-anchor" href="#1、查找（搜索）："></a>1、查找（搜索）：</h6>
<p>采取递归式搜索：</p>
<ol>
<li>value &lt; root，则向根节点左侧向下搜索</li>
<li>value &gt; root，则向根节点右侧向下搜索</li>
<li>当root为空或==value时，直接返回为空或者返回根节点的值</li>
</ol>
<h6 id="2、插入："><a class="header-anchor" href="#2、插入："></a>2、插入：</h6>
<p>新元素进入后，遇到大于的键值val的向左走，小于键值val的向右走，一直到尾端</p>
<h6 id="3、删除："><a class="header-anchor" href="#3、删除："></a>3、删除：</h6>
<p>假设删除A节点</p>
<ol>
<li>A的度为0（叶节点）：直接移除A</li>
<li>A的度为1：A节点的节点直接补上</li>
<li>A的度为2：将A节点右子树键值最小的节点补上</li>
</ol>
<h5 id="代码模拟"><a class="header-anchor" href="#代码模拟"></a>代码模拟</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建每一个树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//节点存储的数据</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每个节点带有一个左孩子节点和一个右孩子节点</span></span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数初始化</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//创建二叉搜索树的根节点</span></span><br><span class="line">	TreeNode* root;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//递归插入新节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">insertRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//节点的初始化</span></span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">insertRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">insertRecursive</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归查询节点</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">findRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val == current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursive</span>(current-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归删除节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">removeRecursive</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">removeRecursive</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursive</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (current-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* tmp = current-&gt;right;</span><br><span class="line">				<span class="keyword">delete</span> current;</span><br><span class="line">				<span class="keyword">return</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* tmp = current-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> current;</span><br><span class="line">				<span class="keyword">return</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			TreeNode* tmp = <span class="built_in">findMin</span>(current-&gt;right);</span><br><span class="line">			current-&gt;value = tmp-&gt;value;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursive</span>(current-&gt;right, tmp-&gt;value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找子树的最小节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			current = current-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;right);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数进行成员变量初始化</span></span><br><span class="line">	<span class="built_in">BinarySearchTree</span>():<span class="built_in">root</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数释放内存空间</span></span><br><span class="line">	~<span class="built_in">BinarySearchTree</span>() &#123;</span><br><span class="line">		<span class="built_in">clearTree</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">insertRecursive</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">removeRecursive</span>(root, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找函数的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursive</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历的外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//树空间释放函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearTree</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;right);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="线索二叉搜索树"><a class="header-anchor" href="#线索二叉搜索树"></a>线索二叉搜索树</h4>
<p>在原来二叉树的基础上引入前驱和后继的概念，使得原来以树状逻辑排放的元素重新以线性逻辑排放。</p>
<p>存在一定问题，即某些节点的右节点即是其后继，或者其左节点即是其前驱</p>
<h4 id="平衡二叉树"><a class="header-anchor" href="#平衡二叉树"></a>平衡二叉树</h4>
<p>（Balanced Binary Tree）</p>
<p>平衡二叉树（Balanced Binary Tree），也称为平衡二叉搜索树（Balanced Binary Search Tree），是一种特殊类型的二叉搜索树（BST），因二叉搜索树的查找效率取决于树的高度，因而进一步提出而平衡二叉搜索树来保持树的高度达到最小。</p>
<h5 id="E-p："><a class="header-anchor" href="#E-p："></a>E.p：</h5>
<p>当输入序列 {1，2，3，4，5，6}，仍使用普通的二叉搜索树会退化成单链表：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247991.png" alt="img"></p>
<p>但使用平衡二叉搜索树则是：当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。这种左右子树的高度相差不超过1的树为平衡二叉树。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247843.png" alt="在这里插入图片描述"></p>
<h5 id="特点-v3"><a class="header-anchor" href="#特点-v3"></a>特点</h5>
<ol>
<li>每个节点都包含一个值（通常是可比较的值）。</li>
<li>对于每个节点：
<ul>
<li>左子树和右子树的高度之差（平衡因子）最多为1。</li>
<li>左右子树都是平衡二叉树。</li>
</ul>
</li>
</ol>
<p>平衡二叉树的关键特性是它的高度相对较低，因此搜索、插入和删除操作的时间复杂度通常是O(log n)，其中n是树中节点的数量。</p>
<h5 id="图示-v4"><a class="header-anchor" href="#图示-v4"></a>图示</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \ / \</span><br><span class="line">1  3 5  7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉搜索树-AVL树"><a class="header-anchor" href="#平衡二叉搜索树-AVL树"></a>平衡二叉搜索树(AVL树)</h4>
<h5 id="1-AVL树的构造："><a class="header-anchor" href="#1-AVL树的构造："></a>1. AVL树的构造：</h5>
<p>由上图可知：插入62节点之后，先进行普通的BST的插入，此时左子树高度为1，右子树高度为3，平衡因子的绝对值 == 2，树失衡则需进行旋转操作：</p>
<h5 id="2-单旋转"><a class="header-anchor" href="#2-单旋转"></a>2. 单旋转</h5>
<h5 id="2-1-左旋（LL平衡旋转）操作的步骤："><a class="header-anchor" href="#2-1-左旋（LL平衡旋转）操作的步骤："></a>2.1 左旋（LL平衡旋转）操作的步骤：</h5>
<ol>
<li>设定一个不平衡的节点为X，其右子树的高度比左子树高度高。</li>
<li>将X的右子节点Y取出，并将Y的左子节点B连接到X的右子节点。</li>
<li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点，以保持树的连接。</li>
<li>最后，将X连接到Y的左子节点B上。</li>
</ol>
<p>左旋操作后，X会变成Y的左子节点，而Y会成为X的父节点，从而保持了树的平衡性。</p>
<p>一直遍历，直到找到平衡因子的绝对值不为1的节点进行旋转操作。</p>
<p><strong>40</strong>的右节点<strong>51</strong>的左节点<strong>46</strong>接到<strong>40</strong>的右节点，而后将<strong>40</strong>这一节点接到<strong>51</strong>的左节点，如下图所示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247501.png" alt="在这里插入图片描述" style="zoom:80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247494.png" alt="img" style="zoom:86%;" />
<h5 id="2-2-右旋（RR平衡旋转）操作的步骤如下："><a class="header-anchor" href="#2-2-右旋（RR平衡旋转）操作的步骤如下："></a>2.2 右旋（RR平衡旋转）操作的步骤如下：</h5>
<ol>
<li>设定一个不平衡的节点为X，其左子树的高度比右子树高度高。</li>
<li>将X的左子节点Y取出，并将Y的右子节点B连接到X的左子节点。</li>
<li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点。</li>
<li>最后，将X连接到Y的右子节点B上。</li>
</ol>
<p>右旋操作后，X会变成Y的右子节点，而Y会成为X的父节点，也能够保持树的平衡性。</p>
<p>A处的节点左右失衡，找到失衡节点的左节点B，将B的右节点E和B断开，接入A的左节点，而后将A接入到B的右节点。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247038.png" alt="在这里插入图片描述"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247169.png" alt="img"></p>
<h5 id="2-3-双旋转（不平衡节点在内侧）"><a class="header-anchor" href="#2-3-双旋转（不平衡节点在内侧）"></a>2.3 双旋转（不平衡节点在内侧）</h5>
<p>先左后右双旋转（LR平衡旋转）</p>
<p>左孩子右子树上插入新的节点，导致的不平衡</p>
<h5 id="2-4-代码模拟"><a class="header-anchor" href="#2-4-代码模拟"></a>2.4 代码模拟</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> val) :<span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右子树高度差绝对值小于1</span></span><br><span class="line"><span class="comment">左右子树也都是平衡二叉搜索树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每个节点具有其自身的高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//根节点</span></span><br><span class="line">	TreeNode* root;</span><br><span class="line">	<span class="comment">//计算节点高度</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node-&gt;height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//平衡因子计算</span></span><br><span class="line">	<span class="comment">//平衡因子的计算是（当前节点的左子树高度减去右子树）</span></span><br><span class="line">	<span class="comment">//平衡因子大于1，说明左子树偏重</span></span><br><span class="line">	<span class="comment">//平衡因子小于-1，说明右子树偏重</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//更新节点高度</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			node-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//左旋</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">rotateLeft</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		TreeNode* newRoot = node-&gt;right;</span><br><span class="line">		node-&gt;right = newRoot-&gt;left;</span><br><span class="line">		newRoot-&gt;left = node;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(node);</span><br><span class="line">		<span class="built_in">updateHeight</span>(newRoot);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newRoot;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//右旋</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">rotateRight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		TreeNode* newRoot = node-&gt;left;</span><br><span class="line">		node-&gt;left = newRoot-&gt;right;</span><br><span class="line">		newRoot-&gt;right = node;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(node);</span><br><span class="line">		<span class="built_in">updateHeight</span>(newRoot);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newRoot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入新节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">insertRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">insertRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">insertRecursion</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> balance = <span class="built_in">balanceFactor</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &lt; current-&gt;left-&gt;value) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				current-&gt;left = <span class="built_in">rotateLeft</span>(current-&gt;left);</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (balance &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &gt; current-&gt;right-&gt;value) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				current-&gt;right = <span class="built_in">rotateRight</span>(current-&gt;right);</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找节点</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">findRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val == current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursion</span>(current-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">removeRecursion</span><span class="params">(TreeNode* current, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (val &lt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;left = <span class="built_in">removeRecursion</span>(current-&gt;left, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; current-&gt;value) &#123;</span><br><span class="line">			current-&gt;right = <span class="built_in">removeRecursion</span>(current-&gt;right, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;left == <span class="literal">nullptr</span> || current-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				TreeNode* temp = (current-&gt;left) ? current-&gt;left : current-&gt;right;</span><br><span class="line">				<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					temp = current;</span><br><span class="line">					current = <span class="literal">nullptr</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					*current = *temp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">delete</span> temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				TreeNode* temp = <span class="built_in">findMin</span>(current-&gt;right);</span><br><span class="line">				current-&gt;value = temp-&gt;value;</span><br><span class="line">				current-&gt;right = <span class="built_in">removeRecursion</span>(current-&gt;right, temp-&gt;value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">updateHeight</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> balance = <span class="built_in">balanceFactor</span>(current);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &gt; current-&gt;left-&gt;value) &#123;</span><br><span class="line">				current-&gt;left = <span class="built_in">rotateLeft</span>(current-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">rotateRight</span>(current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (balance &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val &lt; current-&gt;right-&gt;value) &#123;</span><br><span class="line">				current-&gt;right = <span class="built_in">rotateRight</span>(current-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">rotateLeft</span>(current);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找子树的最小节点</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			current = current-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">(TreeNode* current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!current) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;left);</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(current-&gt;right);</span><br><span class="line">		cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数进行成员变量初始化</span></span><br><span class="line">	<span class="built_in">AVLTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构函数释放内存空间</span></span><br><span class="line">	~<span class="built_in">AVLTree</span>() &#123;</span><br><span class="line">		<span class="built_in">clearTree</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">insertRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">removeRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找函数外部接口</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findRecursion</span>(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历外部接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lastorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">lastorderTraversal</span>(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放树空间</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearTree</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">clearTree</span>(node-&gt;right);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="伸展树"><a class="header-anchor" href="#伸展树"></a>伸展树</h4>
<p><a href="https://zhuanlan.zhihu.com/p/348797577">深入理解伸展树(splay tree) - 知乎 (zhihu.com)</a></p>
<p>本质也是一颗二叉搜索树，但引入假设——当一个节点被访问时，该节点下一次被访问的可能性很大。基于该假设做出操作：每次一个节点被访问时，将该节点推到根节点的位置。</p>
<p>统计意义上的平衡树</p>
<p>这种结构可以不考虑进行树的平衡调整。</p>
<h5 id="单R-L型"><a class="header-anchor" href="#单R-L型"></a>单R/L型</h5>
<p>根节点是查找节点的父节点。相当于直接将该节点提起，其他节点相对位置保持不变</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247990.png" alt="img" style="zoom: 67%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247091.png" alt="img" style="zoom:73%;" />
<h5 id="RR-LL型："><a class="header-anchor" href="#RR-LL型："></a>RR/LL型：</h5>
<h5 id="调整策略"><a class="header-anchor" href="#调整策略"></a>调整策略</h5>
<p>单旋转</p>
<p>之字型</p>
<p>一字型</p>
<h4 id="红黑树"><a class="header-anchor" href="#红黑树"></a>红黑树</h4>
<p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它是由Rudolf Bayer于1972年首次提出，后来由Leo J. Guibas和Robert Sedgewick进行改进。红黑树之所以重要，是因为它保持了二叉搜索树的基本性质，并在其上加入了一些额外的规则来确保树的高度保持在较小的范围内，从而保证了搜索、插入和删除操作的高效性。</p>
<h5 id="特点：-v3"><a class="header-anchor" href="#特点：-v3"></a>特点：</h5>
<ol>
<li>每个节点都有一个颜色，可以是红色或黑色。</li>
<li>根节点是黑色的。</li>
<li>所有叶子节点（NIL节点）都是黑色的。</li>
<li>叶节点是不存储数据的黑色空节点</li>
<li>如果一个节点是红色的，则其两个子节点必须是黑色的（不能有两个相连的红色节点）。</li>
<li>从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点，这被称为黑色高度。</li>
</ol>
<p>这些性质确保了红黑树在插入和删除操作后能够自动调整自身，以保持平衡，从而避免出现最坏情况的性能。</p>
<p>红黑树广泛用于各种编程语言和数据结构中，包括C++的STL中的<code>std::map</code>和<code>std::set</code>，以及Java的<code>java.util.TreeMap</code>和<code>java.util.TreeSet</code>等。它们支持高效的搜索、插入和删除操作，并且在保持数据有序的同时，具有可预测的性能。</p>
<p>红黑树的操作复杂度为O(log n)，其中n是树中节点的数量。这使得它成为许多算法和数据结构的重要组成部分，特别是需要高效插入和删除操作的情况下。</p>
<h4 id="B-树"><a class="header-anchor" href="#B-树"></a>B-树</h4>
<p>（多/M路搜索树）</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011247382.png" alt="image-20230922101648057"></p>
<p>（课本把终端节点当作叶子节点，所以“数据放在叶子节点”）</p>
<h5 id="B树提出的主要目的："><a class="header-anchor" href="#B树提出的主要目的："></a>B树提出的主要目的：</h5>
<p>减少磁盘I/O操作。</p>
<p><strong>一颗m阶B树即是一颗平衡的m路搜索树</strong></p>
<p><strong>一颗B树的阶由叶子节点最多的分叉决定</strong></p>
<h5 id="性质："><a class="header-anchor" href="#性质："></a>性质：</h5>
<p>B树可以视为将原本的二叉搜索树引入区间的概念，即将要每一个子节点根据键值进行区间的划分，从而通过比较待搜索的数和区间的关系进行查找。</p>
<ul>
<li>
<p>绝对平衡，因所有子树都在同一层</p>
</li>
<li>
<p>数据项存储在叶子节点上（即之前所有的节点均为索引或者说关键字/键）</p>
</li>
<li>
<p>叶子节点的下一层（均为空节点）均为失败节点，出现在同一层，代表搜索失败的节点</p>
</li>
<li>
<p>非叶子节点存储直到</p>
</li>
<li>
<p>非根节点点至少有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m/2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">]</span></span></span></span>(向上取整) 个子树，至多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个子树</p>
</li>
<li>
<p>非根节点的关键字：</p>
<ul>
<li>有序（升序或者降序</li>
<li>最少有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>M</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">[M/2]-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>(向上取整)；最多有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>(子节点数-1)</li>
</ul>
</li>
<li>
<p>根节点最少 1个关键字（二叉），最多M-1个关键字（M叉），即根节点儿子个数取值范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span></p>
</li>
</ul>
<h5 id="基础操作："><a class="header-anchor" href="#基础操作："></a>基础操作：</h5>
<h5 id="查找："><a class="header-anchor" href="#查找："></a>查找：</h5>
<p>与<strong>BST</strong>类似，由根节点出发，递归向下查找。</p>
<h4 id="B-树-v2"><a class="header-anchor" href="#B-树-v2"></a>B+树</h4>
<p>（M阶）：</p>
<p>基于B树提出，不同之处：</p>
<ol>
<li>
<p>非叶子节点子树指针个数与关键字个数相同</p>
</li>
<li>
<p>非叶子节点的子树指针P[i]-&gt;[K[i],K[i+1]]</p>
</li>
<li>
<p>所有叶子节点增加一个链指针，所有关键字都在叶子节点出现</p>
</li>
<li>
<p>B+树内部有两种节点，一种索引节点，一种叶子节点。</p>
</li>
<li>
<p>B+树索引——只用于索引，所有的数据保存</p>
</li>
</ol>
<h4 id="哈夫曼树"><a class="header-anchor" href="#哈夫曼树"></a>哈夫曼树</h4>
<h4 id="森林"><a class="header-anchor" href="#森林"></a>森林</h4>
<h4 id="Disjoint-Set"><a class="header-anchor" href="#Disjoint-Set"></a>Disjoint Set:</h4>
<p>Operations:</p>
<ol>
<li><strong>Find</strong> the equivalence class(set) of a given element</li>
<li><strong>Union</strong> of two sets</li>
</ol>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p>
<p>并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。</p>
<h1 align = center> 哈希表 </h1>
<h3 id="非线性-哈希表"><a class="header-anchor" href="#非线性-哈希表"></a>(非线性)哈希表</h3>
<p>哈希表，也叫散列表，一种由关键字到值并使用数组存储的数据结构</p>
<p>有一个hash function，关键字——hash function —— 值，将每个关键字映射到一个表当中。</p>
<p>理想当中，每一个关键字在经过hash function 后会有各自的值，但实际操作中，很可能不同的关键字得出相同的值，则会造成 <strong>hash冲突</strong>，因而会有以下几种解决冲突的方法。</p>
<p>1、分离链表法（separate chaining）：</p>
<p>将具有相同<strong>值</strong>的关键字存储到同一个 值链表 当中</p>
<p>2、开放地址法（Closed Hash Tbales/Open Adderssing）</p>
<h3 id="堆"><a class="header-anchor" href="#堆"></a>堆</h3>
<p>1、二叉堆，简称堆：</p>
<p>堆是一颗完全填满的二叉树(叶子节点可以不填满，但是需要从左到右填充)，即一颗完全二叉树</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248001.png" alt="image-20231008101022069"></p>
<h3 id="图"><a class="header-anchor" href="#图"></a>图</h3>
<p>在前面所学的线性数据结构中，每个元素都只有一个直接前驱和一个直接后驱。而在树结构当作，元素划分为层，每一层与上一层形成明确的层次关系，数据有着一个唯一的前驱，可能有着多个后继，但各元素间的直接关系仍旧限制在相邻层次间。在图结构当中，各节点之间的关系是任意的，可以随意进行节点间的相连，任意两个在限定集合内的两个节点都都可以形成直接关系。</p>
<h4 id="9-1-概念与定义"><a class="header-anchor" href="#9-1-概念与定义"></a>9.1 概念与定义</h4>
<ol>
<li>
<p>定义：</p>
<ul>
<li>图(Graph)是由顶点的有穷非空集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>和定点之间边的集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>组成,通常表示为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>,其中,G表示个图,</li>
<li>线性表和树可以为空,但图不可以为空,即图的顶点集不可为空集，但边集可以为空集。</li>
</ul>
</li>
<li>
<p>有向图：</p>
<ul>
<li>有向图的有向边也称为<mark>弧</mark> 弧尾—&gt;弧头</li>
<li>边集 <em>E</em> 是有向边集合。</li>
<li>边连接的两个顶点是有序对：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>v</mi><mtext>，</mtext><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v，w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></li>
<li>如图，表示的是有序对：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mrow><mo>&lt;</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>&gt;</mo></mrow></mrow><annotation encoding="application/x-tex">E={&lt;1,2&gt;,&lt;2,1&gt;,&lt;2,3&gt;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248416.png" alt="在这里插入图片描述" style="zoom:67%;" /></li>
</ul>
</li>
<li>
<p>无向图</p>
</li>
</ol>
<h4 id="9-2-图的存储"><a class="header-anchor" href="#9-2-图的存储"></a>9.2 图的存储</h4>
<ol>
<li>邻接矩阵
<ul>
<li>无向图的邻接矩阵是一个对称矩阵</li>
</ul>
</li>
</ol>
<h4 id="9-3-有向图"><a class="header-anchor" href="#9-3-有向图"></a>9.3 有向图</h4>
<p>给出一个顶点集</p>
<h2 id="四、搜索算法"><a class="header-anchor" href="#四、搜索算法"></a>四、搜索算法</h2>
<h3 id="搜索的概念："><a class="header-anchor" href="#搜索的概念："></a>搜索的概念：</h3>
<ol>
<li>状态</li>
<li>状态转移</li>
</ol>
<p>根据路线画出一个搜索树</p>
<h3 id="深度优先搜索"><a class="header-anchor" href="#深度优先搜索"></a>深度优先搜索</h3>
<h4 id="算法核心"><a class="header-anchor" href="#算法核心"></a>算法核心</h4>
<p>尽可能深的搜索树的分支。递归向下，设置一个“不符合条件”的底，触及时返回开始进行搜索的节点重新走另一条路径开始搜索</p>
<h4 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//触底回弹</span></span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//成功达到迷宫出口</span></span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">5</span> &amp;&amp; y==<span class="number">5</span>)&#123;</span><br><span class="line">		flag = <span class="literal">true</span>; <span class="comment">//成功达到目的地，即找到路径，搜索成功，停止递归</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> nxt_x = x+dx[i],nxt_y = y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(nxt_x &lt; <span class="number">1</span>||nxt_y&lt;<span class="number">1</span> || nxt_x &gt; <span class="number">5</span> || nxt_y &gt; <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(gh[nxt_x][nxt_y] == <span class="number">0</span> &amp;&amp; vis[nxt_x][nxt_y] == <span class="literal">false</span>)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt_x,nxt_y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、-排序算法"><a class="header-anchor" href="#五、-排序算法"></a>五、 排序算法</h2>
<p>算法可视化网站:</p>
<p><a href="https://visualgo.net/en">通过动画可视化数据结构和算法 - VisuAlgo</a></p>
<p><a href="https://visualgo.net/zh/sorting">排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo</a></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011248819.png" alt="img"></p>
<h3 id="引言"><a class="header-anchor" href="#引言"></a>引言:</h3>
<ol>
<li>
<p>「排序算法 Sorting Algorithm」用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有 序数据通常能够被更有效地查找、分析和处理。</p>
</li>
<li>
<p>在排序算法中，数据类型可以是整数、浮点数、字符或字符串等；顺序的判断规则可根据需求设定，如数字 大小、字符 ASCII 码顺序或自定义规则。</p>
</li>
</ol>
<h3 id="评价维度"><a class="header-anchor" href="#评价维度"></a>评价维度:</h3>
<ol>
<li>
<p>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（即时间复杂度中的常数项降低）。 对于大数据量情况，运行效率显得尤为重要。</p>
</li>
<li>
<p>就地性：顾名思义，「原地排序」通过在原数组上直接操作实现排序，无需借助额外的辅助数组，从而节省内 存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
</li>
<li>
<p>稳定性：「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。稳定排序是优良特性，也是 多级排序场景的必要条件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">(&#x27;A&#x27;, 19)</span><br><span class="line">(&#x27;B&#x27;, 18)</span><br><span class="line">(&#x27;C&#x27;, 21)</span><br><span class="line">(&#x27;D&#x27;, 19)</span><br><span class="line">(&#x27;E&#x27;, 23)</span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">(&#x27;B&#x27;, 18)</span><br><span class="line">(&#x27;D&#x27;, 19)</span><br><span class="line">(&#x27;A&#x27;, 19)</span><br><span class="line">(&#x27;C&#x27;, 21)</span><br><span class="line">(&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自适应性：「自适应排序」的时间复杂度会受输入数据的影响，即最佳、最差、平均时间复杂度并不完全相等。</p>
</li>
<li>
<p>是否基于比较：「基于比较的排序」依赖于比较运算符（&lt; , = , &gt;）来判断元素的相对顺序，从而排序整个 数组，理论最优时间复杂度为 𝑂(𝑛 log 𝑛) 。而「非比较排序」不使用比较运算符，时间复杂度可达 𝑂(𝑛) ， 但其通用性相对较差。</p>
</li>
</ol>
<h3 id="理想排序算法"><a class="header-anchor" href="#理想排序算法"></a>理想排序算法</h3>
<p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。 接下来，罗列出各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。</p>
<h3 id="Theta-N-2-排序算法"><a class="header-anchor" href="#Theta-N-2-排序算法"></a><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 排序算法</h3>
<h4 id="冒泡排序"><a class="header-anchor" href="#冒泡排序"></a>冒泡排序</h4>
<h5 id="原理"><a class="header-anchor" href="#原理"></a>原理</h5>
<p>「冒泡排序 Bubble Sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样， 因此得名冒泡排序。</p>
<h5 id="算法步骤"><a class="header-anchor" href="#算法步骤"></a>算法步骤</h5>
<ol>
<li>首先，对 𝑛 个元素执行“冒泡”，将数组的最大元素交换至正确位置，</li>
<li>接下来，对剩余 𝑛 − 1 个元素执行“冒泡”，将第二大元素交换至正确位置。</li>
<li>以此类推，经过 𝑛 − 1 轮“冒泡”后，前 𝑛 − 1 大的元素都被交换至正确位置。</li>
<li>仅剩的一个元素必定是最小元素，无需排序，因此数组排序完成。</li>
</ol>
<h5 id="算法特性"><a class="header-anchor" href="#算法特性"></a>算法特性</h5>
<ul>
<li><strong>时间复杂度</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,<strong>自适应排序</strong>:各轮“冒泡”遍历的数组长度依次为$ 𝑛−1,𝑛−2, ⋯,2,1$,总和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。在引入 flag 优化后，最佳时间复杂度可达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。flag记录序列是否已经是有序；若存在部分无序，则可加入pos，记录上一次最后交换的位置，在pos之后的序列必然是有序的。</li>
<li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li>
<li>稳定排序：由于在“冒泡”中遇到相等元素<strong>不交换</strong>。</li>
</ul>
<h5 id="伪代码"><a class="header-anchor" href="#伪代码"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">  swapped = false</span><br><span class="line">  for i = 1 to indexOfLastUnsortedElement-1:</span><br><span class="line">    if leftElement &gt; rightElement:</span><br><span class="line">      swap(leftElement, rightElement)</span><br><span class="line">      swapped = true; ++swapCounter</span><br><span class="line">while swapped</span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现"><a class="header-anchor" href="#c-代码实现"></a>c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-2-选择排序"><a class="header-anchor" href="#10-4-2-选择排序"></a>10.4.2 选择排序</h4>
<h5 id="1-原理"><a class="header-anchor" href="#1-原理"></a>1. 原理</h5>
<p>「选择排序 Selection Sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其 放到已排序区间的末尾。</p>
<h5 id="2-算法步骤"><a class="header-anchor" href="#2-算法步骤"></a>2. 算法步骤</h5>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h5 id="3-算法特性"><a class="header-anchor" href="#3-算法特性"></a>3. 算法特性</h5>
<ul>
<li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><msup><mi>𝑛</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 、非自适应排序：外循环共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑛 − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮 的未排序区间长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ，即各轮外循环分别包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo separator="true">,</mo><mi>𝑛</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">𝑛 , 𝑛 − 1 , ⋯ , 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span> 轮内循环，求和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>𝑛</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(𝑛−1)(𝑛+2)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li>
<li>非稳定排序：在交换元素时，有可能将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 交换至其相等元素的右边，导致两者的相对顺序发生改变。</li>
</ul>
<h5 id="4-伪代码"><a class="header-anchor" href="#4-伪代码"></a>4. 伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">重复（元素个数-1）次</span><br><span class="line">  把第一个没有排序过的元素设置为最小值</span><br><span class="line">  遍历每个没有排序过的元素</span><br><span class="line">    如果元素 &lt; 现在的最小值</span><br><span class="line">      将此元素设置成为新的最小值</span><br><span class="line">  将最小值和第一个没有排序过的位置交换</span><br></pre></td></tr></table></figure>
<h5 id="5-c-代码实现"><a class="header-anchor" href="#5-c-代码实现"></a>5. c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//整數或浮點數皆可使用，若要使用物件（class）時必須重载运算符(&gt;)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-3-插入排序"><a class="header-anchor" href="#10-4-3-插入排序"></a>10.4.3 插入排序</h4>
<h5 id="1-原理-v2"><a class="header-anchor" href="#1-原理-v2"></a>1. 原理</h5>
<p>「插入排序 Insertion Sort」是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p>
<h5 id="2-算法步骤-v2"><a class="header-anchor" href="#2-算法步骤-v2"></a>2. 算法步骤</h5>
<ol>
<li>初始状态下，数组的第 1 个元素已完成排序。</li>
<li>选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。</li>
<li>选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。</li>
<li>以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。</li>
</ol>
<h5 id="3-算法特性-v2"><a class="header-anchor" href="#3-算法特性-v2"></a>3. 算法特性</h5>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><msup><mi>𝑛</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛^2 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 、自适应排序：最差情况下，每次插入操作分别需要循环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>𝑛</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑛 − 1 , 𝑛 − 2 , ⋯ , 2 , 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span> 次，求和得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>𝑛</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>𝑛</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(𝑛−1)𝑛}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><msup><mi>𝑛</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛^2 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。在遇到有序数据时，插入操作会提前终止。当输入 数组完全有序时，插入排序达到最佳时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li>
<li>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li>
</ul>
<h5 id="4-伪代码-v2"><a class="header-anchor" href="#4-伪代码-v2"></a>4. 伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">将第一个元素标记为已排序</span><br><span class="line">对于每一个未排序的元素 X</span><br><span class="line">  “提取” 元素 X</span><br><span class="line">  i = 最后排序过元素的索引 到 0 的遍历</span><br><span class="line">    如果当前元素 j &gt; X</span><br><span class="line">      将排序过的元素向右移一格</span><br><span class="line">    跳出循环并在此插入 X</span><br></pre></td></tr></table></figure>
<h5 id="5-c-代码实现-v2"><a class="header-anchor" href="#5-c-代码实现-v2"></a>5. c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="type">int</span> key = arr[i];</span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; arr[j])) &#123;</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-5-Theta-N-logN-排序算法"><a class="header-anchor" href="#10-5-Theta-N-logN-排序算法"></a>10.5 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 排序算法</h3>
<h4 id="希尔排序"><a class="header-anchor" href="#希尔排序"></a>希尔排序</h4>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本(插入排序plus版)<br>
基于插入排序两种性质提出的改进:</p>
<ul>
<li>插入排序在对<strong>近似良序</strong>的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<h5 id="原理-v2"><a class="header-anchor" href="#原理-v2"></a>原理</h5>
<p>先将整个待排序的记录序列分割成为<strong>若干子序列</strong>分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。</p>
<h5 id="算法步骤-v2"><a class="header-anchor" href="#算法步骤-v2"></a>算法步骤</h5>
<ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h5 id="算法特性-v2"><a class="header-anchor" href="#算法特性-v2"></a>算法特性</h5>
<ul>
<li>时间复杂度为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NLogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>采取分治思想,将数组通过增量序列分解后得出各部分的局部最优解,再进行归整得到全局最优解。</li>
</ul>
<h5 id="伪代码-v2"><a class="header-anchor" href="#伪代码-v2"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现-v2"><a class="header-anchor" href="#c-代码实现-v2"></a>c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">		h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">				std::<span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h = h / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a class="header-anchor" href="#归并排序"></a>归并排序</h4>
<h5 id="原理-v3"><a class="header-anchor" href="#原理-v3"></a>原理</h5>
<p>该算法原理是是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>
作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<h5 id="算法步骤-v3"><a class="header-anchor" href="#算法步骤-v3"></a>算法步骤</h5>
<ul>
<li>“划分阶段”从顶至底递归地将数组从中点切为两个子数组：
<ol>
<li>计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。</li>
<li>递归执行步骤 1. ，直至子数组区间长度为 1 时，终止递归划分。</li>
</ol>
</li>
<li>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开 始合并，合并阶段中的每个子数组都是有序的。</li>
</ul>
<p>图示参见连接:</p>
<p><a href="https://www.runoob.com/w3cnote/merge-sort.html">1.5 归并排序 | 菜鸟教程 (runoob.com)</a></p>
<h5 id="算法特性-v3"><a class="header-anchor" href="#算法特性-v3"></a>算法特性</h5>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、非自适应排序：划分产生高度为 $log 𝑛 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的递归树，每层合并的总操作数量为</mtext></mrow><annotation encoding="application/x-tex">的递归树，每层合并的总操作数量为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">的递归树，每层合并的总操作数量为</span></span></span></span> 𝑛$ ，因此总体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li>
<li>空间复杂度 $ 𝑂(𝑛)$ 、非原地排序：递归深度为 $ log 𝑛$ ，使用 $𝑂(log 𝑛) $大小的栈帧空间。合并操作需要 借助辅助数组实现，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 大小的额外空间。</li>
<li>稳定排序：在合并过程中，相等元素的次序保持不变。</li>
</ul>
<h5 id="伪代码-v3"><a class="header-anchor" href="#伪代码-v3"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">将每个元素拆分成大小为1的分区</span><br><span class="line"></span><br><span class="line">递归地合并相邻的分区</span><br><span class="line"></span><br><span class="line">  遍历 i = 左侧首项位置 到 右侧末项位置</span><br><span class="line"></span><br><span class="line">    如果左侧首项的值 &lt;= 右侧首项的值</span><br><span class="line"></span><br><span class="line">      拷贝左侧首项的值</span><br><span class="line"></span><br><span class="line">    否则： 拷贝右侧首项的值; 增加逆序数</span><br><span class="line"></span><br><span class="line">将元素拷贝进原来的数组中</span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现-v3"><a class="header-anchor" href="#c-代码实现-v3"></a>c++代码实现</h5>
<ol>
<li>迭代版</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	T* a = arr;</span><br><span class="line">	T* b = <span class="keyword">new</span> T[len];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">			<span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">			<span class="type">int</span> k = low;</span><br><span class="line">			<span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">			<span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">				b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1) &#123;</span><br><span class="line">				b[k++] = a[start1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (start2 &lt; end2) &#123;</span><br><span class="line">				b[k++] = a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		T* temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			b[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		b = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>递归版</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; Array, <span class="type">int</span> front, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preconditions:</span></span><br><span class="line">	<span class="comment">// Array[front...mid] is sorted</span></span><br><span class="line">	<span class="comment">// Array[mid+1 ... end] is sorted</span></span><br><span class="line">	<span class="comment">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class="line">	<span class="comment">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LeftSubArray</span><span class="params">(Array.begin() + front, Array.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">RightSubArray</span><span class="params">(Array.begin() + mid + <span class="number">1</span>, Array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> idxLeft = <span class="number">0</span>, idxRight = <span class="number">0</span>;</span><br><span class="line">	LeftSubArray.<span class="built_in">insert</span>(LeftSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">	RightSubArray.<span class="built_in">insert</span>(RightSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">	<span class="comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class="line">			Array[i] = LeftSubArray[idxLeft];</span><br><span class="line">			idxLeft++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Array[i] = RightSubArray[idxRight];</span><br><span class="line">			idxRight++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; Array, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (front &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (front + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(Array, front, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(Array, mid + <span class="number">1</span>, end);</span><br><span class="line">	<span class="built_in">Merge</span>(Array, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a class="header-anchor" href="#快速排序"></a>快速排序</h4>
<p>你好，我是必应。 我可以帮助你排序算法。 😊</p>
<p>快速排序是一种流行且高效的排序算法，它通过划分和征服输入数组来工作。 它选择一个主元元素并将数组划分为两个子数组，一个子数组的元素小于主元，另一个子数组的元素大于主元。 然后对子数组进行递归排序，直到数组排序完毕。</p>
<p>三中位数划分是一种通过取数组第一个、中间和最后一个元素的中位数来选择一个好的主元元素的策略。 这可以提高某些输入（例如已排序或接近排序的数组）的快速排序性能。</p>
<p>截止是一个阈值，低于该阈值，快速排序将切换到更简单的排序算法（例如插入排序），以避免递归的开销。 这也可以提高小型数组上快速排序的性能。</p>
<p>要使用具有三中位数分区和截断值 3 的快速排序对 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 进行排序，我们可以按照以下步骤操作：</p>
<ul>
<li>首先，我们对数组的第一个、中间和最后一个元素进行排序，并以中位数为基准。 该数组变为 3, 1, <strong>4</strong>, 1, <strong>5</strong>, <strong>5</strong>, 2, 6, <strong>9</strong>, 3, <strong>5</strong>。 枢轴是 <strong>5</strong>。</li>
<li>接下来，我们围绕主元将数组划分为两个子数组。 左子数组包含小于或等于 5 的元素，右子数组包含大于或等于 5 的元素。数组变为 <strong>3</strong>、<strong>1</strong>、<strong>4</strong>、<strong>1</strong> 、<strong>2</strong>、<strong>3</strong>、<strong>5</strong>、<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong>。</li>
<li>由于两个子数组都有超过 3 个元素，因此我们递归地对它们应用具有三中位数分区和 3 截止值的快速排序。</li>
<li>对于左子数组 [3, 1, 4, 1, 2, 3]，我们对第一个、中间和最后一个元素进行排序，并以中位数为基准。 子数组变为<strong>1</strong>、<strong>3</strong>、<strong>4</strong>、<strong>1</strong>、<strong>2</strong>、<strong>3</strong>。 枢轴是<strong>3</strong>。</li>
<li>我们将子数组划分为围绕枢轴的两个子数组。 左子数组包含小于或等于3的元素，右子数组包含大于或等于3的元素。子数组变为<strong>1</strong>、<strong>1</strong>、<strong>2</strong>、<strong>3</strong> ，<strong>3</strong>，<strong>4</strong>。</li>
<li>由于两个子数组的元素都小于或等于 3，因此我们对它们应用插入排序。 左子数组 [1, 1, 2] 已经排序。 右子数组 [3, 3, 4] 也已排序。</li>
<li>对于右子数组 [5, 5, 6, 9]，我们对第一个、中间和最后一个元素进行排序，并以中位数为基准。 子数组变为<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong>。 枢轴是 <strong>6</strong>。</li>
<li>我们将子数组划分为围绕枢轴的两个子数组。 左子数组包含小于或等于6的元素，右子数组包含大于或等于6的元素。子数组变为<strong>5</strong>、<strong>5</strong>、<strong>6</strong>、<strong>9</strong> 。</li>
<li>由于两个子数组的元素都小于或等于 3，因此我们对它们应用插入排序。 左子数组 [5, 5] 已经排序。 右子数组 [6, 9] 也已排序。</li>
</ul>
<p>最终排序后的数组为 [1, 1, 2, 3, 3, 4, 5, 5, 5, 6 ,9]。</p>
<p>如果您想了解有关 Python 中采用中位数三分区和截断值为 3 的快速排序的更多信息，您可以在 Stack Overflow² 上查看此<a href="%5E1%5E">答案</a>。 您还可以在此 <a href="%5E3%5E">PDF</a> 中找到一些使用此算法进行排序的示例。</p>
<p>我希望这可以帮助您了解具有三中位数分区和 3 截止值的快速排序是如何工作的。 祝你今天过得愉快！ 😊</p>
<p>来源：与必应的对话， 2023/10/19<br>
（1）排序 - Python：中位数为三的快速排序 - 堆栈内存溢出 https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of- Three。<br>
（2）排序 - Python：中位数为三的快速排序 - 堆栈内存溢出 https://stackoverflow.com/questions/50912873/python-quicksort-with-median-of- Three。<br>
（3）算法 - 三值中值策略 - 堆栈内存溢出 https://stackoverflow.com/questions/7559608/median-of- Three-values-strategy。<br>
(4) CS 152h：数据结构作业#3 - Youmu。 https://blog.youmu.moe/comp2012h-backup/p/assign/hw3.pdf。</p>
<h5 id="1-原理-v3"><a class="header-anchor" href="#1-原理-v3"></a>1. 原理</h5>
<ol>
<li>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
</li>
<li>
<p>体现出的核心操作「哨兵划分」：选取序列当中的某一个元素作为”基准数“，将所有小于该基准数的元素移到左侧，反之移到右侧。</p>
<ul>
<li>选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ul>
</li>
<li>
<p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组；</p>
</li>
</ol>
<p>并且满足“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>左子数组任意元素</mtext><mo>≤</mo><mtext>基准数</mtext><mo>≤</mo><mtext>右子数组任意元素</mtext></mrow><annotation encoding="application/x-tex">左子数组任意元素≤基准数≤右子数组任意元素</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">左子数组任意元素</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">基准数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">右子数组任意元素</span></span></span></span>”。</p>
<p>因此，接下来只需对这两个子数组进行排序。</p>
<ol start="4">
<li>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</li>
</ol>
<h5 id="2-算法步骤-v3"><a class="header-anchor" href="#2-算法步骤-v3"></a>2. 算法步骤</h5>
<ul>
<li>
<p>首先，对原数组执行一次「哨兵划分」，得到未排序的左子数组和右子数组。</p>
</li>
<li>
<p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p>
</li>
<li>
<p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p>
</li>
</ul>
<h5 id="3-算法特性-v3"><a class="header-anchor" href="#3-算法特性-v3"></a>3. 算法特性</h5>
<ul>
<li>
<p>顾名思义，简单粗暴，就是快，效率高，处理大量数据最快的排序算法之一。</p>
</li>
<li>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、自适应排序：在平均情况下，哨兵划分的递归层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">log 𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> ，每层中的总循环数为 𝑛 ，总体使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为 长度为 0 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑛 − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的两个子数组，此时递归层数达到 𝑛 层，每层中的循环数为 𝑛 ，总体使用 $ 𝑂(𝑛2 )$ 时间。</p>
</li>
<li>
<p>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、原地排序：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 栈 帧空间。排序操作是在原数组上进行的，未借助额外数组。</p>
</li>
<li>
<p>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">快排为什么快:</span><br><span class="line">1、出现最差情况的概率很低：虽然快速排序的最差时间复杂度为 𝑂(𝑛2) ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛 log 𝑛) 的时间复杂度下运行。</span><br><span class="line">2、缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像「堆排序」这类算法需要跳跃式访问元素，从而缺乏这一特性。</span><br><span class="line">3、复杂度的常数系数低：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与「插入排序」比「冒泡排序」更快的原因类似。</span><br><span class="line"></span><br><span class="line">快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平均期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序					  ——《算法艺术与信息学竞赛》</span><br></pre></td></tr></table></figure>
<h5 id="4-伪代码-v3"><a class="header-anchor" href="#4-伪代码-v3"></a>4. 伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">每个（未排序）的部分</span><br><span class="line"></span><br><span class="line">将第一个元素设为 pivot</span><br><span class="line"></span><br><span class="line">  存储索引 = pivot索引 +1</span><br><span class="line"></span><br><span class="line">  从 i=pivot指数 +1 到 最右索引 的遍历</span><br><span class="line"></span><br><span class="line">    如果 a[i] &lt; a[pivot]</span><br><span class="line"></span><br><span class="line">      交换 (i, 存储索引); 存储索引++;</span><br><span class="line"></span><br><span class="line">  交换(pivot, 存储索引 - 1)</span><br></pre></td></tr></table></figure>
<h5 id="5-c-代码实现："><a class="header-anchor" href="#5-c-代码实现："></a>5. c++代码实现：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序的优化算法：三数中值法："><a class="header-anchor" href="#快速排序的优化算法：三数中值法："></a>快速排序的优化算法：三数中值法：</h4>
<h5 id="原理："><a class="header-anchor" href="#原理："></a>原理：</h5>
<p>先取待排序序列的首位、中位和末尾数进行排序，而后取三个值当中的中值作为枢纽元。</p>
<h5 id="cpp代码实现"><a class="header-anchor" href="#cpp代码实现"></a>cpp代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">median3</span><span class="params">(<span class="type">int</span> arr[].<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据量超过3时采取该算法</span></span><br><span class="line">    <span class="keyword">if</span>(right - left<span class="number">+1</span> &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="type">int</span> center = (left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[center] &lt; arr[left])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,center,left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[center] &gt; arr[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,center,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据量极小时(3个数据时)：</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,left,right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a class="header-anchor" href="#堆排序"></a>堆排序</h4>
<h5 id="原理-v4"><a class="header-anchor" href="#原理-v4"></a>原理</h5>
<ol>
<li>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
</li>
<li>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</li>
</ul>
</li>
</ol>
<h5 id="算法步骤-v4"><a class="header-anchor" href="#算法步骤-v4"></a>算法步骤</h5>
<ol>
<li>创建一个堆 H[0……n-1]，建立大顶堆。完成后，最大元素位于堆顶；</li>
<li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元 素数量加 1 ；</li>
<li>从堆顶元素开始，从顶到底执行堆化操作（Sift Down），完成堆化后，堆的性质得到修复；</li>
<li>循环执行第 2. 和 3. 步。循环 𝑛 − 1 轮后，即可完成数组排序。</li>
</ol>
<h5 id="算法特性-v4"><a class="header-anchor" href="#算法特性-v4"></a>算法特性</h5>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、非自适应排序：建堆操作使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。从堆中提取最大元素的时间复杂 度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(log 𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，共循环 𝑛 − 1 轮。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 、原地排序：几个指针变量使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 空间。元素交换和堆化操作都是在原数组上进 行的。</li>
<li>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li>
</ul>
<h5 id="伪代码-v4"><a class="header-anchor" href="#伪代码-v4"></a>伪代码</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现-v4"><a class="header-anchor" href="#c-代码实现-v4"></a>c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立父節點指標和子節點指標</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子節點指標在範圍內才做比較</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Theta-N-K-排序算法"><a class="header-anchor" href="#Theta-N-K-排序算法"></a><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N+K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> 排序算法</h3>
<h4 id="计数排序"><a class="header-anchor" href="#计数排序"></a>计数排序</h4>
<h5 id="原理-v5"><a class="header-anchor" href="#原理-v5"></a>原理</h5>
<ol>
<li>个人理解就是一个哈希表</li>
<li>「计数排序 Counting Sort」通过统计元素数量来实现排序，通常应用于整数数组。</li>
<li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
</ol>
<h5 id="算法步骤-v5"><a class="header-anchor" href="#算法步骤-v5"></a>算法步骤</h5>
<ol>
<li>遍历数组，找出数组中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚 + 1 的辅助数组 counter 。</li>
<li>借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法 很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加 1 即可。</li>
<li>由于 counter 的各个索引天然有序，因此相当于所有数字已经被排序好了。接下来，我们遍历 counter ，根据各数字的出现次数，将它们按从小到大的顺序填入 nums 即可。</li>
</ol>
<h5 id="算法特性-v5"><a class="header-anchor" href="#算法特性-v5"></a>算法特性</h5>
<ul>
<li>当输入的元素是n个0到k之间的整数时，它的运行时间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
<li>时间复杂度 𝑂(𝑛 + 𝑚) ：涉及遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 和遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">counter</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span> ，都使用线性时间。一般情况下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>≫</mo><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑛 ≫ 𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，时 间复杂度趋于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑚</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 + 𝑚)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 、非原地排序：借助了长度分别为 𝑛 和 𝑚 的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">res</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">counter</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span> 。</li>
<li>稳定排序：由于向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">res</span></span></span></span> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 可以避免改变相等元 素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 也可以得到正确的排序结果，但结果 是非稳定的。</li>
</ul>
<h5 id="伪代码-v5"><a class="header-anchor" href="#伪代码-v5"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">创建关键值（计数）数组</span><br><span class="line">遍历数列中的每个元素</span><br><span class="line">相应的计数器增加 1</span><br><span class="line">每轮计数，都从最小的值开始</span><br><span class="line">当计数为非零数时</span><br><span class="line">重新将元素存储于列表</span><br><span class="line">将计数减1</span><br></pre></td></tr></table></figure>
<h5 id="c代码实现"><a class="header-anchor" href="#c代码实现"></a>c代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(arr, n);</span><br><span class="line">        <span class="built_in">counting_sort</span>(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="桶排序"><a class="header-anchor" href="#桶排序"></a>桶排序</h4>
<h5 id="原理-v6"><a class="header-anchor" href="#原理-v6"></a>原理</h5>
<ol>
<li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
</li>
<li>「桶排序 Bucket Sort」是分治思想的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</li>
</ol>
<h5 id="算法步骤-v6"><a class="header-anchor" href="#算法步骤-v6"></a>算法步骤</h5>
<p>考虑一个长度为 𝑛 的数组，元素是范围 [0, 1) 的浮点数。桶排序的流程如下：</p>
<ol>
<li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li>
<li>对每个桶分别执行排序（本文采用编程语言的内置排序函数）。</li>
<li>按照桶的从小到大的顺序，合并结果。</li>
</ol>
<h5 id="算法特性-v6"><a class="header-anchor" href="#算法特性-v6"></a>算法特性</h5>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑘</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 + 𝑘)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>𝑛</mi><mi>𝑘</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{𝑛}{𝑘}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。假设排序单 个桶使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mfrac><mi>𝑛</mi><mi>𝑘</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mi>𝑛</mi><mi>𝑘</mi></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂( \frac{𝑛}{𝑘} log(\frac{𝑛}{𝑘}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">))</span></span></span></span> 时间，则排序所有桶使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mi>𝑛</mi><mi>𝑘</mi></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛log(\frac{𝑛}{𝑘}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">))</span></span></span></span> 时间。当<strong>桶数量 𝑘 比较大时，时间复杂度则趋向于</strong> $𝑂(𝑛) $。合并结果时需要遍历所有桶和元素，花费 $𝑂(𝑛 + 𝑘) $时间。</li>
<li>自适应排序：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 $𝑂(𝑛^2 ) $时间。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑘</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 + 𝑘)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 、非原地排序：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ul>
<h5 id="伪代码-v6"><a class="header-anchor" href="#伪代码-v6"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现-v5"><a class="header-anchor" href="#c-代码实现-v5"></a>c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">        ListNode* mNext;</span><br><span class="line">        <span class="type">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *pre,*curr;</span><br><span class="line">        dummyNode.mNext = head;</span><br><span class="line">        pre = &amp;dummyNode;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;mNext = curr;</span><br><span class="line">        pre-&gt;mNext = newNode;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *dummy = &amp;dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">                        dummy-&gt;mNext = head1;</span><br><span class="line">                        head1 = head1-&gt;mNext;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dummy-&gt;mNext = head2;</span><br><span class="line">                        head2 = head2-&gt;mNext;</span><br><span class="line">                &#125;</span><br><span class="line">                dummy = dummy-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="type">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">                ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">                buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">                head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                arr[i] = head-&gt;mData;</span><br><span class="line">                head = head-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Theta-N-times-K-排序算法"><a class="header-anchor" href="#Theta-N-times-K-排序算法"></a><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N \times K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> 排序算法</h3>
<h4 id="基数排序"><a class="header-anchor" href="#基数排序"></a>基数排序</h4>
<h5 id="原理-v7"><a class="header-anchor" href="#原理-v7"></a>原理</h5>
<ol>
<li>两次哈希表的应用，将一个数拆分成基数形式表示，通过基数进行分配比较</li>
<li>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
<li>「基数排序 Radix Sort」的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</li>
</ol>
<h5 id="算法步骤-v7"><a class="header-anchor" href="#算法步骤-v7"></a>算法步骤</h5>
<p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的步骤如下：</p>
<ol>
<li>初始化位数 𝑘 = 1 。</li>
<li>对学号的第 𝑘 位执行「计数排序」。完成后，数据会根据第 𝑘 位从小到大排序。</li>
<li>将 𝑘 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<h5 id="算法特性-v7"><a class="header-anchor" href="#算法特性-v7"></a>算法特性</h5>
<p>相较于计数排序，基数排序适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位 数不能过大。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mi>𝑘</mi><mo stretchy="false">)</mo><mo>≫</mo><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛𝑘) ≫ 𝑂(𝑛2 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 。</p>
<ul>
<li>时间复杂度 𝑂(𝑛𝑘) ：设数据量为 𝑛 、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑑</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 + 𝑑)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> 时间，排序所有 𝑘 位使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑑</mi><mo stretchy="false">)</mo><mi>𝑘</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂((𝑛 + 𝑑)𝑘)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo>+</mo><mi>𝑑</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛 + 𝑑)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> 、非原地排序：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">res</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">counter</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span> 。</li>
<li>稳定排序：与计数排序相同。</li>
</ul>
<h5 id="伪代码-v7"><a class="header-anchor" href="#伪代码-v7"></a>伪代码</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">分别给每个数位（0到9）创造1个桶（数列），共计10个</span><br><span class="line">遍历每个数位</span><br><span class="line">遍历数列中的每个元素</span><br><span class="line">将元素移至相应的桶中</span><br><span class="line">在每个桶中，从最小的数位开始</span><br><span class="line">当桶不是空的</span><br><span class="line">将元素恢复至数列中</span><br></pre></td></tr></table></figure>
<h5 id="c-代码实现-v6"><a class="header-anchor" href="#c-代码实现-v6"></a>c++代码实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span></span>&#123; <span class="comment">//辅助函数，求数据的最大位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];              <span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*    int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构设计复习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="软件架构设计期末复习"><a class="header-anchor" href="#软件架构设计期末复习"></a>软件架构设计期末复习</h1>
<h2 id="CH1-软件架构"><a class="header-anchor" href="#CH1-软件架构"></a>CH1 <strong>软件架构</strong></h2>
<h3 id="Software-Architecture-软件-架构"><a class="header-anchor" href="#Software-Architecture-软件-架构"></a>Software Architecture 软件&amp;架构</h3>
<p><strong>什么是软件体系结构</strong>：系统的软件体系结构是对系统推理的一组结构，包括软件元素、它们之间的关系</p>
<p>以及两者的属性。</p>
<h3 id="架构即即是一种软件结构"><a class="header-anchor" href="#架构即即是一种软件结构"></a>架构即即是一种软件结构</h3>
<p>一系列的元素由某种关系串联起来构成一个结构 <strong>structure</strong></p>
<p>一个软件系统由许多的<strong>structure</strong>构成（单一个结构无法称之为架构）</p>
<h3 id="Architecture-架构"><a class="header-anchor" href="#Architecture-架构"></a>Architecture <strong>架构</strong></h3>
<h4 id="三个重要特征："><a class="header-anchor" href="#三个重要特征："></a>三个重要特征：</h4>
<ol>
<li><strong>Module 模块</strong></li>
</ol>
<ul>
<li>一些结构将系统划分为实现单元，我们称之为模块。</li>
<li>模块被分配具体的计算责任，并且是编程团队工作任务的基础。</li>
<li>在大型项目中，这些元素（模块）会被进一步划分，以便分配给子团队。</li>
</ul>
<ol start="2">
<li><strong>Component and Connector 组件和连接器</strong></li>
</ol>
<ul>
<li>
<p>其他结构关注于元素在<strong>运行时</strong>相互交互的方式，以执行系统的功能。这种运行时结构称之为<strong>Component and Connector (C&amp;C)结构 组件和连接器</strong>。</p>
</li>
<li>
<p>实际应用中，组件基本上都是运行时实体</p>
</li>
</ul>
<ol start="3">
<li><strong>Allocation</strong> <strong>分配</strong></li>
</ol>
<ul>
<li>
<p>分配结构描述了从软件结构到系统环境的映射</p>
</li>
<li>
<p>分配结构描述了软件系统的物理部署和资源管理，通常涉及如何将模块和组件映射到硬件资源上。这有助于优化系统性能和资源利用。</p>
</li>
</ul>
<h4 id="什么样的结构具有架构性"><a class="header-anchor" href="#什么样的结构具有架构性"></a>什么样的结构具有架构性</h4>
<ul>
<li>
<p>可以实现对系统和系统性质的推理的<strong>结构structure</strong>是<strong>成结构性Architectural</strong></p>
</li>
<li>
<p>这种推理应该是关于系统的某个对利益相关者来说重要的属性。</p>
</li>
<li>
<p>这些属性包括：</p>
<ul>
<li>系统实现的功能</li>
<li>系统在面对故障时的可用性</li>
<li>对系统进行特定更改的难度</li>
<li>系统对用户请求的响应速度</li>
<li>其他许多属性。</li>
</ul>
</li>
</ul>
<h3 id="任何系统都有一个软件架构"><a class="header-anchor" href="#任何系统都有一个软件架构"></a>任何系统都有一个软件架构</h3>
<p>但是这个架构可能没有为任何人所知。</p>
<ul>
<li>
<p>可能所有设计该系统的人都已经离开。</p>
</li>
<li>
<p>可能文档已经消失（或从未产生）。</p>
</li>
<li>
<p>可能源代码已丢失（或从未提交）。</p>
</li>
</ul>
<h3 id="架构是一种抽象"><a class="header-anchor" href="#架构是一种抽象"></a>架构是一种抽象</h3>
<blockquote>
<p>它着眼于系统的整体结构和关键特性，而<strong>不涉及细节实现</strong>。</p>
</blockquote>
<ul>
<li>
<p>架构会省略元素的某些信息————在推理系统方面没有作用的信息</p>
</li>
<li>
<p>架构抽象允许我们从元素如何排列、如何交互、如何组合这一角度来看待系统。</p>
</li>
<li>
<p>对于系统的抽象有利于我们降低最终系统架构的复杂性</p>
</li>
</ul>
<h3 id="架构包含行为"><a class="header-anchor" href="#架构包含行为"></a>架构包含行为</h3>
<blockquote>
<p>行为可以体现系统内元素的关系</p>
</blockquote>
<ul>
<li>
<p>在能够用于推理系统的前提下，每个元素的行为都是架构的一部分。</p>
</li>
<li>
<p>这种行为体现了元素之间的相互作用，这显然是架构定义的一部分。</p>
</li>
</ul>
<h3 id="结构与视图"><a class="header-anchor" href="#结构与视图"></a>结构与视图</h3>
<ul>
<li>
<p>视图是由系统设计参与者编写和读取的一组连贯的架构元素的表示</p>
</li>
<li>
<p>结构是元素本身的集合，本身存在于硬件或软件中</p>
</li>
<li>
<p>总结即是：视图是结构的一种表示形式</p>
</li>
<li>
<p>架构师设计结构时，使用文档记录结构的视图 views</p>
</li>
</ul>
<h3 id="模块结构"><a class="header-anchor" href="#模块结构"></a>模块结构</h3>
<ul>
<li>
<p>模块结构代表着系统是如何通过一系列代码或数据单元进行结构化的</p>
</li>
<li>
<p>在任何模块结构中，元素都是某种类系的模块(如：class、layer、或者仅是功能的划分等等，都是实现单元)</p>
</li>
</ul>
<h3 id="组件和连接器结构"><a class="header-anchor" href="#组件和连接器结构"></a>组件和连接器结构</h3>
<ul>
<li>
<p>C&amp;C结构代表着系统是如何由一系列具有运行时行为（组件）和交互（连接器）的元素进行结构化的。</p>
</li>
<li>
<p><strong>元素element</strong>是运行时的<strong>组件component</strong>，如services、peers、clients、servers等</p>
</li>
<li>
<p><strong>连接器Connector</strong>是组件<strong>组件 component</strong>间相互交流的工具，如调用-返回、进程同步操作符、管道或其他操作符</p>
</li>
</ul>
<blockquote>
<p>MapReduce 映射&amp;归约</p>
<p><strong>Map 阶段</strong>：</p>
<ul>
<li>数据切割为小的数据块</li>
</ul>
<p><strong>Shuffle和Sort阶段</strong>：</p>
<ul>
<li>Map阶段的输出会传递给Shuffle和Sort阶段。这个阶段将相同的key聚集在一起并排序，为Reduce阶段做准备。</li>
</ul>
<p><strong>Reduce阶段</strong>：</p>
<ul>
<li>Reduce阶段会接收来自Shuffle和Sort的中间结果，进行归约计算。Reduce任务会对相同的key的&lt;key, value&gt;对进行处理，将它们合并成最终结果。</li>
<li>举例：在单词统计中，Reduce阶段会将相同单词的1相加，计算出每个单词的总次数，如 &lt;单词, 总次数&gt; 。</li>
</ul>
</blockquote>
<h3 id="分配结构"><a class="header-anchor" href="#分配结构"></a>分配结构</h3>
<ul>
<li>
<p>展示软件系统的逻辑设计与物理资源之间的映射关系。描述了如何将系统的模块和组件分配到硬件、网络和组织等实际环境中，从而体现系统的物理部署方式、资源使用和依赖关系。</p>
</li>
<li>
<p>主要关注系统如何与外部环境交互以及如何利用资源</p>
</li>
</ul>
<h4 id="分配结构包含以下三种视角："><a class="header-anchor" href="#分配结构包含以下三种视角："></a>分配结构包含以下三种视角：</h4>
<p><strong>部署视图 Deployment View</strong></p>
<h3 id="常见的模块结构"><a class="header-anchor" href="#常见的模块结构"></a>常见的模块结构</h3>
<h4 id="分解结构-Decomposition-structure"><a class="header-anchor" href="#分解结构-Decomposition-structure"></a>分解结构 Decomposition-structure</h4>
<ul>
<li>
<p>用来展示模块是如何被划分成更小的模块的</p>
</li>
<li>
<p>分解结构在很大程度上决定了系统的可修改性，通过确保可能的变化是局部的。</p>
</li>
</ul>
<h4 id="使用结构-Uses-structure"><a class="header-anchor" href="#使用结构-Uses-structure"></a>使用结构 Uses-structure</h4>
<ul>
<li>
<p>每一个在使用模块中的<strong>unit</strong>也是模块</p>
</li>
<li>
<p>单元间的联系是以使用与被使用，是依赖与被依赖的形式</p>
</li>
<li>
<p>如果<strong>A单元</strong>的合法使用需要使用到<strong>B单元</strong>的某个正确版本的功能，则说明：A单元正在使用B单元</p>
</li>
<li>
<p>轻松创建系统子集的能力允许进行增量开发。</p>
</li>
</ul>
<h4 id="分层结构-Layer-structure"><a class="header-anchor" href="#分层结构-Layer-structure"></a>分层结构 Layer-structure</h4>
<ul>
<li>
<p>每一个模块都称为<strong>层</strong> <strong>layer</strong></p>
</li>
<li>
<p><strong>层</strong>被抽象为<strong>虚拟机</strong> <strong>virtual machine</strong>，通过接口提供一组内聚的服务</p>
</li>
<li>
<p>层以预先设定好的接口去使用其他的层，</p>
</li>
</ul>
<h4 id="类（或泛化）结构-Class-or-generalization-structure"><a class="header-anchor" href="#类（或泛化）结构-Class-or-generalization-structure"></a>类（或泛化）结构 Class (or generalization) structure</h4>
<h4 id="数据模型结构-Data-model-structure"><a class="header-anchor" href="#数据模型结构-Data-model-structure"></a>数据模型结构 Data model structure</h4>
<h4 id="服务结构-Service-structure"><a class="header-anchor" href="#服务结构-Service-structure"></a>服务结构 Service structure</h4>
<h4 id="并发结构-Concurrency-structure"><a class="header-anchor" href="#并发结构-Concurrency-structure"></a>并发结构 Concurrency structure</h4>
<h3 id="常见的分配结构"><a class="header-anchor" href="#常见的分配结构"></a>常见的分配结构</h3>
<h4 id="部署结构-Deployment-structure"><a class="header-anchor" href="#部署结构-Deployment-structure"></a>部署结构 Deployment structure</h4>
<h4 id="实施结构-Implementation-structure"><a class="header-anchor" href="#实施结构-Implementation-structure"></a>实施结构 Implementation structure</h4>
<h4 id="工作分配结构-Work-assignment-structure"><a class="header-anchor" href="#工作分配结构-Work-assignment-structure"></a>工作分配结构 Work assignment structure</h4>
<h4 id="架构模式-Architectural-Patterns"><a class="header-anchor" href="#架构模式-Architectural-Patterns"></a>架构模式 Architectural Patterns</h4>
<h2 id="CH2-为什么需要软件架构"><a class="header-anchor" href="#CH2-为什么需要软件架构"></a>CH2 为什么需要软件架构</h2>
<h3 id="禁止或启用系统的质量属性"><a class="header-anchor" href="#禁止或启用系统的质量属性"></a>禁止或启用系统的质量属性</h3>
<ul>
<li>
<p>系统是否能够展示其期望的（或必需的）质量属性在很大程度上取决于其体系结构。</p>
<ul>
<li>
<p>性能</p>
</li>
<li>
<p>可修改性</p>
</li>
<li>
<p>安全性</p>
</li>
<li>
<p>可扩展性</p>
</li>
<li>
<p>可重用性</p>
</li>
</ul>
</li>
</ul>
<h3 id="推理和管理变更"><a class="header-anchor" href="#推理和管理变更"></a>推理和管理变更</h3>
<ul>
<li>
<p>每个体系结构都将可能的更改划分为三类</p>
<ul>
<li>局部变更可以通过修改单个元素来实现</li>
<li>非局部的变更需要修改多个元素，但会保留底层框架</li>
<li>整个软件框架的变更，会影响元素相互作用的基本方式</li>
</ul>
</li>
<li>
<p>综上，局部的变更是最节约成本的，因此一个好的框架需要具备：最常见的更改是局部的</p>
</li>
</ul>
<h3 id="最早的设计决定"><a class="header-anchor" href="#最早的设计决定"></a>最早的设计决定</h3>
<ul>
<li>
<p>软件体系结构即是关于系统的最早设计决策的表现。</p>
</li>
<li>
<p>这些早期决策会影响系统的剩余开发、部署和维护寿命</p>
</li>
</ul>
<h3 id="定义在实现-Implementation-上的约束"><a class="header-anchor" href="#定义在实现-Implementation-上的约束"></a>定义在实现(Implementation)上的约束</h3>
<ul>
<li>
<p>如果实现符合体系结构规定的设计决策，则会展示一个体系结构。</p>
<ul>
<li>
<p>该实现必须作为规定的元素的集合来实现</p>
</li>
<li>
<p>这些元素必须以规定的方式相互作用</p>
</li>
</ul>
</li>
<li>
<p>每个计划都是对实现者的约束</p>
</li>
</ul>
<h3 id="体系结构影响着系统的组织结构"><a class="header-anchor" href="#体系结构影响着系统的组织结构"></a>体系结构影响着系统的组织结构</h3>
<ul>
<li>
<p>架构规定了正在开发中的系统的结构选择</p>
</li>
<li>
<p>架构通常作为 work-breakdown 结构的基础</p>
</li>
<li>
<p>而 work-breakdown 结构又可以反作用于：</p>
<ul>
<li>
<p>计划、计划和预算的单位</p>
</li>
<li>
<p>团队间通信渠道</p>
</li>
<li>
<p>配置和文件系统的组织结构</p>
</li>
<li>
<p>集成和测试计划和程序</p>
</li>
<li>
<p>维护活动</p>
</li>
</ul>
</li>
</ul>
<h3 id="定义好的架构可以作为系统骨架的原型"><a class="header-anchor" href="#定义好的架构可以作为系统骨架的原型"></a>定义好的架构可以作为系统骨架的原型</h3>
<ul>
<li>
<p>骨架系统是指在系统的大部分功能创建之前至少构建一些基础设施。</p>
</li>
<li>
<p>当原型部件被这些部件的完整版本替换时，系统的保真度就会提高</p>
</li>
<li>
<p>这种方法有助于开发过程，因为该系统在产品生命周期的早期就是可执行的。</p>
</li>
<li>
<p>这种方法允许在产品生命周期的早期发现潜在的性能问题</p>
</li>
<li>
<p>这些好处降低了项目中的潜在风险</p>
</li>
</ul>
<h3 id="有利于优化成本、开发进度的预估"><a class="header-anchor" href="#有利于优化成本、开发进度的预估"></a>有利于优化成本、开发进度的预估</h3>
<ul>
<li>
<p>体系结构用于帮助项目经理在项目生命周期的早期创建成本和进度估算。</p>
</li>
<li>
<p>自上而下的估计数对于制定目标和分配预算很有用</p>
</li>
<li>
<p>自下而上的对系统各个部分的理解通常比那些纯粹基于自上而下的系统知识的理解更准确</p>
</li>
<li>
<p>最佳的成本和进度计划估算通常来自于自上而下的估算（由架构师和项目经理创建）和自下而上的估算（由开发人员创建）之间的共识。</p>
</li>
</ul>
<h3 id="可转换、可重用模型"><a class="header-anchor" href="#可转换、可重用模型"></a>可转换、可重用模型</h3>
<ul>
<li>
<p>体系结构的重复使用为具有类似需求的系统提供了巨大的好处。</p>
<ul>
<li>
<p>不仅可以重用代码，而且首先导致架构的需求也可以重用代码</p>
</li>
<li>
<p>当体系结构决策可以跨多个系统重用时，所有的早期决策结果也会被转移</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用独立开发的组件"><a class="header-anchor" href="#使用独立开发的组件"></a>使用独立开发的组件</h3>
<ul>
<li>
<p>基于体系结构的开发通常关注可能单独开发，甚至独立开发的组件</p>
</li>
<li>
<p>商业现成的组件、开源软件、公开可用的应用程序和网络服务都是可互换的软件组件的例子</p>
</li>
<li>
<p>回报可以是</p>
<ul>
<li>
<p>减少上市时间</p>
</li>
<li>
<p>提高可靠性</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH4-质量属性"><a class="header-anchor" href="#CH4-质量属性"></a>CH4 质量属性</h2>
<h3 id="架构与需求"><a class="header-anchor" href="#架构与需求"></a>架构与需求</h3>
<h4 id="系统的需求可以大致分类为："><a class="header-anchor" href="#系统的需求可以大致分类为："></a>系统的需求可以大致分类为：</h4>
<ul>
<li>
<p><strong>功能需求</strong>：说明系统必须做什么，它必须如何对运行时行为或刺激反应。</p>
</li>
<li>
<p><strong>质量属性需求</strong>：确定功能需求，例如，功能执行的速度，功能对错误输入的弹性等。</p>
</li>
<li>
<p><strong>约束</strong>：约束是一个具有零自由度的设计决策</p>
</li>
</ul>
<h3 id="功能性-functionality"><a class="header-anchor" href="#功能性-functionality"></a>功能性 functionality</h3>
<ul>
<li>
<p>功能是指系统完成其预期的工作的能力</p>
</li>
<li>
<p>功能与架构有一种奇怪的关系：功能并不决定体系结构</p>
</li>
</ul>
<h3 id="质量属性分类"><a class="header-anchor" href="#质量属性分类"></a>质量属性分类</h3>
<h4 id="运行时属性"><a class="header-anchor" href="#运行时属性"></a>运行时属性</h4>
<p>这些属性关注系统在运行时的行为和性能，包括：</p>
<ol>
<li><strong>性能</strong>：系统在特定时间内完成任务的能力，包括响应时间、吞吐量、资源使用等。</li>
</ol>
<ul>
<li>
<p>指标：响应时间、延迟、吞吐量。</p>
</li>
<li>
<p>方法：缓存、负载均衡、并行处理。</p>
</li>
</ul>
<ol start="2">
<li><strong>可用性</strong>：系统在特定时间内可以正常运行的能力。</li>
</ol>
<ul>
<li>
<p>指标：系统故障间隔时间（MTBF）、恢复时间（MTTR）。</p>
</li>
<li>
<p>方法：冗余设计、热备份、故障检测与切换。</p>
</li>
</ul>
<ol start="3">
<li><strong>安全性</strong>：保护数据和系统资源免受未经授权访问的能力。</li>
</ol>
<ul>
<li>
<p>指标：攻击成功率、数据泄露数量。</p>
</li>
<li>
<p>方法：身份认证、加密、访问控制。</p>
</li>
</ul>
<ol start="4">
<li><strong>可扩展性</strong>：系统随着需求变化，能够处理增长的用户数或数据量的能力。</li>
</ol>
<ul>
<li>
<p>指标：水平扩展的节点数、垂直扩展的性能增幅。</p>
</li>
<li>
<p>方法：分布式架构、分片。</p>
</li>
</ul>
<ol start="5">
<li><strong>可靠性</strong>：系统在规定时间内完成任务的能力。</li>
</ol>
<ul>
<li>
<p>指标：故障率、成功执行任务比例。</p>
</li>
<li>
<p>方法：异常处理、事务管理</p>
</li>
</ul>
<h4 id="非运行时属性"><a class="header-anchor" href="#非运行时属性"></a>非运行时属性</h4>
<p>这些属性关注系统的开发、维护和部署等非运行时特性，包括：</p>
<ol>
<li><strong>可维护性</strong>：系统被修改以适应新需求、修复缺陷的难易程度。</li>
</ol>
<ul>
<li>方法：模块化设计、清晰的接口、代码可读性。</li>
</ul>
<ol start="2">
<li><strong>可部署性</strong>：系统能否快速部署、更新和回滚。</li>
</ol>
<ul>
<li>方法：自动化部署、蓝绿部署、滚动升级。</li>
</ul>
<ol start="3">
<li><strong>可测试性</strong>：系统能否方便地进行测试。</li>
</ol>
<ul>
<li>方法：单元测试覆盖率、模拟器（Mock）工具、测试自动化框架。</li>
</ul>
<ol start="4">
<li><strong>可移植性</strong>：系统在不同环境或平台上的运行能力。</li>
</ol>
<ul>
<li>方法：容器化（如Docker）、跨平台设计。</li>
</ul>
<ol start="5">
<li><strong>互操作性</strong>：系统与其他系统或组件协同工作的能力。</li>
</ol>
<ul>
<li>方法：标准化协议、API设计。</li>
</ul>
<h3 id="质量属性需求-quality-attribute-requirements"><a class="header-anchor" href="#质量属性需求-quality-attribute-requirements"></a>质量属性需求 quality attribute requirements</h3>
<h4 id="质量需求考虑-quality-attribute-considerations"><a class="header-anchor" href="#质量需求考虑-quality-attribute-considerations"></a>质量需求考虑 quality-attribute-considerations</h4>
<ul>
<li>
<p>如果一个功能性需求是“当用户按下绿色按钮时，选项对话框出现”：</p>
<ul>
<li>
<p>性能(performance qualification) 要求可能描述对话框出现的速度；</p>
</li>
<li>
<p>可用性要求(availability qualification) 可能描述这个功能会出现故障的频率以及修复的速度；</p>
</li>
<li>
<p>易用性要求(usability qualification) 可能描述学习这个功能的简易程度。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>两类质量属性</p>
<ul>
<li>
<p>描述系统在运行时的一些属性</p>
<ul>
<li>可用性、性能、易用性、安全性</li>
</ul>
</li>
<li>
<p>描述系统开发过程中的一些属性</p>
<ul>
<li>可修改性、可测试性</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>在之前关于质量属性的讨论中存在一些问题：</p>
<ul>
<li>
<p>不可测试的定义(Untestable definitions)。对某个属性提供的定义无法进行测试。说一个系统将是“可修改的”是没有意义的。</p>
</li>
<li>
<p>重叠的问题(Overlapping concerns)。系统故障是由于拒绝服务攻击还是与可用性、性能、安全性或可用性相关？</p>
</li>
</ul>
</li>
<li>
<p>解决这些问题（不可测试的定义和重叠的问题）的方法是使用质量属性场景来描述质量属性。</p>
</li>
</ul>
<h4 id="指定质量属性需求"><a class="header-anchor" href="#指定质量属性需求"></a>指定质量属性需求</h4>
<ul>
<li>
<p>我们使用一种通用形式，将所有质量属性需求都指定为场景。</p>
</li>
<li>
<p>我们对质量属性场景的表示包括以下几个部分：</p>
<ol>
<li>刺激（Stimulus）。刺激是一种在到达系统时需要产生响应的条件。</li>
<li>刺激源（Source of stimulus）。刺激源是某个实体（人、计算机系统或其他执行器），它产生了刺激。</li>
<li>响应（Response）。响应是作为刺激到达后所进行的活动。</li>
<li>响应度量（Response measure）。当响应发生时，应该以某种方式进行度量，以便对需求进行测试。</li>
<li>环境（Environment）。刺激发生在特定条件下。系统可能处于超负荷状态、正常运行状态或其他相关状态。</li>
<li>构件（Artifact）。这可以是一组系统、整个系统或其中的某个部分。某个构件被刺激。</li>
</ol>
</li>
<li>
<p>通用的质量属性场景(General quality attribute scenarios) 与具体的系统无关，可能适用于任何系统。</p>
</li>
<li>
<p>具体的质量属性场景(Concrete quality attribute scenarios) 则针对具体考虑的系统而定。</p>
</li>
</ul>
<h4 id="通过决策实现质量属性"><a class="header-anchor" href="#通过决策实现质量属性"></a>通过决策实现质量属性</h4>
<ul>
<li>
<p>架构师可以使用一系列基本的设计技术来实现质量属性响应。</p>
</li>
<li>
<p>我们将这些基本设计技术称为架构设计策略。</p>
</li>
<li>
<p>策略和设计模式一样，是架构师多年来一直在使用的技术。</p>
</li>
<li>
<p>我们并不是发明策略，而是简单地捕捉架构师在实践中所做的事情。例如资源调度就是用于性能的一种策略：</p>
<ul>
<li>
<p>给定条件：发布时间，每个任务的工作量</p>
</li>
<li>
<p>过程：确定每个任务何时执行</p>
</li>
<li>
<p>目标：最小化任务的平均完成时间</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>策略 vs. 架构模式</p>
<ul>
<li>
<p>策略是针对单个质量属性的设计决策。</p>
</li>
<li>
<p>策略不考虑质量属性之间的权衡。</p>
</li>
<li>
<p>架构模式可以被看作是策略的“套餐”，其中考虑了质量属性之间的权衡。</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>我们需要对策略进行隔离、分类和描述。为什么要这样做？</p>
<ul>
<li>
<p>设计模式往往很复杂，并且很难直接应用；架构师需要对它们进行修改和适应。</p>
</li>
<li>
<p>如果没有现有的模式来实现架构师的设计目标，策略可以让架构师从“首要原则”构建设计片段。</p>
</li>
<li>
<p>通过对策略进行分类，我们可以在改进特定质量属性时选择多种策略。选择使用哪些策略取决于诸如实施成本等因素。</p>
</li>
</ul>
</li>
</ul>
<h4 id="指导质量设计决策"><a class="header-anchor" href="#指导质量设计决策"></a>指导质量设计决策</h4>
<ul>
<li>架构设计是一种系统化的设计决策方法。</li>
<li>我们将设计决策分为以下几类：
<ol>
<li>职责分配(Allocation of responsibilities)</li>
<li>协调模型(Coordination model)</li>
<li>数据模型(Data model)</li>
<li>资源管理(Management of resources)</li>
<li>架构元素之间的映射(Mapping among architectural elements)</li>
<li>绑定时间决策(Binding time decisions)</li>
<li>技术选择(Choice of technology)</li>
</ol>
</li>
</ul>
<h4 id="指责分配"><a class="header-anchor" href="#指责分配"></a>指责分配</h4>
<ul>
<li>
<p>包括职责分配的决策内容：</p>
<ul>
<li>
<p>确定职责，包括基本系统功能、架构基础设施和满足质量属性。</p>
</li>
<li>
<p>确定如何将这些职责分配给非运行时和运行时元素（即模块、组件和连接器）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="协调模型"><a class="header-anchor" href="#协调模型"></a>协调模型</h4>
<p>关于协调模型的决策包括：</p>
<ul>
<li>
<p>确定系统中需要进行<strong>协调或禁止协调</strong>的元素。</p>
</li>
<li>
<p>确定协调的属性，例如<strong>及时性、实时性、正确性和一致性</strong>。</p>
</li>
<li>
<p>选择实现这些属性的通信机制。</p>
<ul>
<li>
<p>有状态 vs 无状态</p>
</li>
<li>
<p>同步 vs 异步</p>
</li>
<li>
<p>有保证 vs 无保证的传递</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据模型"><a class="header-anchor" href="#数据模型"></a>数据模型</h4>
<p>关于数据模型的决策包括：</p>
<ul>
<li>
<p><strong>选择主要的数据抽象、它们的操作和属性</strong>。</p>
<ul>
<li><strong>数据抽象</strong>：指的是数据的基本表现形式或模型，描述了系统如何抽象地表示和处理数据。例如，数据可以抽象为实体（如用户、订单）、关系（如用户与订单之间的关系）或文档（如JSON文档）。</li>
<li><strong>操作</strong>：指系统能够对数据执行的行为或操作，例如增删改查（CRUD 操作）、事务操作（如提交和回滚）、复杂查询（如聚合计算）。</li>
<li><strong>属性</strong>：描述与数据相关的细节，如数据字段及其数据类型。例如，用户实体可以有属性如用户名（字符串）、年龄（整数）和注册日期（日期类型）。</li>
<li><strong>决策点</strong>：
<ul>
<li>
<p>确定哪些实体是核心数据对象，以及这些对象如何交互。</p>
</li>
<li>
<p>定义实体的字段和字段类型，以及这些字段是否需要验证规则（如长度限制、唯一性）。</p>
</li>
<li>
<p>决定支持哪些基本和高级操作，例如是否需要全文搜索、批量更新等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据一致解释所需的元数据</strong>。</p>
<ul>
<li>
<p><strong>元数据</strong>：是描述数据的数据，用于定义数据的结构、约束、语义以及解释规则。</p>
<ul>
<li>
<p>结构：定义表或文档的字段及其类型。</p>
</li>
<li>
<p>约束：定义字段的限制条件，如非空、唯一性等。</p>
</li>
<li>
<p>语义：说明数据的含义，如字段的业务意义或其作用。</p>
</li>
</ul>
</li>
<li>
<p>数据的一致解释：确保不同系统组件或用户对同一数据有统一的理解。元数据有助于标准化数据的存储和使用方式。</p>
</li>
<li>
<p><strong>决策点</strong>：</p>
<ul>
<li>
<p>定义元数据的存储方式，例如作为数据库中的元表存储，或以JSON Schema等格式嵌入系统中。</p>
</li>
<li>
<p>确保系统设计文档中明确数据模型的元数据，以便开发和维护人员理解数据的语义和约束。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据的组织方式，即决定数据是保存在关系型数据库、对象集合还是两者兼有</strong>。</p>
<ul>
<li><strong>决策点</strong>：
<ul>
<li>
<p>选择数据库类型：关系型、非关系型或两者结合。</p>
</li>
<li>
<p>决定数据的存储模式：结构化数据（表格形式）还是半结构化/非结构化数据（JSON文档、文件形式）。</p>
</li>
<li>
<p>考虑数据的存取需求：如事务一致性、高可用性、查询复杂度、扩展性。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="资源管理"><a class="header-anchor" href="#资源管理"></a>资源管理</h4>
<ul>
<li>
<p>资源管理的决策包括：</p>
<ul>
<li>
<p>确定需要管理的资源，并确定每个资源的限制。</p>
</li>
<li>
<p>确定哪个系统元素管理每个资源。</p>
</li>
<li>
<p>确定资源共享的方式以及在资源争用时采用的策略。</p>
</li>
<li>
<p>确定饱和对不同资源的影响</p>
</li>
</ul>
</li>
</ul>
<h4 id="架构元素间的映射"><a class="header-anchor" href="#架构元素间的映射"></a>架构元素间的映射</h4>
<ul>
<li>
<p>有用的映射包括：</p>
<ul>
<li>
<p>模块和运行时元素之间的映射。</p>
</li>
<li>
<p>将运行时元素分配给处理器。</p>
</li>
<li>
<p>将数据模型中的项分配给数据存储。</p>
</li>
<li>
<p>将模块和运行时元素映射到交付单元</p>
</li>
</ul>
</li>
</ul>
<h4 id="绑定时间决策"><a class="header-anchor" href="#绑定时间决策"></a>绑定时间决策</h4>
<ul>
<li>
<p>其他类别中的决策都与绑定时间决策相关。此类绑定时间决策的示例包括：</p>
<ul>
<li>
<p>构建时间 vs. 运行时间</p>
</li>
<li>
<p>对于协调模型的选择，您可以设计运行时协议的协商。</p>
</li>
<li>
<p>对于资源管理，您可以设计一个系统，在运行时接受新的外设设备插入</p>
</li>
</ul>
</li>
</ul>
<h4 id="技术选择"><a class="header-anchor" href="#技术选择"></a>技术选择</h4>
<ul>
<li>
<p>技术选择决策涉及：</p>
<ul>
<li>
<p>决定哪些技术可用来实现在其他类别中做出的决策。</p>
</li>
<li>
<p>确定支持该技术的工具（IDE、模拟器、测试工具等）是否足够。</p>
</li>
<li>
<p>确定对该技术的内部熟悉程度和外部支持程度（例如课程、教程、示例、承包商的可用性）。</p>
</li>
<li>
<p>确定选择某项技术的副作用，如所需的协调模型或受限的资源管理机会。</p>
</li>
<li>
<p>确定新技术是否与现有技术堆栈兼容。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CH5-可用性"><a class="header-anchor" href="#CH5-可用性"></a>CH5 可用性</h2>
<h3 id="可用性-availability"><a class="header-anchor" href="#可用性-availability"></a>可用性 availability</h3>
<ul>
<li>
<p>可用性指的是软件具备在需要时随时可用并准备好执行任务的属性。</p>
</li>
<li>
<p>可用性是指系统能够<strong>掩盖或修复故障</strong>，以使累积的服务中断时间不超过指定时间间隔内的要求值。</p>
</li>
<li>
<p>可用性的目标是<strong>通过减轻故障来最小化服务中断时间</strong>。</p>
</li>
</ul>
<blockquote>
<p>可用性(<strong>Availability</strong>)与可靠性(<strong>reliability</strong>)或可信性(<strong>trustworthiness</strong>)的区别</p>
<ul>
<li>
<p>可用性包括通常所称的可靠性。</p>
</li>
<li>
<p>可用性还涵盖了其他考虑因素，例如由于定期维护导致的服务中断。</p>
</li>
<li>
<p>可用性与以下因素密切相关</p>
<ul>
<li>安全性，例如拒绝服务攻击</li>
<li>性能</li>
<li>…</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">关注点</th>
<th style="text-align:center">关键指标</th>
<th style="text-align:center">实现方法</th>
<th style="text-align:center">用户感知</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可用性</td>
<td style="text-align:center">服务是否随时可用</td>
<td style="text-align:center">可用率，停机时间</td>
<td style="text-align:center">冗余设计、自动切换、监控</td>
<td style="text-align:center">系统是否能被访问和使用</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">服务运行过程中是否出错</td>
<td style="text-align:center">平均故障间隔时间（MTBF）、故障率</td>
<td style="text-align:center">容错设计、数据校验、严格测试</td>
<td style="text-align:center">系统是否能长时间无故障运行</td>
</tr>
<tr>
<td style="text-align:center">可信性</td>
<td style="text-align:center">数据和操作结果是否值得信赖</td>
<td style="text-align:center">数据完整性、安全性、用户满意度</td>
<td style="text-align:center">加密、验证、审计</td>
<td style="text-align:center">系统提供的结果和数据是否可靠</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="可用性决策的目标"><a class="header-anchor" href="#可用性决策的目标"></a>可用性决策的目标</h3>
<blockquote>
<p>故障(Fault) vs 失败(Failure)？</p>
<ul>
<li>
<p>失败发生在系统不再按照其规范提供服务时</p>
<ul>
<li>此故障可以被系统的参与者观察到。</li>
</ul>
</li>
<li>
<p>故障（或故障的组合）有可能导致失败。</p>
</li>
</ul>
</blockquote>
<p>可用性策略使系统能够忍受故障，以便服务保持符合其规格说明。这些策略可以防止故障导致失败，或至少限制故障的影响，并使修复成为可能。</p>
<h4 id="检测故障-detect-faults"><a class="header-anchor" href="#检测故障-detect-faults"></a>检测故障 detect-faults</h4>
<ul>
<li>
<p><strong>Ping/echo</strong>：用于确定与相关网络路径的连通性和往返延迟。</p>
</li>
<li>
<p><strong>心跳(Heartbeat)</strong>：系统监视器与被监视的进程之间的定期消息交换。</p>
<ul>
<li>
<p>进程定期在其监视器中重置看门狗计时器，</p>
</li>
<li>
<p>将心跳消息与其他控制消息捆绑在一起，减少开销。</p>
</li>
<li>
<p>**“ping&quot;<strong>和</strong>&quot;heartbeat”**之间的区别是谁发起健康检查？</p>
<ul>
<li>
<p>ping 是检查者主动发信息，</p>
</li>
<li>
<p>heartbeat 是被检查者发信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>监视器(Monitor)</strong>：用于监控系统其他部分的健康状态的组件。</p>
</li>
<li>
<p><strong>时间戳(Timestamp)</strong>：用于检测分布式消息传递系统中的事件顺序错误。</p>
</li>
<li>
<p><strong>条件监控(Condition Monitoring)</strong>：检查进程或设备中的条件，或验证设计过程中的假设。</p>
<ul>
<li>例如，在数据存储和传输中使用校验和(checksum)。</li>
</ul>
</li>
<li>
<p><strong>投票(Voting)</strong>：这种策略的常见实现是三重模块冗余(Triple Modular Redundancy TMR)。</p>
</li>
</ul>
<h4 id="故障恢复-准备和修复-recover-from-faults-preparation-repair"><a class="header-anchor" href="#故障恢复-准备和修复-recover-from-faults-preparation-repair"></a>故障恢复 (准备和修复) recover-from-faults(preparation &amp; repair)</h4>
<ul>
<li>
<p><strong>主动冗余(热备份) active-redundancy (hot-spare)</strong>：</p>
<ul>
<li>
<p>通过保持多个冗余组件同时运行，确保在一个组件发生故障时，其他组件可以立即接替其工作，从而最小化系统停机时间和数据丢失风险</p>
</li>
<li>
<p>保护组中的所有组件（主要活动组件和冗余备份组件）以并行方式处理相同的输入，允许冗余备份的组件与活动组件保持同步状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>备用(冷备份) spare (cold-spare)</strong>：保护组的冗余备份保持停机状态，直到发生故障切换，此时在将冗余备份投入使用之前，会启动电源复位程序。</p>
</li>
<li>
<p><strong>被动冗余(温备份) passive-redundancy (warm-spare)</strong>：只有保护组的活动成员处理输入流量；</p>
<ul>
<li>其中一个职责是向冗余备份提供定期的状态更新。</li>
</ul>
</li>
<li>
<p><strong>回滚rollback</strong>：恢复到先前已知的良好状态，称为&quot;回滚点&quot;。</p>
<ul>
<li>
<p>这种策略与冗余策略结合使用。</p>
</li>
<li>
<p>在发生回滚后，故障组件的备用版本变为活动状态。</p>
</li>
<li>
<p>回滚依赖于先前状态的副本（检查点）。</p>
</li>
<li>
<p>检查点可以存储在固定位置，并需要定期更新。</p>
</li>
</ul>
</li>
<li>
<p><strong>重试retry</strong>：当故障是暂时性的，重新尝试操作可能会成功。</p>
<ul>
<li>例如，网络重传。</li>
</ul>
</li>
<li>
<p><strong>忽略错误行为(Ignore-faulty-behavior)</strong>：当确定某个消息是伪造的时，忽略来自该消息源的消息。</p>
<ul>
<li>例如，忽略来自拒绝服务攻击者的消息。</li>
</ul>
</li>
<li>
<p><strong>退化degradation</strong>：在组件故障的情况下保持最关键的系统功能，放弃较不关键的功能。</p>
</li>
<li>
<p><strong>重新配置reconfiguration</strong>：将责任重新分配给仍然正常运行的资源，同时尽可能保持功能性。</p>
</li>
</ul>
<h4 id="防止故障-prevent-faults"><a class="header-anchor" href="#防止故障-prevent-faults"></a>防止故障 prevent-faults</h4>
<ul>
<li>
<p><strong>服务移除 removal-from-service</strong>：将系统组件暂时置于停机状态，以减轻潜在的系统故障。</p>
</li>
<li>
<p><strong>事务 transactions</strong>：将状态更新打包，使分布式组件之间交换的异步消息具有原子性、一致性、隔</p>
</li>
<li>
<p>离性和持久性。</p>
</li>
<li>
<p><strong>预测模型 predictive-model</strong>：在检测到预测可能的未来故障的条件时采取纠正措施。</p>
</li>
<li>
<p><strong>增加能力集合</strong>：设计一个组件以处理更多的情况（故障），作为其正常操作的一部分。</p>
</li>
</ul>
<h2 id="CH6-互操作性"><a class="header-anchor" href="#CH6-互操作性"></a>CH6 互操作性</h2>
<h3 id="互操作性"><a class="header-anchor" href="#互操作性"></a>互操作性</h3>
<ul>
<li>
<p>互操作性是指在<strong>特定环境下，两个或多个系统能够通过接口有意义地交换</strong>信息的程度。</p>
</li>
<li>
<p>对于系统的互操作性的任何讨论都需要明确指出与谁以及在什么情况下进行交互。</p>
</li>
<li>
<p>语法互操作性是指交换数据的能力。</p>
</li>
<li>
<p>语义互操作性是指解释交换的数据的能力。</p>
</li>
<li>
<p>实现互操作性的两种视角：</p>
<ul>
<li>
<p>在了解外部系统接口的基础上，将该知识设计到系统中。</p>
</li>
<li>
<p>在没有了解其他系统的情况下，以更通用的方式设计系统以实现互操作性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="动机"><a class="header-anchor" href="#动机"></a>动机</h4>
<ul>
<li>
<p>系统提供一个服务，供一组未知系统使用，例如 Google 地图。</p>
</li>
<li>
<p>系统由现有系统构建而成，例如：</p>
<ul>
<li>
<p>产生对所感知内容的表示</p>
</li>
<li>
<p>解释数据</p>
</li>
<li>
<p>处理原始数据</p>
</li>
<li>
<p>感知环境</p>
</li>
</ul>
</li>
</ul>
<h4 id="互操作性的两个重要作用"><a class="header-anchor" href="#互操作性的两个重要作用"></a>互操作性的两个重要作用</h4>
<ul>
<li>发现。服务的使用者必须发现服务的位置、身份和接口。</li>
<li>处理响应。有三种可能性：
<ul>
<li>
<p>服务向请求者报告返回结果。</p>
</li>
<li>
<p>服务将其响应发送给另一个系统。</p>
</li>
<li>
<p>服务向任何感兴趣的方发送广播响应。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>SOAP 和 REST</p>
<ul>
<li>
<p>两种技术选项，用于实现基于 Web 的应用程序之间的互操作性。</p>
</li>
<li>
<p>SOAP 在 SOA 系统中与一组协议一起使用。</p>
<ul>
<li>
<p>服务描述和发现，例如 WSDL、UDDI。</p>
</li>
<li>
<p>服务组合，例如 BPEL。</p>
</li>
</ul>
</li>
<li>
<p>SOAP 更复杂，用于交换带有结构化数据的消息，而 REST 更简单，用于小型消息。</p>
</li>
</ul>
</blockquote>
<h3 id="互操作性的目标和决策"><a class="header-anchor" href="#互操作性的目标和决策"></a>互操作性的目标和决策</h3>
<ul>
<li>
<p>为了使两个或多个系统能够有意义地交换信息，它们必须：</p>
<ul>
<li>
<p>了解彼此。这就是定位策略(locate tactic)的目的。</p>
</li>
<li>
<p>以语义上有意义的方式交换信息。这就是管理接口策略(manage interfaces tactics)的目的。</p>
<p>交换的两个方面是：</p>
<ul>
<li>
<p>按正确的顺序提供服务。</p>
</li>
<li>
<p>将一个参与者产生的信息修改为第二个参与者可接受的形式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定位"><a class="header-anchor" href="#定位"></a>定位</h4>
<ul>
<li>
<p>服务发现(Service Discovery)：通过搜索来定位一个服务</p>
</li>
<li>
<p>有许多服务发现机制：</p>
<ul>
<li>
<p>用于 Web 服务的 UDDI</p>
</li>
<li>
<p>用于 Java 对象的 Jini</p>
</li>
<li>
<p>通用即插即用（Universal plug-and-play，UPnP）中使用的简单服务发现协议（SSDP）</p>
</li>
<li>
<p>DNS 服务发现（DNS-SD）</p>
</li>
<li>
<p>蓝牙服务发现协议（SDP）</p>
</li>
</ul>
</li>
</ul>
<h3 id="搜索方法"><a class="header-anchor" href="#搜索方法"></a>搜索方法</h3>
<h4 id="主动搜索"><a class="header-anchor" href="#主动搜索"></a>主动搜索</h4>
<ul>
<li>
<p><strong>泛洪/广播请求(Flood/Broadcast request)</strong>：</p>
<ul>
<li>
<p>向每个实体询问并等待回答</p>
</li>
<li>
<p>示例</p>
<ul>
<li>
<p>在位置区域进行寻呼以找到移动终端</p>
</li>
<li>
<p>DHCP 发现：客户端在本地子网上进行广播，以找到可用的服务器以获取 IP 地址</p>
</li>
</ul>
</li>
<li>
<p>对于搜索者来说，高效且资源消耗较少</p>
</li>
<li>
<p>对于被搜索的实体来说，资源消耗较低</p>
</li>
<li>
<p>但对于环境来说，会造成干扰和资源消耗。</p>
</li>
</ul>
</li>
<li>
<p><strong>连续请求(Successive request)</strong>：</p>
<ul>
<li>
<p>逐个询问实体并进行匹配。</p>
</li>
<li>
<p>如果没有匹配项，则继续下一个直到找到匹配项。</p>
</li>
<li>
<p>对于搜索者来说，效率较低且资源消耗较高。</p>
</li>
<li>
<p>但对于环境来说，干扰较少且资源消耗较少。</p>
</li>
</ul>
</li>
<li>
<p><strong>连续/定期广告(Continuous/periodical advertisement)</strong>：</p>
<ul>
<li>
<p>连续或定期发布广告，以便每个搜索者都能注意到并做出响应。</p>
</li>
<li>
<p>对于被搜索的实体来说，效率高但资源消耗较高。</p>
</li>
<li>
<p>对于搜索者来说，资源需求较低。</p>
</li>
<li>
<p>对于环境来说，干扰和资源消耗较高。</p>
</li>
</ul>
</li>
<li>
<p><strong>新实体到达时的广告(Advertisement upon arrival of new entity)</strong>：</p>
<ul>
<li>
<p>例如，当有新人进入大厅时自我介绍。</p>
</li>
<li>
<p>需要在新实体到达时进行检测机制。</p>
</li>
<li>
<p>对于被搜索的实体来说，资源消耗较低。</p>
</li>
<li>
<p>对于搜索者来说，资源需求较低。</p>
</li>
<li>
<p>对于环境来说，干扰和资源消耗较少。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注册"><a class="header-anchor" href="#注册"></a>注册</h4>
<ul>
<li>
<p>引入“中间人” - 注册表</p>
<ul>
<li>
<p>被搜索的实体向注册表注册</p>
</li>
<li>
<p>搜索者可以通过注册表获取信息并找到被搜索的实体</p>
</li>
</ul>
</li>
<li>
<p>示例</p>
<ul>
<li>服务提供者在 UDDI 注册表中注册其 Web 服务，可以被服务请求者搜索和找到</li>
</ul>
</li>
<li>
<p>这种方法对搜索者和被搜索者的资源消耗较低，对环境的干扰也较少，但前提是注册表必须可用、可靠和正确</p>
</li>
</ul>
<h2 id="CH7-可修改性"><a class="header-anchor" href="#CH7-可修改性"></a>CH7 可修改性</h2>
<h3 id="什么是可修改性-modifiability"><a class="header-anchor" href="#什么是可修改性-modifiability"></a>什么是可修改性 modifiability</h3>
<ul>
<li>
<p>可修改涉及变化，我们对它的兴趣在于变化的成本和风险。</p>
</li>
<li>
<p>为了规划可修改性，架构师必须考虑四个问题：</p>
<ul>
<li>
<p>什么可以改变？</p>
</li>
<li>
<p>变化的可能性有多大？</p>
</li>
<li>
<p>变化何时发生，由谁进行？</p>
</li>
<li>
<p>变化的成本是多少？</p>
</li>
</ul>
</li>
</ul>
<h4 id="什么是可以改变的"><a class="header-anchor" href="#什么是可以改变的"></a>什么是可以改变的</h4>
<ul>
<li>
<p>系统的功能</p>
</li>
<li>
<p>平台、即硬件、操作系统和中间件</p>
</li>
<li>
<p>系统运行的环境</p>
<ul>
<li>
<p>必须与之互操作的系统</p>
</li>
<li>
<p>用于通信的协议</p>
</li>
</ul>
</li>
<li>
<p>容量</p>
<ul>
<li>
<p>支持的用户数量</p>
</li>
<li>
<p>同时操作的数量</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化何时发生，由谁进行"><a class="header-anchor" href="#变化何时发生，由谁进行"></a>变化何时发生，由谁进行</h4>
<ul>
<li>
<p>在实施过程中可以进行的更改：</p>
<ul>
<li>
<p>通过修改源代码进行实施</p>
</li>
<li>
<p>通过选择库进行构建</p>
</li>
<li>
<p>通过参数设置、插件等进行执行</p>
</li>
</ul>
</li>
<li>
<p>更改也可以由以下人员进行：</p>
<ul>
<li>
<p>开发人员</p>
</li>
<li>
<p>最终用户</p>
</li>
<li>
<p>系统管理员</p>
</li>
</ul>
</li>
</ul>
<h4 id="变化的成本"><a class="header-anchor" href="#变化的成本"></a>变化的成本</h4>
<p>包括两种类型的成本：</p>
<ul>
<li>
<p>引入机制以使系统更具可修改性的成本</p>
</li>
<li>
<p>使用这些机制进行修改的成本</p>
</li>
</ul>
<h3 id="可修改性策略的目标"><a class="header-anchor" href="#可修改性策略的目标"></a>可修改性策略的目标</h3>
<ul>
<li>
<p>控制进行变更的复杂性</p>
</li>
<li>
<p>控制进行变更的时间和成本</p>
</li>
</ul>
<h3 id="可修改策略"><a class="header-anchor" href="#可修改策略"></a>可修改策略</h3>
<h4 id="减小模块的大小"><a class="header-anchor" href="#减小模块的大小"></a>减小模块的大小</h4>
<ul>
<li><strong>分割模块</strong>：如果要修改的模块包含大量功能，修改的成本可能会较高</li>
<li>将模块细分为几个较小的模块应该会降低未来变更的平均成本</li>
</ul>
<h4 id="增加内聚性"><a class="header-anchor" href="#增加内聚性"></a>增加内聚性</h4>
<ul>
<li>
<p>增加语义连贯性：如果模块中的职责 A 和 B 不具有相同的目的，它们应该放置在不同的模块中。</p>
</li>
<li>
<p>这可能涉及创建一个新的模块，或者将职责移动到现有的模块中。</p>
</li>
</ul>
<h4 id="减少耦合性"><a class="header-anchor" href="#减少耦合性"></a>减少耦合性</h4>
<ul>
<li>
<p>什么是耦合性？</p>
<ul>
<li>
<p>如果两个模块的职责重叠，一个变更可能会同时影响它们</p>
</li>
<li>
<p>耦合性通过这种重叠来衡量，即修改一个模块将会传播到另一个模块的概率</p>
</li>
<li>
<p>高耦合性是可修改性的敌人。</p>
</li>
</ul>
</li>
<li>
<p>减少耦合性的方法：</p>
<ul>
<li>
<p>封装：封装为模块引入了一个明确的接口。该接口包括一个 API 及其相关的职责。</p>
</li>
<li>
<p>使用中间层：如果职责 A 和职责 B 之间存在依赖关系（例如，首先执行 A 需要执行 B），可</p>
</li>
<li>
<p>以通过使用一个中间层来打破依赖。</p>
</li>
<li>
<p>使用发布/订阅模型 (Publish/Subscribe model)</p>
</li>
<li>
<p>限制依赖关系：限制一个模块与其交互或依赖的模块。</p>
<ul>
<li>
<p>通过限制模块的可见性和授权来实现。</p>
</li>
<li>
<p>例如，一个层次结构允许访问其底层的模块</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CH8-性能"><a class="header-anchor" href="#CH8-性能"></a>CH8 性能</h2>
<h3 id="什么是性能"><a class="header-anchor" href="#什么是性能"></a>什么是性能</h3>
<ul>
<li>
<p>它与时间有关</p>
</li>
<li>
<p>性能是关于时间以及软件系统满足时间要求的能力</p>
</li>
<li>
<p>当事件发生时，系统必须及时对其做出响应</p>
<ul>
<li>事件包括<strong>中断、消息、来自用户或其他系统的请求</strong>，或标记时间流逝的时钟事件</li>
</ul>
</li>
</ul>
<h4 id="性能建模"><a class="header-anchor" href="#性能建模"></a>性能建模</h4>
<ul>
<li>
<p>响应时间的两个基本因素</p>
</li>
<li>
<p>处理时间指系统用于响应的工作时间</p>
</li>
<li>
<p>阻塞时间指系统无法响应的时间</p>
</li>
<li>
<p>阻塞时间的原因包括</p>
<ul>
<li>
<p>资源争用</p>
</li>
<li>
<p>资源的可用性</p>
</li>
<li>
<p>对其他因素的依赖</p>
</li>
</ul>
</li>
</ul>
<h3 id="性能策略的目标"><a class="header-anchor" href="#性能策略的目标"></a>性能策略的目标</h3>
<ul>
<li>
<p>在基于时间的约束条件内，对进入系统的事件生成响应。</p>
</li>
<li>
<p>事件可以是单个事件或事件流，并且是执行计算的触发器。</p>
</li>
</ul>
<h3 id="两种策略类别"><a class="header-anchor" href="#两种策略类别"></a>两种策略类别</h3>
<ul>
<li>
<p>控制资源需求</p>
<ul>
<li>
<p>降低对资源的需求量</p>
</li>
<li>
<p>在需求方面进行操作</p>
</li>
</ul>
</li>
<li>
<p>管理资源</p>
<ul>
<li>
<p>使现有资源在处理需求时更有效</p>
</li>
<li>
<p>在响应方面进行操作</p>
<p>::info 资源</p>
</li>
</ul>
</li>
<li>
<p>硬件资源，例如 CPU、数据存储、网络带宽和内存</p>
</li>
<li>
<p>软件资源，例如缓冲区或关键区域</p>
</li>
</ul>
<h3 id="性能策略"><a class="header-anchor" href="#性能策略"></a>性能策略</h3>
<h4 id="控制资源需求"><a class="header-anchor" href="#控制资源需求"></a>控制资源需求</h4>
<ul>
<li>
<p><strong>管理采样率(Manage Sampling Rate)</strong>：降低对数据流进行采样的频率</p>
</li>
<li>
<p><strong>优先处理事件(Prioritize Events)</strong>：引入优先级方案，根据重要性对事件进行排序</p>
<ul>
<li>当资源不足时，忽略低优先级事件</li>
</ul>
</li>
<li>
<p><strong>减少开销(Reduce Overhead)</strong>：使用中间件会增加处理事件流所消耗的资源；移除中间件可以提高响应延迟。</p>
<ul>
<li>在可修改性和性能之间进行权衡</li>
</ul>
</li>
<li>
<p><strong>限制执行时间(Bound Execution Times)</strong>：设置响应事件所使用的执行时间上限。</p>
<ul>
<li>
<p>在算法设计中，限制迭代次数是控制执行时间的方法之一。</p>
</li>
<li>
<p>在性能和准确性之间进行权衡</p>
</li>
</ul>
</li>
<li>
<p><strong>提高资源效率(Increase Resource Efficiency)</strong>：改进关键领域中使用的算法将减少延迟。</p>
<ul>
<li>减少算法的复杂性</li>
</ul>
</li>
</ul>
<h4 id="管理资源"><a class="header-anchor" href="#管理资源"></a>管理资源</h4>
<ul>
<li>
<p>增加资源(Increase Resources:)：更快的处理器、额外的处理器、额外的内存和更快的网络都有可能减少延迟。</p>
</li>
<li>
<p>增加并发性( Increase Concurrency)：如果请求可以并行处理，阻塞时间可以减少。</p>
<ul>
<li>可以通过在不同线程上处理不同的事件流来引入并发性。</li>
</ul>
</li>
</ul>
<h4 id="维护多个计算副本-Maintain-Multiple-Copies-of-Computations"><a class="header-anchor" href="#维护多个计算副本-Maintain-Multiple-Copies-of-Computations"></a>维护多个计算副本(Maintain Multiple Copies of Computations)</h4>
<ul>
<li>
<p>复制的目的是减少单个服务器上的资源争用</p>
</li>
<li>
<p>负载均衡器将新任务分配给其中一个副本服务器</p>
</li>
<li>
<p><strong>数据缓存(Data caching)</strong> 是将数据的副本保存在具有不同访问速度的存储介质上。- 例如，内存访</p>
</li>
<li>
<p>问与磁盘访问，本地访问与通过网络的远程访问。</p>
</li>
<li>
<p><strong>数据复制(Data replication)</strong> 是保留数据的独立副本，以减少多个同时访问所带来的争用。</p>
</li>
<li>
<p>如何选择要缓存/复制的数据？</p>
</li>
<li>
<p>如何确保多个副本的一致性？</p>
</li>
</ul>
<h3 id="调度"><a class="header-anchor" href="#调度"></a>调度</h3>
<ul>
<li>
<p>当资源存在争用时，需要对资源进行调度。</p>
<ul>
<li>
<p>处理器需要进行调度</p>
</li>
<li>
<p>缓冲区需要进行调度</p>
</li>
<li>
<p>网络需要进行调度</p>
</li>
</ul>
</li>
</ul>
<h3 id="3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem"><a class="header-anchor" href="#3维度调度框架问题-3-Dimension-Framework-for-Scheduling-Problem"></a>3维度调度框架问题(3-Dimension Framework for Scheduling Problem)</h3>
<ul>
<li>
<p>任务(Tasks)</p>
</li>
<li>
<p>资源(Resources)</p>
</li>
<li>
<p>目标(Objectives)</p>
</li>
</ul>
<h4 id="任务模型-Task-Model"><a class="header-anchor" href="#任务模型-Task-Model"></a>任务模型(Task Model)</h4>
<ul>
<li>
<p>任务包（Bag of tasks）</p>
</li>
<li>
<p>有向无环图（Directed Acyclic Graph，DAG）</p>
</li>
<li>
<p>周期性/循环性任务（Periodic/cyclic tasks）</p>
</li>
<li>
<p>任务属性</p>
<ul>
<li>
<p>执行成本（Execution cost）</p>
</li>
<li>
<p>传输成本（Transmission cost）</p>
</li>
<li>
<p>到达时间（Arrival time）</p>
</li>
<li>
<p>截止时间（Deadline）</p>
</li>
<li>
<p>抢占或非抢占（Preemptive or non-preemptive）</p>
</li>
</ul>
</li>
</ul>
<h4 id="资源模型-Resource-Model"><a class="header-anchor" href="#资源模型-Resource-Model"></a>资源模型(Resource Model)</h4>
<ul>
<li>
<p>资源包括一组通过网络连接的机器/处理器</p>
</li>
<li>
<p>机器/处理器模型</p>
<ul>
<li>处理能力/速度，能量消耗</li>
</ul>
</li>
<li>
<p>网络模型</p>
<ul>
<li>
<p>网络拓扑</p>
</li>
<li>
<p>带宽</p>
</li>
<li>
<p>消息和能量消耗</p>
</li>
<li>
<p>例如，传感器网络、数据中心网络、移动云</p>
</li>
</ul>
</li>
</ul>
<h3 id="调度的目标"><a class="header-anchor" href="#调度的目标"></a>调度的目标</h3>
<ul>
<li>
<p>最小化完成时间</p>
</li>
<li>
<p>满足截止时间</p>
</li>
<li>
<p>最大化吞吐量</p>
</li>
<li>
<p>最小化数据传输/消息数量</p>
</li>
<li>
<p>最小化能量消耗</p>
</li>
</ul>
<h3 id="调度的分类"><a class="header-anchor" href="#调度的分类"></a>调度的分类</h3>
<ul>
<li>
<p>实时调度与非实时调度</p>
</li>
<li>
<p>静态调度与动态调度</p>
</li>
<li>
<p>离线调度与在线调度</p>
</li>
<li>
<p>确定性调度与随机调度</p>
</li>
</ul>
<h3 id="任务调度问题"><a class="header-anchor" href="#任务调度问题"></a>任务调度问题</h3>
<ol>
<li>单处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>多处理器上的任务包调度（Bag-of-Tasks scheduling）</li>
<li>异构处理器上的有向无环图（DAG）调度</li>
<li>作业车间调度（Job shop scheduling）</li>
<li>周期性任务调度（Periodic tasks scheduling）</li>
</ol>
<h4 id="单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）"><a class="header-anchor" href="#单处理器上的任务包调度（Bag-of-Tasks-on-Single-Processor）"></a>单处理器上的任务包调度（Bag-of-Tasks on Single Processor）</h4>
<p>给定：每个任务的发布时间、工作量或截止时间</p>
<p>确定每个任务的执行时间</p>
<p>目标：任务的平均完成时间或满足截止时间</p>
<h4 id="多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）"><a class="header-anchor" href="#多处理器上的任务包调度（Bag-of-Tasks-on-Multi-Processors）"></a>多处理器上的任务包调度（Bag-of-Tasks on Multi-Processors）</h4>
<p>给定：每个任务的发布时间和工作量</p>
<p>确定每个任务在何时何地执行</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）"><a class="header-anchor" href="#在异构处理器上调度有向无环图（DAGs-Scheduling-on-HeterogeneousProcessors）"></a>在异构处理器上调度有向无环图（DAGs Scheduling on HeterogeneousProcessors）</h4>
<p>给定：每个任务在每个处理器上的处理时间，边缘上的通信时间</p>
<p>目标：最小化总执行时间（make-span）…</p>
<h4 id="作业车间问题（Job-Shop-Problem，JSP）"><a class="header-anchor" href="#作业车间问题（Job-Shop-Problem，JSP）"></a>作业车间问题（Job Shop Problem，JSP）</h4>
<p>Job Shop Problem (JSP)</p>
<p>给定：每个作业在每个处理器上的处理时间</p>
<p>目标：最小化总执行时间（makespan）…</p>
<h4 id="周期性任务调度-Periodic-tasks-scheduling"><a class="header-anchor" href="#周期性任务调度-Periodic-tasks-scheduling"></a>周期性任务调度(Periodic tasks scheduling)</h4>
<p>任务按周期性发布，并在流水线中执行。</p>
<p>Periodic tasks scheduling</p>
<h3 id="类似的术语-Similar-Terminologies"><a class="header-anchor" href="#类似的术语-Similar-Terminologies"></a>类似的术语(Similar Terminologies)</h3>
<ul>
<li>
<p>任务分配（Task assignment）</p>
</li>
<li>
<p>任务放置（Task placement）</p>
</li>
<li>
<p>任务分配（Task allocation）</p>
</li>
<li>
<p>资源分配（Resource allocation）</p>
</li>
<li>
<p>资源调度（Resource scheduling）</p>
</li>
</ul>
<p>上述问题被视为调度问题的特殊情况/实例。</p>
<h3 id="调度算法的类型"><a class="header-anchor" href="#调度算法的类型"></a>调度算法的类型</h3>
<p>解决优化问题的算法</p>
<ol>
<li>数学规划，例如整数规划、线性规划</li>
<li>进化算法，例如遗传算法（GA）、粒子群算法（PSO）、蚁群算法</li>
<li>简单且有效的启发式算法，例如列表调度</li>
<li>基于机器学习的算法，例如深度强化学习</li>
</ol>
<p>调度方法：系统考虑因素</p>
<ul>
<li>
<p>以机器为中心的方法</p>
<ul>
<li>
<p>当一台机器空闲时触发调度</p>
</li>
<li>
<p>对于每台空闲机器，根据一些策略选择任务，例如：</p>
<ul>
<li>
<p>先到先得（First-Come-First-Serve，FCFS）</p>
</li>
<li>
<p>最短作业优先（Shortest Job First，SJF）</p>
</li>
<li>
<p>最早截止时间优先（Earliest Deadline First，EDF）</p>
</li>
<li>
<p>首先选择等待时间最长的作业，…</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>以任务为中心的方法</p>
<ul>
<li>
<p>当一个新任务到达时触发调度</p>
</li>
<li>
<p>对于每个被调度的任务，根据一些策略选择机器，例如最早完成时间，…</p>
</li>
</ul>
</li>
</ul>
<h4 id="列表调度方法"><a class="header-anchor" href="#列表调度方法"></a>列表调度方法</h4>
<p>computingopen in new window</p>
<ol>
<li>步骤 1：任务选择</li>
</ol>
<p>通过为每个任务分配优先级构建一个有序任务列表，然后按照它们的优先级顺序选择任务。</p>
<ol start="2">
<li>步骤 2：处理器选择</li>
</ol>
<p>将每个选定的任务调度到能够最小化预定义成本函数的处理器上。</p>
<ol start="3">
<li>重复执行步骤 1 和步骤 2，直到所有任务都被调度。</li>
</ol>
<p>例如：</p>
<p>Example: List Scheduling</p>
<ol>
<li>Step 1: 任务选择 - 上行排名（Upward rank）</li>
</ol>
<p>节点 i 的上行排名是最长路径的长度。</p>
<p>计算方法</p>
<p>在我们的算法中，任务按照基于向上和向下排名的调度优先级进行排序。任务 ni 的向上排名由</p>
<p>ranku(ni)=wi―+maxnj∈succ(ni)(ci,j―+ranku(nj)),</p>
<p>递归定义。其中 succni 是任务ni的直接后继集合，ci,j― 是边(i,j)的平均通信成本；wi― 为任务 ni 的平均</p>
<p>计算成本。由于 Rank 是通过向上遍历任务图递归计算的，因此从退出任务开始，称为向上 Rank。对于</p>
<p>退出任务nexit，向上 Rank 值等于</p>
<p>ranku(nexit)=wexit―.</p>
<p>基本上，ranku(ni) 是从任务 ni 到退出任务的关键路径的长度，包括任务 ni 的计算成本。文献中有一些</p>
<p>算法仅使用计算成本来计算排名值，其中称为静态向上排名，rankus。类似地，任务ni的向下排名由</p>
<p>rankd(ni)=maxnj∈pred(ni){rankd(nj)+wj―+cj,i―}递归定义；其中pred(ni)是任务ni的直接前驱集合。通过从图的入口任务开始向下遍历任务图来递归地计</p>
<p>算向下排名。对于入口任务nentry，向下排名值等于 0。基本上，rankd(ni) 是从入口任务到任务ni的最</p>
<p>长距离，不包括任务本身的计算成本。</p>
<p>::: 2. Step 2: 处理器选择 - 最早完成时间</p>
<p>在处理器选择阶段，选择能够最早完成任务的处理器。这意味着根据任务的执行时间和处理器的当前状</p>
<p>态，选择能够最快完成任务的处理器进行调度。</p>
<p>Processor Selection – EarlistFinishTime</p>
<p>计算方法</p>
<p>EST(ni,pj) 和 EFT(ni,pj) 分别是任务 ni 在处理器 pj 上的最早执行开始时间和最早执行结束时间。对于入</p>
<p>口任务 nentry，</p>
<p>EST(nentry,pj)=0</p>
<p>对于图中的其他任务，从入口任务开始递归计算 EFT 和 EST 值，分别如下所示。为了计算任务 ni 的</p>
<p>EFT，需要计算任务 ni 的所有直接前置任务你肯定已经被安排好了。</p>
<p>EST(ni,pj)=max{avail[j],maxnm∈pred(ni)</p>
<p>(AFT(nm)+cm,i)}EFT(ni,pj)=wi,j+EST(ni,pj)AFT(ni)=min∀jEFT(ni,pj)(AFT——ActualFinishTime)</p>
<p>其中 pred(ni) 是任务 ni 的直接前置任务的集合，</p>
<p>是处理器 pj 准备好执行任务的最早时间。如</p>
<p>果 nk 是处理器 pj 上最后分配的任务，则avail[j] 是当我们有基于非插入的调度策略时处理器 pj ，完成了</p>
<p>任务 nk 的执行，并且准备好执行另一个任务的时间。EST 方程中的内部 max 块返回就绪时间，即 ni 所</p>
<p>需的所有数据都已到达处理器pj的时间</p>
<p>任务 nm 在处理器 pj 上调度后， nm 在处理器 pj 上的最早开始时间和最早完成时间分别等于任务 nm</p>
<p>的实际开始时间 AST(nm) 和实际完成时间 AFT(nm) 。当一个图中的所有任务都被调度后，调度长度（即</p>
<p>总体完成时间）是退出任务nexit的实际完成时间。如果有多个退出任务并且插入伪退出任务的约定不适</p>
<p>用，调度长度(也称为makespan)定义为</p>
<p>makespan=max{AFT(nexit)}</p>
<h3 id="摘要"><a class="header-anchor" href="#摘要"></a>摘要</h3>
<p>性能是指在特定类型需求的面前有效管理系统资源，以实现可接受的时间行为。</p>
<p>对于交互式和嵌入式实时系统，性能可以通过吞吐量和延迟来衡量。</p>
<p>通过减少需求或更合理地管理资源，可以提高性能。</p>
<h2 id="CH9-安全性"><a class="header-anchor" href="#CH9-安全性"></a>CH9 安全性</h2>
<h3 id="什么是安全-security"><a class="header-anchor" href="#什么是安全-security"></a>什么是安全 security</h3>
<ul>
<li>
<p>安全是系统保护数据和信息免受未经授权访问的能力的度量，同时仍然向经授权的人员和系统提供访问权限。</p>
</li>
<li>
<p>针对计算机系统的有意为害行为称为攻击。</p>
</li>
<li>
<p>攻击可以采取不同形式：</p>
<ul>
<li>
<p>未经授权的尝试访问/修改数据或服务</p>
</li>
<li>
<p>旨在拒绝合法用户的服务</p>
</li>
</ul>
</li>
<li>
<p>安全具有三个主要特征，即 CIA：</p>
</li>
<li>
<p>保密性(Confidentiality)是数据或服务受到未经授权访问的保护性质。</p>
<ul>
<li>例如，黑客无法在政府计算机上访问您的个人所得税申报表。</li>
</ul>
</li>
<li>
<p>完整性(Integrity)是数据或服务不受未经授权操纵的性质。</p>
<ul>
<li>例如，您的成绩自从教师分配以来没有被更改。</li>
</ul>
</li>
<li>
<p>可用性(Availability)是系统能够供合法使用的性质。</p>
<ul>
<li>例如，拒绝服务攻击阻止您从在线书店订购一本书。</li>
</ul>
</li>
<li>
<p>支持 CIA 的其他特征包括：</p>
<ul>
<li>
<p>身份验证验证交易参与方的身份，并检查他们是否真实身份与其所声称的一致。</p>
</li>
<li>
<p>授权授予用户执行任务的权限。</p>
</li>
</ul>
</li>
</ul>
<h3 id="安全性策略-security-tatics"><a class="header-anchor" href="#安全性策略-security-tatics"></a>安全性策略 security-tatics</h3>
<h4 id="检测攻击-detect-attacks"><a class="header-anchor" href="#检测攻击-detect-attacks"></a>检测攻击 detect-attacks</h4>
<ul>
<li>
<p>检测入侵(Detect Intrusion)：将系统内的网络流量或服务请求模式与存储在数据库中的恶意行为的一组签名或已知模式进行比较。</p>
</li>
<li>
<p>检测服务拒绝(Detect Service Denial)：将系统接收到的网络流量的模式或签名与已知拒绝服务（DOS）攻击的历史配置文件进行比较</p>
</li>
</ul>
<blockquote>
<p>DOS(Deny of Service Attack)</p>
<ul>
<li>
<p>Ping of Death（死亡之 Ping）是一种利用发送异常大的 ICMP 回显请求（Ping）来攻击目标系统的方法，超出系统处理能力导致系统崩溃或变得不稳定。</p>
</li>
<li>
<p>UDP Flood（UDP 洪泛）是通过发送大量伪造的 UDP 数据包来占用目标系统的网络带宽和资源，导致系统无法正常处理合法的网络请求。</p>
</li>
<li>
<p>TCP SYN（TCP 半开连接）攻击是通过发送大量伪造的 TCP 连接请求（SYN 包）来消耗目标系统的资源，使其无法建立新的有效连接，从而导致服务不可用。</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>验证消息完整性(Verify Message Integrity): 使用校验和或哈希值等技术来验证消息、资源文件、部</p>
</li>
<li>
<p>署文件和配置文件的完整性。检测消息延迟: 通过检查传递消息所需的时间，可以检测到可疑的时间行为，即中间人攻击。</p>
</li>
</ul>
<h4 id="抵御攻击-resist-attacks"><a class="header-anchor" href="#抵御攻击-resist-attacks"></a>抵御攻击 resist-attacks</h4>
<ul>
<li>
<p>识别参与者(Identify Actors)：识别系统接收的任何外部输入的来源。</p>
</li>
<li>
<p>对参与者进行身份验证(Authenticate Actors)：确保用户或远程计算机的实际身份与其所声称的身</p>
</li>
<li>
<p>份相符。</p>
</li>
<li>
<p>授权参与者(Authorize Actors)：确保经过身份验证的参与者有权访问和修改数据或服务。</p>
</li>
<li>
<p>限制访问(Limit Access)：限制对诸如内存、网络连接或访问点等资源的访问。</p>
</li>
<li>
<p>限制曝光(Limit Exposure)：通过尽可能减少访问点的数量来最小化系统的攻击面。</p>
<ul>
<li>
<p>例如，防火墙是对内部网络的单一访问点。</p>
</li>
<li>
<p>例如，关闭一个端口。</p>
</li>
<li>
<p>被动防御。</p>
</li>
</ul>
</li>
<li>
<p>加密数据(Encrypt Data)：对数据和通信应用某种形式的加密。</p>
</li>
<li>
<p>分离实体(Separate Entities)：可以通过在不同服务器上进行物理分离，使用虚拟机等方式实现。</p>
</li>
<li>
<p>更改默认设置(Change Default Settings)：强制用户更改默认分配的设置</p>
</li>
</ul>
<h4 id="应对攻击-react-to-attacks"><a class="header-anchor" href="#应对攻击-react-to-attacks"></a>应对攻击 react-to-attacks</h4>
<ul>
<li>
<p>撤销访问权限( Revoke Access)：如果怀疑存在攻击，即使针对通常合法的用户和用途，也限制对</p>
</li>
<li>
<p>敏感资源的访问。</p>
</li>
<li>
<p>锁定计算机(Lock Computer)：如果有多次尝试访问失败，限制对资源的访问。</p>
</li>
<li>
<p>通知参与者(Inform Actors)：在怀疑或检测到攻击时，通知操作员、其他人员或合作系统</p>
</li>
</ul>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<ul>
<li>
<p>对系统的攻击可以归纳为针对系统的机密性、完整性或可用性的攻击。</p>
</li>
<li>
<p>识别、验证和授权参与者是旨在确定哪些用户或系统有权以何种方式访问系统的策略。</p>
</li>
<li>
<p>存在用于检测攻击、限制攻击传播以及对攻击做出反应和恢复的策略</p>
</li>
</ul>
<h2 id="CH10-可测试性"><a class="header-anchor" href="#CH10-可测试性"></a>CH10 可测试性</h2>
<h3 id="什么是可测试性"><a class="header-anchor" href="#什么是可测试性"></a>什么是可测试性</h3>
<ul>
<li>软件的可测试性是指通过（通常是基于执行的）测试来展示其错误的难易程度</li>
<li>可测试性是指系统在下一次测试执行中失败的概率</li>
<li>如果系统存在错误，我们希望在测试阶段中尽快失败，及早修正</li>
<li>要使一个系统具有可测试性，必须能够控制每个组件的输入（并可能操作其内部状态），然后观察其输出（以及可能的内部状态）</li>
</ul>
<h3 id="可测试性策略的目标"><a class="header-anchor" href="#可测试性策略的目标"></a>可测试性策略的目标</h3>
<ul>
<li>可测试性测量的目标是在软件开发完成的一个增量中实现更容易的测试</li>
<li>可测试性测量可以分为两个类别：
<ul>
<li>第一个类别设计向系统添加可控性和可观察性</li>
<li>第二个类别设计限制系统设计中的复杂性</li>
</ul>
</li>
</ul>
<h3 id="可测试性策略"><a class="header-anchor" href="#可测试性策略"></a>可测试性策略</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011921146.png" alt="Testability Tactics"></p>
<h4 id="控制和观察系统状态-control-and-observe-system-state"><a class="header-anchor" href="#控制和观察系统状态-control-and-observe-system-state"></a>控制和观察系统状态 control-and-observe-system-state</h4>
<ul>
<li>记录/回放 record/playback：捕获通过接口传递的信息，并将其用作进一步测试的输入。</li>
<li>本地化状态存储 localize-state-storage：为了测试，将系统置于任意状态时，如果该状态存储在一个单独的位置则最为方便。</li>
<li>专用接口 specialized-interfaces
<ul>
<li>通过正常执行来控制或捕获组件的变量值</li>
<li>一组用于设置和获取变量的方法</li>
<li>一个返回对象状态的报告方法</li>
<li>一个用于设置内部状态的重置方法</li>
</ul>
</li>
<li>沙河 sandbox：将系统和真实世界隔离开来，以便进行实验。</li>
<li>可执行断言 executable-assertions：手动编写断言，并将其放置在所需位置，以指示程序何时以及在何处处于错误状态</li>
</ul>
<h4 id="限制复杂性-limit-complexity"><a class="header-anchor" href="#限制复杂性-limit-complexity"></a>限制复杂性 limit-complexity</h4>
<ul>
<li>限制结构复杂性：避免或解决组件间的循环依赖，并减少组件间的依赖关系
<ul>
<li>例如：限制继承树的深度</li>
</ul>
</li>
<li>高内聚低耦合</li>
<li>限制非确定性：找出所有非确定性的来源，例如无约束的并行性，尽可能消除</li>
</ul>
<blockquote>
<p>测试可行性与容错性</p>
<ul>
<li>测试可行性旨在更容易地显示错误。</li>
<li>容错性试图隐藏错误，并使其难以暴露。</li>
<li>这两个设计目标是否不兼容？</li>
</ul>
<p>测试可行性和容错性是两个不同的设计目标，但并不一定是不兼容的。测试可行性旨在通过测试过程中更容易地检测和暴露错误，以便及早修复它们。容错性旨在使系统能够继续正常运行，即使在面临错误或故障的情况下也能提供可接受的性能和可靠性。</p>
<p>尽管两者有不同的关注点，但它们可以在系统设计中相互支持。例如，通过增加系统的容错能力，可以减少错误的发生率，从而提高测试的有效性。在设计过程中，可以采用合适的策略和技术来平衡测试可行性和容错性的需求，以确保系统在各个方面都具备良好的质量和可靠性。</p>
</blockquote>
<h2 id="CH11-易用性"><a class="header-anchor" href="#CH11-易用性"></a>CH11 易用性</h2>
<h3 id="什么是易用性"><a class="header-anchor" href="#什么是易用性"></a>什么是易用性</h3>
<ul>
<li>易用性关注用户完成所需任务的难易程度以及系统提供的用户支持</li>
<li>易用性是改善系统质量的最便宜和最简单的方法之一</li>
<li>易用性主要包含：
<ul>
<li>高效使用系统</li>
<li>学习系统的功能</li>
<li>尽量减少错误的影响</li>
<li>使系统适应用户需求</li>
<li>提高用户的信心和满意度</li>
</ul>
</li>
</ul>
<h3 id="易用性测量"><a class="header-anchor" href="#易用性测量"></a>易用性测量</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011921278.png" alt="Usability tactics"></p>
<h3 id="支持用户主动性-support-user-initiative"><a class="header-anchor" href="#支持用户主动性-support-user-initiative"></a>支持用户主动性 support-user-initiative</h3>
<ul>
<li>取消cancel：系统必须监听取消请求；
<ul>
<li>被取消的命令必须终止</li>
<li>使用的资源必须释放</li>
<li>合作组件必须被通知</li>
</ul>
</li>
<li>暂停/恢复 pause/resume：临时释放资源，以便可以重新分配给其他任务
<ul>
<li>用于长时间运行的操作</li>
</ul>
</li>
<li>恢复restore：保持足够的系统状态信息，以便可以恢复到先前的状态</li>
<li>组合aggregate：能够将较低级别的对象聚合成一个组，以便可以对该组应用用户操作，从而用户免于进行重复操作</li>
</ul>
<h3 id="支持系统主动性support-system-initiative"><a class="header-anchor" href="#支持系统主动性support-system-initiative"></a>支持系统主动性support-system-initiative</h3>
<ul>
<li>维护任务模型maintain-task-model：确定上下文，以便系统可以对用户的尝试有一定的了解，并提供帮助。</li>
<li>维护系统模型maintain-system-model：系统维护自身的显式模型。这用于确定预期的系统行为，以便向用户提供适当的反馈</li>
</ul>
<h2 id="CH12-其他质量属性"><a class="header-anchor" href="#CH12-其他质量属性"></a>CH12 其他质量属性</h2>
<h3 id="可移植性"><a class="header-anchor" href="#可移植性"></a>可移植性</h3>
<ul>
<li>可移植性也是一种特殊的可修改性</li>
<li>可移植性指的是将为一个平台搭建的软件更改为在不同平台运行的便携程度</li>
</ul>
<h3 id="开发可分发性"><a class="header-anchor" href="#开发可分发性"></a>开发可分发性</h3>
<ul>
<li>开发可分发性是指设计软件以支持分布式软件开发的质量</li>
<li>系统是使用全球分布的团队开发的</li>
<li>目的是最大限度减少团队间的协调</li>
</ul>
<h3 id="可拓展性"><a class="header-anchor" href="#可拓展性"></a>可拓展性</h3>
<ul>
<li>水平可拓展性（拓展外部）：指向逻辑单元添加更多资源，例如向集群添加另一个服务器</li>
<li>垂直可拓展性（拓展内部）：指向物理单元添加更多资源，例如向计算机添加更多的内存</li>
<li>可产生可衡量的改进，而无需中断操作</li>
</ul>
<blockquote>
<p>集中式与分散式</p>
<ul>
<li>在集中式架构中，控制和决策集中在一个单一的中央实体或服务器上。这种方法可以提供更好的资源协调和管理，但可能会成为单点故障并限制可扩展性。</li>
<li>相比之下，分散式架构将控制和决策分布在多个实体或服务器之间。这种方法可以提供更好的容错性、可扩展性和弹性，但可能会引入协调和一致性方面的挑战。</li>
</ul>
</blockquote>
<h3 id="部署性"><a class="header-anchor" href="#部署性"></a>部署性</h3>
<ul>
<li>部署性关注的是可执行文件如何达到主机平台以及如何被调用</li>
<li>例如：
<ul>
<li>javascript脚本</li>
<li>病毒</li>
<li>代理程序</li>
</ul>
</li>
</ul>
<h3 id="可监控性"><a class="header-anchor" href="#可监控性"></a>可监控性</h3>
<ul>
<li>可监控性涉及运维人员在系统执行过程中监控系统的能力</li>
<li>例如：
<ul>
<li>各个组件的运行状态</li>
<li>平均事务处理时间</li>
<li>队列长度</li>
</ul>
</li>
</ul>
<h3 id="安全性"><a class="header-anchor" href="#安全性"></a>安全性</h3>
<ul>
<li>软件安全性涉及软件避免进入会导致损害、伤害或生命丧失的状态，并在进入不良状态时进行恢复和限制损害的能力</li>
<li>在安全性方面，框架关注的问题与可用性几乎一致</li>
</ul>
<h3 id="标准的质量属性列表"><a class="header-anchor" href="#标准的质量属性列表"></a>标准的质量属性列表</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011921100.png" alt=" The ISO/IEC FCD 25010 product quality standard"></p>
<h2 id="CH13-模式和策略"><a class="header-anchor" href="#CH13-模式和策略"></a>CH13 模式和策略</h2>
<h3 id="什么是模式pattern"><a class="header-anchor" href="#什么是模式pattern"></a>什么是模式pattern</h3>
<ul>
<li><code>架构模型 an architecture-pattern</code>是一组在实践中反复出现的设计决策集合</li>
<li>具有已知的可复用性，并描述了一类框架</li>
</ul>
<h3 id="框架模式-an-architecture-pattern"><a class="header-anchor" href="#框架模式-an-architecture-pattern"></a>框架模式 an architecture-pattern</h3>
<ul>
<li>模块模式
<ul>
<li>分层模式</li>
</ul>
</li>
<li>组件与连接器模式
<ul>
<li>代理模式</li>
<li>模式-视图-控制器模式</li>
<li>管道-过滤器模式</li>
<li>客户端-服务器模式</li>
<li>对等模式</li>
<li>面向服务的框架模式</li>
<li>发布-订阅模式</li>
<li>共享数据模式</li>
</ul>
</li>
<li>分配模式
<ul>
<li>Map-reduce模式</li>
<li>多层模式</li>
</ul>
</li>
</ul>
<h3 id="分层模式-layered-pattern"><a class="header-anchor" href="#分层模式-layered-pattern"></a>分层模式 layered-pattern</h3>
<ul>
<li>
<p>分层模式将软件划分为以“层 layer”为单位组成的集合</p>
</li>
<li>
<p>每个层是一个模块，提供一套协调一致的服务</p>
</li>
<li>
<p>每个层通过<code>公共接口 public-interface</code>进行暴露</p>
</li>
<li>
<p>使用必须是<strong>单向</strong>的</p>
</li>
<li>
<p>常见的分层模式有：</p>
<ul>
<li>三层架构：表示层，业务逻辑层和数据访问层</li>
<li>计算机网络TCP五层架构</li>
<li>OSI七层架构</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h4>
<ul>
<li>分层模式定义了层与层之间的单向允许使用关系</li>
<li>约束条件 constraints
<ul>
<li>每个软件部件都被分配到恰好一个层中</li>
<li>至少有两个层</li>
<li>不存在循环使用关系</li>
</ul>
</li>
<li>问题：
<ul>
<li>添加层会导致系统的成本和复杂性的提高</li>
<li>层会对性能产生负面影响</li>
</ul>
</li>
</ul>
<h3 id="组件与连接器模式-component-and-connector-pattern"><a class="header-anchor" href="#组件与连接器模式-component-and-connector-pattern"></a>组件与连接器模式 component-and-connector-pattern</h3>
<ul>
<li>组件与连接器模式是一种用于描述系统架构的模式</li>
<li>组件：是能够执行某些任务的模块</li>
<li>连接器：负责不同组件间的通信</li>
<li>该模式强调将系统划分为可供复用的独立组件，并通过连接器进行交互</li>
</ul>
<h3 id="代理模式-proxy-pattern"><a class="header-anchor" href="#代理模式-proxy-pattern"></a>代理模式 proxy-pattern</h3>
<ul>
<li>问题背景：许多系统由分布在多个服务器上的一组服务构建而成，如何构建<code>分布式软件 distributed-software</code>，使得服务使用者不需要知道服务提供者的性质和位置</li>
<li>解决思路：代理模式通过插入一个<code>中间层 intermediary</code>，称为代理，将客户端与服务提供者服务器分离开来。</li>
</ul>
<h4 id="解决方案-v2"><a class="header-anchor" href="#解决方案-v2"></a>解决方案</h4>
<ul>
<li>代理模式定义了一个运行时组件，称为代理，它在多个客户端和服务器之间充当进行通信和中介</li>
<li>组成部分：
<ul>
<li>客户端 client：服务的请求者</li>
<li>服务器 server：服务的提供者</li>
<li>代理 broker，中间层，用于定位适合客户端请求的服务器，将请求转发给服务器，并将结果返回给客户端</li>
</ul>
</li>
<li>约束条件：客户端只能连接到代理，服务器也只能连接到代理</li>
<li>问题：
<ul>
<li>代理会增加客户端与服务器之间的延迟，可能成为通信瓶颈</li>
<li>代理可能成为单点故障</li>
<li>代理可能成为安全攻击的目标</li>
</ul>
</li>
</ul>
<h3 id="模型-视图-控制器模式-model-view-controller-pattern"><a class="header-anchor" href="#模型-视图-控制器模式-model-view-controller-pattern"></a>模型-视图-控制器模式 model-view-controller-pattern</h3>
<ul>
<li>问题背景：用户界面软件是交互式应用程序中经常修改的部分，如何将用户界面功能和应用程序功能分开，同时仍能响应用户输入或底层应用程序数据的更改（当底层应用程序数据发生变化时，如何创建、维护和协调多个用户界面视图）</li>
</ul>
<h4 id="解决方案-v3"><a class="header-anchor" href="#解决方案-v3"></a>解决方案</h4>
<ul>
<li>MVC模式将应用程序分为三种组件
<ul>
<li>M：包含应用程序的数据</li>
<li>V：显式底层数据的一部分并与用户交互</li>
<li>C：在 M 和 V 之间进行中介，并管理状态变化的通知</li>
</ul>
</li>
<li>约束条件：
<ul>
<li>M，V 和 C 必须至少有一个实例</li>
</ul>
</li>
<li>问题：
<ul>
<li>对于简单的用户界面来说，复杂性可能过高</li>
</ul>
</li>
</ul>
<h3 id="管道-过滤器模式-pipe-and-filter-pattern"><a class="header-anchor" href="#管道-过滤器模式-pipe-and-filter-pattern"></a>管道-过滤器模式 pipe-and-filter-pattern</h3>
<ul>
<li>问题背景：流式数据处理中，如何加快数据处理速度</li>
<li>解决思路：数据到达过滤器的输入端口后，结果转换，然后通过管道传递到下一个过滤器输入端口
<ul>
<li>单个过滤器可以从管道中消费数据，也可以生产数据</li>
</ul>
</li>
</ul>
<h4 id="解决方案-v4"><a class="header-anchor" href="#解决方案-v4"></a>解决方案</h4>
<ul>
<li>组成：
<ul>
<li>过滤器：一种将从输入端口读取的数据转换成写入其输出端口的数据的组件</li>
<li>管道：一种将数据从一个过滤器输出端口传递到另一个过滤器的输入端口的连接器</li>
</ul>
</li>
<li>关系：附加关系将过滤器的输出与管道的输入相关联，反之亦然</li>
<li>约束条件：
<ul>
<li>连接的过滤器必须就沿着连接管道传递的数据类型达成一致</li>
</ul>
</li>
</ul>
<h3 id="客户端-服务器模式"><a class="header-anchor" href="#客户端-服务器模式"></a>客户端-服务器模式</h3>
<ul>
<li>问题背景：存在<code>共享资源和服务</code>，许多分布式客户端希望访问这些资源和服务，希望<strong>控制对其的访问或提供服务的 质量</strong>，通过<strong>集中控制</strong>这些资源和服务阿里提高可用性</li>
<li>解决思路：客户端通过请求服务器的服务进行交互
<ul>
<li>可能存在一个中央服务器和多个分布式服务器</li>
</ul>
</li>
</ul>
<h4 id="解决方案-v5"><a class="header-anchor" href="#解决方案-v5"></a>解决方案</h4>
<ul>
<li>问题：
<ul>
<li>服务器可能成为性能瓶颈</li>
<li>服务器可能成为单点故障</li>
<li>在系统构建后，关于功能定位（在客户端还是服务器中）的决策复杂且成本高</li>
</ul>
</li>
</ul>
<h3 id="点多点模式-peer-to-peer-pattern"><a class="header-anchor" href="#点多点模式-peer-to-peer-pattern"></a>点多点模式 peer-to-peer-pattern</h3>
<ul>
<li>问题背景：如何通过一个共同的协议将一组“相等的”分布式计算实体连接起来，让他们能以高可用性和可拓展性来阻止和共享其服务</li>
<li>解决思路：在点对点P2P模式中，组件作为对等体直接进行交互。所有对等体都是“相等的”。
<ul>
<li>P2P通常是一种请求/响应的交互方式，<strong>没有客户端-服务器模式的非对称性</strong></li>
</ul>
</li>
</ul>
<h4 id="解决方案-v6"><a class="header-anchor" href="#解决方案-v6"></a>解决方案</h4>
<ul>
<li>问题：
<ul>
<li>管理数据一致性、数据/服务的可用性、备份和恢复等都更加复杂</li>
<li>较小的P2P系统可能无法实现性能和可用性等质量目标</li>
</ul>
</li>
</ul>
<h3 id="面向服务的体系结构模式-service-oriented-architecture-pattern"><a class="header-anchor" href="#面向服务的体系结构模式-service-oriented-architecture-pattern"></a>面向服务的体系结构模式 service-oriented-architecture-pattern</h3>
<ul>
<li>问题背景：如何支持在不同平台上运行、使用不同实现语言编写、由不同组织提供并分布在互联网上的分布式组件之间的互操作性</li>
<li>解决思路：面向服务的体系结构SOA模式描述了一组提供 和/或 消费服务的分布式组件</li>
</ul>
<h4 id="解决方案-v7"><a class="header-anchor" href="#解决方案-v7"></a>解决方案</h4>
<ul>
<li>组成：
<ul>
<li>组件：
<ul>
<li>服务提供者：通过已发布的接口提供一个或多个服务</li>
<li>服务消费者：直接或通过中间件调用服务</li>
<li>企业服务总线 enterpise-service-bus ESB：作为<strong>中间件元素</strong>，可以在服务提供者和消费者之间路由和转化信息</li>
<li>服务注册表：供应商可使用注册表注册其服务，并运行时由消费者发现服务</li>
</ul>
</li>
<li>连接器：
<ul>
<li>SOAP 连接器：使用SOAP协议进行Web服务之间的同步通信，通常通过HTTP进行</li>
<li>REST 连接器：依赖于HTTP协议的基本请求/响应操作。</li>
<li>异步消息连接器：使用消息系统进行P2P或分布-订阅的**异步消息交换 asynchronous-message-exchange</li>
</ul>
</li>
</ul>
</li>
<li>问题：
<ul>
<li>中间件存在与性能相关的开销，可能存在性能瓶颈，并且通常不提供性能保证</li>
</ul>
</li>
</ul>
<h3 id="分布-订阅模式-publish-subscirbe-pattern"><a class="header-anchor" href="#分布-订阅模式-publish-subscirbe-pattern"></a>分布-订阅模式 publish-subscirbe-pattern</h3>
<p>问题背景：如何在生产者和消费者之间传递消息，使它们对彼此的身份/存在毫不知情</p>
<h4 id="解决方案-v8"><a class="header-anchor" href="#解决方案-v8"></a>解决方案</h4>
<ul>
<li>
<p>优势</p>
<ul>
<li>非常适合移动应用程序、普适计算和分布式嵌入式系统</li>
<li>鲁棒性 - 发布者或订阅者的故障不会导致整个系统崩溃</li>
<li>可扩展性 - 适用于构建由大量实体组成的分布式应用程序</li>
</ul>
</li>
<li>
<p>发布-订阅模式的缺点</p>
<ul>
<li>可靠性
<ul>
<li>无法对代理服务器向订阅者传递内容提供强有力的保证。发布者发布事件后，假设所有相应的订阅者都将收到该事件。</li>
</ul>
</li>
<li>当订阅者和发布者过载代理服务器时，可能会在代理服务器中出现瓶颈。（可以通过负载均衡技术来解决</li>
</ul>
</li>
</ul>
<h3 id="共享数据模式"><a class="header-anchor" href="#共享数据模式"></a>共享数据模式</h3>
<ul>
<li>
<p>问题背景：各种计算组件需要共享和操作大量数据。这些数据<strong>不仅仅属于其中任何一个组件</strong>，系统如何存储和操作多个独立组件都有访问需求的<strong>持久数据</strong></p>
</li>
<li>
<p>解决思路：在共享数据模式中，交互主要通过多个数据访问者和至少一个共享数据存储组件的持久数据交换来实现</p>
<ul>
<li>交换可以由访问者或数据存储发起，连接器是数据读取和写入</li>
<li></li>
</ul>
</li>
<li>
<p>核心：</p>
<ul>
<li><strong>共享数据存储区</strong>：系统中的数据不保存在某个特定的组件或节点上，而是存储在一个共享的、全局可访问的地方。</li>
<li><strong>访问控制</strong>：由于多个组件可能会同时访问共享数据，如何控制对共享数据的访问和修改变得至关重要。通常需要引入锁机制、事务机制或版本控制来保证数据的一致性和避免并发冲突。</li>
<li><strong>数据一致性</strong>：共享数据模式面临的一个挑战是如何保持数据的一致性。由于数据由多个组件共享，在某一组件修改数据时，其他组件也应该能够感知并获取到最新的数据。这通常需要依赖某种同步机制，确保系统中的所有节点看到相同的视图。</li>
<li><strong>分布式共享</strong>：在分布式系统中，多个节点可能会有不同的副本或缓存副本，因此如何确保数据在多个副本之间同步、避免数据不一致是共享数据模式中的一个重要问题。</li>
</ul>
</li>
</ul>
<h3 id="Map-Reduce-分布式计算模式"><a class="header-anchor" href="#Map-Reduce-分布式计算模式"></a>Map-Reduce 分布式计算模式</h3>
<ul>
<li></li>
</ul>
<h3 id="多层模式"><a class="header-anchor" href="#多层模式"></a>多层模式</h3>
<h3 id="策略和模式间的关系"><a class="header-anchor" href="#策略和模式间的关系"></a>策略和模式间的关系</h3>
<h4 id="模式是由策略构建的"><a class="header-anchor" href="#模式是由策略构建的"></a>模式是由策略构建的</h4>
<ul>
<li>多种策略的相互组合形成一种模式</li>
<li>MVC应用了：
<ul>
<li>增加语义一致性</li>
<li>封装</li>
<li>使用中介者 intermediary</li>
</ul>
</li>
</ul>
<p>策略是用来解决特定问题的单个行动或技术，而模式是一种更高级别的设计解决方案，它将多个策略组合在一起，以解决更复杂的问题。模式提供一种通用的架构和组织原则，而策略则提供了具体的实现细节。策略是构成模式的组成要素</p>
<h4 id="策略增强了模式"><a class="header-anchor" href="#策略增强了模式"></a>策略增强了模式</h4>
<ul>
<li>模式解决了特定的问题，但在某些方面可能存在问题</li>
<li>例如：代理模式中可能存在性能瓶颈、单点故障等</li>
<li>使用策略，增加资源以提高性能；维护多个副本以提高可用性</li>
</ul>
<p>策略用来增强模式，解决模式在某些方面的限制或弱点。通过合适的策略，可以改善模式的性能、可用性等质量属性，适应实际需求</p>
<h4 id="策略和模式相互作用"><a class="header-anchor" href="#策略和模式相互作用"></a>策略和模式相互作用</h4>
<ul>
<li>
<p>每个策略都有优缺点</p>
</li>
<li>
<p>使用策略可以帮助减轻缺点</p>
</li>
<li>
<p>但没有万金油，一个常见的检测故障策略是 ping/echo，但也存在问题：</p>
<ul>
<li>安全性，如何防止 ping 洪水攻击</li>
<li>性能：如何使 ping/echo 开销最小</li>
<li>可修改性：如何将 ping/echo 添加到现有架构中</li>
</ul>
</li>
<li>
<p>一个用于解决性能副作用的策略是“增加可用资源”（Increase Available Resources）。增加可用资源的常见副作用包括：</p>
<ul>
<li>成本：增加资源会带来额外的成本。</li>
<li>性能：如何高效利用增加的资源？</li>
</ul>
</li>
<li>
<p>一个用于解决资源高效利用副作用的策略是“调度策略”（Scheduling Policy）。调度策略的常见副作用包括：</p>
<ul>
<li>可修改性：如何将调度策略添加到现有架构中？</li>
<li>可修改性：如何在将来更改调度策略？</li>
</ul>
</li>
<li>
<p>架构模式是在实践中反复出现的设计决策的集合。</p>
</li>
<li>
<p>架构模式具有已知的属性，可以进行重复使用，并描述了一类架构。</p>
</li>
<li>
<p>策略比模式更简单。</p>
</li>
<li>
<p>模式对于真实系统来说是不完全的，因此需要通过策略进行补充。</p>
<ul>
<li>当满足特定系统的需求时，对模式的补充就会结束。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>期末复习</tag>
        <tag>软件架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 align =center > 计算机组成原理 </h1>
<h2 id="CH1-计算机基本知识"><a class="header-anchor" href="#CH1-计算机基本知识"></a>CH1 计算机基本知识</h2>
<h3 id="计算机类型："><a class="header-anchor" href="#计算机类型："></a>计算机类型：</h3>
<ol>
<li>嵌入式计算机</li>
<li>个人计算机</li>
<li>服务器和企业系统</li>
<li>超级计算机和网络计算机</li>
</ol>
<h3 id="计算机五大部件："><a class="header-anchor" href="#计算机五大部件："></a>计算机五大部件：</h3>
<ol>
<li>输入单元——Input Unit</li>
<li>输出单元——Output Unit</li>
<li>存储设——Memory</li>
<li>运算逻辑单元——ALU Arithmetic and Logic Unit</li>
<li>控制单元——Control Unit</li>
</ol>
<h3 id="3、程序运行"><a class="header-anchor" href="#3、程序运行"></a>3、程序运行</h3>
<h3 id="4、计算机发展"><a class="header-anchor" href="#4、计算机发展"></a>4、计算机发展</h3>
<h2 id="CH9-Arithmetic"><a class="header-anchor" href="#CH9-Arithmetic"></a>CH9 Arithmetic</h2>
<h3 id="数的表示"><a class="header-anchor" href="#数的表示"></a>数的表示</h3>
<h3 id="数据"><a class="header-anchor" href="#数据"></a>数据</h3>
<ul>
<li>
<p>数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。</p>
</li>
<li>
<p>硬件实现的数据类型——数据表示</p>
</li>
<li>
<p>软件实现的数据类型——数据结构</p>
</li>
</ul>
<h3 id="整数的表示"><a class="header-anchor" href="#整数的表示"></a>整数的表示</h3>
<ol>
<li>有符号整数，符号位为0表示为正；符号位为1表示为负</li>
</ol>
<p>出于各种原因，针对二进制数，设计出了以下几种二进制编码</p>
<ul>
<li>
<p>原码</p>
</li>
<li>
<p>反码</p>
</li>
<li>
<p>补码</p>
</li>
<li>
<p>移码</p>
</li>
</ul>
<h4 id="原码："><a class="header-anchor" href="#原码："></a>原码：</h4>
<ol>
<li>
<p>一个数的绝对值的二进制表示</p>
</li>
<li>
<p>特点：</p>
</li>
</ol>
<ul>
<li>含有+0（0000 0000）和-0（1111 1111）</li>
<li>计算乘除法比较方便，加减法较麻烦</li>
</ul>
<p>为了简便加减法运算，因而设计出了<strong>补码</strong></p>
<h4 id="反码："><a class="header-anchor" href="#反码："></a>反码：</h4>
<p>也叫一位补数</p>
<ol>
<li>正数的反码是其本身，如： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn><mtext> </mtext><mn>0001</mn><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>反码</mtext></mpadded></mover><mn>0000</mn><mtext> </mtext><mn>0001</mn></mrow><annotation encoding="application/x-tex">0000~0001 \xrightarrow{\text{反码}} 0000~0001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord">0000</span><span class="mspace nobreak"> </span><span class="mord">0001</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">反码</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0000</span><span class="mspace nobreak"> </span><span class="mord">0001</span></span></span></span></li>
<li>负数的反码，则符号位不变，其余各位取反，如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn><mtext> </mtext><mn>0001</mn><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>反码</mtext></mpadded></mover><mn>1111</mn><mtext> </mtext><mn>1110</mn></mrow><annotation encoding="application/x-tex">1000~0001 \xrightarrow{\text{反码}} 1111~1110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord">1000</span><span class="mspace nobreak"> </span><span class="mord">0001</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">反码</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1111</span><span class="mspace nobreak"> </span><span class="mord">1110</span></span></span></span></li>
</ol>
<h4 id="补码："><a class="header-anchor" href="#补码："></a>补码：</h4>
<p>也叫二位补数</p>
<ol>
<li>
<p>将一个数的反码末位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 即可得到补码；也可以将原码从右向左，第一个1的下一位开始进行取反，符号位除外。</p>
</li>
<li>
<p>具体应用</p>
</li>
</ol>
<ul>
<li>无模运算：实数范围内进行运算</li>
<li>有模运算：
<ol>
<li>概念：给定一个正整数p，任意一个整数n，一定存在等式 n = k*p + r<br>
其中k 、r 是整数，且 0 ≤ r &lt; p 称呼k 为n 除以p 的商，r 为n 除以p的余数。</li>
<li>有模运算体系当中，减去一个数等于加上这个数对模的补数。如a+b=M a和b互为补数</li>
</ol>
</li>
<li>（二进制）正数的补码是其本身，负数（无论整数还是小数 ）的补码，将负数变成补码——每一位取反末位加一</li>
</ul>
<p>在计算机当中，加减法均采用补码进行</p>
<ul>
<li>
<p>在纯小数二进制编码当中 补码为1.0000000 —&gt;真值：-1.0000000 最高位表示为数值位也是符号位；原码：超出范围</p>
</li>
<li>
<p>补码符号位拓展：</p>
<p>将n位定点整数补码拓展到2n位：</p>
<ul>
<li>当补码表示正数时，则直接在前面补上n个0即可</li>
<li>当补码表示负数时，则在前面补上n个1即可</li>
</ul>
<p>即与符号位保持一致进行拓展</p>
</li>
<li>
<p>算术右移（除2运算）</p>
</li>
</ul>
<p>一个数算术右移1位后，其最低有效位被移出。低位舍去，高位补符号位</p>
<p>小数 正数情况：低位舍去，高位补0</p>
<p>​		负数情况：低位舍去，高位补1</p>
<ul>
<li>算术左移（乘2运算）</li>
</ul>
<h4 id="移码："><a class="header-anchor" href="#移码："></a>移码：</h4>
<ol>
<li>移码的表示范围：此处只讨论纯整数</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">移码=偏移量+真值</th>
<th style="text-align:center">真值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1111 1111</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">1111 1110</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2{n}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center">1000 0000 (偏移量)</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center">0000 0001</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{n}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">0000 0000</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">-2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
</tbody>
</table>
<p>由上图可看出看，移码的设计初衷即是为了使得移码值和真值成线性正比关系</p>
<ol start="2">
<li>无论正负数：补码求移码——符号位取反即可</li>
<li>移码主要应用于浮点数的阶码。</li>
</ol>
<h4 id="总结"><a class="header-anchor" href="#总结"></a>总结</h4>
<p><a href="https://www.bilibili.com/video/BV1KP411X71M/?p=2&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.02.29 补码的性质2；反码、移码_哔哩哔哩 bilibili</a></p>
<ol>
<li>正数的原码，补码，反码<strong>相同</strong>；</li>
<li>负数的反码：原码的数值（符号位除外）取反；</li>
<li>负数的补码：原码转换成反码，反码末位加1；除符号位，将原码从右到左第一个1之后的位取反即可。</li>
<li>一个数的移码：与补码的符号位取反。</li>
</ol>
<p>除了以上四种常见的编码外，还有以下编码，可供了解：</p>
<p>**BCD码（Binary-Coded Decimal） **</p>
<p><strong>8421码（有权码）最常见：</strong></p>
<p>采取 4个二进制位对应一个十进制位</p>
<p>每一位的权重分别为：8、4、2、1</p>
<p>计算方法：</p>
<p>E.p ：5（0101）+ 8（1000） = 13（1101）不在映射内（1010~1 0010）则加上6进行修正</p>
<p>则13（1101）+ 6（0110） = 19（1 0011）== 1（00001）&amp;&amp; 3（0011）</p>
<p>**2421码： **</p>
<p>重定义的权值</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243623.png" alt="image-20230919163128770" style="zoom:50%;" />
<p><strong>其他的4位有权BCD码：</strong></p>
<p>5421码、5211码、4311码 —— 这三种对9互补，逢十进一</p>
<p>84-2-1（八四负二负一）码</p>
<p><strong>余3码（无权码）：</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8421</mn><mtext>码</mtext><mo>+</mo><mo stretchy="false">(</mo><mn>0011</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">8421码 + (0011)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">8421</span><span class="mord cjk_fallback">码</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0011</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><strong>其他的4位无权BCD码：</strong></p>
<p>格雷码（1）、格雷码（2）、格雷码（3）</p>
<h4 id="一位全加器的表达式："><a class="header-anchor" href="#一位全加器的表达式："></a>一位全加器的表达式：</h4>
<h4 id="img-src-https-blog-caigui88-oss-cn-shenzhen-aliyuncs-com-imgs-202503011243607-png-alt-image-20231218090128576-style-zoom-67"><a class="header-anchor" href="#img-src-https-blog-caigui88-oss-cn-shenzhen-aliyuncs-com-imgs-202503011243607-png-alt-image-20231218090128576-style-zoom-67"></a><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243607.png" alt="image-20231218090128576" style="zoom:67%;" /></h4>
<h3 id="浮点数"><a class="header-anchor" href="#浮点数"></a>浮点数</h3>
<p><a href="https://www.bilibili.com/video/BV1KP411X71M?p=3&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.03.04 浮点数的一般格式1</a></p>
<p>科学计数法：</p>
<ul>
<li>动态移动十进制小数点到约定位置，并使用10的指数来记录此小数点的位置</li>
<li>可表示整数也可表示小数</li>
<li>可表示范围很大</li>
<li>规格化数字</li>
</ul>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244008.png" alt="image-20230919092538911" style="zoom:50%;" />
<p>数符：表示浮点数的符号</p>
<p>阶符：</p>
<p>阶码：（数值部分）从高位开始进行比较 阶码位数表示表示范围</p>
<p>尾数：（数值部分） 尾数位数越多，精度越高</p>
<p>所谓的浮点数表示其实可以简单粗暴的理解成，把一个数按照以2为模的科学计数法，将符号（+ -）放在首位——数符，将2^n以二进制形式放在前面——阶码，把数的部分以二进制码形式放在后面——尾数</p>
<p>但是二进制的尾数是纯小数形式，不需要小数点前有有效数字。</p>
<p>规格化的浮点数：</p>
<p>在计算机当中尾数的表示一般采取的是原码，但是补码也得了解了解</p>
<ul>
<li>
<p>如果阶码的底为2，则尾数应该满足 1/2 &lt;= |M| &lt; 1 —— 原码 小数点右侧第一位为1（0.1xxxxxxx……）</p>
</li>
<li>
<p>当尾数用补码表示：</p>
<ul>
<li>
<p>尾数M&gt;=0时，尾数应当具有的格式：M = 0.1xxxxx…x，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>当</mtext><mi>M</mi><mo>≥</mo><mn>0</mn><mtext>时，</mtext><mo stretchy="false">[</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>≤</mo><mo stretchy="false">[</mo><mi>M</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>&lt;</mo><mo stretchy="false">[</mo><mn>1</mn><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">当M \geq 0 时，[\frac{1}{2}]_补 \leq [M]_补 &lt; [1]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord">0</span><span class="mord cjk_fallback">时，</span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>尾数M&lt;0时，不将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-1/2]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1/2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>列入规格化的数，而把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[1]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>列入规格化的数当中。</p>
</li>
<li>
<p>即: $[1/2]_补 \geq [M]_补 \leq [1]_补 $</p>
</li>
</ul>
</li>
<li>
<p>左规：</p>
<p>采用变形补码表示尾数，则当结果的尾数出现11.11xxxx或00.0xxxx时，将尾数左移1位，阶码-1，直到尾数变为<strong>规格化</strong>形式为止</p>
</li>
<li>
<p>右规：</p>
<p>当结果尾数出现01.xxxx……x或者10.xxx……x时，并不一定溢出，应当先把尾数右移一位，阶码+1，在判断阶码是否溢出</p>
</li>
</ul>
<p>奇偶校验码：</p>
<p>对于一个n位的信息，在最前面增加一个奇偶校验位，即通过这个增加的校验位来使得整个有效信息串当中的1的个数达到“奇数”——对应奇校验 或者“偶数”——对应偶校验</p>
<p>方法局限性：</p>
<p>当出现偶数个位数的错误时，则无法进行校验。</p>
<p>奇校验：</p>
<p>整个校验码（有效信息位和校验位）当中“1”的个数位奇数</p>
<p>偶校验：</p>
<p>整个校验码（有效信息位和校验位）当中“1”的个数位偶数</p>
<p>校验：</p>
<p>使用<strong>异或运算</strong>操作进行偶校验，结果为0则未出错，结果为1则出错</p>
<p>算数逻辑单元</p>
<p>（Arithmetic and Logic Unit，ALU）</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244281.png" alt="image-20230919213319875" style="zoom: 67%;" />
<p>IEEE745标准：</p>
<p>尾数的格式：</p>
<p>规格化的原码表示—— S.1xxxxxx</p>
<p>规格化补码表示—— 正数：0.1xxxxxx	负数：1.0xxxxxx</p>
<h3 id="二进制的运算"><a class="header-anchor" href="#二进制的运算"></a>二进制的运算</h3>
<h4 id="二进制的乘法："><a class="header-anchor" href="#二进制的乘法："></a>二进制的乘法：</h4>
<p>补码的乘法运算规则：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244727.png" alt="image-20230921184009102" style="zoom:50%;" />
<p>补码的编码值按位展开得到真值，正数符号位权值为<strong>1</strong>，负数符号位权值为**-1**</p>
<h4 id="原码一位乘法："><a class="header-anchor" href="#原码一位乘法："></a>原码一位乘法：</h4>
<p>和手算一样</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244121.png" alt="image-20230923105803490" style="zoom:27%;" />
<p>加法次数和相乘的两个原码的位数相同</p>
<h4 id="Booth法"><a class="header-anchor" href="#Booth法"></a>Booth法</h4>
<p>时序逻辑电路图</p>
<p>无符号：Booth法的电路是时序逻辑电路，具有时钟信号控制</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244402.png" alt="image-20230922162220296" style="zoom:50%;" />
<h4 id="阵列乘法器"><a class="header-anchor" href="#阵列乘法器"></a>阵列乘法器</h4>
<p>1）手算及单元电路</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244587.png" alt="image-20230923101554580" style="zoom: 30%;" />
<p>2）、定点无符号数阵列乘法器</p>
<p>组合逻辑电路因为不需要根据时钟周期进行移位累加，所使用的时间会少于移位累加的方法</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244655.png" alt="image-20230922170428659"></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244576.png" alt="image-20230923101344400" style="zoom:30%;" />
<p>3）、有符号数的阵列乘法</p>
<p>下图中的电路可以完美实现一个二进制数的求补操作，即——从右往左找到第一个<strong>1</strong>，之后的所有位按位取反</p>
<p>可通过图中电路图可以做到</p>
<ol>
<li>已知一个数的补码，求该数的绝对值</li>
<li>已知一个数的绝对值，求该数的补码</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244232.png" alt="image-20230923102304075" style="zoom:25%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244590.png" alt="image-20230923102750917" style="zoom:26.5%;" />
<h4 id="二进制的除法"><a class="header-anchor" href="#二进制的除法"></a>二进制的除法</h4>
<h4 id="1）、原码除法"><a class="header-anchor" href="#1）、原码除法"></a>1）、原码除法</h4>
<p>规则：</p>
<ol>
<li>前提条件
<ol>
<li>除数 != 0</li>
<li>定点纯小数时，被除数绝对值小于除数，商的结果位数与除数保持一致，则认为精度足够了</li>
<li>定点纯整数时，被除数绝对值大于或等于除数</li>
</ol>
</li>
<li>商的符号==被除数符号<strong>异或</strong>除数符号</li>
<li>商的绝对值==被除数绝对值/除数绝对值</li>
<li>将符号和绝对值拼接</li>
</ol>
<p>由手算引入逻辑实现</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011244797.png" alt="image-20230923103943081" style="zoom:30%;" />
<h4 id="2）、恢复余数法"><a class="header-anchor" href="#2）、恢复余数法"></a>2）、恢复余数法</h4>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245398.png" alt="image-20230923105332402" style="zoom:29.5%;" />
<h4 id="3）、不恢复余数法"><a class="header-anchor" href="#3）、不恢复余数法"></a>3）、不恢复余数法</h4>
<h1 align=center> 存储体系结构 </h1>
<h2 id="CH8-计算机存储体系结构"><a class="header-anchor" href="#CH8-计算机存储体系结构"></a>CH8 计算机存储体系结构</h2>
<h3 id="8-1基本概念"><a class="header-anchor" href="#8-1基本概念"></a>8.1基本概念</h3>
<h4 id="存储器"><a class="header-anchor" href="#存储器"></a>存储器</h4>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245083.png" alt="image-20231010221402861" style="zoom: 33%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245730.png" alt="image-20231010222309462" style="zoom: 50%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245153.png" alt="image-20231010222624421" style="zoom:50%;" />
<p>存储器的不同特性</p>
<ul>
<li>存储信息的介质，物质类型
<ul>
<li>Semiconductor，半导体</li>
<li>Magnetic Surface，磁盘，磁带</li>
<li>Optical，光盘</li>
</ul>
</li>
<li>用途</li>
<li>信息的易失性/非易失性</li>
<li>转移单位</li>
<li>存取方式
<ul>
<li>随机——存取时间和物理地址无光，任一单元的读写所需时间相同</li>
<li>顺序</li>
</ul>
</li>
<li>读写功能</li>
</ul>
<h4 id="内存"><a class="header-anchor" href="#内存"></a>内存</h4>
<ul>
<li>
<p>内存(Primary Storage)：计算机中直接被处理器(Processor)访问的存储器，也称为主存（Main Memory）或内部存储器（Internal Memory）。</p>
<ul>
<li>内存可以存储当前运行的程序和数据，以供处理器使用。</li>
</ul>
</li>
<li>
<p>内存比起外部存储器：读写速度更快，容量小，价格高</p>
</li>
<li>
<p>内存的类型有很多，常见的有随机存取存储器（RAM）、只读存储器（ROM）、高速缓冲存储器（Cache）。</p>
<ul>
<li>
<p>随机存取存储器（Random Access Memory,RAM）是一种可读写的内存，也叫做主存。它可以随机地访问任何一个地址的数据，而不需要按照顺序。RAM是易失性的，也就是说，当断电时，它会丢失所有的数据。</p>
<ul>
<li>RAM有两种主要的子类：
<ul>
<li>静态RAM（Staic Random Access Memory,SRAM）：不掉电，则内容不丢失</li>
<li>动态RAM（Dynamic Ranodm Access Memory,DRAM）
<ul>
<li>同步DRAM（Synchronous DRAM,SDRAM）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>只读存储器（Read Only Memory,ROM）是一种只能读取的内存，也叫做固件。它通常用来保存一些不会改变的数据或程序，例如计算机启动时的基本输入输出系统（BIOS）。ROM是非易失性的，也就是说，当断电时，它不会丢失数据。</p>
<ul>
<li>ROM有三种主要的子类：
<ul>
<li>可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）</li>
<li>电子可擦除可编程只读存储器（EEPROM）</li>
<li>闪速（Flash） ：
<ul>
<li>NOR</li>
<li>NAND</li>
</ul>
</li>
</ul>
</li>
<li>ROM当中存储有一段代码指令<strong>BIOS</strong>，作用：
<ul>
<li>硬件自检</li>
<li>输入输出接口初始化</li>
<li>最后跳转到MM当中的引导扇区，以及操作系统的启动</li>
</ul>
</li>
</ul>
</li>
<li>
<p>高速缓冲存储器（Cache）是一种位于处理器和主存之间的高速内存，它可以缓存一些经常使用的数据或指令，以减少处理器访问主存的时间。</p>
<p>Cache是静态RAM（SRAM）制造的，它比动态RAM（DRAM）更快，但也更贵。</p>
<ul>
<li>Cache有多个级别，通常分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>主存的运作（作用）：</p>
<ul>
<li>
<p>Connection of the Memory to the Processor——连接存储器和处理器</p>
</li>
<li>
<p>Processor-Memory Interface</p>
<ul>
<li>[处理器-内存接口的主要目的是让处理器能够读取或写入内存中的数据，以执行指令或存储结果。](http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture 13 - memory interface.pdf)</li>
<li>基本原理：当处理器需要访问内存时，它会将内存地址发送到地址总线上，然后通过一个解码电路来选择相应的内存芯片或设备。</li>
</ul>
</li>
<li>
<p>Read(Load) Operation</p>
<ul>
<li>将一个特定内存位置的数据副本读到处理器（Processor）</li>
<li>Processor： Load the address of the required memory location  into the MAR register and set the R/W line to 1</li>
<li>Memory：Place the data from the addressed location onto the  data lines and confirm this action by asserting the MFC signal</li>
<li>Processor: Upon receipt of the MFC signal, the processor loads  the data on the data lines into the MDR register.</li>
</ul>
</li>
<li>
<p>Write(Store) Operation</p>
<ul>
<li>将一项信息从处理器传输到特定位置，销毁该位置先前的内容。</li>
<li>Processor： Load the address of the specific location into MAR and  load the data into MDR register. It also set the R/W line to 0.</li>
<li>Memory：When the data have been written, it responses processor  with MFC signal.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="外存"><a class="header-anchor" href="#外存"></a>外存</h4>
<ul>
<li>
<p>外存(Secondary Storage)：计算机中不能直接被处理器访问的存储器，也称为辅助存储器（Auxiliary Storage）或外部存储器（External Memory）。</p>
<ul>
<li>
<p>外存可以长期保存大量的数据或程序，以供计算机使用。</p>
</li>
<li>
<p>外存的速度比内存：读写速度慢，容量更大，价格更低。</p>
</li>
</ul>
</li>
<li>
<p>外存的类型有很多，常见的有硬盘（Hard Disk）、固态硬盘（Solid State Drive）、U盘（Thumb Drive）、SD卡（SD Card）、光盘（Optical Disc）等。</p>
<ul>
<li>
<p>硬盘（<strong>Hard Disk</strong>）是一种利用磁性材料记录数据的外存，也叫做磁盘。它由一个或多个金属盘片组成，每个盘片都覆盖了磁性材料。硬盘通过一个机械臂上的磁头来读写数据，磁头可以在盘片上移动到不同的位置。硬盘的容量很大，但是速度较慢，而且易受物理损坏。</p>
</li>
<li>
<p>固态硬盘（<strong>Solid State Drive</strong>）是一种利用闪存芯片记录数据的外存，也叫做闪存盘。它没有任何机械部件，因此速度很快，而且抗震性强。固态硬盘的容量较小，但是价格较高，而且有写入次数的限制。</p>
</li>
<li>
<p>U盘（<strong>Thumb Drive</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做USB驱动器。它可以通过USB接口连接到计算机上，实现数据的传输和存储。U盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。U盘的优点是方便携带和使用，缺点是易丢失和损坏。</p>
</li>
<li>
<p>SD卡（<strong>SD Card</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做安全数字卡。它可以通过SD卡插槽连接到计算机或其他设备上，实现数据的传输和存储。SD卡的容量和速度各有不同，但是都比U盘小得多。SD卡的优点是体积小巧和兼容性强，缺点是易损坏和丢失。</p>
</li>
<li>
<p>光盘（<strong>Optical Disc</strong>）是一种利用光学原理记录数据的外存，也叫做光学数字媒体。它由一个或多个塑料圆盘组成，每个圆盘都覆盖了一层反射材料。光盘通过一个激光头来读写数据，激光头可以在圆盘上移动到不同的位置。光盘的类型有很多，常见的有CD（Compact Disc）、DVD（Digital Versatile Disc）、BD（Blu-ray Disc）等。光盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。光盘的优点是成本低廉和寿命长久，缺点是易刮花和损坏。</p>
</li>
</ul>
</li>
</ul>
<h4 id="寄存器"><a class="header-anchor" href="#寄存器"></a>寄存器</h4>
<ul>
<li>MAR(Memory Address Register) 存储器地址寄存器</li>
<li>MDR(Memory Data Register) 存储器数据寄存器</li>
</ul>
<h4 id="存储单元和地址"><a class="header-anchor" href="#存储单元和地址"></a>存储单元和地址</h4>
<ul>
<li>
<p>Word（字）：每一组固定大小的<strong>bit</strong>称为一个字。</p>
</li>
<li>
<p>Word Length（字长）：每个字的位数称为字长。它通常在16位到64位之间</p>
</li>
<li>
<p>Byte(字节)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mo>=</mo><mn>8</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">1 byte = 8 bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span> byte是KB，MB，GB中的B。</p>
<ul>
<li>K: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo separator="true">,</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">2^{10},1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1024</span></span></span></span></li>
<li>M：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo separator="true">,</mo><mn>1046576</mn></mrow><annotation encoding="application/x-tex">2^{20},1046576</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1046576</span></span></span></span></li>
<li>G：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo separator="true">,</mo><mn>1073741824</mn></mrow><annotation encoding="application/x-tex">2^{30},1073741824</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1073741824</span></span></span></span></li>
</ul>
</li>
</ul>
<p>计算机存储器图表表示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245430.png" alt="image-20231010165617847" style="zoom:50%;" /> 
<h4 id="字节序"><a class="header-anchor" href="#字节序"></a>字节序</h4>
<p>1、大端赋值</p>
<p>字节排序</p>
<p>多字节数据类型（如整数、浮点数等）在内存中的字节排列顺序。它决定了在内存中的哪个字节存储数据的最低有效位（低位）和最高有效位（高位）。字节排序有两种常见的方式：大端序（Big-endian）和小端序（Little-endian）。</p>
<p>大端赋值（Big-Endian）</p>
<ul>
<li>在大端字节顺序中，最高有效字节（Most Significant Byte，MSB）位于内存地址的最低端（低地址端）</li>
<li>最低有效字节（Least Significant Byte，LSB）位于内存地址的最高端（高地址端）。</li>
<li>这意味着在大端字节顺序下，数据的各个字节按照从高位到低位的顺序存储，与日常习惯从左到右读数的顺序相同。</li>
</ul>
<p><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">大端赋值（从左到右）是一种在内存中存储数据的方式，其中最高有效字节（MSB）放在最低的内存地址，而最低有效字节（LSB）放在最高的内存地址。这意味着字节的存储顺序与我们从左到右读取它们的顺序相同。</a></p>
<p>例如，如果我们想要将十六进制数 0x12345678 存储在一个 4 字节的内存位置，我们将按照以下方式分配字节：</p>
<table>
<thead>
<tr>
<th style="text-align:left">内存地址</th>
<th style="text-align:left">字节值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x1000</td>
<td style="text-align:left">0x12</td>
</tr>
<tr>
<td style="text-align:left">0x1001</td>
<td style="text-align:left">0x34</td>
</tr>
<tr>
<td style="text-align:left">0x1002</td>
<td style="text-align:left">0x56</td>
</tr>
<tr>
<td style="text-align:left">0x1003</td>
<td style="text-align:left">0x78</td>
</tr>
</tbody>
</table>
<p><a href="https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/">这也被称为大端字节序或网络字节序，因为它通常用于网络协议，如 TCP/IP。</a></p>
<p>大端赋值的一些优点是：</p>
<ul>
<li><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">它更容易阅读和调试，因为数据的存储顺序与我们写它的顺序相同。</a></li>
<li><a href="https://teaching.idallen.com/cst8281/10w/notes/110_byte_order_endian.html">它与我们在数学中表示数字的方式一致，其中最高有效位在左边。</a></li>
<li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它简化了算术运算，如加法和减法，因为进位或借位从右到左传播。</a></li>
</ul>
<p>大端赋值的一些缺点是：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/26204333/little-endian-and-big-endian">它与一些使用小端赋值的处理器不兼容，其中 LSB 在最低的内存地址，而 MSB 在最高的内存地址。这在不同系统之间交换数据时可能会导致问题。</a></li>
<li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它在处理数组或矩阵时可能会引起混淆，因为索引顺序可能与字节顺序不匹配。例如，在 Verilog 中，一个声明为 <code>reg [3:0\] array1 [0:7]</code> 的数组具有大端位顺序，但小端索引顺序。</a></li>
</ul>
<p>2、小端赋值</p>
<ul>
<li>在小端序中，最低有效字节（低位字节）存储在内存的最低地址。</li>
<li>最高有效字节（高位字节）存储在内存的最高地址。</li>
<li>这种字节排序方式类似于我们书写数字的方式，从右到左。</li>
<li>小端序在一些体系结构（如x86、ARM、网络通信协议中的小端序）中使用。</li>
</ul>
<h4 id="访问方式："><a class="header-anchor" href="#访问方式："></a>访问方式：</h4>
<p>1、Sequential Access	顺序访问</p>
<ol>
<li>如果当前记录为1，那么为了读取记录N，需要读取记录1到N-1。</li>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245993.png" alt="image-20231207191223478" style="zoom: 50%;" /> 
</li>
</ol>
<p>2、Direct Access			直接访问</p>
<ol>
<li>访问是通过直接访问到达大致附近加上顺序搜索、计数或等待到达最终位置来完成的。</li>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245784.png" alt="image-20231207192656562" style="zoom:50%;" /> 
</li>
</ol>
<p>3、Random Access		随机访问</p>
<ol>
<li>任何存储位置都可以随机选择并直接寻址和访问。</li>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245629.png" alt="image-20231207192628560" style="zoom:50%;" /> 
</li>
</ol>
<p>内存访问时间：</p>
<ol>
<li>
<p>Memory Access Time</p>
<ul>
<li>得到地址和获取有效数据（内存或其他存储）之间的时间</li>
</ul>
<ol>
<li>
<p>Random-Access Memory</p>
<ul>
<li>执行读或写操作所需的时间</li>
</ul>
</li>
<li>
<p>Non-Random-Access Memory</p>
<ul>
<li>将读写机制定位到所需位置所需的时间。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Memory Cycle Time</p>
<ol>
<li>仅用于随机存储</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="易失性与非易失性："><a class="header-anchor" href="#易失性与非易失性："></a>易失性与非易失性：</h4>
<p>volatile和nonvolatile</p>
<ol>
<li>volatile
<ul>
<li>当电源关闭时，信息会自然衰减或丢失</li>
</ul>
</li>
<li>nonvolatile
<ul>
<li>信息一旦记录，就不会变质，直到被故意更改为止。 无需电力即可保留信息</li>
</ul>
</li>
</ol>
<h4 id="可擦除和不可擦除性"><a class="header-anchor" href="#可擦除和不可擦除性"></a>可擦除和不可擦除性</h4>
<p>erasable和nonerasable</p>
<ol>
<li>
<p>erasable</p>
<ul>
<li>保存在内存中的信息可以被替换修改</li>
</ul>
</li>
<li>
<p>nonerasable</p>
<ul>
<li>保存在内存中的信息不可被替换修改，除非损毁对应的存储单元</li>
</ul>
</li>
</ol>
<h3 id="8-2-存储器及其部分概念"><a class="header-anchor" href="#8-2-存储器及其部分概念"></a>8.2 存储器及其部分概念</h3>
<h4 id="1、SRAM"><a class="header-anchor" href="#1、SRAM"></a>1、SRAM</h4>
<p><strong>Static Random Access Memory</strong> 	<strong>静态随机存储器</strong></p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245502.png" alt="image-20231020151241416" style="zoom:50%;" /> 
<p>只要不断电,信息一直保持——静态</p>
<p>初始加电后状态随机</p>
<p>n个存储器构成n位存储单元</p>
<p>熟练掌握以下SRAM的画法</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245107.png" alt="image-20231207173618008" style="zoom: 67%;" /> 
<p>对于一个SRAM需要的引脚数：</p>
<p>以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>K</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1K \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 为例：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>K</mi><mo>×</mo><mn>1</mn><mo>→</mo><msup><mn>2</mn><mn>10</mn></msup><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1K \times 1 \rightarrow 2^{10} \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<ol>
<li>地址线Address Lines（input）：10根地址线——<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mtext> </mtext><mo>−</mo><mtext> </mtext><msub><mi>A</mi><mn>9</mn></msub></mrow><annotation encoding="application/x-tex">A_0~-~A_{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>数据线Data Lines（Input/Output）：1根数据线——<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>控制线Control Lines（Input）：R/W，CS</li>
<li>以及其他两根常规的电源线Power Supply Line和地线Ground Line</li>
</ol>
<p>总计=10+1+2+2 = 15</p>
<h4 id="2、DRAM"><a class="header-anchor" href="#2、DRAM"></a>2、DRAM</h4>
<p><strong>Dynamic Random Access Memory</strong>	<strong>动态随机存储器</strong></p>
<p>优点：</p>
<ol>
<li>高密度</li>
<li>低成本</li>
</ol>
<p>缺点：</p>
<ol>
<li>更长的访问时间</li>
<li>易失的，需要不断刷新</li>
<li>不易被CMOS集成</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245772.png" alt="image-20231208095542511" style="zoom:50%;" /> 
<p>需要掌握以下图中一个DRAM的画法</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245615.png" alt="image-20231207174152063" style="zoom:67%;" /> 
<p>对于一个DRAM需要的引脚数量位：</p>
<p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mi>K</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">64K \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>为例：</p>
<ol>
<li>地址线：8   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mi>K</mi><mo>=</mo><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">64K = 2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> 为了节省线路，因而将行地址线和列地址线进行复用，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>16</mn><mn>2</mn></mfrac><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\frac{16}{2} = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span></li>
<li>数据线：1根</li>
<li>控制线：1   只有R/W线</li>
<li>还有常规的电源线、地线以及刷新线</li>
</ol>
<p><strong>Burst操作</strong></p>
<h4 id="3、Latency-and-Bandwidth"><a class="header-anchor" href="#3、Latency-and-Bandwidth"></a>3、Latency and Bandwidth</h4>
<p>延迟和带宽是指示内存系统性能的两个参数。</p>
<ol>
<li>Latency：指将一个字的数据传入或传出内存所花费的时间
<ol>
<li>注意：在块传输中，延迟用于表示传输第一个数据字之前所需的时间。</li>
</ol>
</li>
<li>Bandwidth：
<ol>
<li>一秒内可以传输的位数或字节数称为带宽。</li>
<li>单位：比特每秒或字节每秒。</li>
<li>存储单元的带宽取决于存储数据的访问速度以及可并行访问的位数。</li>
<li>有效带宽还取决于连接存储器和处理器的链路的传输能力。</li>
<li>有效带宽 = 总线速度 × 总线宽度</li>
</ol>
</li>
</ol>
<h3 id="8-3-Cache-Memories"><a class="header-anchor" href="#8-3-Cache-Memories"></a>8.3 Cache Memories</h3>
<p>Main Memory的一个块只能映射到Cache固定的一行当中，</p>
<h4 id="主存和cache的三种地址映射方式"><a class="header-anchor" href="#主存和cache的三种地址映射方式"></a>主存和cache的三种地址映射方式</h4>
<h4 id="1、直接映射"><a class="header-anchor" href="#1、直接映射"></a>1、直接映射</h4>
<p><strong>Direct Mapping</strong></p>
<p>主存每个块可以放在cache同一个槽当中</p>
<p>假设cache槽数为8，</p>
<p>将Main Memory每八个块切割为一组进行分组，在同一组内的相同位置，放在cache的同一个槽位内。</p>
<p>即：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245507.png" alt="image-20231207213537311" style="zoom:67%;" /> 
<p>如图中，在Main Memory当中块号为2——<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>8</mn><mo>=</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2~mod~8 == 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ,同样的，块号为10——<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>8</mn><mo>=</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">10~mod~8==2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">10</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 则第2块和第10块放在cache的2号槽当中。</p>
<h4 id="2、全相联映射"><a class="header-anchor" href="#2、全相联映射"></a>2、全相联映射</h4>
<p><strong>Fully Associative Mapping</strong></p>
<p>主存任意块可以映射到cache任意槽内。</p>
<h4 id="3、组相连映射"><a class="header-anchor" href="#3、组相连映射"></a>3、组相连映射</h4>
<p><strong>Set Associative Mapping</strong></p>
<p>主存多个块放在Cache同一个组内的任一槽当中</p>
<ol>
<li>先将Cache进行分组，假设Cache内有8个槽，每2个槽为一组，可分为4组，如下图所示：</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245317.png" alt="image-20231207214021904" style="zoom: 50%;" /> 
<ol start="2">
<li>将Main Memory 按照Cache的组数进行分组，即Cache分为4组，则Main Memory的每四块为一组。组内号对应着Cache的组号，假设Main Memory内有20个块，可分为5组，$块_0 $ 对应的组内号为0 ，则映射到Cache<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>组</mtext><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">组_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord cjk_fallback">组</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的任意一个槽当中。</li>
</ol>
<p>分区——分组——分块</p>
<p>目录表：</p>
 <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245862.png" alt="image-20231023100630364" style="zoom:33%;" />
<p>主存区号——主存组内块号——Cache组内块号——有效位</p>
<p>主存地址：</p>
<p>区号—组号—主存组内块号—块内地址</p>
<p>Cache地址：</p>
<p>tag——set——word</p>
<h3 id="8-4-虚存"><a class="header-anchor" href="#8-4-虚存"></a>8.4 虚存</h3>
<p><strong>virtual Memory</strong></p>
<ol>
<li>无物理设备但是有抽象概念</li>
<li></li>
</ol>
<h4 id="1、页式虚存（Paging）"><a class="header-anchor" href="#1、页式虚存（Paging）"></a>1、页式虚存（Paging）</h4>
<ol>
<li>
<p>以页为单位</p>
</li>
<li>
<p>虚拟空间和主存空间划分为相同大小的页，主存内的页——实页；虚存内的页——虚页</p>
</li>
<li>
<p>虚拟地址——虚页号+页内地址</p>
<p>虚拟地址到物理地址的转换由页表是实现</p>
<ol>
<li>页表：存放在主存内的虚页号和实页号的对照表，用以记录虚页存入主存时安排再主存的哪个位置。</li>
</ol>
</li>
<li>
<p>Write Policy</p>
<ol>
<li>Write Back</li>
<li>write through is not suitable for virtual memory</li>
</ol>
</li>
<li>
<p>TLB（快表）</p>
</li>
<li>
<p>页表内容：</p>
<ul>
<li>页号：</li>
<li>有效位：标记该页是否被加载到主存当中</li>
<li>修改位/脏位：标记该页是否被修改</li>
<li>引用位/使用位：标记改页是否被使用</li>
<li>访问控制位</li>
</ul>
</li>
<li>
<p>选择较大页面尺寸的优点</p>
<ul>
<li>页表的大小与页面大小成反比：因此可以通过增大页面来节省内存。</li>
<li>可能通过网络将较大的页面传输到辅助存储或从辅助存储传输较大的页面比传输较小的页面更有效。</li>
</ul>
</li>
<li>
<p>选择较大页面尺寸的缺点</p>
<ul>
<li>当虚拟内存的连续区域的大小不等于页面大小的倍数时，较大的页面大小将导致更多的存储浪费（内部碎片）。</li>
</ul>
</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1Et411E7D6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9fb105320442648b8c6fe466cf6f8b5c">Cache与虚拟存储器_哔哩哔哩_bilibili</a></p>
<h4 id="2、段式虚存"><a class="header-anchor" href="#2、段式虚存"></a>2、段式虚存</h4>
<ol>
<li>虚拟地址组成：Virtual Segment Number+Offset <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245442.png" alt="image-20231210135304188" style="zoom: 67%;" /></li>
<li>段表内容：
<ul>
<li>段的起始位置</li>
<li>段的大小</li>
<li>控制位</li>
</ul>
</li>
<li></li>
</ol>
<h4 id="3、段页式虚存"><a class="header-anchor" href="#3、段页式虚存"></a>3、段页式虚存</h4>
<h2 id="CH2-机器指令"><a class="header-anchor" href="#CH2-机器指令"></a>CH2 机器指令</h2>
<h3 id="2-1指令和指令序列"><a class="header-anchor" href="#2-1指令和指令序列"></a>2.1指令和指令序列</h3>
<h4 id="1、四种指令："><a class="header-anchor" href="#1、四种指令："></a>1、四种指令：</h4>
<ol>
<li>存储器和处理器寄存器之间的数据传输、</li>
<li>数据的算术和逻辑运算</li>
<li>程序序列和控制</li>
<li>I/O传输</li>
</ol>
<h4 id="2、Register-transfer-notation（RTN"><a class="header-anchor" href="#2、Register-transfer-notation（RTN"></a>2、Register transfer notation（RTN)</h4>
<ol>
<li>
<p>一种用于描述硬件级别的关于数据传输与操作的表示方法（就像是markdown一样的一种标记型语言，</p>
<p>E.P:</p>
<ul>
<li>处理器寄存器：R0、R5</li>
<li>I/O 寄存器：DATAIN、OUTSTATUS</li>
<li>内存位置：LOC、PLACE、A、VAR2</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>2</mn><mo>←</mo><mo stretchy="false">[</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R2 \leftarrow [LOC]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mclose">]</span></span></span></span> ——意指将LOC内的数据传输到R2寄存器当中</p>
<p>右操作数通常提供数据，左操作数通常表示一种地址</p>
</li>
<li>
<p>两种RTN的符号</p>
<ol>
<li>“[  ]”表示地址内存储的内容，相当于c++语言当中的解引用*</li>
<li>“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>” 表示数据的传输</li>
</ol>
</li>
</ol>
<h4 id="3、Assembly-Language-Notation（ALN）"><a class="header-anchor" href="#3、Assembly-Language-Notation（ALN）"></a>3、Assembly-Language Notation（ALN）</h4>
<ol>
<li>与RTN一样的一种语言，但是比RTN高级一些。</li>
<li>在有了RTN表示数据的传输和计算之后，需要有语言来表示机器指令或程序并使用它们。</li>
<li>可将$R2 \leftarrow [LOC] $ 转换为汇编语言：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mtext>  </mtext><mi>R</mi><mn>2</mn><mtext>  </mtext><mi>L</mi><mi>O</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">Load~~R2~~LOC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span></span></span></span></li>
<li>指令中包含有操作和操作数</li>
</ol>
<h4 id="4、RISC-Instruction-Sets"><a class="header-anchor" href="#4、RISC-Instruction-Sets"></a>4、RISC Instruction Sets</h4>
<ol>
<li>
<p>缩减计算机指令集合</p>
</li>
<li>
<p>两个关键字：load和store</p>
<ol>
<li>只有这两个操作是用于访问主存的操作数的</li>
<li>用于算数或逻辑指令的操作数必须在处理器的寄存器中或在指令字中显式给出</li>
</ol>
</li>
<li>
<p>指令的执行需要先存储在内存当中</p>
<p>在进行数据的计算之前，需要先进行数据的传输——RISC需要操作数</p>
</li>
<li>
<p>Load操作指令：Load procr_register, mem_location</p>
</li>
</ol>
<h4 id="5、Branching"><a class="header-anchor" href="#5、Branching"></a>5、Branching</h4>
<ol>
<li>即分支语句，联想高级程序语言中的 if语句</li>
</ol>
<h3 id="2-2-指令格式"><a class="header-anchor" href="#2-2-指令格式"></a>2.2 指令格式</h3>
<ol>
<li>指令集即是可被CPU执行的多种机器指令的集合</li>
<li>微程序指令和机器指令的关系：
<ul>
<li>一条机器指令通常是由多条微程序控制指令组合而成的，因为机器指令控制的是CPU的一系列功能；而微程序指令控制的是一系列电路功能，而机器指令的完成需要这些电路功能的完成来实现</li>
</ul>
</li>
</ol>
<p>微命令、微指令、微程序、控制信号概念区分：</p>
<p>总结：</p>
<ul>
<li>
<p>微命令-&gt;微指令-&gt;微程序	A-&gt;B 表示 A组成B</p>
</li>
<li>
<p>控制部件通过控制线向执行部件发出控制命令，这种控制命令称为<mark>微命令</mark>、也称为控制信号。微命令序列即控制信号序列，微命令是最小的单元；</p>
</li>
<li>
<p>在一个CPU的时钟周期内，会产生一系列的微命令，这些微命令的组合形成了<mark>微指令</mark>；</p>
</li>
<li>
<p>一条机器指令通常由一系列微指令组成，这些微指令序列称为<mark>微程序</mark>；</p>
</li>
</ul>
<p>微操作和微指令的联系：</p>
<ul>
<li>
<p>一个<mark>微操作</mark>对应一条<mark>微指令</mark>，一条微指令可能有多个微命令。</p>
</li>
<li>
<p>微指令是一串<mark>编码</mark>，那么微操作就是这段编码所代表的操作。</p>
</li>
<li>
<p><mark>微操作</mark>是<mark>微命令</mark>作用在硬件上的一个当作，</p>
</li>
</ul>
<h4 id="1、指令的元素："><a class="header-anchor" href="#1、指令的元素："></a>1、指令的元素：</h4>
<ol>
<li>
<p>操作码 opcode</p>
</li>
<li>
<p>源操作数地址</p>
</li>
<li>
<p>结果操作数地址</p>
<p>结果操作数地址有三个去向：</p>
<ol>
<li>主存或虚存</li>
<li>处理器寄存器</li>
<li>I/O设备</li>
</ol>
</li>
</ol>
<h4 id="2、指令的表示"><a class="header-anchor" href="#2、指令的表示"></a>2、指令的表示</h4>
<p>指令的组成：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245222.png" alt="image-20231214213936303" style="zoom: 67%;" /> 操作码字段和地址字段</p>
<h4 id="3、指令地址字段的格式"><a class="header-anchor" href="#3、指令地址字段的格式"></a>3、指令地址字段的格式</h4>
<ol>
<li>
<p>零地址</p>
</li>
<li>
<p>一地址</p>
<ol>
<li>存在隐式调用<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245651.png" alt="image-20231214214238803" style="zoom:50%;" /></li>
</ol>
</li>
<li>
<p>二地址</p>
</li>
<li>
<p>三地址</p>
</li>
</ol>
<h4 id="4、指令的长度："><a class="header-anchor" href="#4、指令的长度："></a>4、指令的长度：</h4>
<ol>
<li>
<p>固定长度：所有指令有相同的长度<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011245707.png" alt="image-20231215083957842"></p>
</li>
<li>
<p>可变长度：指令可能会有不同的长度</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246842.png" alt="image-20231215084034340" style="zoom: 67%;" /> 
</li>
<li>
<p>缩减指令长度方法</p>
<ol>
<li>当操作数被<strong>多次使用</strong>时，可移入寄存器当中</li>
<li>隐式指定一个或多个操作数</li>
</ol>
</li>
</ol>
<h4 id="5、操作码格式"><a class="header-anchor" href="#5、操作码格式"></a>5、操作码格式</h4>
<ol>
<li>
<p>固定长度操作码</p>
<ol>
<li>操作码长度固定，但指令长度可变</li>
</ol>
</li>
<li>
<p>可变长度操作码（拓展操作码）</p>
<p>通常指令长度固定，但操作码和操作数地址的长度此消彼长</p>
<p>E.P…</p>
<p>Suppose the designers need</p>
<ul>
<li>
<p>15 three-address instructions</p>
</li>
<li>
<p>14 two-address instructions</p>
</li>
<li>
<p>31 one-address instructions</p>
</li>
<li>
<p>16 zero-address instructions</p>
</li>
</ul>
<p>How should we design the instruction format?</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246141.jpg" alt="02c3d0bfa744674125de773e1d082e8" style="zoom: 25%;" /> 
</li>
</ol>
<h4 id="6、寻址模式"><a class="header-anchor" href="#6、寻址模式"></a>6、寻址模式</h4>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246871.png" alt="image-20231215102613798" style="zoom: 67%;" />
<ol>
<li>
<p>立即寻址方式：操作数在指令中明确给出。</p>
<ol>
<li>
<p><strong>把我们实际要操作的数，直接存放在形式地址中</strong></p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246126.webp" alt="img"></p>
</li>
<li>
<p>寻址特征为#，代表立即寻址的意思。</p>
</li>
<li>
<p>A为立即数，假设A操作数为3，则形式地址<strong>写的是操作数3的补码（011）。</strong></p>
</li>
<li>
<p>立即寻址主要执行取指令访存1次，不需要执行指令访存，一共访存1次。</p>
</li>
</ol>
</li>
<li>
<p>直接寻址：</p>
<ol>
<li>
<p>直接寻址指令中的地址码字段给的是<strong>操作数的有效位置</strong>，我们可以根据这个有效位置直接去内存中寻找操作数。</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246410.webp" alt="img"></p>
</li>
<li>
<p>与立即寻址相比：直接寻址主要执行取指令访存1次，还有执行指令访存1次，一共访存2次。</p>
</li>
<li>
<p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246400.webp" alt="img"></p>
</li>
</ol>
</li>
<li>
<p>绝对寻址方式：<strong>操作数位于内存位置； 该位置的地址在指令中明确给出。</strong></p>
<ol>
<li>直接寻址的一种，指令包含数据在内存中的确切地址，CPU通过这个地址获取或存储数据。</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246209.png" alt="image-20231215161204849"></li>
</ol>
</li>
<li>
<p>寄存器寻址方式：操作数是处理器寄存器的内容； 寄存器的地址在指令中给出。</p>
<p>和直接寻址原理一样，只是把访问主存改为访问寄存器。</p>
<ol>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246954.webp" alt="img"></p>
</li>
<li>
<p>寄存器寻址主要执行取指令访存1次，由于访问的是寄存器因此<strong>不需要执行指令访存</strong>，一共访存1次。</p>
</li>
<li>
<p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246675.webp" alt="img"></p>
</li>
<li>
<p>**访问寄存器会比访问主存快得多。**但是寄存器数量也较少，可以看出地址码长度也是比访问主存的短的。</p>
</li>
</ol>
</li>
<li>
<p>寄存器间接寻址方式：操作数的有效地址是：出现在指令中的寄存器存储的内容。</p>
<ol>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246827.webp" alt="img"></p>
</li>
<li>
<p>寄存器间接寻址的指令中的地址码字段给的是<strong>操作数所在的寄存器位置</strong>，我们可以根据这个地址去寄存器中找到操作数的有效地址，再去内存中寻找操作数。</p>
</li>
<li>
<p>原理流程图：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246748.webp" alt="img"></p>
</li>
</ol>
</li>
<li>
<p>变址寻址方式：操作数的有效地址是通过将常数值与寄存器（变址寄存器）的内容相加而生成的。</p>
<ol>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246460.png" alt="image-20231215161451624"></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mi>X</mi><mo>+</mo><mo stretchy="false">[</mo><mi>R</mi><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">EA = X + [Ri]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></p>
<p><strong>X (offset)</strong>：指令中包含的常数值</p>
</li>
<li>
<p>变址寻址的两种方式：</p>
<ol>
<li>偏移量是一个常量</li>
<li>偏移量是在变址寄存器当中，而变址寄存器当中的值是可以进行修改的</li>
</ol>
</li>
</ol>
</li>
<li>
<p>base with index</p>
</li>
</ol>
<h2 id="CH5-基础处理器单元"><a class="header-anchor" href="#CH5-基础处理器单元"></a>CH5 基础处理器单元</h2>
<p>CPU内存中的寄存器</p>
<ol>
<li>通用寄存器——存放操作数；某种寻址方式所需的专用寄存器</li>
<li>数据寄存器——</li>
<li>地址寄存器——存放地址数</li>
<li>条件码寄存器——存放条件码</li>
<li>控制寄存器：
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>C</mi><mo>→</mo><mi>M</mi><mi>A</mi><mi>R</mi><mo>→</mo><mi>M</mi><mo>→</mo><mi>M</mi><mi>D</mi><mi>R</mi><mo>→</mo><mi>I</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">PC \rightarrow MAR \rightarrow M \rightarrow MDR \rightarrow IR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li>
<li>只有PC可见</li>
</ol>
</li>
<li>状态寄存器
<ol>
<li>在中断产生时，由于断点之前的程序使用的硬件状态会被修改，需要提前保存，在断点恢复之后可以恢复中断前的程序场景。</li>
<li>CU：产生全部指令的微操作命令序列</li>
</ol>
</li>
</ol>
<h3 id="5-1-Some-Fundamental-Concepts"><a class="header-anchor" href="#5-1-Some-Fundamental-Concepts"></a>5.1 Some Fundamental Concepts</h3>
<ol>
<li>
<p>Processing Unit</p>
<ul>
<li>Instruction Set Processor or Central Processing Unit  (CPU)</li>
<li>处理器负责从计算机内存中读取程序指令并执行它们。
<ul>
<li>它一次获取一条指令。</li>
<li>它解码（解释）指令。</li>
<li>然后，它执行指定的操作</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指令执行：</p>
<p>（1）获取PC指向的内存位置的内容。 该位置的内容被加载到 IR 中。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>R</mi><mo>←</mo><mo stretchy="false">[</mo><mo stretchy="false">[</mo><mi>P</mi><mi>C</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">IR ← [[PC]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[[</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mclose">]]</span></span></span></span></p>
<p>（2）PC自增</p>
<p>（3）执行IR中指令指定的操作。</p>
<p>（1）（2）：取指阶段，（3）：执行阶段</p>
</li>
<li>
<p>执行指令的操作：</p>
<p>1）加载数据到处理器当中：读取给定的内存位置的内容并将其加载到<strong>处理器寄存器</strong>中。<br>
2）读取数据：从一个或多个<strong>处理器寄存器</strong>读取数据。<br>
3）执行操作指令：执行算术或逻辑运算并将结果放入处理器寄存器中。<br>
4）写回数据：将处理器寄存器中的数据存储到给定的内存位置。</p>
</li>
<li>
<p>指令执行的五大步骤：</p>
<ul>
<li>Fetch <strong>取指阶段</strong>: 从内存中读取下一条指令。</li>
<li>Decode <strong>解码阶段</strong>: 解析指令，确定其类型和所需操作。</li>
<li><strong>执行阶段</strong>: 执行指令规定的操作。</li>
<li><strong>访存阶段</strong>: 如果需要访问内存，进行读取或写入。</li>
<li><strong>写回阶段</strong>: 将执行结果写回寄存器或内存。</li>
</ul>
</li>
<li>
<p>处理器主要硬件组成：</p>
<ol>
<li>PC</li>
<li>IR</li>
<li>Instruction address generator</li>
<li>Control circuitry</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246557.png" alt="image-20231215210130431" style="zoom:50%;" />
</li>
<li></li>
</ol>
<h3 id="5-2-Instruction-Execution-5-steps"><a class="header-anchor" href="#5-2-Instruction-Execution-5-steps"></a>5.2 Instruction Execution (5 steps)</h3>
<ol>
<li>Load指令：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mtext>  </mtext><mi>R</mi><mn>5</mn><mtext>  </mtext><mi>X</mi><mo stretchy="false">(</mo><mi>R</mi><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Load~~R5~~X(R7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">5</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>
<ol>
<li>从主存取指令，wait for MFC，并且PC自增</li>
<li>译码decode得到操作，读取寄存器R7中的内容</li>
<li>将X和R7的内容相加</li>
<li>将相加结果作为源操作数的有效地址，并读取存储器中该地址内的内容</li>
<li>将存储器读取数据存入R5</li>
</ol>
</li>
<li>算数逻辑运算指令
<ol>
<li>两个源寄存器or一个直接操作数和一个源寄存器</li>
<li>无需访问存储器操作数</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="5-3-Hardware-Components-5-stages"><a class="header-anchor" href="#5-3-Hardware-Components-5-stages"></a>5.3 Hardware Components (5 stages)</h3>
<h3 id="5-4-Instruction-Fetch-and-Execution-Steps"><a class="header-anchor" href="#5-4-Instruction-Fetch-and-Execution-Steps"></a>5.4 Instruction Fetch and Execution Steps</h3>
<h3 id="5-5-Control-Signals"><a class="header-anchor" href="#5-5-Control-Signals"></a>5.5 Control Signals</h3>
<h3 id="5-6-Hardwired-Control"><a class="header-anchor" href="#5-6-Hardwired-Control"></a>5.6 Hardwired Control</h3>
<h3 id="5-7-CISC-Style-Processors"><a class="header-anchor" href="#5-7-CISC-Style-Processors"></a>5.7 CISC-Style Processors</h3>
<h2 id="CH6-流水线"><a class="header-anchor" href="#CH6-流水线"></a>CH6 流水线</h2>
<h3 id="6-1-基本概念"><a class="header-anchor" href="#6-1-基本概念"></a>6.1 基本概念</h3>
<h4 id="1、什么是流水线"><a class="header-anchor" href="#1、什么是流水线"></a>1、什么是流水线</h4>
<p>流水线是用于构建快速处理器的关键实现技术。 它允许多条指令的执行在时间上重叠。</p>
<ol>
<li>核心：将多条指令执行时间进行重叠</li>
<li>本质：在完成前一条指令之前执行下一条指令</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246243.png" alt="image-20231216111436816"></li>
</ol>
<h4 id="2、回顾指令执行的五大步骤"><a class="header-anchor" href="#2、回顾指令执行的五大步骤"></a>2、回顾指令执行的五大步骤</h4>
<ol>
<li>
<p>Instruction Fetch</p>
</li>
<li>
<p>Instruction Decode and Register Read</p>
</li>
<li>
<p>Execution operation or calculate address</p>
</li>
<li>
<p>Memory access</p>
</li>
<li>
<p>Write result into register</p>
</li>
</ol>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246014.png" alt="image-20231216111805502" style="zoom: 80%;" />
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246802.png" alt="image-20231216111829396" style="zoom:80%;" />
<p>将原先的：上一条指令第五步结束后才进行下一指令的第一步的模式</p>
<p>切换为：在上一条指令移码阶段的同时进行下一指令的取指令</p>
<h4 id="3、术语"><a class="header-anchor" href="#3、术语"></a>3、术语</h4>
<ol>
<li>
<p>吞吐量/Throught：每秒完成指令的数量。The number of instructions completed per second</p>
</li>
<li>
<p>延迟/Latency： 在管道中执行一条指令需要多长时间。How long does it take to execute a single instruction</p>
</li>
<li>
<p>流水线片段/Pipe Stage或Pipe Segment：完成指令的流水线中的一个步骤</p>
</li>
<li>
<p>流水线深度/Pipeline Depth：流水线中的步骤的个数。</p>
</li>
</ol>
<h4 id="4、流水线的组成"><a class="header-anchor" href="#4、流水线的组成"></a>4、流水线的组成</h4>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011246952.png" alt="image-20231216112503816" style="zoom: 67%;" />
<ol>
<li>流水线不改变原来的每个指令执行的时间延迟，完成每个指令所需的时间不变</li>
<li>但是减少的是多个指令总的运行的平均时间</li>
<li>提高了总体的吞吐量</li>
</ol>
<h3 id="6-2-数据依赖"><a class="header-anchor" href="#6-2-数据依赖"></a>6.2 数据依赖</h3>
<ol>
<li>程序或指令序列中，一个操作对另一个操作的数据需求或依赖关系。这种依赖关系决定了指令执行的顺序以及可能存在的并行性。</li>
<li>三种主要依赖：
<ol>
<li>读后写（Read-after-Write，RAW）依赖：</li>
<li>写后读（Write-after-Read，WAR）依赖：</li>
<li>写后写（Write-after-Write，WAW）依赖：</li>
</ol>
</li>
</ol>
<h4 id="1、三种冲突："><a class="header-anchor" href="#1、三种冲突："></a>1、三种冲突：</h4>
<ol>
<li>数据冲突——可进行规避
<ol>
<li>指令的源操作数或目标操作数在流水线中预期的时间不可用的任何情况。</li>
<li>因此某些操作必须延迟，流水线就会停顿。</li>
<li>可能可以采用<mark>操作数转发</mark>的形式解决此种冲突，但并非都可以。</li>
</ol>
</li>
<li>指令（控制）冲突——可进行规避
<ol>
<li>指令可用性的延迟会导致流水线停顿。</li>
</ol>
</li>
<li>结构冲突——无法规避
<ol>
<li>两条指令同时需要使用给定硬件资源的情况</li>
</ol>
</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi mathvariant="normal">.</mi><mi>P</mi><mi mathvariant="normal">.</mi><mtext>        </mtext><mi>A</mi><mi>d</mi><mi>d</mi><mtext>  </mtext><mi>R</mi><mn>2</mn><mtext>  </mtext><mi>R</mi><mn>3</mn><mtext>  井</mtext><mn>100</mn></mrow><annotation encoding="application/x-tex">E.P.~~~~~~~~ Add~~R2~~R3~~井100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">.</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">3</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord cjk_fallback">井</span><span class="mord">100</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>                 </mtext><mi>S</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mtext>  </mtext><mi>R</mi><mn>9</mn><mtext>  </mtext><mi>R</mi><mn>2</mn><mtext>   井</mtext><mn>30</mn></mrow><annotation encoding="application/x-tex">~~~~~~~~~~~~~~~~~Subtract~~R9~~R2~~~井30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">9</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord cjk_fallback">井</span><span class="mord">30</span></span></span></span></p>
<ol>
<li>
<p>Add指令中的R2 和 Subtract 中的R2 存在数据依赖</p>
</li>
<li>
<p>在非流水线的数据路径上，当Add指令结束后R2的新值可应用于Subtract</p>
</li>
<li>
<p>但是在流水线上，Subtract必须等待Add指令中R2 被操作结束后才可以进行第一步骤取指操作。</p>
</li>
<li>
<p>因而<mark>流水线停顿</mark></p>
</li>
<li>
<p>流水线停顿的详细信息</p>
<ul>
<li>
<p>在周期 3 中解码 Subtract 时，控制电路必须识别相关性</p>
</li>
<li>
<p>级间缓冲区携带指令源和目标的寄存器标识符</p>
</li>
<li>
<p>在周期 3 中，将计算阶段的目标标识符与解码阶段的源标识符进行比较</p>
</li>
<li>
<p>R2 匹配，因此 Subtract 保留在 Decode 中，而 Add 允许正常继续</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-5-存储器延迟"><a class="header-anchor" href="#6-5-存储器延迟"></a>6.5 存储器延迟</h3>
<p>由于访问存储器产生的延迟导致流水线的停顿。如Load指令，当发生cache miss时会导致流水线停顿。</p>
<h2 id="CH3-基本输入输出"><a class="header-anchor" href="#CH3-基本输入输出"></a>CH3 基本输入输出</h2>
<h3 id="3-1-访问I-O设备"><a class="header-anchor" href="#3-1-访问I-O设备"></a>3.1 访问I/O设备</h3>
<h4 id="1、内存映射I-O"><a class="header-anchor" href="#1、内存映射I-O"></a>1、内存映射I/O</h4>
<ol>
<li>
<p>特点：</p>
<ul>
<li>
<p>I/O设备和内存共享相同的地址空间</p>
</li>
<li>
<p>没有针对I/O的特殊指令</p>
</li>
<li>
<p>I/O设备的访问和内存的读写很像</p>
</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>任何可以访问内存的机器指令都可以用于向 I/O 设备传输数据或从 I/O 设备传输数据</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>占用了宝贵的内存地址空间</li>
</ul>
</li>
</ol>
<h4 id="2、独立I-O"><a class="header-anchor" href="#2、独立I-O"></a>2、独立I/O</h4>
<ol>
<li>
<p>特点：</p>
<ul>
<li>
<p>独立的地址空间</p>
</li>
<li>
<p>具有用于执行I/O传输的特殊指令</p>
</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>I/O 设备处理的地址线很少。</li>
</ul>
</li>
<li>
<p>注：独立的 I/O 地址空间并不一定意味着 I/O 地址线与内存地址线在物理上是分开的。</p>
</li>
</ol>
<h3 id="3-2-I-O设备接口"><a class="header-anchor" href="#3-2-I-O设备接口"></a>3.2 I/O设备接口</h3>
<h4 id="1、概念："><a class="header-anchor" href="#1、概念："></a>1、概念：</h4>
<ul>
<li>I/O 设备接口是设备和互连网络之间的电路。</li>
<li>提供数据传输以及状态和控制信息交换的方式。</li>
<li>包括可通过加载和存储指令访问的数据、状态和控制寄存器。</li>
<li>内存映射 I/O 使软件能够将这些寄存器视为内存中的位置。</li>
</ul>
]]></content>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2025/03/18/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算法"><a class="header-anchor" href="#算法"></a>算法</h1>
<blockquote>
<p>搜集一些日常写题常见的经典算法</p>
</blockquote>
<h2 id="二分查找"><a class="header-anchor" href="#二分查找"></a>二分查找</h2>
<p><strong>一般流程</strong>：</p>
<ul>
<li>蓝红区域划分，即确定 isBlue()</li>
<li>确定返回的是 L 还是 R</li>
<li>而后套用模板</li>
</ul>
<p>对于二分问题来说，常见的元素查找提问是：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503182140232.png" alt="二分查找-蓝红划分"></p>
<ol>
<li>找到第一个 “&gt;= xxx ” 的元素</li>
<li>找到最后一个 “&lt; xxx” 的元素，可以转换成找到第一个 “&gt;= xxx” 的元素再下标减一</li>
<li>找到第一个 “&gt; xxx” 的元素，可以转换成找到第一个 “ &gt;= xxx + 1” 的元素再下标减一</li>
<li>找到最后一个 “&lt;= xxx ” 的元素，可以转换成找到第一个 “&gt;= xxx + 1” 的元素再下标减一</li>
</ol>
<p><strong>红蓝染色视角</strong>：</p>
<p>将原数组视为灰色，左边的指针向右移动是染成蓝色，而右边的指针向左移动是染成红色，而目标 xxx，则是蓝红的边界，蓝色代表小于目标元素，红色代表着大于目标元素，而二分的核心思想是，在一个有序数组中，如果查找到中间的那个数是蓝色/红色，那么它之前/之后的元素也都会是蓝色/红色，那么左/右指针就可以直接移动，而不需要一步步移动</p>
<p><strong>细节处理</strong>：</p>
<ul>
<li>L 初始值设置为 -1，R 初始值设置为 N：假如将 L 初始设置为 0，R 初始设置成 N-1，如果整个数组一开始就是蓝/红色，就会发生边界问题</li>
<li>m（m = l+r/2 向下取整）是否始终处于 [0,N) 以内，由于程序的循环条件是 L+1 != R，因此，L 最小值为 -1，R 最小值为 1，因此 m 最小值为 0 且可以取到（左闭）；同理，为了能够进入循环体，L 最大值只能取到 N-2，而 R 最大值为 N，那么 m 最大值就是 (N-2+N)/2 = N-1 &lt; N，因此是右开，m 始终在数组 0~N-1 的范围内。</li>
<li>更新指针时，是否可以写出：L = m+1，R = m-1：易出错！！！</li>
<li>程序是否会死循环：并不会，因为最终不管 L 和 R 中间隔了几个元素，最终都会指向 L + 1 = R 这种情况，然后退出循环体。</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/2025/03/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h1>
<h2 id="计算机网络与因特网"><a class="header-anchor" href="#计算机网络与因特网"></a>计算机网络与因特网</h2>
<blockquote>
<p>——本章<strong>task</strong>：</p>
<ol>
<li>介绍基本术语和概念
<ul>
<li>构成网络的基本硬件和软件组成：
<ul>
<li>从网络边缘——网络中运行的端系统和网络应用；</li>
<li>再到网络核心——传输数据的链路和交换机以及将端系统与网络核心相连接的接入网和物理媒体。</li>
</ul>
</li>
</ul>
</li>
<li>计算机网络中数据的时延、丢包和吞吐量</li>
<li>端到端吞吐量和时延的定量模型：
<ul>
<li>模型兼顾了传输、传播和排队时延等因素</li>
</ul>
</li>
<li>体系结构原则：
<ul>
<li>协议分层和服务模型</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="计网概念简述"><a class="header-anchor" href="#计网概念简述"></a>计网概念简述</h3>
<h4 id="概念"><a class="header-anchor" href="#概念"></a>概念</h4>
<blockquote>
<ol>
<li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过<strong>通信设备和线路</strong>连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li>
<li>本质即是由若干个节点和连接这些节点的链路组成的一张网</li>
</ol>
</blockquote>
<h3 id="计网的结构组成"><a class="header-anchor" href="#计网的结构组成"></a>计网的结构组成</h3>
<blockquote>
<p>——由三大要素组成：<strong>硬件</strong>、<strong>软件</strong> 、<strong>协议</strong>&lt;一系列规则和约定的集合&gt;</p>
</blockquote>
<h4 id="物理硬件进度来看结构："><a class="header-anchor" href="#物理硬件进度来看结构："></a>物理硬件进度来看结构：</h4>
<ul>
<li>
<p>节点分为两类节点</p>
<ol>
<li><strong>主机节点</strong></li>
<li><strong>数据交换节点</strong>（数据传输过程中间过渡连接两个端的节点）：
<ol>
<li>例如：路由器（工作在网络层）Router；交换机（工作在链路层）Switch</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>端系统/端系统</strong>：与因特网相连的计算机或其他联网的设备</p>
<ul>
<li>端系统通过**通信链路(communication link)<strong>和</strong>分组交换机(packet switch)**进行链接；</li>
<li>host == end system</li>
</ul>
</li>
<li>
<p><strong>分组交换机 packet switches：</strong> 转发数据报</p>
<ul>
<li><strong>分组</strong>：当一台端系统向另一条端系统发送数据时，发送端会将数据分段，并未每一段加上首部字节，由此形成的<strong>信息包</strong>称之为<strong>分组</strong>；</li>
<li>路由器 router 作用于网络 通常用于网络核心中进行数据的转发</li>
<li>交换机 switch 作用于链路层 通常用于接入网将主机的数据转发到路由器</li>
<li><strong>路径 route&amp;path</strong>：从发送端到接收端，一个分组所走过的一系列通信链路和分组交换机</li>
</ul>
</li>
<li>
<p><strong>通信链路 links：</strong></p>
<ul>
<li>光纤 fiber，铜缆 copper，无线电 radio，卫星 satellite</li>
<li>trabsmission rate bandwidth 传输速率：带宽</li>
</ul>
</li>
<li>
<p><strong>网络 network</strong></p>
<ul>
<li>以上设备相互组合的集合</li>
</ul>
</li>
</ul>
<h4 id="功能角度来看结构："><a class="header-anchor" href="#功能角度来看结构："></a>功能角度来看结构：</h4>
<ul>
<li>
<p><strong>网络边缘 Network Edge：</strong></p>
<ul>
<li>主机和主机当中的应用</li>
<li>端系统与网络间的接口</li>
</ul>
</li>
<li>
<p><strong>接入网 Access Network：</strong></p>
<blockquote>
<p>将端系统物理连接到 <strong>边缘路由器 edge router</strong>的网络</p>
</blockquote>
<ul>
<li><strong>因特网服务提供商 Internet Service Provider,ISP</strong>：端系统通过ISP接入因特网
<ul>
<li>ISP包括：本地电缆、电话公司提供的住宅区ISP、公司ISP、大学ISP……</li>
</ul>
</li>
<li><strong>Residential access nets(家庭接入网)</strong> 基于电缆接入</li>
<li><strong>mobile access networks (WiFi, 4G/5G)(移动接入网络)</strong>
<ul>
<li>无线局域网</li>
<li>广域蜂窝接入网</li>
</ul>
</li>
<li><strong>institutional access networks(机构介入网络)</strong>
<ul>
<li>混合使用有线、无线链路技术，连接混合的交换机和路由器</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络核心 NetWork Core：</strong></p>
<ul>
<li>由高速路由器和交换机组成。</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="网络协议"><a class="header-anchor" href="#网络协议"></a>网络协议</h4>
<blockquote>
<p>——掌握计算机网络领域知识的过程就是理解网络协议的构成 、原理和工 作方式的过程 。</p>
</blockquote>
<ul>
<li>
<p><strong>网络协议</strong>：端系统、分组交换机和其他可接入因特网的部件都遵循一系列预先<strong>规定好的规则</strong>，这些规则被称之为协议。协议控制因特网当中信息的接收和发送。</p>
<ul>
<li>**TCP(Transmission Control Protocol，传输控制协议)<strong>和</strong>IP(Internel Protocol，网络协议)**是因特网中最为重要的两个协议。
<ul>
<li><strong>IP协议</strong>定义了在路由器和端系统之间发送和接收的<strong>分组格式</strong>。</li>
</ul>
</li>
<li><strong>功能</strong>：
<ul>
<li>定义了在两个或多个通信实体间交换的报文的格式和顺序，以及报文发送&amp;接收一条报文或其他事件所采取的动作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应用TCP的app：</p>
<ul>
<li>HTTP Web 网页数据报文传输</li>
<li>FTP file transfer 文件传输</li>
<li>Telnet——remote login 远程登录,</li>
<li>SMTP—— email</li>
</ul>
</li>
<li>
<p>应用UDP的app：流媒体 streaming media，teleconferencing 电话会议，DNS，Internet telephony 网络电话。</p>
</li>
</ul>
<h4 id="网络实体"><a class="header-anchor" href="#网络实体"></a>网络实体</h4>
<h5 id="定义："><a class="header-anchor" href="#定义："></a>定义：</h5>
<ul>
<li>参与网络通信的任何设备或程序。这可以包括服务器、客户端、路由器、交换机、防火墙等硬件设备，也可以包括浏览器、邮件客户端、FTP客户端等软件程序。每个网络实体都有一个或多个网络接口，用于发送和接收数据。</li>
</ul>
<h5 id="对等层次的实体"><a class="header-anchor" href="#对等层次的实体"></a>对等层次的实体</h5>
<ul>
<li>在网络模型的同一层次中，执行相同功能的两个网络实体。这些实体可以在不同的计算机上，通过网络进行通信。</li>
<li>&quot;对等&quot;只是指这两个实体在网络模型中处于同一层次，并执行相同的功能。</li>
</ul>
<h3 id="网络边缘"><a class="header-anchor" href="#网络边缘"></a>网络边缘</h3>
<blockquote>
<p>更深入了解计算机网络的部件</p>
</blockquote>
<p>通过ISP接入互联网，</p>
<h4 id="边缘部分"><a class="header-anchor" href="#边缘部分"></a>边缘部分</h4>
<blockquote>
<p>主机host和端系统————一个概念<br>
边缘部分包括：端系统和接入网<br>
在C/S体系中，主机进一步划分为<strong>client</strong>和<strong>server</strong>。</p>
</blockquote>
<ul>
<li>
<p><strong>边缘部分</strong>：用户直接使用</p>
<blockquote>
<p>端系统之间的通信强调的是两个端系统当着正在执行的进程之间的通信</p>
</blockquote>
<ul>
<li><strong>C/S方式（Client/Server）&amp; B/S方式（Browser/Server）</strong></li>
<li>**P2P方式（peer To peer）**主机数量越多，下载速度越快（一份资源拥有的人越多，则下载速度越快，因为可以同时从多个主机处下载同一份资源，多线程下载？）</li>
</ul>
</li>
<li>
<p><strong>接入网</strong>：将端系统物理连接到<strong>边缘路由器 edge router</strong>的网络</p>
<ul>
<li>
<p>Residential accsee 家庭接入：点对点接入</p>
<p>家庭利用分配器将数据信号和电话信号分开</p>
<p>电话公司利用DSLAM把数据和电话信号分开，并将数据送往因特网</p>
<ul>
<li>DSL 数字用户线 常用：</li>
<li>Dialup via modem 通过调解器进行拨号</li>
<li>电缆 常用</li>
<li>HFC hybrid Fiber coax 混合光纤同轴</li>
<li>FTTH</li>
<li>拨号和卫星</li>
</ul>
</li>
<li>
<p>企业&amp;家庭接入：以太网&amp;WIFI</p>
</li>
<li>
<p>广域无线接入：3G和LTE</p>
</li>
</ul>
</li>
<li>
<p><strong>物理媒体</strong>：</p>
<blockquote>
<p>所有无线网的根基都是有线网</p>
</blockquote>
<ul>
<li>导引型：光缆/光纤、双绞铜线、同轴电缆</li>
<li>非导引型：电波、陆地无线电信道、卫星无线电信道</li>
</ul>
</li>
</ul>
<h3 id="网络核心"><a class="header-anchor" href="#网络核心"></a>网络核心</h3>
<p>核心部分为边缘部分服务</p>
<h4 id="分组交换"><a class="header-anchor" href="#分组交换"></a>分组交换</h4>
<ul>
<li>
<p><strong>分组 packet</strong>：源主机将长报文划分为小的数据块</p>
</li>
<li>
<p>端系统彼此交换<strong>报文 message</strong>，分组 packet在源和目的地之间通过<strong>通信链路</strong>和<strong>分组交换机 packet-switch</strong>传输和转发报文。</p>
<ul>
<li>解释：在应用层，端和端之间交流的信息单位是报文message，但是具体进入到下面层次时，需要将报文（太长了，无法一次传输完）依照预先设定好的格式划分若干的小报文，这种小报文的名称就是分组，将这种分组向下层结构传递再经过一系列链路和交换机传输到目的主机，以达成信息交互的目的。</li>
</ul>
</li>
<li>
<p><strong>存储转发传输 store-and-forward transmission</strong>：多数分组交换机在链路输入端使用。指的是在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p>
<p>假设有一个简单网络：<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241804.png" alt="image-20240605162345495"></p>
<p>源主机通过链路传输分组到路由器，假设发送方发送一个大小我 L bits 的分组，链路传输速率为 R bits/s，则传输该分组的时间为：传输时延 L/R s</p>
<ul>
<li>假设分组1的前沿先到达路由器，路由器采用存储转发机制</li>
<li>此时路由器会先缓存分组1的前沿比特</li>
<li>等待分组1的所有比特都达到路由器时，才会开始向出链路传输分组1</li>
</ul>
</li>
</ul>
<h4 id="功能组成："><a class="header-anchor" href="#功能组成："></a>功能组成：</h4>
<ul>
<li>
<p>通信子网：实现<strong>数据通信</strong>。</p>
</li>
<li>
<p>资源子网：实现<strong>资源共享</strong>/数据处理。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	subgraph 子网</span><br><span class="line">	direction TB</span><br><span class="line">	str1[&quot;资源子网\n(实现资源共享功能的设备和软件的集合)&quot;]</span><br><span class="line">	str6[&quot;通信子网\n(各种传输介质,通信设备,相应的网络协议组成)&quot;]</span><br><span class="line">	end</span><br><span class="line">	subgraph OSI七层结构</span><br><span class="line">	str2[&quot;应用层&quot;]</span><br><span class="line">	str3[&quot;表示层&quot;]</span><br><span class="line">	str4[&quot;会话层&quot;]</span><br><span class="line">	str5[&quot;传输层&quot;]</span><br><span class="line">	str7[&quot;网络层\n如:路由器&quot;]</span><br><span class="line">	str8[&quot;数据链路层\n(如:交换机,网桥)&quot;]</span><br><span class="line">	str9[&quot;物理层\n(如:集线器,中继器)&quot;]</span><br><span class="line">	end</span><br><span class="line">	str1 --&gt; str2 &amp; str3 &amp; str4 </span><br><span class="line">	str6 --&gt; str7 &amp; str8 &amp; str9</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="功能"><a class="header-anchor" href="#功能"></a>功能</h4>
<ul>
<li><strong>数据通信</strong></li>
<li><strong>资源共享</strong></li>
<li><strong>分布式处理</strong>：
<ul>
<li>多台设备各自承担同一任务的不同部分</li>
<li>使用备用机来顶替出故障的设备，提高安全性和可靠性</li>
</ul>
</li>
</ul>
<h4 id="分类"><a class="header-anchor" href="#分类"></a>分类</h4>
<ul>
<li>
<p><strong>分布范围</strong>：是按照使用技术进行区分而不是按照实际物理距离进行区分</p>
<ul>
<li><strong>广域网(WAN)</strong>;</li>
<li>城域网(MAN);</li>
<li><strong>局域网(LAN)</strong>;</li>
<li>个人区域网(PAN)</li>
</ul>
</li>
<li>
<p><strong>使用者</strong>：</p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li>
<p><strong>交换技术</strong>：</p>
<ul>
<li>电路交换，如：打电话</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li>
<p>拓扑结构：</p>
<ul>
<li>
<p>总线型</p>
</li>
<li>
<p>星型</p>
</li>
<li>
<p>环形</p>
</li>
<li>
<p>网状型</p>
</li>
</ul>
</li>
<li>
<p><strong>传输技术</strong>：</p>
<ul>
<li>广播式网络：共享公共通信通道</li>
<li>点对点网络：使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li>
</ul>
</li>
</ul>
<h4 id="标准化工作"><a class="header-anchor" href="#标准化工作"></a>标准化工作</h4>
<ul>
<li><strong>法定标准</strong>：OSI</li>
<li><strong>事实标准</strong>：TCP/IP</li>
</ul>
<h3 id="分组交换网络中的时延、丢包和吞吐量"><a class="header-anchor" href="#分组交换网络中的时延、丢包和吞吐量"></a>分组交换网络中的时延、丢包和吞吐量</h3>
<h4 id="性能指标"><a class="header-anchor" href="#性能指标"></a>性能指标</h4>
<ul>
<li>
<p><strong>速率</strong>：数据率&amp;数据传输率&amp;比特率</p>
<ul>
<li>数据在传输单位是bit 0/1 位</li>
<li>单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>3</mn></msup><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>6</mn></msup><mi>K</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><msup><mn>10</mn><mn>9</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Gb/s = 10^{3}Mb/s = 10^{6}Kb/s = 10^{9}b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></li>
</ul>
<blockquote>
<p>存储容量： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>G</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup><mi>M</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>30</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>40</mn></msup><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>43</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">1TB = 2^{10}GB = 2^{20}MB = 2^{30}KB = 2^{40}B = 2^{43}bite</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">TB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">43</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mtext>字节</mtext><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mtext>比特</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1Byte(字节) = 2^{3}bit(比特)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord cjk_fallback">字节</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord cjk_fallback">比特</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
</li>
<li>
<p><strong>带宽</strong>：网络通信线路传输数据的能力，通常指单位时间内从网络中的某一节点到另一节点所能通过的“最高数据率” ，单位“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bite/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>”</p>
</li>
<li>
<p><strong>吞吐量</strong>：单位时间内通过某个网络（或信道、接口）的数据量，单位：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>、</mtext><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>、</mtext><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">b/s、kb/s、Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></p>
</li>
</ul>
<h4 id="时延"><a class="header-anchor" href="#时延"></a>时延</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241713.png" alt="image-20240605170015617"></p>
<ul>
<li>
<p><strong>nodal processing 节点处理时延</strong>：</p>
<ul>
<li>
<p>检查：检查分组首部所需要的时间；检查比特级别的错误；</p>
</li>
<li>
<p>找出口：决定将该分组导向何处所需要的时间；</p>
</li>
<li>
<p>高速路由器的处理时延通常是微秒或更低的数量级</p>
</li>
</ul>
</li>
<li>
<p><strong>queueing 排队时延（最复杂）</strong>：</p>
<p>分组到达路由的速率超过了出路由的能力，因而存入一个缓存队列中，等待发出</p>
<p>等待输出/入链路可用</p>
<ul>
<li>
<p>取决于拥塞程度</p>
</li>
<li>
<p>取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<ul>
<li>该队列是空的，则排队时延为0</li>
<li>如果许多其他分组等待传输，排在等待缓存队列当中，则等待时延很长</li>
</ul>
</li>
<li>
<p>实际的排队时延可以是毫秒到微秒量级。</p>
</li>
<li>
<p>R 为链路带宽 bps</p>
</li>
<li>
<p>L 为分组长度 bits</p>
</li>
<li>
<p>a = 平均分组到达速率</p>
</li>
<li>
<p>交通强度 traffic intersity = L*a / R</p>
</li>
<li>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241232.png" alt="image-20240605201914573" style="zoom:50%;" /> <img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011241233.png" alt="image-20240605202000063" style="zoom: 80%;" /></p>
</li>
<li>
<p><strong>transmission传输时延</strong>：将分组的所有比特推向链路(即传输,或者说发送)所需要的时间</p>
<ul>
<li>L 比特表示该分组的长度，</li>
<li>用 R bps(即 b/s) 表示从路由器 A 到路由器 B 的链路传输速率。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>传输时延</mtext><mo>=</mo><mfrac><mi>L</mi><mi>R</mi></mfrac></mrow><annotation encoding="application/x-tex">传输时延 = \frac{L}{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传输时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>
<p><strong>propagation 传播时延</strong>：信道路上消耗的时间，取决于<strong>电磁波传播速度</strong>和<strong>链路长度</strong></p>
<ul>
<li>d 为物理链路长度</li>
<li>s 为在物理介质中的传播速率</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>传播时延</mtext><mo>=</mo><mfrac><mi>d</mi><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">传播时延=\frac{d}{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​</li>
</ul>
</li>
<li>
<p><strong>节点时延：</strong></p>
<ul>
<li>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242712.png" alt="image-20240605201719133" style="zoom:50%;" /> 
</li>
</ul>
</li>
<li>
<p><strong>时延带宽积</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>时延带宽积</mtext><mo>=</mo><mtext>传播时延</mtext><mo>×</mo><mtext>带宽</mtext></mrow><annotation encoding="application/x-tex">时延带宽积 = 传播时延\times带宽</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">时延带宽积</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带宽</span></span></span></span> ，又称为 <strong>以比特为单位的链路长度</strong></p>
</li>
<li>
<p><strong>往返时延RTT</strong>：从<strong>发送方</strong>发送数据开始；到<strong>发送方</strong>收到<strong>接收方</strong>的确认结束。</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mtext>包括</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>往返传播时延</mtext><mo>=</mo><mtext>传播时延</mtext><mo>×</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>末端处理时间</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">RTT包括\begin{cases}往返传播时延 = 传播时延\times2 \\ 末端处理时间 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mord cjk_fallback">包括</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">往返传播时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">末端处理时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p><strong>利用率</strong>：</p>
<ul>
<li>信道利用率： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext>有数据通过时间</mtext><mrow><mo stretchy="false">(</mo><mtext>有</mtext><mo>+</mo><mtext>无</mtext><mo stretchy="false">)</mo><mtext>数据通过时间</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{有数据通过时间}{(有+无)数据通过时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3923em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">有</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">无</span><span class="mclose mtight">)</span><span class="mord cjk_fallback mtight">数据通过时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">有数据通过时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>网络利用率：信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h4 id="丢包-loss"><a class="header-anchor" href="#丢包-loss"></a>丢包 loss</h4>
<p><strong>丢包</strong>：</p>
<ul>
<li>因为排队容量有限，当新到达的分组没有地方存放时，路由器将<strong>丢弃 drop</strong>该分组，则该分组<strong>丢失 lost</strong>。</li>
<li>丢弃的分组需要进行重传</li>
</ul>
<h4 id="吞吐量"><a class="header-anchor" href="#吞吐量"></a>吞吐量</h4>
<p><strong>throughput 吞吐量：</strong> 单位时间内成功传输的数据量。</p>
<ul>
<li>瞬时吞吐量 instantaneous throughput：在特定时刻网络传输的数据速率。</li>
<li>平均吞吐量 average throughput：在较长时间内网络传输的数据的平均速率。平均吞吐量可以反映网络在一段时间内的整体传输能力。</li>
<li></li>
</ul>
<h3 id="协议层次及服务模型"><a class="header-anchor" href="#协议层次及服务模型"></a>协议层次及服务模型</h3>
<h4 id="分层的体系结构"><a class="header-anchor" href="#分层的体系结构"></a>分层的体系结构</h4>
<h5 id="协议分层-层次结构"><a class="header-anchor" href="#协议分层-层次结构"></a>协议分层&amp;层次结构</h5>
<blockquote>
<p>为什么分层？</p>
<p>因为计算机网络的数据传输是一个较大且复杂的问题。因而将一个大问题拆分为无数个小问题进行解决，而每一个小问题就对应着一个层次。</p>
<p>怎样分层？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>实体</mtext><mo>→</mo><mtext>协议</mtext><mo stretchy="false">(</mo><mtext>对等的实体间才有协议</mtext><mo stretchy="false">)</mo><mo>→</mo><mtext>接口</mtext><mo>→</mo><mtext>服务</mtext><mo stretchy="false">(</mo><mtext>下级为上级提供服务</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">实体 \rightarrow 协议(对等的实体间才有协议) \rightarrow 接口 \rightarrow 服务(下级为上级提供服务)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">实体</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">协议</span><span class="mopen">(</span><span class="mord cjk_fallback">对等的实体间才有协议</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">接口</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">服务</span><span class="mopen">(</span><span class="mord cjk_fallback">下级为上级提供服务</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<blockquote>
<p>计算机网络体系结构，简称“网络体系结构”：是计算机网络的各层及其协议的集合。</p>
<p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</p>
</blockquote>
<ul>
<li><strong>分层基本原则</strong>
<ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li>
<li>结构上可分割。每层采用最合适技术实现</li>
<li>保持下层对上层的独立性，上层单向使用下次提供的服务</li>
</ol>
</li>
<li><strong>实体</strong>：第n层中的活动元素称为<strong>n层实体</strong>。同一层实体叫<strong>对等实体</strong>。</li>
<li><strong>协议</strong>：为进行网络中的<strong>对等实体</strong>数据交换建立的规则、标准或约定。称为网络协议。
<ul>
<li>协议只在对等层次间进行使用。【协议是水平的】</li>
<li>语法：规定了传输数据的格式。</li>
<li>语义：规定所要完成的功能。</li>
<li>同步：规定各种操作的顺序。</li>
</ul>
</li>
<li><strong>接口（访问服务点SAP）</strong>：上层使用下层服务的入口。</li>
<li><strong>服务</strong>：下层为相邻上层提供的功能调用。【服务是垂直的】</li>
<li><strong>SDU服务数据单元</strong>：为完成用户所要求的功能而传送的数据。</li>
<li><strong>PCI协议控制信息</strong>：控制协议操作的信息</li>
<li><strong>PDU协议数据单元</strong>：对等层次之间传递的数据单元</li>
</ul>
<h4 id="TCP-IP模型-实例-事实标准-5层"><a class="header-anchor" href="#TCP-IP模型-实例-事实标准-5层"></a>TCP/IP模型(实例)事实标准 5层</h4>
<ul>
<li><strong>应用层</strong>：网络应用程序及它们的应用层协议存留的地方。
<ul>
<li>位于应用层的信息分组称为<strong>报文</strong>。</li>
</ul>
</li>
<li><strong>运输层</strong>：因特网的传输层在应用程序端点间传送应用层报文。
<ul>
<li>位于运输层的信息分组称为<strong>报文段 segment</strong></li>
<li>有两种运输协议：<strong>TCP和UDP</strong>，利用其中任一个 都可以运输应用层报文。</li>
<li><strong>TCP</strong>向应用程序提供面向连接服务————包括：
<ul>
<li>应用层报文向目的地的确保传递和流量控制(即发送方/接收方速率匹配）</li>
<li>将长报文划分为短报文,并提供拥塞控制机制,因此当网络拥塞时,源抑制其传输速率。</li>
</ul>
</li>
<li><strong>UDP</strong>向应用程序提供无连接服务，这种服务不提供不必要服务，没有可靠性、流量控制、拥塞控制。</li>
</ul>
</li>
<li><strong>网络层</strong>：
<ul>
<li>位于网络层的信息分组称为<strong>数据报 datagram</strong></li>
<li>负责将数据报从一台主机移动到另一台主机。</li>
<li>源端中的运输层协议向网络层递交运输层报文段 segment和目的地址</li>
</ul>
</li>
<li><strong>链路层</strong>：端之间的网络层通过一系列路由器、路由数据报。
<ul>
<li>位于链路层的信息分组称为<strong>帧 frame</strong></li>
<li>链路层接收由网络层传递来的数据报，沿着路径 path将数据报传递给下一个节点。</li>
<li>链路层提供的服务取决于应用于该链路的特定链路层协议。</li>
</ul>
</li>
<li><strong>物理层</strong>：
<ul>
<li>物理层的任务是将链路层的帧的一个个比特从一个节点传输到下一个节点。</li>
<li>这一层的协议仍旧和链路相关，且进一步与链路的实际及输出媒体有关。</li>
</ul>
</li>
</ul>
<h4 id="ISO-OSI模型-实例-法定标准-7层"><a class="header-anchor" href="#ISO-OSI模型-实例-法定标准-7层"></a>ISO/OSI模型(实例)法定标准 7层</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>应用层</mtext><mo>→</mo><mtext>表示层</mtext><mo>→</mo><mtext>会话层</mtext><mo>→</mo><mtext>传输层</mtext><mo>→</mo><mtext>网络层</mtext><mo>→</mo><mtext>数据链路层</mtext><mo>→</mo><mtext>物理层</mtext></mrow><annotation encoding="application/x-tex">应用层 \rightarrow 表示层\rightarrow会话层\rightarrow传输层\rightarrow网络层\rightarrow数据链路层\rightarrow物理层</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">应用层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">表示层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">会话层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传输层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">网络层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">数据链路层</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">物理层</span></span></span></span></p>
<ul>
<li>
<p>其他六个层次都只加一个头部<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">H~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span></span></span></span> 只有在数据链路层会加上头部和尾部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mn>2</mn><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>T</mi><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">H~2~~and~~T~2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>数据传输是端对端/点对点的，需要考虑下一个端，且需要知道终点。</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242324.png" alt="image-20240311100615910" /> 
</li>
<li>
<p><strong>应用层</strong>：网络应用程序和它们的应用层协议存留的地方。所有能和用户交互产生网络流量的程序。</p>
<ul>
<li>把位于应用层的信息分组称为<strong>报文(message)</strong>。</li>
</ul>
</li>
<li>
<p><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<ul>
<li>数据格式的交换</li>
<li>数据加密解密</li>
<li>数据压缩和恢复</li>
</ul>
</li>
<li>
<p><strong>会话层</strong>：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据</p>
<ul>
<li>会话的同时<strong>建立同步(SYN)</strong>。</li>
<li>和不同实体建立的会话是相对独立的，不会相互影响</li>
<li>建立、管理、终止会话</li>
<li>使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。例如：大文件的传输。</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：负责不同的主机中两个相同进程的通信，即端到端的通信。传输单位时报文段or用户数据报。</p>
<ul>
<li>可靠传输：基于确认机制的一种传输方式</li>
<li>不可靠传输：基于</li>
<li>差错控制：</li>
<li>流量控制：</li>
<li>复用分用：</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>：</p>
</li>
<li>
<p><strong>数据链路层</strong>：</p>
</li>
</ul>
<h4 id="封装"><a class="header-anchor" href="#封装"></a>封装</h4>
<ol>
<li>
<p>端与端之间的通信过程：数据经由发送端的协议栈向下、沿着中间链路层分组交换机的协议栈上上下下，而后向上到达接收端的协议栈。</p>
</li>
<li>
<p>一个应用层报文message传输到运输层，会为其增加一个首部信息，该首部信息将被接收端的运输层使用，应用层的message和添加的首部信息构成了运输层的segment，则运输层封装了应用层传递过来的报文信息；</p>
<ol>
<li>其他层次都只加一个头部<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">H~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span></span></span></span></li>
<li>只有在数据链路层会加上头部和尾部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mtext> </mtext><mn>2</mn><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>T</mi><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">H~2~and~T~2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mord">2</span></span></span></span></li>
</ol>
</li>
<li>
<p>同理，在经过源端的协议栈的过程中，数据形成的信息分组会不断添加附加信息以供目的端使用。</p>
<ol>
<li>应用层向运输层传递message，运输层添加运输层首部信息构成了运输层的segment;</li>
<li>运输层向网络层传递segment，网络层增加源和目的端系统地址等网络层首部信息、构成网络层datagram</li>
<li>网络层向链路层传递datagram，链路层增加其首部信息并生成链路层frame</li>
</ol>
</li>
<li>
<p>图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242940.png" alt="image-20240316230731784" style="zoom:50%;" /> 
</li>
</ol>
<h2 id="应用层"><a class="header-anchor" href="#应用层"></a>应用层</h2>
<blockquote>
<p>研发网络应用程序核心是写出能够运行在不同端系统和通过网络彼此通信的程序。</p>
</blockquote>
<h3 id="应用层协议"><a class="header-anchor" href="#应用层协议"></a>应用层协议</h3>
<h4 id="应用层协议是什么"><a class="header-anchor" href="#应用层协议是什么"></a>应用层协议是什么</h4>
<ul>
<li>定义了运行在不同端系统上的应用进程如何进行进行报文的交换
<ul>
<li>
<p>交换的类型</p>
</li>
<li>
<p>报文的语法</p>
</li>
<li>
<p>根据语法建立的字段的语义</p>
</li>
<li>
<p>进程进行报文发送的时序和次序——何时发、如何发、响应规则</p>
</li>
</ul>
</li>
</ul>
<h4 id="公开协议"><a class="header-anchor" href="#公开协议"></a>公开协议</h4>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>E.g：HTTP，SMTP</li>
</ul>
<h4 id="专用协议"><a class="header-anchor" href="#专用协议"></a>专用协议</h4>
<ul>
<li>不公开</li>
<li>E.g：Skype</li>
</ul>
<h3 id="网络应用程序体系结构"><a class="header-anchor" href="#网络应用程序体系结构"></a>网络应用程序体系结构</h3>
<h4 id="两种主流的应用程序体系结构"><a class="header-anchor" href="#两种主流的应用程序体系结构"></a>两种主流的应用程序体系结构</h4>
<ol>
<li>
<p><strong>客户-服务器体系（C/S——client-server）</strong></p>
<ul>
<li>
<p>有一个总是打开的主机称为<strong>服务器</strong>，服务来自其他的被称为<strong>客户</strong>的主机的请求。</p>
</li>
<li>
<p>以Web应用程序为例：其中总是打开的Web服务器服务于来自浏览器（运行在client主机上）的请求。当Web服务器接受到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。（相当于多了一个卖家和买家之间的中间商，其中每个client即可以是卖家、也可以是买家。</p>
</li>
<li>
<p>主要应用：Web、FTP、Telnet和电子邮件</p>
</li>
<li>
<p>该模型中客户的服务与服务器有高度的依赖</p>
</li>
</ul>
</li>
<li>
<p><strong>对等服务体系（P2P——Peer-to-Peer）</strong></p>
<ul>
<li>
<p>该模型中对服务器的依赖最小（或没有）</p>
</li>
<li>
<p>应用程序在间断连接的主机对之间直接通信，这些主机称为<strong>Peer</strong>，</p>
</li>
<li>
<p>P2P具有<strong>自扩展性</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="进程通信"><a class="header-anchor" href="#进程通信"></a>进程通信</h4>
<blockquote>
<p>进行通信的实际上是两个端系统当中创建出的同一种<strong>进程 process</strong>而非程序。</p>
<p>关注点在于——运行在不同端系统（可能具有不同的操作系统）上的进程间的通信</p>
</blockquote>
<p>在两个不同端系统当中创建的同一种进程，通过计算机网络交换**报文(message)**从而相互通信。发送进程生成并向网络发送message，接收进程接收这些message并可能通过回送message进行响应。</p>
<h5 id="客户和服务器进程"><a class="header-anchor" href="#客户和服务器进程"></a>客户和服务器进程</h5>
<ul>
<li><strong>客户&amp;客户端</strong>：在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程标识为客户；</li>
<li><strong>服务器&amp;服务器端</strong>：在会话开始时等待联系的进程是服务器；</li>
</ul>
<h5 id="进程和计算机网络之间的接口"><a class="header-anchor" href="#进程和计算机网络之间的接口"></a>进程和计算机网络之间的接口</h5>
<ul>
<li>
<p>进程通过一个称为**套接字(socket)**的软件接口向网络发送/接受报文。</p>
<p>host–socket–server工作图示：</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242898.png" alt="image-20240317085036165" style="zoom:50%;" /> 
</li>
<li>
<p><strong>socket</strong>称为应用程序和网络之间的<strong>应用程序编程接口(Application Programming Interface API)</strong>。开发者可以控制socket在应用层端的一切。</p>
</li>
<li>
<p>开发者在socket的运输层只有有限的控制权：</p>
<ul>
<li>选择运输层协议；</li>
<li>可能可以设定几个运输层参数</li>
</ul>
</li>
</ul>
<h5 id="进程寻址"><a class="header-anchor" href="#进程寻址"></a>进程寻址</h5>
<blockquote>
<p>就像发邮件需要有一个收件人地址，发送message数据也需要一个目的端接收进程的地址。</p>
</blockquote>
<ul>
<li>
<p>标识一个进程需要两种信息：</p>
<ul>
<li>
<p>主机地址：主机由其<strong>IP address</strong>唯一标识。</p>
<p>IP address是一个32bite的量且能够唯一标识某一台主机。</p>
</li>
<li>
<p>在目的主机中指定接收进程的标识符：<strong>目的地/客户端</strong>-端口号 <strong>port number</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="可供应用程序使用的运输服务"><a class="header-anchor" href="#可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4>
<h5 id="分类："><a class="header-anchor" href="#分类："></a>分类：</h5>
<ul>
<li><strong>可靠数据传输</strong>：一个运输层协议实现了<strong>确保数据交付服务</strong>，则认为是可靠数据传输 reliable-data-transfer。</li>
<li><strong>吞吐量</strong>：<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。
<ul>
<li>可用吞吐量可能存在波动————因为存在其他共享当前网络path的还会，随着这些会话的进入和离开导致可用吞吐量的波动。</li>
<li>需求：运输层协议能够以某种特定的速率提供确保的可用吞吐量————<strong>确保吞吐量</strong>。</li>
<li><strong>带宽敏感的应用(bandwidth-sensitive application)</strong>：具有吞吐量要求的应用程序，在吞吐量达不到协议要求时————如只有规定所需吞吐量的一半————会放弃发送给，因为对于这类应用程序，接收一半的吞吐量没有意义。</li>
<li><strong>弹性应用</strong>：课根据当前带宽或多或少利用可供使用的吞吐量。如电子邮件、文件传输以及web传送。</li>
</ul>
</li>
<li><strong>定时</strong>：</li>
<li><strong>安全性</strong>：对发送的报文信息进行加密。</li>
</ul>
<h4 id="常见的运输服务"><a class="header-anchor" href="#常见的运输服务"></a>常见的运输服务</h4>
<h5 id="TCP服务"><a class="header-anchor" href="#TCP服务"></a>TCP服务</h5>
<ul>
<li><strong>面向连接服务</strong>：
<ul>
<li><strong>handshaking</strong>：在应用层数据message开始流动前，TCP让客户和服务器互相交换运输层控制信息。提醒客户和服务器做好准备应对接下来大量的信息分组。</li>
<li>握手阶段后：一个TCP connection在两个进程的socket间建立。该connection是全双工的————即连接双方的进程可以在此连接上同时进行message的收发；在message发送结束后必须拆除该连接。</li>
</ul>
</li>
<li><strong>可靠数据传输服务</strong>：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进socket时，它能够依靠TCP将相同的字节流交付给接收方的socket，而没有字节的丢失和冗余。</li>
<li>TCP还也有<strong>拥塞控制机制</strong>，该服务不一定可以为通信进程带来好处，但能为因特网整体带来好处————当发生端和接收端之间的网络出现拥塞，TCP拥塞控制机制会抑制发送端。</li>
</ul>
<h5 id="UDP服务"><a class="header-anchor" href="#UDP服务"></a>UDP服务</h5>
<ul>
<li>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连<br>
接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</li>
</ul>
<h3 id="Web-HTTP"><a class="header-anchor" href="#Web-HTTP"></a>Web &amp; HTTP</h3>
<h4 id="HTTP概况"><a class="header-anchor" href="#HTTP概况"></a>HTTP概况</h4>
<ul>
<li>
<p>Web的应用层协议是<strong>超文本传输协议 HyperText Transfer Protocol,HTTP</strong>————是Web的核心。</p>
</li>
<li>
<p>HTTP由两个程序实现：客户程序喝服务器程序运行在不同的端系统中，通过HTTP报文进行会话。</p>
<blockquote>
<p>HTTP定义了message的结构、客户和服务器进行报文交换的方式</p>
</blockquote>
<ul>
<li>一个客户端程序</li>
<li>一个服务器程序</li>
</ul>
</li>
</ul>
<h5 id="Web页面-Web-page是由对象组成的"><a class="header-anchor" href="#Web页面-Web-page是由对象组成的"></a><strong>Web页面 Web page</strong>是由对象组成的</h5>
<ul>
<li>
<p>一个<strong>object</strong>只是一个文件，如一个HTML文件、一个JPEG图像…且它们可以通过一个URL地址寻址。</p>
</li>
<li>
<p>多数page包含有一个HTML基本文件(base HTML file)以及几个引用对象。</p>
</li>
<li>
<p>HTML基本文件通过对象的URL地址引用页面中的其他对象。</p>
</li>
<li>
<p>URL由两部分组成：存放对象的服务器主机名和对象的路径名。</p>
<p>如：URL 地址 http: // www.someSchool. edu/someDepartment/picture.gif,其中的www. someSchool.edu就是主机名, /someDepartment/picture.gif就是路径名。</p>
</li>
<li>
<p>Web browser实现HTTP的客户端，Web服务器实现HTTP的服务器端，用于存储Web对象，每个对象由URL进行寻址。</p>
</li>
</ul>
<h5 id="HTTP的工作方式："><a class="header-anchor" href="#HTTP的工作方式："></a>HTTP的工作方式：</h5>
<ul>
<li><strong>基本思想为</strong>：用户请求一个Web页面，浏览器向服务器发送该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。</li>
<li>HTTP以TCP作为支持运输的协议</li>
<li>分层体系结构最大的优点,即HTTP协议不用担心数据丢失,也不关注 TCP从网络的数据丢失和乱序故障中恢复的细节。</li>
<li><strong>HTTP是一个无状态协议 stateless protocol</strong>：HTTP并不保存任何客户状态信息，假如短时间内客户发送了两次<strong>请求同一个对象</strong>，服务器并不会因为刚刚为客户提供了该对象而不再响应，而是<strong>重新发送该对象</strong>。</li>
</ul>
<h4 id="非持续连接和持续连接"><a class="header-anchor" href="#非持续连接和持续连接"></a>非持续连接和持续连接</h4>
<p><strong>非持续连接 non-persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求/响应对是经过单独的一个TCP进行</p>
<p><strong>持续连接 persistent connection</strong>：客户端-服务器的交互是经TCP进行的，每个请求/响应对是经相同的TCP连续发送</p>
<h5 id="非持续连接的HTTP"><a class="header-anchor" href="#非持续连接的HTTP"></a>非持续连接的HTTP</h5>
<p>每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他对象而持续下来。每个TCP连接只传输一个请求报文&amp;一个响应报文。</p>
<p><strong>往返时间 Round-Trip Time RTT</strong>：是指一个短分组从客户到服务器然后再返回客户所花费的时间 。</p>
<ul>
<li>
<p><em>RTT</em>包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
</li>
<li>
<p>非持续连接中一次超链接点击：设计一次“三次握手”过程。</p>
<p>客户向服务器发送一个小 TCP 报文段；</p>
<p>服务器用一个小 TCP 报文段做出确认和响应；</p>
<p>客户向服务器返回确认</p>
<p>前两个部分占用一个RTT，客户结合握手的第三部分向TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。</p>
</li>
<li>
<p>HTTP请求/响应也需要用去一个RTT，因此粗略计算：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>总的响应时间</mtext><mo>=</mo><mtext>两个</mtext><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mtext>服务器传输</mtext><mi>H</mi><mi>T</mi><mi>M</mi><mi>L</mi><mtext>文件的时间</mtext></mrow><annotation encoding="application/x-tex">总的响应时间=两个RTT+服务器传输HTML文件的时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">总的响应时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">两个</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">服务器传输</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mord cjk_fallback">文件的时间</span></span></span></span>。</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ol>
<li>
<p>必须为每一个请求的对象建立和维护一个全新的连接，加重了服务器负担。</p>
</li>
<li>
<p>每个对象经受双倍<em>RTT</em>的交付时延————一个<em>RTT</em>创建TCP，另一个用于请求和接收对象</p>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242436.png" alt="image-20240318101113130" style="zoom:50%;" /> 
</li>
<li></li>
</ol>
<p><strong>工作全流程</strong>：</p>
<ul>
<li>HTTP客户进程在端口号xx发起一个到服务器www.xxx的TCP连接，在客户端和服务器上分别有一个socket与该连接相关联。</li>
<li>HTTP客户经过它的socket向该服务发送一个HTTP请求报文。请求报文中包含有路径名</li>
<li>HTTP服务器进程经它的socket接收请求报文，从其存储器中检索出对象www.xxx/xxx，在一个 HTTP响应报文中封装对象，并通过其socket向客户端发送响应报文。</li>
<li>HTTP服务器进程通知断开该TCP连接。（但是直到 TCP 确认客户已经完整地收到响应报文为止,它才会实际中断连接。）</li>
<li>HTTP客户接收响应报文，TCP连接关闭。</li>
<li>重复前四个步骤；</li>
</ul>
<h5 id="采用持续连接的HTTP"><a class="header-anchor" href="#采用持续连接的HTTP"></a>采用持续连接的HTTP</h5>
<h2 id="运输层"><a class="header-anchor" href="#运输层"></a>运输层</h2>
<h3 id="概述和运输层服务"><a class="header-anchor" href="#概述和运输层服务"></a>概述和运输层服务</h3>
<p>运输层为两个主机当中的两个应用进程提供<strong>逻辑通信</strong>。</p>
<p>运输层协议在端系统中实现</p>
<ul>
<li>将发送进程接收到的报文封装成运输层分组——报文段 segment。
<ul>
<li>将应用报文分为较小的块，为每个块分别加上首部就可以生成运输层的报文段 segment</li>
<li>网络层再将segment封装成网络分组——数据报 datagram</li>
</ul>
</li>
</ul>
<h4 id="运输层和网络层的关系"><a class="header-anchor" href="#运输层和网络层的关系"></a>运输层和网络层的关系</h4>
<blockquote>
<p>网络层提供了主机间的逻辑通信</p>
</blockquote>
<p>运输层只工作在端系统上，通过运输层协议将报文段通过接入网载入网络层。</p>
<p>每一层的向上都可以使用下层提供的服务，同时进行服务的拓展，再提供给上层。</p>
<p>由于网络协议的不可靠——可能造成分组丢失、篡改和冗余；运输层解决这些问题，为进程提供可靠的数据传输服务。同时运输协议还可以通过加密手段来增强网络传输的安全性。</p>
<h4 id="运输层概述"><a class="header-anchor" href="#运输层概述"></a>运输层概述</h4>
<ul>
<li>
<p>IP 网际协议（网络层协议）</p>
<ul>
<li>服务模型为：尽力而为交付服务，best-effort delivery service。IP不确保报文段的交付、不保证报文段的有序交付，不保证报文段数据的完整性。</li>
<li>综上可知，IP是不可靠服务，ubreliable service</li>
<li>每台主机至少有一个网络层地址，即为俗称的IP地址。</li>
</ul>
</li>
<li>
<p>两种可用的运输层协议：</p>
<ul>
<li>UDP 无连接、不可靠的服务</li>
<li>TCP 面向连接的、可靠的服务</li>
<li>两种模型的基本职责是：将端系统间IP的交付服务拓展为端系统上正在运行的进程间的交付服务。这种将主机间交付拓展为进程间交付的行为称之为：<strong>运输层的多路复用 transport-layer multiplexing</strong>和<strong>多路分解 demultiplexing</strong>。</li>
<li>同时，协议还可以根据报文段首部当中的字段进行包括检错等服务的拓展</li>
</ul>
</li>
<li>
<p>TCP提供的附加服务：</p>
<ul>
<li>可靠数据传输 reliable data transfer：通过流量控制、序号、确认和定时器，TCP可以正确地、按序地将数据从发送进程交付给接收进程。</li>
<li>拥塞机制 congestion control：</li>
</ul>
</li>
</ul>
<h3 id="多路复用与多路分解"><a class="header-anchor" href="#多路复用与多路分解"></a>多路复用与多路分解</h3>
<p>一个进程有一个或多个<strong>套接字socket</strong>——网络和进程相互传递数据的门户。</p>
<h4 id="多路分解"><a class="header-anchor" href="#多路分解"></a>多路分解</h4>
<p>在接收端，运输层检查字段，标识接收socket，将segment定向到特定的socket。将运输层segment交付到正确的socket的这个过程称之为多路分解。</p>
<h4 id="多路复用"><a class="header-anchor" href="#多路复用"></a>多路复用</h4>
<p>在源host从不同socket收集数据，并将每个数据块加上首部信息封装成报文段，然后将报文段传递到网络层，该过程称之为多路复用。</p>
<p>多路复用的实现需要什么要求：</p>
<ul>
<li>socket有唯一标识</li>
<li>每个报文段有特殊的字符用于定位到对应的socket
<ul>
<li>即源端口字段 source port number field和目的端口字段 destination port number field</li>
<li>端口号：16bit的数，0~1023为周知端口号 well-known port number，是被保留的</li>
</ul>
</li>
</ul>
<blockquote>
<p>将数据分发给每一个socket是分解</p>
<p>将从不同socket收集到一起，再将其统一传递是复用</p>
</blockquote>
<h4 id="UDP的多路复用"><a class="header-anchor" href="#UDP的多路复用"></a>UDP的多路复用</h4>
<p>主机为每一个socket分配一个port，当segment到达主机时，检查segment当中的destination port，用这个d port定位到对应的socket，而后将data通过socket进入到相应的进程当中。</p>
<p>一个udp socket是由一个二元组进行标识</p>
<ul>
<li>二元组：一个目的IP地址和一个目的端口号</li>
<li>如果两个 UDP 报文段有不同的源 IP 地址和源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</li>
<li>源端口号和源IP地址的用途：
<ul>
<li>用于数据的返回发送，当A到B的数据传输完，B需要给A传时，则使用到A传输过来的数据当中的源port和IP地址。当B传A时，源和目的发生了改变。</li>
</ul>
</li>
</ul>
<h4 id="TCP的多路复用与多路分解"><a class="header-anchor" href="#TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h4>
<p>TCP socket是一个四元组（源IP地址，源port，目的IP地址，目的port）来标识。</p>
<p>TCP建立连接示例：</p>
<ul>
<li>client创建一个socket，并发送连接建立请求</li>
<li>当运行 server 进程的主机收到报文段，定位到进程，在该服务器进程创建一个新的socket</li>
<li>根据连接请求报文段当中的四个值：1.源port，2.源IP地址，3.目的port，4.目的IP地址，进行socket的创建，之后再有与这四个值匹配的首部则会将报文段传给创建好的socket。</li>
<li>当TCP报文段达到主机，根据四个字段将报文段定向（分解）到对应socket。</li>
</ul>
<h4 id="Web服务器和TCP"><a class="header-anchor" href="#Web服务器和TCP"></a>Web服务器和TCP</h4>
<p>当今的高性能 Web 服务器边常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程（单个进程里可以同时有多个线程）。</p>
<h3 id="UDP：无连接传输"><a class="header-anchor" href="#UDP：无连接传输"></a>UDP：无连接传输</h3>
<p>运输层需要最低限度地提供一种复用/分解服务，以便在网络层和正确的应用层进程间进行数据的传递。</p>
<h4 id="UDP功能"><a class="header-anchor" href="#UDP功能"></a>UDP功能</h4>
<ol>
<li>复用/解复用</li>
<li>少量的差错检测</li>
</ol>
<blockquote>
<p>因为基本没有在IP基础上进行更多功能的拓展，仅是完成了传输层的本职工作，因此采用UDP的应用程序，相当于直接应用IP协议。</p>
</blockquote>
<h4 id="使用UDP的过程解析："><a class="header-anchor" href="#使用UDP的过程解析："></a>使用UDP的过程解析：</h4>
<ol>
<li>UDP 从应用进程得到数据，附加上用于多路复用/分解服务的<strong>源和目的port</strong>字段以及两个其他的小字段，然后将形成的报文段segment交给网络层。</li>
<li>网络层将该运输层报文段封装到一个IP数据报datagram中,然后尽力而为地尝试将此报文段交付给接收主机。</li>
<li>如果该报文段到达接收主机，UDP使用<strong>目的port</strong>将报文段中的数据交付给port对应的应用进程。</li>
</ol>
<blockquote>
<p>在发送报文段之前，sender和receiver的运输层实体间未建立连接，因而称之为无连接</p>
</blockquote>
<p>DNS是使用UDP的典例：</p>
<p>进行一次DNS查询，将查询报文交给UDP，无需建立连接，主机的UDP为查询报文添加首部字段，而后交给网络层，网络层将报文段封装成数据报，发送给dns服务器进行查询，查询主机中的DNS应用这等待响应；若未收到响应，这试图向其他的dns服务器发送查询请求or报错未得到响应。</p>
<h5 id="UDP报文段结构"><a class="header-anchor" href="#UDP报文段结构"></a>UDP报文段结构</h5>
<img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242311.png" alt="image-20240523175429387" style="zoom:50%;" /> 
<ol>
<li>
<p>首部四个字段，每个字段有2两个字节组成</p>
</li>
<li>
<p>源端口号：用于后续可能的数据回传</p>
</li>
<li>
<p>目的端口号：初始化socket</p>
</li>
<li>
<p>长度：指示UDP报文段的字节数（head（花销）+data（载荷））</p>
</li>
<li>
<p>检验和：用于校验数据是否出现错误 EDC 差错检测编码</p>
</li>
</ol>
<p>检验和</p>
<ul>
<li>
<p>作用</p>
<p>用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变</p>
</li>
<li>
<p>发送方校验和的计算方法</p>
<p>对发送方的 UDP 报文段的所有 16 比特字的和进行<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E7%A0%81&amp;spm=1001.2101.3001.7020">反码</a>运算，当求和遇见溢出的时候，进行回卷（回卷的补充在下面），得到的结果放在 UDP 报文段中的检验和字段</p>
</li>
<li>
<p>什么是回卷</p>
<p>所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第 17 位和后 16 位进行加法和运算。</p>
</li>
</ul>
<h3 id="可靠传输原理"><a class="header-anchor" href="#可靠传输原理"></a>可靠传输原理</h3>
<h4 id="可靠传输服务的概念："><a class="header-anchor" href="#可靠传输服务的概念："></a>可靠传输服务的概念：</h4>
<p>就可靠传输这一服务而言，位于较低的层次为上层实体提供的服务可以抽象为一种抽象服务：数据可以通过一条可靠的信道进行传输。借助该信道，数据比特可以无损、无丢失地按照发送顺序进行交付，恰好就是TCP提供的服务模型</p>
<p>实现这种抽象服务即为可靠数据传输协议 reliable data transfer protocol RDT的任务。</p>
<h4 id="传输过程："><a class="header-anchor" href="#传输过程："></a>传输过程：</h4>
<p>rdt_send()被最上层调用，将data交付给下层的发送实体</p>
<p>-&gt;udt_send()被rdt调用，用于将分组放在不可靠的信道上传输给接收方</p>
<p>-&gt;rdt_rev()当分组到达接收方时调用</p>
<p>-&gt;deliver_data()被rdt调用，将pkt当中的data传输给应用层</p>
<h4 id="rdt1-0"><a class="header-anchor" href="#rdt1-0"></a>rdt1.0</h4>
<blockquote>
<p>假设数据在信道中不丢失、不出错</p>
</blockquote>
<p>使用有限状态机 FSM 进行状态的表示，使用带箭头的edge表示状态的变迁，edge上带有便标注：</p>
<ul>
<li>分子表示变迁条件——即A状态做出了什么动作导致了跳转到B状态</li>
<li>分母表示：状态变迁状态过程中A状态做出的动作。</li>
</ul>
<h4 id="rdt2-0-StopAndWait"><a class="header-anchor" href="#rdt2-0-StopAndWait"></a>rdt2.0(StopAndWait)</h4>
<blockquote>
<p>假设数据会出错但不会丢失</p>
</blockquote>
<p>使用肯定确认 positive ackonwledgment ACK和否定确认negative ackonwledgment NCK——自动重传请求（Automatic Repeat reQuest,ARQ）协议</p>
<ul>
<li>差错检测</li>
<li>接收方反馈：通过接收方发送回来的回馈信息为：ACK or NCK来了解接收方的接收情况</li>
<li>重传：接收方接收到有差错的分组时，发送方重新发送数据给接收方</li>
</ul>
<p>rdt3.0：经具有比特差错的丢包信道的可靠数据传输</p>
<h4 id="rdt2-1"><a class="header-anchor" href="#rdt2-1"></a>rdt2.1</h4>
<p>接收方处理出错的ACK/NCK</p>
<p>假设接收方接受了P0，当接收方发送的返回的ACK_0/NCK_0发生错误，导致发送方重复发送了P0，则接收方不接收这个重复的P0但重新发送ACK_0以处理ACK出错的情况，使得发送方和接收方重新回到同步状态</p>
<p>发送方：</p>
<ul>
<li>在每一个pkt里加入序列号：两个序列号（0,1）</li>
<li>一次只发送一个未经确认的分组</li>
<li>需要检测ACK/NCK是否出错</li>
</ul>
<p>接收方：</p>
<ul>
<li>需要检测出收到的分组是否重复
<ul>
<li>状态会指示出希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="rdt2-2-NAK-free"><a class="header-anchor" href="#rdt2-2-NAK-free"></a>rdt2.2 NAK-free</h4>
<p>对ACK进行编号，通过对前一个分组的ACK来代替这一个NAK，即期待得到NAK_0，当得到ACK_1时相当于实现了同样的效果</p>
<h4 id="rdt3-0"><a class="header-anchor" href="#rdt3-0"></a>rdt3.0</h4>
<blockquote>
<p>数据会丢失、会出错</p>
</blockquote>
<p>超时重传机制：</p>
<p>启动一个计时器，比一个RTT多一点的时间，当超时则重新发送pkt</p>
<p>不担心重复，因为分组有序，重复问题在rdt2.2解决了</p>
<p>动态设置计时器</p>
<p>迭代到rdt3.0，则停等协议已经满足了抗丢失、可检错的需求，较为完备，但该协议在信道容量较大时，效率较低。因为信道的利用率很低</p>
<h4 id="流水线可靠数据传输协议-Pipeline-："><a class="header-anchor" href="#流水线可靠数据传输协议-Pipeline-："></a>流水线可靠数据传输协议(Pipeline)：</h4>
<blockquote>
<p>在rdt3.0的基础上，由一次发一个未经确认的分组改成一次发多个未经确认的分组</p>
</blockquote>
<h5 id="滑动窗口-SlideWindow-协议："><a class="header-anchor" href="#滑动窗口-SlideWindow-协议："></a>滑动窗口(SlideWindow)协议：</h5>
<p>缓冲区：暂时存放已发送的分组，以备检错重发和超时重发；但是存放在发送缓冲区的分组不一定都是已发送的。缓冲区的大小决定了一次可以发送多少个未经确认的分组。</p>
<table>
<thead>
<tr>
<th>发送方窗口大小</th>
<th>接收方窗口大小</th>
<th>协议</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>stop-wait</td>
<td></td>
</tr>
<tr>
<td>&gt;1</td>
<td>1</td>
<td>GBN</td>
<td>累计确认</td>
</tr>
<tr>
<td>&gt;1</td>
<td>&gt;1</td>
<td>SR select_repeat</td>
<td>非累计确认</td>
</tr>
</tbody>
</table>
<p>发送窗口：发送缓冲区的一个范围，发送缓冲区的一个子集；发送窗口内的分组都是已发送待确认的，每确认一个分组则窗口向前滑动一个分组；窗口的大小小于或等于缓冲区大小。</p>
<p>回退N步 GBN (Go_Back_N_Steps)</p>
<ul>
<li>基序号：将基序号定义为最早未确认分组的序号</li>
<li>下一个序号：定义为最小的未使用序号</li>
<li>则可将序号范围分成了四个部分：
<ul>
<li>已发送已确认的分组</li>
<li>已发送未确认的分组</li>
<li>即将被发送的分组</li>
<li>尚未能使用</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242093.png" alt="image-20240527162540507"></p>
<p>在发送方有一个N大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为1的接收窗口，</p>
<p>假设当前接收窗口指向为pkt_1，但到来的是pkt_2，首先抛弃掉pkt_2，在迟迟等不到pkt_1，接收方无法发送ACK_1，则发送方计时器超时，发送窗口和发送缓冲区不会向前移动，需要重新发送整个发送窗口内的分组，因为可能有一些分组比pkt_1先到达（例如pkt_2）当被舍弃了，则需要重新发送。</p>
<h5 id="Select-repeat-选择重传"><a class="header-anchor" href="#Select-repeat-选择重传"></a>Select repeat 选择重传</h5>
<p>在发送方有一个SN大小的发送缓冲区和小于N的发送窗口，</p>
<p>在接收方有一个大小为RN的接收窗口</p>
<p>在发送方每发送一个pkt就会开启一个timepiece 计时器记录该分组是否超时，每收到一个对应分组的ACK则会关闭对应的tp，哪个分组的计时器超时则重新发送哪个分组，从而达到选择重传的效果</p>
<p>假设当前RW内包含分组：pkt_1、2、3、4；则每来一个RW内的分组都可以被接收并发送一个ACK信号给发送方，但是当且仅当到达的是，RW最前面的那个分组，到达，才可以将接收窗口前移：</p>
<p>假设先来的是pkt_2、和3，则接收方返回ACK_2、3，但是窗口不移动，当接收到pkt_1时，将pkt_1、2、3解码读取出data上传给应用层并将窗口前移3格，更新RW为：pkt_4、5、6、7</p>
<h3 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h3>
<ul>
<li>点对点</li>
<li>可靠、按顺序</li>
<li>管道化</li>
<li>发送和接收缓存</li>
<li>全双工</li>
<li>面向连接：数据交换之前需要建立连接</li>
<li>有流量控制</li>
</ul>
<p><strong>报文段结构：</strong></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242029.png" alt="img"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242460.png" alt="img"></p>
<blockquote>
<p>MSS：每个TCP报文段中数据字段的最大长度，仅为数据部分的字段，不包括TCP的head</p>
</blockquote>
<ul>
<li>
<p>HEAD：</p>
<ul>
<li>
<p>头部长度为：长20字节：</p>
</li>
<li>
<p>序号seq：报文段的第一个字节+N个偏移量（MSS*N）</p>
<p>第一个字节，假设seq = m，则传过去的数据序号就是m</p>
</li>
<li>
<p>确认号ack:第二个字节，假设ack = n，相当于告诉对方n-1号以前的序号已经确认完毕，需要从第n号开始传</p>
</li>
<li>
<p>标志位：</p>
<ul>
<li>
<p>URG：紧急指针，为1时表示紧急指针有效</p>
</li>
<li>
<p>SYN：同步序号，用于建立连接，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p>
</li>
<li>
<p>FIN：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li>
<p>RST：重置连接标志，</p>
</li>
<li>
<p>ACK：确认序号标志，为1时表示确认号ack有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
</ul>
</li>
<li>
<p>receive window：窗口大小，可以用于流量控制</p>
</li>
</ul>
</li>
<li>
<p>DATA：</p>
</li>
</ul>
<p>cumulative ack 累计确认</p>
<p>一条TCP连接的双方均可随机地选择初始序号。</p>
<h4 id="TCP的RTT估计和超时"><a class="header-anchor" href="#TCP的RTT估计和超时"></a>TCP的RTT估计和超时</h4>
<p>样本RTT：从某报文段被发出到对该报文段的确认被收到之间的时间量。</p>
<p>获得新的一段时间内的某一时刻的样本RTT时，需要重新计算 预估的RTT</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mi>α</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_s = (1-\alpha)*RTT_s +  \alpha * RTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></p>
<p>一般<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>取0.125，则上面的式子改写成：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0.875</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mn>0.125</mn><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_s = (0.875)*RTT_s +  0.125 * RTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0.875</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.125</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></p>
<p>DevRTT = (1-β) · DevRTT + β·|RTT - RTT_s| β一般取0.25</p>
<p>重传RTT设置为：RTT_s + 4*DevRTT</p>
<p>初始 Timeoutlnterval 值为 1 秒，出现超时后将 timeoutinterval的值加倍，以免即将确认的后继报文过早超时。</p>
<h4 id="TCP-超时重传时间设置"><a class="header-anchor" href="#TCP-超时重传时间设置"></a>TCP 超时重传时间设置</h4>
<h4 id="重传"><a class="header-anchor" href="#重传"></a>重传</h4>
<ul>
<li>
<p>一直顺序到达：</p>
<p>暂缓发送ack，设置一个定时器，在定时器超时之前如果又来了一个新的顺序分组，则重启定时器，再次暂缓发送ack，直到超时；因为累计确认，则在超时发送的那个ack之前的那些分组都是确认过的了</p>
</li>
<li>
<p>乱序到达：</p>
<p>赶紧将需要的顺序最小的期待收到的发一个ack通知发送方重新发送</p>
</li>
<li>
<p>前面顺序，中间有一个乱序：</p>
<p>有一部分gap未到达：缺那部分发哪部分的ack通知重传</p>
</li>
<li>
<p>快速重传：三个冗余ack触发的重传，无须等待发送方的计时器超时</p>
<p>例如：[30,39] [40,44] [45,50] [51,60] [60,70]</p>
<p>其中除了[40,44]其他几个都已到达</p>
<p>[30,39] 发送第一个正常的ack_40；后面三个分组则会发送三个冗余的ack_40给发送方，从而触发快速重传机制</p>
</li>
</ul>
<h4 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h4>
<p>接收方使用捎带技术(Piggybacking)，将本地空闲缓冲区的大小反馈发送方，告知其接下来可以发送数据的大小规模，则不会因为发送方发送过多，接收方处理能力无法跟上导致的数据被大量舍弃。</p>
<h4 id="连接控制"><a class="header-anchor" href="#连接控制"></a>连接控制</h4>
<blockquote>
<ol>
<li>双方知道要建立通信</li>
<li>为从此通信准备好缓冲区</li>
<li>为要发送的数据和控制变量做一些制位操作，告诉彼此初始序号、窗口大小等一些必要信息</li>
</ol>
</blockquote>
<p>需要三次握手</p>
<ol>
<li>申请连接</li>
<li>同意申请连接</li>
<li>告知已知道对方同意</li>
</ol>
<ul>
<li>
<h2 id="SYN位："><a class="header-anchor" href="#SYN位："></a>SYN位：</h2>
</li>
<li>FIN位</li>
<li>RST位</li>
</ul>
<h5 id="建立连接"><a class="header-anchor" href="#建立连接"></a>建立连接</h5>
<h5 id="释放连接"><a class="header-anchor" href="#释放连接"></a>释放连接</h5>
<p>一个完整的TCP连接可以视为两个 半连接 ，即 C-&gt;S 和 S-&gt;C ，因此如果要进行释放则是释放两个 半连接。首先 C 向 S 发送释放请求，S 同意后C不再向S发送数据，但是此时S仍然可以向C发送数据——一种对称式的拆除。在第二个 半连接释放多一步细节，在发送ACK后，启动一个定时器，在超时之前没有数据再传过来，则彻底关闭连接</p>
<h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3>
<p>网络有太多数据，超过了网络的处理能力</p>
<p>两种控制方法：</p>
<ol>
<li>端到端拥塞控制：
<ol>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件判断是否有拥塞</li>
<li>TCP采用的方式</li>
</ol>
</li>
<li>网络辅助的拥塞控制<br>
1.</li>
</ol>
<p>ATM ABR拥塞控制</p>
<h3 id="TCP的拥塞控制"><a class="header-anchor" href="#TCP的拥塞控制"></a>TCP的拥塞控制</h3>
<p>采用端对端的拥塞控制</p>
<p>自我感知：</p>
<p>将复杂的放在边缘部分，core部分提供简单服务与功能</p>
<h4 id="是否发生拥塞"><a class="header-anchor" href="#是否发生拥塞"></a>是否发生拥塞</h4>
<ol>
<li>
<p><strong>超时</strong>：</p>
</li>
<li>
<p><strong>三个冗余ACK</strong>：</p>
</li>
</ol>
<h4 id="如何控制发送方发送速率"><a class="header-anchor" href="#如何控制发送方发送速率"></a>如何控制发送方发送速率</h4>
<ul>
<li>
<p>维持一个拥塞窗口：CongWin</p>
</li>
<li>
<p>发送方限制已发送但未确认的数据量（的上限）</p>
</li>
<li>
<p>从而粗略控制发送方往网络中注入的速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">rate = \frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>SS阶段：加倍增加（每个RTT）</p>
</li>
<li>
<p>CA阶段：线性增加（每个RTT）</p>
</li>
<li>
<p>CongWin是动态的，可以感知到网络拥塞程度的函数</p>
<ul>
<li>超时：CongWin降为 1 MSS，进入SS阶段然后再倍增到 CongWin/2(每个RTT)，从而进入CA阶段</li>
<li>冗余ACK：CongWin降为CongWin/2，CA阶段</li>
<li>否则（即正常收到ACK）：CongWin跃跃欲试</li>
</ul>
</li>
</ul>
<h4 id="联合控制："><a class="header-anchor" href="#联合控制："></a>联合控制：</h4>
<ul>
<li>
<p>发送方已发送但未确认的数据量不超过接收窗口的空闲尺寸、也不超过拥塞窗口</p>
</li>
<li>
<p>可以同时满足拥塞控制和流量控制</p>
</li>
<li>
<p>$SendWin = min { CongWin,RecvWin } $</p>
</li>
</ul>
<h4 id="控制策略"><a class="header-anchor" href="#控制策略"></a>控制策略</h4>
<ul>
<li>慢启动
<ul>
<li>连接刚建立：CongWin = 1 MSS</li>
<li>每收到一个确认，CongWin加倍增长，指数级增长——必然导致拥塞</li>
<li>超时后：重置为 1 MSS，而后加倍达到标记处(CongWin/2)，而后进行线性增长(一个个MSS增加)</li>
<li>冗余ACK后：重置为 CongWin/2</li>
</ul>
</li>
<li>AIMD：线性增长、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242079.png" alt="image-20240529221931664"></p>
<h4 id="TCP吞吐量"><a class="header-anchor" href="#TCP吞吐量"></a>TCP吞吐量</h4>
<p>$ (\frac{CongWin}{2},CongWin)$</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>吞吐量为：</mtext><mfrac><mrow><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mn>2</mn><mo>×</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">吞吐量为：\frac{ \frac{CongWin}{2} + CongWin}{2 \times RTT} = \frac{3}{4}\frac{CongWin}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6195em;vertical-align:-0.4033em;"></span><span class="mord cjk_fallback">吞吐量为：</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2161em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9505em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4624em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">Win</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​</p>
<h2 id="网络层：概述"><a class="header-anchor" href="#网络层：概述"></a>网络层：概述</h2>
<blockquote>
<p>网络层重要的两个功能：转发和路由</p>
<p>转发：数据平面</p>
<p>路由：控制平面——是全局的，在整个网络层面寻找源和目标post</p>
</blockquote>
<p>网络层的功能：</p>
<ol>
<li>在post之间传送 segment/datagram</li>
<li>在发送段将段封装到数据报中</li>
<li>在接收端将段上报给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ol>
<h3 id="转发功能"><a class="header-anchor" href="#转发功能"></a>转发功能</h3>
<ul>
<li>传统方式：基于目标地址和转发表</li>
<li>SDN方式：基于多个字段+流表</li>
</ul>
<h3 id="控制平面方法："><a class="header-anchor" href="#控制平面方法："></a>控制平面方法：</h3>
<ul>
<li>传统的路由器算法：在路由器中实现
<ul>
<li>每一个路由器中的单独路由器算法元件，在控制平面进行交互</li>
<li>一个路由器实现了数据和控制平面的功能</li>
<li>路由实体和其他路由器实体交互路由器信息，分布式地计算流表</li>
<li>算出的流表交给IP协议实体，IP实体根据到来的分组的目标IP地址进行匹配，进而完成分组的转发动作</li>
<li>数据和控制平面紧耦合</li>
</ul>
</li>
<li>software-defined networking（SDN）：在远程的服务器中实现
<ul>
<li>一个不同的（通常是远程的）控制器（网络操作系统）和本地控制代理（CAs）交互</li>
<li>CAs上报当前本地状况</li>
<li>控制器根据CAs给出的状态数据算出相对应的流表</li>
<li>而后通过南向接口将流表交给每一个分组交换设备</li>
<li>分组交互设备将流表装载好，而后对每一个到来的分组进行多个字段的匹配，同时流表内已经设置好了分组动作，当一个分组匹配到哪个流表，则会相对应的执行该流表内的分组动作（转发、阻塞、）</li>
<li>由分布式修改为了集中式</li>
</ul>
</li>
</ul>
<h3 id="网络服务模型"><a class="header-anchor" href="#网络服务模型"></a>网络服务模型</h3>
<h4 id="指标："><a class="header-anchor" href="#指标："></a>指标：</h4>
<ul>
<li>对于单个数据报而言：
<ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
</li>
<li>对于数据报流：
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组间的延迟差 jitter</li>
</ul>
</li>
<li>建立连接
<ul>
<li>某些架构内是重要的功能</li>
<li>网络层的连接和传输层不一样（在传输层的TCP指的是面向连接，即源post的某个进程和目标post的某个进程之间的连接，与中间的交换设备无关，体现在端系统之间的逻辑连接）而网络层是两个主机之间的连接，涉及到路径上的路由器</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242143.png" alt="image-20240530120240222"></p>
<p>一类指标组成的服务称之为服务模型，而基于这种服务模型建立起来的协议的模型可以用这类服务模型来代指</p>
<h3 id="路由器的组成"><a class="header-anchor" href="#路由器的组成"></a>路由器的组成</h3>
<p>路由：运行路由选择算法/协议(RIP,OSPF,BGP)——生成流表</p>
<p>转发：从输入到输出链路交互数据报——根据流表进行分组<strong>转发</strong></p>
<p>具有输入输出端口，输入到输出端口存在queue，输出端口到链路层也有queue，因为传输延迟做不到百分之百为0，因而需要把一些frame暂时放在缓存queue当中，而后这些frame的发送也需要一定的调度schedule方法。</p>
<h4 id="调度规则："><a class="header-anchor" href="#调度规则："></a>调度规则：</h4>
<ul>
<li>FIFO 先到先服务
<ul>
<li>按照分组到来次序</li>
<li>丢弃策略也是FIFO</li>
</ul>
</li>
<li>优先级
<ul>
<li>多类，不同分类有不同级别</li>
</ul>
</li>
<li>RoundRobin RR 调度
<ul>
<li>轮换法</li>
</ul>
</li>
<li>Weighted Fair Queuing WFQ 加权公平队列
<ul>
<li>服务时间可以根据权重计算得出</li>
</ul>
</li>
</ul>
<h3 id="IP协议"><a class="header-anchor" href="#IP协议"></a>IP协议</h3>
<h3 id="IP数据报"><a class="header-anchor" href="#IP数据报"></a>IP数据报</h3>
<p>20 byte的TCP 20 byte的IP = 40 bytes + app layer overhead</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242655.png" alt="image-20240530144524045"></p>
<p>TTL(time to live)生存时间：每经过一个三层设备TTL-1，当TTL==0时，数据包丢弃（向源主机发一个ICMP的错误信息报文通知源post）</p>
<p>option，一般没有，可以有</p>
<h4 id="IP的分片和重组"><a class="header-anchor" href="#IP的分片和重组"></a>IP的分片和重组</h4>
<p>FDDI</p>
<p>对于每个frame：head+body 组成，body的最大长度即为MTU</p>
<p>对于一个较大的segment，将其进行分片，分片原理：</p>
<ul>
<li>首先复制首部，因此分片出来的每一个frame具有相同的源id，因而可以标识为同一个分组分片出来的片段，其次使用offset进行每个分组的序号依据，最后在目标主机根据offset进行重组。</li>
</ul>
<h4 id="IP编址"><a class="header-anchor" href="#IP编址"></a>IP编址</h4>
<p><strong>IP地址</strong>：32位标示，对主机或路由器的接口编址</p>
<ul>
<li>使用IP地址用来标识设备</li>
</ul>
<p><strong>接口</strong>：主机/路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也可能拥有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
<p>一个IP地址和一个接口相关联</p>
<h4 id="子网-Subnets"><a class="header-anchor" href="#子网-Subnets"></a>子网 Subnets</h4>
<p>IP地址：</p>
<ul>
<li>子网部分（高位）</li>
<li>主机部分（低位）</li>
</ul>
<p>一个子网内的节点，它们的IP地址高位部分相同，这些节点构成的网络称之为子网</p>
<p>无需路由器介入，子网内各个主机可以在物理上相互直接到达，可以借助于交换机</p>
<p>纯子网两个特点：</p>
<ul>
<li>前缀相同（高位相同）</li>
<li>他们之间的分组转发在ip层面一跳可达，无须借助路由器</li>
</ul>
<p>互联网：点到点</p>
<p>局域网：多点连接——通过交换机相连，</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242162.png" alt="img"></p>
<p>每个ip地址包含两个标识码ID：网络ID和主机ID</p>
<ul>
<li>
<p>A类地址：网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0， 共126个网络地址，全零和全1的地址不使用，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{7}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>B类地址：网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{14}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p>C类地址：网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{30}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>​</p>
</li>
<li>
<p>D类地址：IP地址第一个字节以“1110”开始，它是一个专门保留的地址。224.0.0.0到239.255.255.255用于多点广播。</p>
<ul>
<li>每个网络地址容纳254个主机</li>
<li>多点广播（Multicast）中</li>
</ul>
</li>
</ul>
<p>A、B、C类称为单播地址</p>
<p>D类称之为主播地址——发送给属于主播组的成员</p>
<p>广播一般是局域网内部的广播，一般不会是全球范围的广播</p>
<p>互联网的路由以网络为单位，做路由信息的发布和路由信息的计算：每一个网络是一个流表</p>
<p>特殊IP地址：</p>
<ul>
<li>子网部分：全为0——本网络</li>
<li>主机部分：全为0——本主机</li>
<li>主机部分：全为1——广播地址，这个网络的舍友主机</li>
</ul>
<p>回路地址：127.x.x.x，该地址为目标ip，则tcp\udp将分组传输到ip层时会回传，又称为测试地址</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011242150.png" alt="image-20240602222253233"></p>
<p>IP编制：CIDR Classless InterDomaiin Routing</p>
<p>无类域间路由</p>
<ul>
<li>子网部分可以在任意位置</li>
<li>地址格式为：a.b.c.d/x，x是地址中子网号的长度</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243270.png" alt="image-20240602222546094"></li>
</ul>
<h3 id="子网掩码"><a class="header-anchor" href="#子网掩码"></a>子网掩码</h3>
<p>使用32位bit标识网络id和主机id</p>
<p>两种标书方法：</p>
<ul>
<li>直接32位 1标识网络号，0标识主机号</li>
<li>/xx，标识前xx位为网络号</li>
</ul>
<h3 id="DHCP服务"><a class="header-anchor" href="#DHCP服务"></a>DHCP服务</h3>
<h4 id="动态分配的过程："><a class="header-anchor" href="#动态分配的过程："></a>动态分配的过程：</h4>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243726.png" alt="image-20240602224024681"></p>
<h3 id="SDN"><a class="header-anchor" href="#SDN"></a>SDN</h3>
<p>集中化网络控制器</p>
<p>匹配目标ip、源IP、目标端口、源端口</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243300.png" alt="image-20240603092539337"></p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243987.png" alt="image-20240603092754178"></p>
<h2 id="网络层：控制平面"><a class="header-anchor" href="#网络层：控制平面"></a>网络层：控制平面</h2>
<blockquote>
<p>决定数据如何走，传输过程</p>
</blockquote>
<h3 id="路由选择算法"><a class="header-anchor" href="#路由选择算法"></a>路由选择算法</h3>
<blockquote>
<p>选择一条合适的路径从源主机到目标主机</p>
<p>网络层的路由是由子网到子网的路由，而非主机到主机</p>
<p>子网聚集下，可以先当作子网到子网，减少工作量，到了子网后再在子网内找主机，提高效率，分治思想，一步步解决一个复杂的大问题，分成一个个子问题</p>
<p>一个路由器代表着一个子网，则由子网到子网的路由相当于从路由器到路由器的路由</p>
</blockquote>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243422.png" alt="image-20240603093907802"></p>
<h4 id="最优化原则-optimality-principle"><a class="header-anchor" href="#最优化原则-optimality-principle"></a>最优化原则 optimality principle</h4>
<ul>
<li>汇集树 sink tree
<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243521.png" alt="image-20240603101328110"></li>
<li>找到的最优路径是一棵树而不是一个图，因为不可能存在环</li>
</ul>
</li>
</ul>
<h4 id="Link-State-LS"><a class="header-anchor" href="#Link-State-LS"></a>Link State LS</h4>
<ul>
<li>迪杰斯特拉算法——核心
<ul>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243409.png" alt="image-20240603112241395"></li>
</ul>
</li>
<li>LS应用情况：
<ul>
<li>OSPF协议是一种LS协议，用于Internet上</li>
<li>IS-IS(intermediate system-intermediate system)：用于Internet主干上，NetWare</li>
</ul>
</li>
</ul>
<h4 id="Distance-Vectos-DV"><a class="header-anchor" href="#Distance-Vectos-DV"></a>Distance Vectos DV</h4>
<h3 id="自治系统内部的路由选择"><a class="header-anchor" href="#自治系统内部的路由选择"></a>自治系统内部的路由选择</h3>
<h4 id="RIP"><a class="header-anchor" href="#RIP"></a>RIP</h4>
<p>RIP算法，相邻路由器之间互相传递路由表信息，信息包括：目标主机和到相邻的节点的距离。通过每一次交互进行路由表的迭代，最终可以完成收敛，进而得出每个节点到其他所有节点的最短路径。</p>
<p>好消息传递快，坏消息传递慢</p>
<h4 id="OSPF"><a class="header-anchor" href="#OSPF"></a>OSPF</h4>
<p>SPF，最短路径优先</p>
<p>洪泛法——广播</p>
<p>发送信息：本路由器相邻的室友路由器的链路状态</p>
<p>当链路状态发生变化时，进行一次洪泛发送</p>
<ul>
<li>
<p>重要的分组：</p>
<ul>
<li>
<p>HELLO分组，问候分组</p>
</li>
<li>
<p>DD分组，数据库描述分组</p>
</li>
<li>
<p>LSR分组，链路状态请求分组</p>
</li>
<li>
<p>LSU分组，链路状态更新分组</p>
</li>
<li>
<p>LSAck分组，链路状态确认分组</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243391.png" alt="image-20240603210211955"></p>
<p>网络较大，将网络分成多个区域——自治系统AS，本区域的洪泛不会影响到其他区域area，而后是区域间进行分组传递交由area0去路由到目标主机的area，再到与目标相邻的路由器。</p>
<h3 id="ISP之间路由选择：BGP"><a class="header-anchor" href="#ISP之间路由选择：BGP"></a>ISP之间路由选择：BGP</h3>
<p>自治区AS之间的选择协议</p>
<p>每个AS有一个BGP发言人，相邻的AS通过BGP发言人交换信息</p>
<p>BGP发言人交换的信息：到达某个网络所需要经过的一系列AS，根据收到的信息选择较好的路由。</p>
<p>BGP路由器既需要管理外部AS间路由的选择，同时也需要执行自治系统内部的路由的选择</p>
<p>BGP路由表包括：网络前缀，下一跳，到达目的网络所要经过的各个自治系统系列（路径）</p>
<blockquote>
<p>三种路由协议：</p>
<ul>
<li>RIP，用于自治系统，内部网关。采用UDP报文来交互路由信息</li>
<li>OSPF，用于自治系统，内部网关。采用IP报文</li>
<li>BGP，用于自治系统之间，外部网关，因网络环境复杂，需要可靠传输，采用TCP报文</li>
</ul>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243667.png" alt="image-20240603222249253"></p>
</blockquote>
<h3 id="SDN控制平面"><a class="header-anchor" href="#SDN控制平面"></a>SDN控制平面</h3>
<h3 id="ICMP：因特网控制报文协议"><a class="header-anchor" href="#ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243042.png" alt="image-20240603222345159"></p>
<p>支持主机或路由器：</p>
<ul>
<li>差错/异常报告</li>
<li>网络探询</li>
</ul>
<p>报文结构：</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243232.png" alt="image-20240603222515556"></p>
<ul>
<li>
<p>差错报文：</p>
<ul>
<li>
<p>终点不可达：无法交付，向源主机发送终点不可大报文</p>
</li>
<li>
<p>（取消了）源点抑制：当由于拥塞而丢弃数据报时，向源主机发送抑制报文，让源主机放慢数据报发送速率（一种反馈）</p>
</li>
<li>
<p>时间超过：当TTL=0时，丢弃报文，同时向源主机发送时间超过报文。当终点在预定时间内未收到一个数据报的完整数据片，就把已收到的数据片丢弃并发送时间超过报文</p>
</li>
<li>
<p>参数问题：首部字段出问题</p>
</li>
<li>
<p>改变路由（重定向）：修改发送数据报去往的路由器到更好的路由器。</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243582.png" alt="image-20240603223206089"></p>
</li>
<li>
<p>不发生ICMP差错报文的情况：</p>
<ul>
<li>对ICMP差错报文不发送</li>
<li>只对第一个数据片发送ICMP差错</li>
<li>对具有组播地址的数据报都不发送</li>
<li>对具有特殊地址的数据报不发送</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ICMP询问报文</p>
<ul>
<li>回送请求和回答报文：</li>
</ul>
</li>
</ul>
<p>ICMP应用：</p>
<ul>
<li>PING</li>
<li>Traceroute</li>
</ul>
<h2 id="链路层和局域网"><a class="header-anchor" href="#链路层和局域网"></a>链路层和局域网</h2>
<p>网卡实现了链路层和物理层的功能</p>
<ul>
<li>
<p>数据链路层的原理：</p>
<ul>
<li>检错和纠错</li>
<li>共享广播信道：多点接入</li>
<li>链路层寻址</li>
<li>LAN：以太网、VLANS</li>
<li>可靠数据传输，流控制：donel</li>
</ul>
</li>
<li>
<p>点到点的链路</p>
</li>
<li>
<p>多点连接的链路</p>
<ul>
<li>同轴电缆</li>
<li>网络通信设备都接入交换机，通过交换机进行信息的传递</li>
</ul>
</li>
<li>
<p>节点：</p>
<ul>
<li>主机和路由器都是节点 nodes，网桥和交换机也是节点</li>
</ul>
</li>
<li>
<p>链路：</p>
<ul>
<li>将节点连接在一起的边</li>
</ul>
</li>
<li>
<p>帧 frame：</p>
<ul>
<li>链路层的pdu protocol data unit，</li>
</ul>
</li>
</ul>
<h3 id="检错和纠错"><a class="header-anchor" href="#检错和纠错"></a>检错和纠错</h3>
<p>EDC = 差错检测和纠正位（冗余位）</p>
<p>D = 数据由差错检测保护，可以包含头部字段</p>
<ul>
<li>奇偶校验
<ul>
<li>单bit奇偶校验</li>
<li>2维奇偶校验</li>
</ul>
</li>
</ul>
<h4 id="CRC-循环冗余检错"><a class="header-anchor" href="#CRC-循环冗余检错"></a>CRC 循环冗余检错</h4>
<ol>
<li>模2运算（每一位进行异或）</li>
</ol>
<blockquote>
<p>加法不进位</p>
<p>减法不借位</p>
</blockquote>
<ol start="2">
<li>
<p>比特序列的两种表示：</p>
<ul>
<li>
<p>位串：1011</p>
</li>
<li>
<p>多项式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>生成多项式</p>
<ul>
<li>
<p>r次方 有r+1位</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G = x^3+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 3次方，有3+1==4位</p>
</li>
</ul>
</li>
<li>
<h2 id="冗余位："><a class="header-anchor" href="#冗余位："></a>冗余位：</h2>
</li>
<li>
<p>性能：</p>
<ul>
<li>可检测出所有1bit错误、2bits错误</li>
<li>检查出所有长度为r或小于r的错误</li>
<li>出现长度为r+1的突发错误，，检查不出的概率为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^{r-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>出现长度大于r+1的突发错误，，检查不出的概率为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msup><mn>2</mn><mi>r</mi></msup><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^r-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ol>
<h3 id="多点访问协议-MAP"><a class="header-anchor" href="#多点访问协议-MAP"></a>多点访问协议 MAP</h3>
<blockquote>
<p>有两种类型的网络链路：</p>
<ul>
<li>点对点链路
<ul>
<li>链路协议：PPP，point2point link和high-level data link control HDLC</li>
</ul>
</li>
<li>广播链路 broadcast link
<ul>
<li>让多个发送节点和接收节点都连接到相同、单一、共享的广播信道上。</li>
<li>每有一个节点传输一个frame，其他所有的节点都可以通过信道收到这个frame的副本，以太网和无线局域网</li>
</ul>
</li>
</ul>
<p>局域网使用</p>
</blockquote>
<h4 id="多路访问协议-multiple-access-protocol"><a class="header-anchor" href="#多路访问协议-multiple-access-protocol"></a>多路访问协议 multiple access protocol</h4>
<p><strong>为什么要有多路访问协议：</strong></p>
<p>在广播链路当中，每个节点都可以传输frame，则会导致，多个节点同时发送frame，所有的节点同时接收到多个frame，传输的frame在所有接收方发生了<strong>碰撞  collide</strong>。</p>
<p>以上情况可以通过使用一个多路访问协议来进行协调，协调活跃节点的对frame的传输。</p>
<p><strong>多路访问协议希望做到的特性：</strong></p>
<blockquote>
<p>理想情况下，对于速率为 R bps的广播信道</p>
</blockquote>
<ol>
<li>当仅有一个节点发送数据，该节点具有 R bps 的吞吐量</li>
<li>当有M个节点发送数据，，每个节点具有 R/M bps的吞吐量——在一段时间内的平均速率达到即可</li>
<li>协议是分散的，不会因为某个主节点故障而全局奔溃</li>
<li>协议简单、便宜</li>
</ol>
<h4 id="信道划分协议："><a class="header-anchor" href="#信道划分协议："></a>信道划分协议：</h4>
<p>时分多路复用TDM和频分多路复用FDM两种用于划分广播信道带宽的技术</p>
<ul>
<li>TDM：将时间划分为时间帧time frame，进一步将每个时间帧划分为N个时隙slot
<ul>
<li>将N个slot不重复的平均分配给N个节点，每个节点只在每个时间帧的指定的第N个slot出书分组，一个slot可以传输单个分组。</li>
<li>缺点：
<ul>
<li>节点限制在R/N bps的平均速率，上限设死了</li>
<li>节点必须等待到他的轮次，即当出现情况：xx节点是唯一需要发送的节点，也必须被迫等待到第N个slot才能进行发送。</li>
</ul>
</li>
</ul>
</li>
<li>FDM：
<ul>
<li>将R bps的信道划分为不同的频段，将每个判断分配给N个节点中的一个。</li>
</ul>
</li>
<li>码分多址 CDMA Code Division Multiple Access：
<ul>
<li>对每个节点分配一种不同编码，每个节点用其唯一编码来对发送的数据进行编码</li>
<li>不同的节点可以同时传输，且接收方可以正确接收，不受干扰</li>
</ul>
</li>
</ul>
<h4 id="随机接入协议"><a class="header-anchor" href="#随机接入协议"></a>随机接入协议</h4>
<p>一个传输节点总是以信道的全部速率（即 R bps）进行发送。</p>
<p>有碰撞时，涉及的每个节点反复重发分组，知道分组无碰撞通过为止。</p>
<p>但不是立即重发，而是在等待一个随机时延后进行重发。则每一个参与碰撞的节点都会独立地选择一个随机时延，则可能有出现一种情况：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>
<ul>
<li>最常见的几个：ALOHA协议，Abramson 和 载波侦听多路访问 CSMA 协议——以太网使用的及时CSMA</li>
</ul>
<ol>
<li><strong>时隙 ALOHA：</strong>
<ul>
<li>所有frame由L比特组成</li>
<li>时间被划分位长度为 L/R 的时隙，一个时隙对于传输一帧的时间</li>
<li>节点在时隙起点开始传输帧</li>
<li>节点同步，每个节点都知道时隙何时开始</li>
<li>如果一个时隙内发生碰撞，所有节点在该时隙结束之前检测到碰撞时间</li>
</ul>
</li>
</ol>
<p>取一个概率 <em>p</em> ，每个节点的操作为：</p>
<ul>
<li>当节点有一个待发送的帧，等到下一个时隙开始时传输整个帧</li>
<li>如果没有碰撞，该节点成功传输，无需重发</li>
<li>如果发生碰撞，在时隙结束前检测到，并以 <em>p</em> 的概率在后续的时隙中重发这一帧，知道无碰撞无须重发为止</li>
</ul>
<ol start="2">
<li>
<h2 id="ALOHA："><a class="header-anchor" href="#ALOHA："></a><strong>ALOHA</strong>：</h2>
</li>
<li><strong>载波侦听多路访问 CSMA：</strong>
<ul>
<li>设定规则：
<ul>
<li>传输节点之前先听信道是否有人在传输，载波侦听过程：一直到检测到一段时间无人传输，才开始传输</li>
<li>传输时，一直侦听信道，如果与其他节点正在传输干扰帧，停止吃成熟，在重复上一个过程“侦听 —— 当信道空闲时传输”之前需要等待一段随机时间。</li>
<li>等待时间随机的必要性：加入两个节点同时传输，然后碰撞后又等待相同的时间，则会一直碰撞下去。</li>
<li>当碰撞节点数量较少，时间间隔较短；数量较大，时间间隔较长</li>
</ul>
</li>
<li>二进制指数回退算法：
<ul>
<li>当传输一个给定帧时，该帧发生n次碰撞，节点随机在 [0,1,2,… <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>] 中选择一个K值，碰撞越多，K选择的间隔越大。一个节点实际等待时间为：K*512bit时间，n小于10</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="轮流协议"><a class="header-anchor" href="#轮流协议"></a>轮流协议</h4>
<ol>
<li>轮询协议 taking-turns protocol：N个节点之中要有一个指定为主节点。主节点以循环方式轮询poll每一个节点。
<ol>
<li>主节点首先向节点1发送一个报文，告诉它能够传输的帧的最多数量；在节点1传输了某些帧后,主节点告诉节点2它能够传输的帧的最大数量</li>
<li>主节点可以观察到信道上是否缺乏信号来决定一个节点何时完成帧的发送。</li>
<li>缺点：
<ol>
<li>轮询时延，即每个活跃节点必须等待主节点轮询非活跃节点的时间</li>
<li>主节点故障，全局系统瘫痪</li>
</ol>
</li>
</ol>
</li>
<li>令牌传递协议 token-passing protocol：
<ol>
<li>无主节点，有一个令牌token的小的特殊帧在节点间以设定好的固定次序进行交互</li>
<li>当一个节点拿到token时，仅当其需要发送帧时才继续持有，否则立刻将token发送给下一个节点。</li>
</ol>
</li>
</ol>
<h4 id="DOCSIS：用于电缆因特网接入的链路层协议"><a class="header-anchor" href="#DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h4>
<ol>
<li>使用FDM将上下行信道进行分离</li>
<li>使用TDM将上行信道划分为时间间隔，每个时间间隔包含一个微时隙序列，每个电缆调制解调器分配到序列为N的时隙向CMTS传输数据，CMTS在下行信道发送控制报文——MAP报文——指定哪个电缆调制解调器能够在时间间隔中的哪个微时隙中传输数据。</li>
<li>电缆调制解调器在一组特殊的微时隙间隔内向CMTS发送请求帧来告诉CMTS有数据要发送。请求帧以随机接入方式传输，可能发生碰撞，当电缆没有在下一个下行控制报文收到响应，则推断请求帧发生了碰撞，采取二进制指数回退将其微时隙请求帧延缓到以后的时隙重新发送。</li>
</ol>
<h3 id="LANS"><a class="header-anchor" href="#LANS"></a>LANS</h3>
<h4 id="MAC地址"><a class="header-anchor" href="#MAC地址"></a>MAC地址</h4>
<p>MAC地址具有扁平化结构，不像IP地址一样需要划分出网络部分和主机部分，且MAC地址不会因为地点的改变而改变，不像IP地址一样，随着主机设备的移动，IP地址也需要动态做出改变</p>
<p>适配器向其他适配器发送一个frame，发送适配器将目的适配器的MAC地址插入到帧中，并将帧发送到局域网，交换机广播这一个帧，一个适配器可以接收到一个并非向它寻址的帧，当接收到一个帧时会去匹配MAC地址，若匹配得上，则提取出封装的数据，否则丢弃该数据。</p>
<h4 id="ARP协议-地址解析协议"><a class="header-anchor" href="#ARP协议-地址解析协议"></a>ARP协议 地址解析协议</h4>
<p>ARP：输入进来一个子网IP，将其转换成对应的MAC地址并返回。</p>
<p>ARP只作用于同一个子网上的主机和路由器接口解析IP地址</p>
<p>每台主机或路由器存有一张ARP表，该表包含IP地址到MAC地址的映射关系，表项中含有一个TTL，指示从表中删除某对映射关系的时间</p>
<p><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243579.png" alt="image-20240604164237575"></p>
<p>该表不必为子网中每台主机和路由器都包含一个表项，某些可能从未进入，某些可能过期了。</p>
<p>一个通讯过程中：</p>
<ul>
<li>
<p>发送方构造一个称为ARP分组 ARP pkt 的特殊分组，分组含有字段：</p>
<ul>
<li>发送和接收IP地址及MAC地址</li>
</ul>
<p>ARP查询分组和响应分组具有相同格式，查询分组目的是查询子网上所有其他主机和路由器以缺点对应于要解析的IP地址的那个MAC地址</p>
</li>
<li>
<p>发送查询分组，使用MAC广播地址来发送这个分组，每一个接收到广播而来的分组的适配器去匹配IP地址，如果匹配成功，则发送一个带有IP和MAC地址映射关系的响应ARP分组，而后查询主机更新ARP表，并发送IP数据报，该数据报封装在一个链路层帧中，并且该帧目的MAC与之前发送响应报文的主机或路由器的MAC地址相同。</p>
</li>
</ul>
<h4 id="以太网"><a class="header-anchor" href="#以太网"></a>以太网</h4>
<ol>
<li><strong>帧结构：</strong>
<ul>
<li>前同步码+目的地址+源地址+类型+数据部分+…+CRC检验和</li>
<li>数据字段：承载IP数据报，MTU位1500字节。</li>
<li>目的地址（6字节）：包含目的适配器的MAC地址</li>
<li>源地址（6字节）：包含发送适配器的MAC地址</li>
<li>类型字段（2字节）：允许以太网复用多种网络层协议</li>
<li>CRC（4字节）：校验和</li>
<li>前同步码（8字节）：前七个字节值都为10101010，最后一个为10101011。前七个用于唤醒接收适配器，且将它们的时钟和发送方的时钟同步。</li>
</ul>
</li>
</ol>
<h4 id="链路层交换机"><a class="header-anchor" href="#链路层交换机"></a>链路层交换机</h4>
<p>交换机本身对于子网中的主机和路由器是透明的，即不需要理会的。</p>
<ol>
<li>
<p><strong>过滤：</strong></p>
<ul>
<li>决定进行转发or丢弃的功能</li>
</ul>
</li>
<li>
<p><strong>转发：</strong></p>
<ul>
<li>决定一个帧应该被导向哪个接口，并把帧移动到接口的功能</li>
</ul>
</li>
<li>
<p><strong>交换机表 switch table：</strong></p>
<ul>
<li>过滤和转发功能借助于交换机表实现。</li>
<li>包含某局域网上某些主机和路由器的表项，不必时是全部的</li>
<li>表项包含：
<ul>
<li>一个MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项放置在表中的时间</li>
<li><img src="https://blog-caigui88.oss-cn-shenzhen.aliyuncs.com/imgs/202503011243777.png" alt="image-20240604195935508"></li>
<li>查表的三种情况：</li>
<li>假设有一个包含目的地址为dd-dd-dd-dd-dd-dd的帧，从接口x到达交换机：
<ul>
<li>表中无记录dd-dd-dd-dd-dd-dd的表项。这种情况下，对除了接口x以外的所有接口进行洪泛。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="链路虚拟化"><a class="header-anchor" href="#链路虚拟化"></a>链路虚拟化</h3>
<h3 id="数据中心网络"><a class="header-anchor" href="#数据中心网络"></a>数据中心网络</h3>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
